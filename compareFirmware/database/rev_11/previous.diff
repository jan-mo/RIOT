diff --git a/drivers/include/pcd8544.h b/drivers/include/pcd8544.h
index 487bce7f87..66a63983f5 100644
--- a/drivers/include/pcd8544.h
+++ b/drivers/include/pcd8544.h
@@ -122,6 +122,32 @@ void pcd8544_set_bias(const pcd8544_t *dev, uint8_t bias);
  */
 void pcd8544_write_img(const pcd8544_t *dev, const uint8_t img[]);
 
+/**
+ * @brief   Sets a single stackedpixel on the display
+ *
+ * The position of the 8 stacked pixels is specified in columns (x) and rows (y)
+ * Writes 8 pixels that are defined in data to the memory of the display
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] x             column_px absolute position to write pixel [0 - 83]
+ * @param[in] y             row from display to write pixel [0 - 5]
+ * @param[in] data          definition of 8 stacked pixels (y direction)
+ */
+void pcd8544_write_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data);
+
+/**
+ * @brief   Removes a single stackedpixel on the display
+ *
+ * The position of the 8 stacked pixels is specified in columns (x) and rows (y)
+ * Clears 8 pixels that are defined in data to the memory of the display
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] x             column_px absolute position to clear pixel [0 - 83]
+ * @param[in] y             row from display to clear pixel [0 - 5]
+ * @param[in] data          definition of 8 stacked pixels (y direction)
+ */
+void pcd8544_clear_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data);
+
 /**
  * @brief   Write a single ASCII character to the display
  *
diff --git a/drivers/pcd8544/pcd8544.c b/drivers/pcd8544/pcd8544.c
index 6ef8e65dc9..b5c5f96b49 100644
--- a/drivers/pcd8544/pcd8544.c
+++ b/drivers/pcd8544/pcd8544.c
@@ -320,11 +320,43 @@ void pcd8544_write_img(const pcd8544_t *dev, const uint8_t img[])
     done(dev);
 }
 
+void pcd8544_write_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data)
+{
+    /* check position */
+    if (x >= PCD8544_RES_X || y_line >= PCD8544_ROWS) {
+        return;
+    }
+    /* set position */
+    lock(dev);
+    _set_x(dev, x);
+    _set_y(dev, y_line);
+
+    /* write pixel */
+    _write(dev, MODE_DTA, data);
+    done(dev);
+}
+
+void pcd8544_clear_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data)
+{
+    /* check position */
+    if (x >= PCD8544_RES_X || y_line >= PCD8544_ROWS) {
+        return;
+    }
+    /* set position */
+    lock(dev);
+    _set_x(dev, x);
+    _set_y(dev, y_line);
+
+    /* write pixel */
+    _write(dev, MODE_DTA, data);
+    done(dev);
+}
+
 void pcd8544_write_c(const pcd8544_t *dev, uint8_t x, uint8_t y, char c)
 {
     /* check position */
     if (x >= PCD8544_COLS || y >= PCD8544_ROWS) {
-        return ;
+        return;
     }
     /* set position */
     lock(dev);
diff --git a/firmwareExample/graphplot.c b/firmwareExample/graphplot.c
new file mode 100644
index 0000000000..f7f90c0cea
--- /dev/null
+++ b/firmwareExample/graphplot.c
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2021 Technische Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     firmwareExample
+ * @{
+ *
+ * @file
+ * @brief       Graph Plotting
+ *
+ * @author      Jan Mohr <jan.mohr@campus.tu-berlin.de>
+ *
+ * @}
+ */
+
+#include <stdio.h>
+#include "pcd8544.h"
+#include "graphplot.h"
+
+/* debug config */
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+static int16_t y_value_min = 0;
+static int16_t y_value_max = 0x7FFF;
+
+static uint8_t graph_mode = 0;
+
+static uint8_t pixel_save[PCD8544_RES_X][PCD8544_ROWS] = {{0x00}};
+
+static const uint8_t graph_img_0[] = {
+    0x84,0x82,0xFF,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x00,0x00,0x3F,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,
+    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,
+    0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
+    0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,
+    0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
+    0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xA8,0x70,0x20,
+};
+
+static const uint8_t graph_img_1[] = {
+    0x84,0x82,0xFF,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xA0,0xC0,0x80,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+};
+
+void graphplot_clear(void) {
+    for (uint8_t x = 0; x < PCD8544_RES_X; x++) {
+        for (uint8_t y_line = 0; y_line < PCD8544_ROWS; y_line++){
+            pixel_save[x][y_line] = 0x00;
+        }
+    }
+}
+
+void graphplot_write_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y) {
+    /* check position */
+    if (x >= PCD8544_RES_X || y >= PCD8544_RES_Y) {
+        return;
+    }
+
+    /* calc y position */
+    uint8_t y_line = y / 8;
+
+    /* check pixel array */
+    pixel_save[x][y_line] = pixel_save[x][y_line] | (1 << (y % 8));
+
+    /* write stackedpixel */
+    pcd8544_write_stackedpixel(dev, x, y_line, pixel_save[x][y_line]);
+}
+
+void graphplot_clear_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y) {
+    /* check position */
+    if (x >= PCD8544_RES_X || y >= PCD8544_RES_Y) {
+        return;
+    }
+
+    /* calc y position */
+    uint8_t y_line = y / 8;
+
+    /* check pixel array */
+    pixel_save[x][y_line] = pixel_save[x][y_line] & ~(1 << (y % 8));
+
+    /* remove stackedpixel */
+    pcd8544_clear_stackedpixel(dev, x, y_line, pixel_save[x][y_line]);
+}
+
+void graphplot_diagram(const pcd8544_t *dev, uint8_t mode) {
+    uint8_t x, y_line;
+
+    /* store current mode of graph */
+    graph_mode = mode;
+
+    if (mode == 0) {
+        /* store graph_img in pixel_save */
+        for (unsigned i = 0; i < (PCD8544_RES_X * PCD8544_RES_Y / 8); i++) {
+            y_line = i / PCD8544_RES_X;
+            x = i - (PCD8544_RES_X * y_line);
+            pixel_save[x][y_line] = graph_img_0[i];
+        }
+        pcd8544_write_img(dev, graph_img_0);
+    }
+
+    else if (mode == 1) {
+        /* store graph_img in pixel_save */
+        for (unsigned i = 0; i < (PCD8544_RES_X * PCD8544_RES_Y / 8); i++) {
+            y_line = i / PCD8544_RES_X;
+            x = i - (PCD8544_RES_X * y_line);
+            pixel_save[x][y_line] = graph_img_1[i];
+        }
+
+        pcd8544_write_img(dev, graph_img_1);
+    }
+
+    else {
+        graph_mode = 0;
+        return;
+    }
+}
+
+void graphplot_set_min_max(int16_t min, int16_t max) {
+    /* check if value max is bigger than min and not equal */
+    if (graph_mode == 0) // mode with first quadrant
+        assert(max > min && max != -min);
+    if (graph_mode == 1) // mode with first and second quadrant
+        assert(max > min && max == -min);
+
+    y_value_min = min;
+    y_value_max = max;
+}
+
+void graphplot_write_coordinate(const pcd8544_t *dev, uint8_t x_coordinate, int16_t y_coordinate) {
+    /* check if in range */
+    if (y_coordinate >= y_value_max)
+        y_coordinate = y_value_max;
+    if (y_coordinate <= y_value_min)
+        y_coordinate = y_value_min;
+
+    /* save y_coordinate and sign of y_value */
+    bool neg_sign = false;
+    uint64_t y_value = 0;
+    y_value = y_coordinate;
+    if (y_coordinate < 0){
+        neg_sign = true;
+        y_value = y_coordinate * (-1);
+    }
+
+    /* y-axis parameter */
+    uint8_t axis_range = PCD8544_RES_Y - 1 - GRAPHPLOT_OFFSET_Y;
+    uint32_t value_range = (y_value_max - y_value_min);
+    uint32_t multiplier = 0x4000;
+
+    y_value = (y_value * axis_range * multiplier) / value_range;
+
+    /* restore y_value */
+    uint8_t y = y_value / multiplier;
+
+    if (graph_mode == 0)
+        y = (-1) * y + axis_range;
+    else if (graph_mode == 1) {
+        if (neg_sign)
+            y = y + axis_range / 2;
+        else
+            y = (-1) * y + axis_range / 2;
+    }
+    
+    /* check position */
+    if (x_coordinate >= PCD8544_RES_X || y >= PCD8544_RES_Y) {
+        return;
+    }
+
+    /* calc y position */
+    uint8_t y_line = y / 8;
+
+    /* check pixel array */
+    pixel_save[x_coordinate][y_line] = pixel_save[x_coordinate][y_line] | (1 << (y % 8));
+
+    /* write stackedpixel */
+    pcd8544_write_stackedpixel(dev, x_coordinate, y_line, pixel_save[x_coordinate][y_line]);
+}
diff --git a/firmwareExample/graphplot.h b/firmwareExample/graphplot.h
new file mode 100644
index 0000000000..843ed97d71
--- /dev/null
+++ b/firmwareExample/graphplot.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2021 Technische Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     firmwareExample
+ * @brief       Module to plot a graph on LCD display PCD8544
+ *
+ * @{
+ *
+ * @file
+ * @brief       Interface definition for plotting on the PCD8544 LCD
+ *
+ * @author      Jan Mohr <jan.mohr@campus.tu-berlin.de>
+ */
+
+#ifndef GRAPHPLOT_H
+#define GRAPHPLOT_H
+
+#include <stdint.h>
+
+#include "pcd8544.h"
+
+#define GRAPHPLOT_OFFSET_X 3
+#define GRAPHPLOT_OFFSET_Y 3
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/**
+ * @brief   Sets a single pixel on the display
+ *
+ * The position of the pixel is specified in columns (x) and rows (y)
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] x         column_px absolute position to write pixel [0 - 83]
+ * @param[in] y         row_px absolute position to write pixel [0 - 47]
+ */
+void graphplot_write_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y);
+
+/**
+ * @brief   Removes a single pixel on the display
+ *
+ * The position of the pixel is specified in columns (x) and rows (y)
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] x         column_px absolute position to clear pixel [0 - 83]
+ * @param[in] y         row_px absolute position to clear pixel [0 - 47]
+ */
+void graphplot_clear_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y);
+
+/**
+ * @brief   Write the diagram-image to memory of the given display
+ *
+ * The diagram-image is displayed after calling the function and the
+ * pixel array is updated.
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] mode      set the mode of the diagram [0 - 1]
+ */
+void graphplot_diagram(const pcd8544_t *dev, uint8_t mode);
+
+/**
+ * @brief   Set the min and max value for y-axis
+ *
+ * The min and max of the graph can be set,
+ * needs for graphplot_write_coordinate() function
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] min       the minimum value for y-axis
+ * @param[in] max       the maximum value for y-axis
+ */
+void graphplot_set_min_max(int16_t min, int16_t max);
+
+/**
+ * @brief   Write coordinate to the graph
+ *
+ * The position of the pixel is calculated with min max value of the graph,
+ * function graphplot_set_min_max() needs to be called before 
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] x_coordinate  time_tick value of the graph [0 - 83]
+ * @param[in] y_coordinate  value must be between min max, can be raw data value
+ */
+void graphplot_write_coordinate(const pcd8544_t *dev, uint8_t x_coordinate, int16_t y_coordinate);
+
+/**
+ * @brief   Clear the pixel array
+ *
+ * The pixel array is set to zero
+ *
+ */
+void graphplot_clear(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GRAPHPLOT_H */
+/** @} */
diff --git a/firmwareExample/main.c b/firmwareExample/main.c
index f8aa9497a1..fc7a8ed988 100644
--- a/firmwareExample/main.c
+++ b/firmwareExample/main.c
@@ -7,7 +7,7 @@
  */
 
 /**
- * @ingroup     examples
+ * @ingroup     firmwareExample
  * @{
  *
  * @file
@@ -51,9 +51,17 @@
 #include "pcd8544.h"
 static pcd8544_t dev_pcd;
 
+/* plotting graph */
+#include "graphplot.h"
+bool GRAPHPLOT_ENABLE = false;
+
 /* timings */
 #define SECOND          1000000
 #define MILLI_SECOND    1000
+/* values */
+#define INTERRUPT_WAIT      (350 * MILLI_SECOND)
+#define ADC_thread_delay    (300 * MILLI_SECOND)
+#define LIS_thread_delay    (200 * MILLI_SECOND)
 
 /* debug config */
 #define ENABLE_DEBUG 0
@@ -71,13 +79,11 @@ static msg_t _main_msg_queue[MAIN_QUEUE_SIZE];
 char adc_thread_stack[THREAD_STACKSIZE_MAIN];
 kernel_pid_t ADC_thread_pid;
 bool ADC_thread_sleep = false;
-uint32_t ADC_thread_delay = 800 * MILLI_SECOND;
 
 /* LIS threading */
 char lis_thread_stack[THREAD_STACKSIZE_MAIN];
 kernel_pid_t LIS_thread_pid;
 bool LIS_thread_sleep = false;
-uint32_t LIS_thread_delay = 450 * MILLI_SECOND;
 
 /* toggles the user LED */
 static int led_toggle(int argc, char **argv) {
@@ -87,12 +93,21 @@ static int led_toggle(int argc, char **argv) {
     return 1;
 }
 
+/* clears full display and pixel array for graphplot */
+void __clear_display(void) {
+    graphplot_clear();
+    pcd8544_clear(&dev_pcd);
+}
+
 /* read ADC (differential mode) */
 static int adc_read(int argc, char **argv) {
     (void)argc;
     (void)argv;
 
+    __clear_display();
+
     ADC_thread_sleep = true;
+    GRAPHPLOT_ENABLE = false;
     char buffer[PCD8544_COLS] = {0};
 
     int sample = adc_sample(ADC_LINE(ADC_SAMPLE_LINE), ADC_RES_10BIT);
@@ -111,16 +126,35 @@ void *adc_read_periodic(void *arg)
     (void) arg;
     int sample = 0;
     char buffer[PCD8544_COLS] = {0};
+    uint8_t time_ticks = GRAPHPLOT_OFFSET_X;
 
     while (1) {
         /* read ADC data */
         sample = adc_sample(ADC_LINE(ADC_SAMPLE_LINE), ADC_RES_10BIT);
+
         DEBUG("ADC value: %d\n", sample);
-        /* print to display */
-        sprintf(buffer, "ADC: %d", sample);
-        pcd8544_write_l(&dev_pcd, 0, buffer);
+
+        /* checking max time_ticks */
+        if (time_ticks >= PCD8544_RES_X - GRAPHPLOT_OFFSET_X) {
+            /* reset */
+            time_ticks = GRAPHPLOT_OFFSET_X;
+            if (GRAPHPLOT_ENABLE)
+                graphplot_diagram(&dev_pcd, 0);
+        }
+
+        if (!GRAPHPLOT_ENABLE) {
+            /* print to display */
+            sprintf(buffer, "ADC: %d", sample);
+            pcd8544_write_l(&dev_pcd, 0, buffer);
+        }
+        else {
+            /* print to graph */
+            graphplot_write_coordinate(&dev_pcd, time_ticks, sample);
+        }
 
         xtimer_usleep(ADC_thread_delay);
+        time_ticks++;
+
         if (ADC_thread_sleep)
             thread_sleep();
     }
@@ -133,7 +167,10 @@ static int adc_thread_wakeup (int argc, char **argv){
     (void)argc;
     (void)argv;
 
+    __clear_display();
+
     ADC_thread_sleep = false;
+    GRAPHPLOT_ENABLE = false;
     thread_wakeup(ADC_thread_pid);
 
     return 0;
@@ -147,7 +184,7 @@ void button_int_cb(void* arg) {
     puts("interrupt received.");
     pcd8544_clear(&dev_pcd);
     pcd8544_write_s(&dev_pcd, 1, 2, "Button_inter.");
-    xtimer_usleep(350 * MILLI_SECOND);
+    xtimer_usleep(INTERRUPT_WAIT);
     pcd8544_clear(&dev_pcd);
     gpio_irq_enable(BTN0_PIN);
 }
@@ -176,8 +213,8 @@ void lis_func_init(void) {
         puts("lis3dh [Failed]");
     }
 
-    lis3dh_set_odr(&dev_lis, lis3dh_params[0].odr);
-    lis3dh_set_scale(&dev_lis, lis3dh_params[0].scale);
+    lis3dh_set_odr(&dev_lis, LIS3DH_ODR_100Hz);
+    lis3dh_set_scale(&dev_lis, 2);
     lis3dh_set_axes(&dev_lis, LIS3DH_AXES_XYZ);
 #endif
 }
@@ -187,7 +224,10 @@ static int lis_read(int argc, char **argv) {
     (void)argc;
     (void)argv;
 
+    __clear_display();
+
     LIS_thread_sleep = true;
+    GRAPHPLOT_ENABLE = false;
     char buffer[PCD8544_COLS] = {0};
 
 #ifdef MODULE_LIS2DH12_SPI
@@ -231,7 +271,9 @@ void *lis_read_periodic(void *arg)
 {
     (void) arg;
 
+    int16_t value_x, value_y, value_z;
     char buffer[PCD8544_COLS] = {0};
+    uint8_t time_ticks = GRAPHPLOT_OFFSET_X;
 
     while (1) {
         /* read LIS data */
@@ -239,36 +281,50 @@ void *lis_read_periodic(void *arg)
         lis2dh12_fifo_data_t data = {0};
 
         lis2dh12_read(&dev_lis, &data);
-        DEBUG("X: %d  Y: %d  Z: %d\n", data.axis.x, data.axis.y, data.axis.z);
-
-        /* print to display */
-        sprintf(buffer, "X: %d", data.axis.x);
-        pcd8544_write_l(&dev_pcd, 1, buffer);
-
-        sprintf(buffer, "Y: %d", data.axis.y);
-        pcd8544_write_l(&dev_pcd, 2, buffer);
-
-        sprintf(buffer, "Z: %d", data.axis.z);
-        pcd8544_write_l(&dev_pcd, 3, buffer);
+        value_x = data.axis.x;
+        value_y = data.axis.y;
+        value_z = data.axis.z;
 
 #elif MODULE_LIS3DH
         lis3dh_data_t data = {0};
 
         lis3dh_read_xyz(&dev_lis, &data);
-        DEBUG("X: %d  Y: %d  Z: %d\n", data.acc_x, data.acc_y, data.acc_z);
-
-        /* print to display */
-        sprintf(buffer, "X: %d", data.acc_x);
-        pcd8544_write_l(&dev_pcd, 1, buffer);
-
-        sprintf(buffer, "Y: %d", data.acc_y);
-        pcd8544_write_l(&dev_pcd, 2, buffer);
-
-        sprintf(buffer, "Z: %d", data.acc_z);
-        pcd8544_write_l(&dev_pcd, 3, buffer);
+        value_x = data.acc_x;
+        value_y = data.acc_y;
+        value_z = data.acc_z;
 #endif
 
+        DEBUG("X: %d  Y: %d  Z: %d\n", value_x, value_y, value_z);
+
+        /* checking max time_ticks */
+        if (time_ticks >= PCD8544_RES_X - GRAPHPLOT_OFFSET_X) {
+            /* reset */
+            time_ticks = GRAPHPLOT_OFFSET_X;
+            if (GRAPHPLOT_ENABLE)
+                graphplot_diagram(&dev_pcd, 1);
+        }
+
+        if (!GRAPHPLOT_ENABLE) {
+            /* print to display */
+            sprintf(buffer, "X: %d", value_x);
+            pcd8544_write_l(&dev_pcd, 1, buffer);
+
+            sprintf(buffer, "Y: %d", value_y);
+            pcd8544_write_l(&dev_pcd, 2, buffer);
+
+            sprintf(buffer, "Z: %d", value_z);
+            pcd8544_write_l(&dev_pcd, 3, buffer);
+        }
+        else {
+            /* print to graph */
+            graphplot_write_coordinate(&dev_pcd, time_ticks, value_x);
+            graphplot_write_coordinate(&dev_pcd, time_ticks, value_y);
+            graphplot_write_coordinate(&dev_pcd, time_ticks, value_z);
+        }
+
         xtimer_usleep(LIS_thread_delay);
+        time_ticks++;
+
         if (LIS_thread_sleep)
             thread_sleep();
     }
@@ -281,7 +337,10 @@ static int lis_thread_wakeup (int argc, char **argv){
     (void)argc;
     (void)argv;
 
+    __clear_display();
+
     LIS_thread_sleep = false;
+    GRAPHPLOT_ENABLE = false;
     thread_wakeup(LIS_thread_pid);
 
     return 0;
@@ -310,7 +369,7 @@ static int display_clear(int argc, char **argv) {
     (void)argc;
     (void)argv;
 
-    pcd8544_clear(&dev_pcd);
+    __clear_display();
     return 0;
 }
 
@@ -334,17 +393,85 @@ static int display_invert(int argc, char **argv) {
 
 /* write to specific line and column of display */
 static int display_write(int argc, char **argv) {
-    uint8_t x, y;
+    uint8_t line, column;
 
     if (argc < 4) {
         printf("usage: %s LINE COLUMN STRING\n", argv[0]);
         return -1;
     }
 
+    line = atoi(argv[1]);
+    column = atoi(argv[2]);
+
+    pcd8544_write_s(&dev_pcd, column, line, argv[3]);
+    return 0;
+}
+
+/* writes a specific pixel on display */
+static int display_pixel(int argc, char **argv) {
+    uint8_t x, y;
+
+    if (argc < 3) {
+        printf("usage: %s POSX POSY\n", argv[0]);
+        return -1;
+    }
+
     x = atoi(argv[1]);
     y = atoi(argv[2]);
 
-    pcd8544_write_s(&dev_pcd, y, x, argv[3]);
+    graphplot_write_pixel(&dev_pcd, x, y);
+    return 0;
+}
+
+/* removes a specific pixel on display */
+static int display_pixel_clear(int argc, char **argv) {
+    uint8_t x, y;
+
+    if (argc < 3) {
+        printf("usage: %s POSX POSY\n", argv[0]);
+        return -1;
+    }
+
+    x = atoi(argv[1]);
+    y = atoi(argv[2]);
+
+    graphplot_clear_pixel(&dev_pcd, x, y);
+    return 0;
+}
+
+/* plot diagram on display */
+static int display_graph_adc(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    /* display the diagram */
+    graphplot_diagram(&dev_pcd, 0);
+    graphplot_set_min_max(0, 1200);
+
+    /* stops ADC and LIS threads */
+    LIS_thread_sleep = true;
+    ADC_thread_sleep = false;
+    GRAPHPLOT_ENABLE = true;
+    thread_wakeup(ADC_thread_pid);
+
+    return 0;
+}
+
+/* plot diagram on display */
+static int display_graph_lis(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    /* display the diagram */
+    graphplot_diagram(&dev_pcd, 1);
+    graphplot_set_min_max(-1500, 1500);
+
+    /* stops ADC and LIS threads */
+    LIS_thread_sleep = false;
+    ADC_thread_sleep = true;
+    GRAPHPLOT_ENABLE = true;
+    thread_wakeup(LIS_thread_pid);
+
     return 0;
 }
 
@@ -356,6 +483,10 @@ static const shell_command_t shell_commands[] = {
     { "disp_invert", "Invert display", display_invert },
     { "disp_write", "Write string to display", display_write},
     { "disp_clear", "Clear display", display_clear },
+    { "pixel", "Writes a pixel at given position", display_pixel},
+    { "pixel_clear", "Removes a pixel at given position", display_pixel_clear},
+    { "graph_lis", "Plots the diagram image and displays the LIS data over time period", display_graph_lis},
+    { "graph_adc", "Plots the diagram image and displays the LIS data over time period", display_graph_adc},
     { "lis_read", "Read acceleration data", lis_read },
     { "lis_read_periodic", "Periodic read of acceleration data", lis_thread_wakeup },
     { "adc_read", "Read ADC value, stops periodic read", adc_read},
