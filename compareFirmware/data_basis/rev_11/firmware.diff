diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
index f5ce1f9881..8fe9488708 100644
--- a/.github/ISSUE_TEMPLATE/bug_report.md
+++ b/.github/ISSUE_TEMPLATE/bug_report.md
@@ -11,8 +11,7 @@ IF YOUR ISSUE IS RELATED TO SECURITY
 please submit it to the security mailing-list security@riot-os.org.
 
 If your issue is a question related to the usage of RIOT, please submit it to
-our forum at https://forum.riot-os.org, to the user mailing-list
-users@riot-os.org, or to the developer mailing-list devel@riot-os.org.
+our forum at https://forum.riot-os.org.
 -->
 
 #### Description
diff --git a/.github/labeler.yml b/.github/labeler.yml
new file mode 100644
index 0000000000..6e1345b993
--- /dev/null
+++ b/.github/labeler.yml
@@ -0,0 +1,155 @@
+"Area: arduino API":
+  - "sys/arduino/**/*"
+
+"Area: BLE":
+  - "pkg/nimble/**/*"
+  - "sys/net/ble/**/*"
+  - "sys/include/net/bluetil/**/*"
+  - "sys/include/net/skald/**/*"
+  - "sys/include/net/skald.h"
+
+"Area: boards":
+  - "boards/**/*"
+
+"Area: build system":
+  - "Makefile.*"
+  - "makefiles/**/*"
+  - "**/*.mk"
+
+"Area: CI":
+  - ".circleci/**/*"
+  - ".github/**/*.yml"
+  - ".murdock"
+
+"Area: CoAP":
+  - "sys/net/application_layer/*coap/**/*"
+  - "sys/include/net/*coap*/**/*"
+
+"Area: core":
+  - "core/**/*"
+
+"Area: cpu":
+  - "cpu/**/*"
+
+"Area: doc":
+  - "doc/**/*"
+  - "**/*.md"
+  - "**/*.txt"
+
+"Area: drivers":
+  - "drivers/**/*"
+
+"Area: examples":
+  - "examples/**/*"
+
+"Area: Kconfig":
+  - "dist/tools/kconfiglib/**/*"
+  - "makefiles/kconfig.mk"
+  - "kconfigs/*"
+  - "**/Kconfig"
+
+"Area: LoRa":
+  - "drivers/llcc68/**/*"
+  - "drivers/sx126x/**/*"
+  - "drivers/sx127x/**/*"
+  - "drivers/include/llcc68.h"
+  - "drivers/include/sx126x.h"
+  - "drivers/include/sx127x.h"
+  - "pkg/semtech-loramac/**/*"
+  - "sys/net/lora/**/*"
+  - "sys/net/gnrc/link_layer/lorawan/**/*"
+  - "sys/include/net/lorawan/**/*"
+  - "sys/include/net/gnrc/lorawan/**/*"
+  - "sys/include/net/gnrc/lorawan.h"
+  - "sys/include/net/lora.h"
+  - "sys/include/net/loramac.h"
+
+"Area: network":
+  - "sys/net/**/*"
+  - "sys/include/net/**/*"
+  - "pkg/lwip/**/*"
+  - "pkg/openthread/**/*"
+  - "pkg/openwsn/**/*"
+  - "pkg/paho-mqtt/**/*"
+
+"Area: OTA":
+  - "sys/suit/**/*"
+  - "sys/include/suit/**/*"
+  - "sys/include/suit.h"
+
+"Area: pkg":
+  - "pkg/**/*"
+
+"Area: SAUL":
+  - "drivers/saul/**/*"
+  - "drivers/include/saul/**/*"
+  - "drivers/include/saul.h"
+  - "sys/saul_reg/**/*"
+  - "sys/include/saul_reg.h"
+
+"Area: sys":
+  - "sys/**/*"
+
+"Area: tests":
+  - "tests/**/*"
+  - "fuzzing/**/*"
+  - "dist/pythonlibs/**/*"
+  - "makefiles/tests/**/*"
+
+"Area: timers":
+  - "sys/*timer/**/*"
+  - "sys/include/*timer/**/*"
+  - "sys/include/*timer.h"
+
+"Area: toolchain":
+  - "makefiles/toolchain/**/*"
+
+"Area: tools":
+  - "dist/tools/**/*"
+  - "dist/testbed-support/**/*"
+  - "makefiles/tools/**/*"
+
+"Area: USB":
+  - "sys/usb/**/*"
+  - "sys/include/usb/**/*"
+  - "sys/include/usb.h"
+
+"Platform: native":
+  - "boards/native/**/*"
+  - "cpu/native/**/*"
+
+"Platform: ARM":
+  - "cpu/arm7_common/**/*"
+  - "cpu/cortexm_common/**/*"
+  - "cpu/cc2*/**/*"
+  - "cpu/efm32/**/*"
+  - "cpu/kinetis/**/*"
+  - "cpu/lm4f120/**/*"
+  - "cpu/lpc*/**/*"
+  - "cpu/nrf5*/**/*"
+  - "cpu/qn908x/**/*"
+  - "cpu/sam*/**/*"
+  - "cpu/stellaris_common/**/*"
+  - "cpu/stm32/**/*"
+  - "makefiles/arch/cortexm.inc.mk"
+
+"Platform: AVR":
+  - "cpu/atmega*/**/*"
+  - "cpu/avr8_common/**/*"
+  - "makefiles/arch/avr8.inc.mk"
+
+"Platform: ESP":
+  - "cpu/esp*/**/*"
+
+"Platform: MIPS":
+  - "cpu/mips*/**/*"
+  - "makefiles/arch/mips.inc.mk"
+
+"Platform: MSP":
+  - "cpu/msp*/**/*"
+  - "makefiles/arch/msp430.inc.mk"
+
+"Platform: RISC-V":
+  - "cpu/riscv_common/**/*"
+  - "cpu/fe310/**/*"
+  - "makefiles/arch/riscv.inc.mk"
diff --git a/.github/workflows/labeler.yml b/.github/workflows/labeler.yml
new file mode 100644
index 0000000000..0523287795
--- /dev/null
+++ b/.github/workflows/labeler.yml
@@ -0,0 +1,14 @@
+name: pr-labeler
+
+on:
+  pull_request_target:
+    types: [opened, synchronize, reopened]
+
+jobs:
+  triage:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/labeler@main
+      with:
+        repo-token: "${{ secrets.GITHUB_TOKEN }}"
+        sync-labels: true
diff --git a/.github/workflows/release-test.yml b/.github/workflows/release-test.yml
index 97e58d4b37..8ed73bacb5 100644
--- a/.github/workflows/release-test.yml
+++ b/.github/workflows/release-test.yml
@@ -34,6 +34,9 @@ on:
         description: 'riot/riotbuild docker image version'
         required: true
         default: 'latest'
+      filter:
+        description: 'Pytest filter. Leave empty for all.'
+        required: false
 
 env:
   DOCKER_MAKE_ARGS: -j
@@ -74,6 +77,12 @@ jobs:
         IOTLAB_USER=$(cat ~/.iotlabrc | cut -f1 -d:)
         ssh -oStrictHostKeyChecking=accept-new \
           ${IOTLAB_USER}@saclay.iot-lab.info exit
+    - name: Fetch host key from IoT-LAB lille site
+      if: ${{ matrix.pytest_mark == 'iotlab_creds' }}
+      run: |
+        IOTLAB_USER=$(cat ~/.iotlabrc | cut -f1 -d:)
+        ssh -oStrictHostKeyChecking=accept-new \
+          ${IOTLAB_USER}@lille.iot-lab.info exit
     - name: Checkout Release-Specs
       uses: actions/checkout@v2
       with:
@@ -116,6 +125,9 @@ jobs:
               grep -q "[0-9]\{4\}.[0-9]\{2\}-RC[0-9]\+"; then
           TOX_ARGS+="--non-RC "
         fi
+        if [ -n "${{ github.event.inputs.filter }}" ]; then
+          K="-k"
+        fi
 
         cd Release-Specs
         # definition in env does not work since $GITHUB_WORKSPACE seems not to
@@ -123,22 +135,23 @@ jobs:
         ${{ matrix.sudo }} \
           BUILD_IN_DOCKER=1 \
           DOCKER_MAKE_ARGS=${DOCKER_MAKE_ARGS} \
-          DOCKER_ENV_VARS=USEMODULE \
+          DOCKER_ENV_VARS="USEMODULE QUIETER" \
           GITHUB_REPOSITORY=${GITHUB_REPOSITORY} \
           GITHUB_RUN_ID=${GITHUB_RUN_ID} \
           GITHUB_SERVER_URL=${GITHUB_SERVER_URL} \
-          LORAWAN_APP_KEY="${{ secrets.CI_TTN_APPKEY  }}" \
-          LORAWAN_NWK_SKEY="${{ secrets.CI_TTN_NWKSKEY_ABP  }}" \
-          LORAWAN_APP_SKEY="${{ secrets.CI_TTN_APPSKEY_ABP  }}" \
+          APPKEY="${{ secrets.CI_TTN_APPKEY  }}" \
+          NWKSKEY="${{ secrets.CI_TTN_NWKSKEY_ABP  }}" \
+          APPSKEY="${{ secrets.CI_TTN_APPSKEY_ABP  }}" \
           LORAWAN_DL_KEY="${{ secrets.CI_TTN_APPID_KEY  }}" \
-          LORAWAN_DEV_EUI="009E40529364FBE6" \
-          LORAWAN_APP_EUI="70B3D57ED003B26A" \
-          LORAWAN_DEV_ADDR="26011EB0" \
+          DEVEUI="009E40529364FBE6" \
+          APPEUI="70B3D57ED003B26A" \
+          DEVADDR="26011EB0" \
           TTN_APP_ID="11-lorawan" \
           TTN_DEV_ID="riot_lorawan_1" \
           TTN_DEV_ID_ABP="riot_lorawan_1_abp" \
           RIOTBASE=${RIOTBASE} \
-          $(which tox) -e test -- ${TOX_ARGS} -m "${{ matrix.pytest_mark }}"
+          $(which tox) -e test -- ${TOX_ARGS} \
+            ${K} "${{ github.event.inputs.filter }}" -m "${{ matrix.pytest_mark }}"
     - name: junit2html and XML deploy
       if: always()
       run: |
diff --git a/.github/workflows/test-on-iotlab.yml b/.github/workflows/test-on-iotlab.yml
index e4abbbbee3..fc5f90cc93 100644
--- a/.github/workflows/test-on-iotlab.yml
+++ b/.github/workflows/test-on-iotlab.yml
@@ -68,7 +68,7 @@ jobs:
     runs-on: ubuntu-latest
     name: ${{ matrix.boards.riot }}
     env:
-      IOTLAB_NODE: auto-ssh
+      IOTLAB_NODE: auto
       BUILD_IN_DOCKER: 1
       # Force .bin files generation because these files are used to flash on IoT-LAB and
       # because compile_and_test_for_board forces RIOT_CI_BUILD which skip .bin
diff --git a/.github/workflows/tools-test.yml b/.github/workflows/tools-test.yml
index 56fdc079e1..b5dc5a6bd4 100644
--- a/.github/workflows/tools-test.yml
+++ b/.github/workflows/tools-test.yml
@@ -24,10 +24,13 @@ jobs:
         python -m pip install --upgrade pip
         python -m pip install tox
         python -m pip install kconfiglib
+        sudo apt-get install gcc-multilib
     - name: Test backport_pr
       run: cd dist/tools/backport_pr && tox
     - name: Test compile_and_test_for_board
       run: cd dist/tools/compile_and_test_for_board && tox
+    - name: Test riotctrl_ctrl
+      run: cd dist/pythonlibs/riotctrl_ctrl && tox
     - name: Test riotctrl_shell
       run: cd dist/pythonlibs/riotctrl_shell && tox
     - name: Test kconfig script
diff --git a/.murdock b/.murdock
index 4ec20129f6..83c3673d5e 100755
--- a/.murdock
+++ b/.murdock
@@ -7,62 +7,32 @@
 #: ${TEST_BOARDS_LLVM_COMPILE:="iotlab-m3 native nrf52dk mulle nucleo-f401re samr21-xpro slstk3402a"}
 : ${TEST_BOARDS_LLVM_COMPILE:=""}
 
-: ${TEST_KCONFIG_samr21_xpro:="examples/hello-world tests/periph_*
-tests/test_tools tests/congure_* tests/xtimer_* tests/ztimer_*
-tests/driver_ad7746 tests/driver_adcxx1c tests/driver_ads101x tests/driver_adt101x
-tests/driver_adt7310 tests/driver_adxl345 tests/driver_aip31068 tests/driver_apa102
-tests/driver_apds99xx tests/driver_apds99xx_full tests/driver_at tests/driver_at24cxxx
-tests/driver_at24mac tests/driver_at25xxx tests/driver_at30tse75x tests/driver_ata8520e
-tests/driver_b* tests/driver_ccs811 tests/driver_ccs811_full tests/driver_dcf77
-tests/driver_dfplayer tests/driver_dht tests/driver_ds18 tests/driver_ds75lx
-tests/driver_ds1307 tests/driver_ds3231 tests/driver_ds3234 tests/driver_dsp0401
-tests/driver_dynamixel tests/driver_edbg_eui tests/driver_f* tests/driver_g*
-tests/driver_h* tests/driver_i* tests/driver_j* tests/driver_l*
-tests/driver_mag3110 tests/driver_mhz19 tests/driver_mma7660
-tests/driver_motor_driver tests/driver_mpl3115a2 tests/driver_mpu9x50
-tests/driver_mq3 tests/driver_my9221 tests/driver_nvram_spi tests/mtd_flashpage
-tests/mtd_mapper tests/driver_o* tests/driver_p* tests/driver_q*
-tests/driver_r* tests/driver_s* tests/driver_t* tests/driver_u*
-tests/driver_v*"}
-: ${TEST_KCONFIG_native:="examples/hello-world
+: ${TEST_KCONFIG_BOARDS_AVAILABLE:="
+native
+samr21-xpro
+nucleo-f103rb
+"}
+
+: ${TEST_KCONFIG_ENFORCE_APP_GROUPS:="
 tests/cb_mux*
 tests/congure_*
-tests/driver_ws281x
-tests/eepreg
+tests/driver_b*
+tests/driver_f*
+tests/driver_g*
+tests/driver_h*
+tests/driver_i*
+tests/driver_j*
+tests/driver_l*
+tests/driver_o*
+tests/driver_p*
+tests/driver_q*
+tests/driver_r*
+tests/driver_s*
+tests/driver_t*
+tests/driver_u*
+tests/driver_v*
 tests/periph_*
-tests/pkg_c25519
-tests/pkg_cayenne-lpp
-tests/pkg_cifra
-tests/pkg_cn-cbor
-tests/pkg_emlearn
-tests/pkg_hacl
-tests/pkg_heatshrink
-tests/pkg_jsmn
-tests/pkg_libb2
-tests/pkg_libcose
-tests/pkg_libfixmath
-tests/pkg_libhydrogen
-tests/pkg_lora-serialization
-tests/pkg_micro-ecc
-tests/pkg_minmea
-tests/pkg_monocypher
-tests/pkg_nanocbor
-tests/pkg_nanopb
-tests/pkg_qDSA
-tests/pkg_qcbor
-tests/pkg_relic
-tests/pkg_tiny-asn1
-tests/pkg_tinycbor
-tests/pkg_tinycrypt
-tests/pkg_tweetnacl
-tests/pkg_umorse
-tests/pkg_yxml
-tests/posix_sleep
 tests/prng_*
-tests/shell
-tests/struct_tm_utility
-tests/sys_crypto
-tests/test_tools
 tests/xtimer_*
 tests/ztimer_*
 "}
@@ -99,13 +69,19 @@ RUN_TESTS=${RUN_TESTS:-${NIGHTLY}}
 DWQ_ENV="-E BOARDS -E APPS -E NIGHTLY -E RUN_TESTS -E ENABLE_TEST_CACHE
          -E TEST_HASH -E CI_PULL_LABELS"
 
-get_kconfig_test_apps() {
-    case "$1" in
-        "samr21-xpro") echo "${TEST_KCONFIG_samr21_xpro}" ;;
-    esac
-    case "$1" in
-        "native") echo "${TEST_KCONFIG_native}" ;;
-    esac
+get_supported_kconfig_board_app() {
+    local board=$1
+    local appdir=$2
+
+    if is_in_list "${board}" "${TEST_KCONFIG_BOARDS_AVAILABLE}"; then
+        if is_in_list "${appdir}" "${TEST_KCONFIG_ENFORCE_APP_GROUPS}"; then
+            return 0
+        fi
+        if [ -f "${appdir}/app.config.test" ]; then
+            return 0
+        fi
+    fi
+    return 1
 }
 
 check_label() {
@@ -314,23 +290,19 @@ compile() {
 
     should_check_kconfig_hash=0
 
-    for app in $(get_kconfig_test_apps "${board}")
-    do
-        if [ "${appdir}" = "${app}" ]; then
-            should_check_kconfig_hash=1
-            BOARD=${board} make -C${appdir} clean
-            CCACHE_BASEDIR="$(pwd)" BOARD=${board} TOOLCHAIN=${toolchain} RIOT_CI_BUILD=1 TEST_KCONFIG=1 \
-                            make -C${appdir} all test-input-hash -j${JOBS:-4}
-            RES=$?
-            if [ $RES -eq 0 ]; then
-                kconfig_test_hash=$(test_hash_calc "${BINDIR}")
-            else
-                kconfig_test_hash=0
-                echo "An error occurred while compiling using Kconfig";
-            fi
-            break
+    if get_supported_kconfig_board_app "${board}" "${appdir}"; then
+        should_check_kconfig_hash=1
+        BOARD=${board} make -C${appdir} clean
+        CCACHE_BASEDIR="$(pwd)" BOARD=${board} TOOLCHAIN=${toolchain} RIOT_CI_BUILD=1 TEST_KCONFIG=1 \
+                        make -C${appdir} all test-input-hash -j${JOBS:-4}
+        RES=$?
+        if [ $RES -eq 0 ]; then
+            kconfig_test_hash=$(test_hash_calc "${BINDIR}")
+        else
+            kconfig_test_hash=0
+            echo "An error occurred while compiling using Kconfig";
         fi
-    done
+    fi
 
     # compile without Kconfig
     CCACHE_BASEDIR="$(pwd)" BOARD=$board TOOLCHAIN=$toolchain RIOT_CI_BUILD=1 \
diff --git a/CODEOWNERS b/CODEOWNERS
index 5ad69b5f02..456bca4597 100644
--- a/CODEOWNERS
+++ b/CODEOWNERS
@@ -115,8 +115,8 @@
 /sys/event/                                 @kaspar030
 /sys/evtimer/                               @kaspar030
 /sys/fmt/                                   @kaspar030
-/sys/net/application_layer/gcoap/           @haukepetersen @kb2ma
-/sys/net/application_layer/nanocoap/        @kaspar030 @haukepetersen @kb2ma
+/sys/net/application_layer/gcoap/           @haukepetersen @kb2ma @chrysn
+/sys/net/application_layer/nanocoap/        @kaspar030 @haukepetersen @kb2ma @chrysn
 /sys/include/net/sock*                      @maribu
 /sys/net/netif/                             @miri64 @jia200x
 /sys/net/gnrc/network_layer/                @miri64
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 2bdafb260d..2c1e9de169 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -10,15 +10,13 @@ of this document using the following links:
 * [Writing Documentation][writing-documentation]
 * [Working with Git][working with git]
 
-If you have questions, please write a post over at our [forum], send an email to
-<users@riot-os.org> or <devel@riot-os.org> mailing list or chat on `#riot-os` on
-[IRC] or [Matrix].
+If you have questions, please write a post over at our [forum] or chat on
+`#riot-os:matrix.org` on [Matrix].
 
 As a reminder, all contributors are expected to follow our
 [Code of Conduct](CODE_OF_CONDUCT.md).
 
 [forum]: https://forum.riot-os.org
-[IRC]: http://webchat.freenode.net?channels=riot-os
 [Matrix]: https://matrix.to/#/#riot-os:matrix.org
 
 ## Getting Started
@@ -191,8 +189,8 @@ into the source repository.
   preoccupied with other PRs. If it happens that your PR receives no review for
   a long time, don't hesitate to gently solicit a review by commenting or
   by explicitly mentioning a maintainer that you know is knowledgeable in the
-  area of the PR. You can also advertise the PR on devel@riot-os.org mailing
-  list and ask for a review there.
+  area of the PR. You can also advertise the PR on the [forum] and ask for a
+  review there.
 
 * Try to answer reviews as quickly as possible to speed up the review process
   and avoid stalled PRs.
diff --git a/Makefile b/Makefile
index 775ebef32c..8ae12421fd 100644
--- a/Makefile
+++ b/Makefile
@@ -38,10 +38,8 @@ welcome:
 	@echo ""
 	@echo "Please see our Quick Start Guide at:"
 	@echo "    https://doc.riot-os.org/getting-started.html"
-	@echo "You can ask questions on our forum:"
+	@echo "You can ask questions or discuss with other users on our forum:"
 	@echo "    https://forum.riot-os.org"
-	@echo "Or discuss with other users on the mailing list:"
-	@echo "    users@riot-os.org (http://lists.riot-os.org/mailman/listinfo/users)"
 
 print-versions:
 	@./dist/tools/ci/print_toolchain_versions.sh
diff --git a/Makefile.base b/Makefile.base
index 88cb367043..58124cc1e5 100644
--- a/Makefile.base
+++ b/Makefile.base
@@ -67,9 +67,14 @@ ifeq ($(strip $(ASSMSRC))$(NO_AUTO_SRC),)
   ASSMSRC := $(wildcard *.S)
 endif
 
+
 ifneq (,$(SRCXX))
-  ifeq (,$(filter cpp,$(FEATURES_USED)))
-    $(error Found C++ source, but feature "cpp" is not used. Add "FEATURES_REQUIRED += cpp")
+  ifeq (,$(filter cpp,$(USEMODULE)))
+    ifneq (1,$(TEST_KCONFIG))
+      $(error Found C++ source, but feature "cpp" is not used. Add "FEATURES_REQUIRED += cpp")
+    else
+      $(error Found C++ source, but "cpp" module is not used. Enable the MODULE_CPP in Kconfig)
+    endif
   endif
 endif
 
diff --git a/Makefile.dep b/Makefile.dep
index ba85bed880..8a8adb2116 100644
--- a/Makefile.dep
+++ b/Makefile.dep
@@ -10,7 +10,7 @@
 
 # include external modules dependencies
 # processed before RIOT ones to be evaluated before the 'default' rules.
--include $(EXTERNAL_MODULE_DIRS:%=%/Makefile.dep)
+-include $(EXTERNAL_MODULE_PATHS:%=%/Makefile.dep)
 
 # pull dependencies from sys and drivers
 include $(RIOTBASE)/sys/Makefile.dep
@@ -104,7 +104,13 @@ FEATURES_OPTIONAL += no_idle_thread
 
 ifneq (,$(filter libstdcpp,$(FEATURES_USED)))
   # Also use C++ if libstdc++ is used
-  FEATURES_REQUIRED += cpp
+  USEMODULE += cpp
+  USEMODULE += libstdcpp
+endif
+
+ifneq (,$(filter cpp,$(FEATURES_USED)))
+  # Also use C++ if libstdc++ is used
+  USEMODULE += cpp
 endif
 
 ifneq (,$(filter test_utils_interactive_sync,$(USEMODULE)))
diff --git a/Makefile.include b/Makefile.include
index 692fe86a53..365a3a32df 100644
--- a/Makefile.include
+++ b/Makefile.include
@@ -41,22 +41,23 @@ include $(RIOT_MAKEFILES_GLOBAL_PRE)
 -include Makefile.local
 
 # set undefined variables
-RIOTBASE            ?= $(_riotbase)
-RIOTCPU             ?= $(RIOTBASE)/cpu
+RIOTBASE                        ?= $(_riotbase)
+RIOTCPU                         ?= $(RIOTBASE)/cpu
 # Deprecated to set RIOTBOARD, use EXTERNAL_BOARD_DIRS
-RIOTBOARD           ?= $(RIOTBASE)/boards
-EXTERNAL_BOARD_DIRS ?=
-RIOTMAKE            ?= $(RIOTBASE)/makefiles
-RIOTPKG             ?= $(RIOTBASE)/pkg
-RIOTTOOLS           ?= $(RIOTBASE)/dist/tools
-RIOTPROJECT         ?= $(shell git rev-parse --show-toplevel 2>/dev/null || pwd)
-BUILD_DIR           ?= $(RIOTBASE)/build
-APPDIR              ?= $(CURDIR)
-BINDIRBASE          ?= $(APPDIR)/bin
-BINDIR              ?= $(BINDIRBASE)/$(BOARD)
-PKGDIRBASE          ?= $(RIOTBASE)/build/pkg
-DLCACHE             ?= $(RIOTTOOLS)/dlcache/dlcache.sh
-DLCACHE_DIR         ?= $(RIOTBASE)/.dlcache
+RIOTBOARD                       ?= $(RIOTBASE)/boards
+EXTERNAL_BOARD_DIRS             ?=
+RIOTMAKE                        ?= $(RIOTBASE)/makefiles
+RIOTPKG                         ?= $(RIOTBASE)/pkg
+RIOTTOOLS                       ?= $(RIOTBASE)/dist/tools
+RIOTPROJECT                     ?= $(shell git rev-parse --show-toplevel 2>/dev/null || pwd)
+BUILD_DIR                       ?= $(RIOTBASE)/build
+APPDIR                          ?= $(CURDIR)
+BINDIRBASE                      ?= $(APPDIR)/bin
+BINDIR                          ?= $(BINDIRBASE)/$(BOARD)
+PKGDIRBASE                      ?= $(RIOTBASE)/build/pkg
+DLCACHE                         ?= $(RIOTTOOLS)/dlcache/dlcache.sh
+DLCACHE_DIR                     ?= $(RIOTBASE)/.dlcache
+WARNING_EXTERNAL_MODULE_DIRS    ?= 1
 
 # include CI info such as BOARD_INSUFFICIENT_MEMORY, if existing
 -include Makefile.ci
@@ -82,17 +83,20 @@ __OVERRIDE_DIRECTORY_VARIABLES := $(__DIRECTORY_VARIABLES)
 # Use absolute paths in recursive "make" even if overridden on command line.
 MAKEOVERRIDES += $(foreach v,$(__OVERRIDE_DIRECTORY_VARIABLES),$(v)=$($(v)))
 
-# Setting EXTERNAL_BOARD_DIRS as command line argument is too messy to handle:
-# Even when every path in EXTERNAL_BOARD_DIRS is turned into an absolute path
-# using override, sub-makes will still get the original value. Using
-# MAKEOVERRIDES has issues with spaces in the values, which are used as
-# separator in EXTERNAL_BOARD_DIRS. So we just enforce setting the value
+# Setting EXTERNAL_BOARD_DIRS and EXTERNAL_MODULE_DIRS as command line argument
+# is too messy to handle: Even when every path in EXTERNAL_BOARD_DIRS is turned
+# into an absolute path using override, sub-makes will still get the original
+# value. Using MAKEOVERRIDES has issues with spaces in the values, which are
+# used as separator in EXTERNAL_BOARD_DIRS. So we just enforce setting the value
 # either in a Makefile, or as environment variable.
-ifeq ($(origin EXTERNAL_BOARD_DIRS),command line)
+ifeq ($(INSIDE_DOCKER),0)
   # In Docker absolute paths are always given, so only fail when not in docker
-  ifeq ($(INSIDE_DOCKER),0)
+  ifeq ($(origin EXTERNAL_BOARD_DIRS),command line)
     $(error EXTERNAL_BOARD_DIRS must be passed as environment variable, and not as command line argument)
   endif
+  ifeq ($(origin EXTERNAL_MODULE_DIRS),command line)
+    $(error EXTERNAL_MODULE_DIRS must be passed as environment variable, and not as command line argument)
+  endif
 endif
 
 # Deprecation of configuring 'RIOTBOARD'
@@ -102,15 +106,27 @@ ifneq ($(abspath $(RIOTBASE)/boards),$(abspath $(RIOTBOARD)))
   __DIRECTORY_VARIABLES += RIOTBOARD
 endif
 
-ifneq (,$(BOARDSDIR))
-  # Only warn users, not the CI.
-  ifneq ($(RIOT_CI_BUILD),1)
-    # Do not warn when set from sub-make
-    ifeq ($(MAKELEVEL),0)
+# Only warn users, not the CI.
+ifneq ($(RIOT_CI_BUILD),1)
+  # Do not warn when set from sub-make
+  ifeq ($(MAKELEVEL),0)
+    ifneq (,$(BOARDSDIR))
       $(warning Using BOARDSDIR is deprecated use EXTERNAL_BOARD_DIRS instead)
       $(info EXTERNAL_BOARD_DIRS can contain multiple folders separated by space)
     endif
+
+    # API change warning for EXTERNAL_MODULE_DIRS, remove by 2021.10
+    ifneq (,$(EXTERNAL_MODULE_DIRS))
+      ifeq (1,$(WARNING_EXTERNAL_MODULE_DIRS))
+        $(info Warning! EXTERNAL_MODULE_DIRS is a search folder since 2021.07-branch, see \
+               https://doc.riot-os.org/creating-modules.html#modules-outside-of-riotbase)
+      endif
+    endif
   endif
+endif
+
+# Needed for backward compatibility:
+ifneq (,$(BOARDSDIR))
   EXTERNAL_BOARD_DIRS += $(BOARDSDIR)
 endif
 
@@ -130,6 +146,9 @@ override DLCACHE_DIR            := $(abspath $(DLCACHE_DIR))
 EXTERNAL_BOARD_DIRS             := $(foreach dir,\
                                              $(EXTERNAL_BOARD_DIRS),\
                                              $(abspath $(dir)))
+EXTERNAL_MODULE_DIRS            := $(foreach dir,\
+                                             $(EXTERNAL_MODULE_DIRS),\
+                                             $(abspath $(dir)))
 
 # Ensure that all directories are set and don't contain spaces.
 ifneq (, $(filter-out 1, $(foreach v,$(__DIRECTORY_VARIABLES),$(words $($(v))))))
@@ -171,6 +190,7 @@ include $(RIOTMAKE)/utils/checks.mk
 include $(RIOTMAKE)/docker.inc.mk
 
 # include color echo macros
+include $(RIOTMAKE)/utils/ansi.mk
 include $(RIOTMAKE)/color.inc.mk
 
 # include concurrency helpers
@@ -255,6 +275,7 @@ else
 endif
 
 QUIET ?= 1
+QUIETER ?= 0
 
 ifeq ($(QUIET),1)
   Q=@
@@ -263,8 +284,6 @@ else
   Q=
 endif
 
-QQ=
-
 # Set this to 1 to enable code in RIOT that does safety checking
 # which is not needed in a production environment but helps in the
 # development process:
@@ -462,7 +481,13 @@ ifeq ($(RIOT_CI_BUILD),1)
         RIOTNOLINK:=1
     endif
     # be more quiet when building for CI
-    QQ:=@
+    QUIETER=1
+endif
+
+ifeq ($(QUIETER),1)
+  QQ=@
+else
+  QQ=
 endif
 
 # if you want to publish the board into the sources as an uppercase #define
@@ -510,7 +535,7 @@ include $(RIOTBASE)/sys/Makefile.include
 -include $(USEPKG:%=$(RIOTPKG)/%/Makefile.include)
 
 # include external modules configuration
--include $(EXTERNAL_MODULE_DIRS:%=%/Makefile.include)
+-include $(EXTERNAL_MODULE_PATHS:%=%/Makefile.include)
 
 # Deduplicate includes without sorting them
 # see https://stackoverflow.com/questions/16144115/makefile-remove-duplicate-words-without-sorting
@@ -552,8 +577,14 @@ include $(RIOTMAKE)/modules.inc.mk
 .PHONY: FORCE
 
 ifneq (,$(IOTLAB_NODE))
-  # iot-lab serial and flasher
-  include $(RIOTBASE)/dist/testbed-support/makefile.iotlab.single.inc.mk
+  # iot-lab archi mapping
+  include $(RIOTBASE)/dist/testbed-support/makefile.iotlab.archi.inc.mk
+  ifneq (,$(IOTLAB_ARCHI))
+    # iot-lab serial and flasher
+    include $(RIOTBASE)/dist/testbed-support/makefile.iotlab.single.inc.mk
+  else
+    $(info $(COLOR_YELLOW)Board "$(BOARD)" incompatible with IOTLAB_NODE variable$(COLOR_RESET))
+  endif
 endif
 
 ELFFILE ?= $(BINDIR)/$(APPLICATION).elf
@@ -592,14 +623,15 @@ else
 endif
 
 # variables used to compile and link c++
-ifneq (,$(filter cpp,$(FEATURES_USED)))
+ifneq (,$(filter cpp,$(USEMODULE)))
   CPPMIX ?= 1
 endif
 
 # We assume $(LINK) to be gcc-like. Use `LINKFLAGPREFIX :=` for ld-like linker options.
 LINKFLAGPREFIX ?= -Wl,
 
-DIRS += $(EXTERNAL_MODULE_DIRS)
+# Also build external modules
+DIRS += $(EXTERNAL_MODULE_PATHS)
 
 # Define dependencies required for building (headers, downloading source files,)
 BUILDDEPS += $(RIOTBUILD_CONFIG_HEADER_C)
diff --git a/README.md b/README.md
index 5473e34992..0b98306773 100644
--- a/README.md
+++ b/README.md
@@ -6,7 +6,6 @@
 [![Merge chance][merge-chance-badge]][merge-chance-link]
 [![Stack Overflow questions][stackoverflow-badge]][stackoverflow-link]
 [![Twitter][twitter-badge]][twitter-link]
-[![IRC][irc-badge]][irc-link]
 [![Matrix][matrix-badge]][matrix-link]
 
                           ZZZZZZ
@@ -75,6 +74,30 @@ but not limited to:
 * Sigfox
 * LoRaWAN
 
+## GETTING RIOT
+
+The most convenient way to get RIOT is to clone it via Git
+
+```console
+$ git clone https://github.com/RIOT-OS/RIOT
+```
+
+this will ensure that you get all the newest features and bug fixes with the
+caveat of an ever changing work environment.
+
+If you prefer things more stable, you can download the source code of one of our
+quarter annual releases [via Github][releases] as ZIP file or tarball. You can
+also checkout a release in a cloned Git repository using
+
+```console
+$ git pull --tags
+$ git checkout <YYYY.MM>
+```
+
+For more details on our release cycle, check our [documentation][release cycle].
+
+[releases]: https://github.com/RIOT-OS/RIOT/releases
+[release cycle]: https://doc.riot-os.org/release-cycle.html
 
 ## GETTING STARTED
 * You want to start the RIOT? Just follow our
@@ -85,7 +108,7 @@ For specific toolchain installation, follow instructions in the
 [getting started](https://doc.riot-os.org/getting-started.html) page.
 * The RIOT API itself can be built from the code using doxygen. The latest
   version of the documentation is uploaded daily to
-  [riot-os.org/api](https://riot-os.org/api).
+  [doc.riot-os.org](https://doc.riot-os.org).
 
 ## FORUM
 Do you have a question, want to discuss a new feature, or just want to present
@@ -100,8 +123,6 @@ To contribute something to RIOT, please refer to our
 [contributing document](CONTRIBUTING.md).
 
 ## MAILING LISTS
-* RIOT OS kernel developers list: [devel@riot-os.org](https://lists.riot-os.org/mailman/listinfo/devel)
-* RIOT OS users list: [users@riot-os.org](https://lists.riot-os.org/mailman/listinfo/users)
 * RIOT commits: [commits@riot-os.org](https://lists.riot-os.org/mailman/listinfo/commits)
 * Github notifications: [notifications@riot-os.org](https://lists.riot-os.org/mailman/listinfo/notifications)
 
@@ -121,8 +142,6 @@ https://www.riot-os.org
 
 [api-badge]: https://img.shields.io/badge/docs-API-informational.svg
 [api-link]: https://riot-os.org/api/
-[irc-badge]: https://img.shields.io/badge/chat-IRC-brightgreen.svg
-[irc-link]: https://webchat.freenode.net?channels=%23riot-os
 [license-badge]: https://img.shields.io/github/license/RIOT-OS/RIOT
 [license-link]: https://github.com/RIOT-OS/RIOT/blob/master/LICENSE
 [master-ci-badge]: https://ci.riot-os.org/RIOT-OS/RIOT/master/latest/badge.svg
diff --git a/VERSION b/VERSION
index ba58a79433..aba1066bdc 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-RIOT_VERSION = 2021.04
+RIOT_VERSION = 2021.07
diff --git a/boards/arduino-nano-33-iot/Kconfig b/boards/arduino-nano-33-iot/Kconfig
index a48a492cc9..99ca1a5c31 100644
--- a/boards/arduino-nano-33-iot/Kconfig
+++ b/boards/arduino-nano-33-iot/Kconfig
@@ -11,7 +11,9 @@ config BOARD_ARDUINO_NANO_33_IOT
     bool
     default y
     select CPU_MODEL_SAMD21G18A
+    select HAS_PERIPH_ADC
     select HAS_PERIPH_I2C
+    select HAS_PERIPH_PWM
     select HAS_PERIPH_RTC
     select HAS_PERIPH_RTT
     select HAS_PERIPH_SPI
diff --git a/boards/arduino-nano-33-iot/Makefile.features b/boards/arduino-nano-33-iot/Makefile.features
index 6aae77d530..c43f111ff1 100644
--- a/boards/arduino-nano-33-iot/Makefile.features
+++ b/boards/arduino-nano-33-iot/Makefile.features
@@ -2,7 +2,9 @@ CPU = samd21
 CPU_MODEL = samd21g18a
 
 # Put defined MCU peripherals here (in alphabetical order)
+FEATURES_PROVIDED += periph_adc
 FEATURES_PROVIDED += periph_i2c
+FEATURES_PROVIDED += periph_pwm
 FEATURES_PROVIDED += periph_rtc
 FEATURES_PROVIDED += periph_rtt
 FEATURES_PROVIDED += periph_spi
diff --git a/boards/arduino-nano-33-iot/include/periph_conf.h b/boards/arduino-nano-33-iot/include/periph_conf.h
index e05d2df77a..b65cbd5810 100644
--- a/boards/arduino-nano-33-iot/include/periph_conf.h
+++ b/boards/arduino-nano-33-iot/include/periph_conf.h
@@ -139,6 +139,72 @@ static const uart_conf_t uart_config[] = {
 #define UART_NUMOF          ARRAY_SIZE(uart_config)
 /** @} */
 
+/**
+ * @name PWM configuration
+ * @{
+ */
+#define PWM_0_EN            1
+#define PWM_1_EN            1
+
+#if PWM_0_EN
+/* PWM0 channels */
+static const pwm_conf_chan_t pwm_chan0_config[] = {
+    /* GPIO pin, MUX value, TCC channel */
+    { GPIO_PIN(PA, 4), GPIO_MUX_E, 0},
+    { GPIO_PIN(PA, 5), GPIO_MUX_E, 1},
+};
+#endif
+#if PWM_1_EN
+/* PWM1 channels */
+static const pwm_conf_chan_t pwm_chan1_config[] = {
+    /* GPIO pin, MUX value, TCC channel */
+    { GPIO_PIN(PA, 10), GPIO_MUX_E,  0 },
+    { GPIO_PIN(PA, 11), GPIO_MUX_E,  1 },
+};
+#endif
+
+/* PWM device configuration */
+static const pwm_conf_t pwm_config[] = {
+#if PWM_0_EN
+    {TCC_CONFIG(TCC0), pwm_chan0_config, ARRAY_SIZE(pwm_chan0_config), SAM0_GCLK_MAIN},
+#endif
+
+#if PWM_1_EN
+    {TCC_CONFIG(TCC1), pwm_chan1_config, ARRAY_SIZE(pwm_chan1_config), SAM0_GCLK_MAIN},
+#endif
+};
+
+/* number of devices that are actually defined */
+#define PWM_NUMOF           ARRAY_SIZE(pwm_config)
+/** @} */
+
+/**
+ * @name ADC configuration
+ * @{
+ */
+
+/* ADC Default values */
+#define ADC_PRESCALER                       ADC_CTRLB_PRESCALER_DIV512
+
+#define ADC_NEG_INPUT                       ADC_INPUTCTRL_MUXNEG_GND
+#define ADC_GAIN_FACTOR_DEFAULT             ADC_INPUTCTRL_GAIN_1X
+#define ADC_REF_DEFAULT                     ADC_REFCTRL_REFSEL_INT1V
+
+static const adc_conf_chan_t adc_channels[] = {
+    /* port, pin, muxpos */
+    {GPIO_PIN(PA, 2), ADC_INPUTCTRL_MUXPOS_PIN0},    /* A0 */
+    {GPIO_PIN(PB, 2), ADC_INPUTCTRL_MUXPOS_PIN10},   /* A1 */
+    {GPIO_PIN(PA, 11), ADC_INPUTCTRL_MUXPOS_PIN19},  /* A2 */
+    {GPIO_PIN(PA, 10), ADC_INPUTCTRL_MUXPOS_PIN18},  /* A3 */
+    {GPIO_PIN(PB, 8), ADC_INPUTCTRL_MUXPOS_PIN2},    /* A4 */
+    {GPIO_PIN(PB, 9), ADC_INPUTCTRL_MUXPOS_PIN3},    /* A5 */
+    {GPIO_PIN(PA, 9), ADC_INPUTCTRL_MUXPOS_PIN17},   /* A6 */
+    {GPIO_PIN(PB, 3), ADC_INPUTCTRL_MUXPOS_PIN11},   /* A7 */
+};
+
+#define ADC_NUMOF                           ARRAY_SIZE(adc_channels)
+/** @} */
+
 /**
  * @name I2C configuration
  * @{
@@ -163,17 +229,29 @@ static const i2c_conf_t i2c_config[] = {
  */
 static const spi_conf_t spi_config[] = {
     {   /* Connected to NINA W102 */
-        .dev      = &SERCOM4->SPI,
+        .dev      = &SERCOM2->SPI,
         .miso_pin = GPIO_PIN(PA, 13),
         .mosi_pin = GPIO_PIN(PA, 12),
         .clk_pin  = GPIO_PIN(PA, 15),
-        .miso_mux = GPIO_MUX_D,
-        .mosi_mux = GPIO_MUX_D,
-        .clk_mux  = GPIO_MUX_D,
+        .miso_mux = GPIO_MUX_C,
+        .mosi_mux = GPIO_MUX_C,
+        .clk_mux  = GPIO_MUX_C,
         .miso_pad = SPI_PAD_MISO_1,
         .mosi_pad = SPI_PAD_MOSI_0_SCK_3,
         .gclk_src = SAM0_GCLK_MAIN,
     },
+    {
+        .dev = &SERCOM3->SPI,
+        .miso_pin = GPIO_PIN(PA, 19),
+        .mosi_pin = GPIO_PIN(PA, 16),
+        .clk_pin = GPIO_PIN(PA, 17),
+        .miso_mux = GPIO_MUX_D,
+        .mosi_mux = GPIO_MUX_D,
+        .clk_mux = GPIO_MUX_D,
+        .miso_pad = SPI_PAD_MISO_3,
+        .mosi_pad = SPI_PAD_MOSI_0_SCK_1,
+        .gclk_src = SAM0_GCLK_MAIN,
+    },
 };
 
 #define SPI_NUMOF           ARRAY_SIZE(spi_config)
diff --git a/boards/atmega256rfr2-xpro/include/board.h b/boards/atmega256rfr2-xpro/include/board.h
index 7e4edde9fa..22b61528af 100644
--- a/boards/atmega256rfr2-xpro/include/board.h
+++ b/boards/atmega256rfr2-xpro/include/board.h
@@ -42,6 +42,14 @@ extern "C" {
 #define XTIMER_BACKOFF              (40)
 /** @} */
 
+/**
+ * @name    ztimer configuration values
+ * @{
+ */
+#define CONFIG_ZTIMER_USEC_ADJUST_SET     (128)
+#define CONFIG_ZTIMER_USEC_ADJUST_SLEEP   (128)
+/** @} */
+
 /**
  * @name    Macros for controlling the on-board LED
  * @{
diff --git a/boards/atxmega-a1u-xpro/Kconfig b/boards/atxmega-a1u-xpro/Kconfig
index efb90396a0..7e7fdffafc 100644
--- a/boards/atxmega-a1u-xpro/Kconfig
+++ b/boards/atxmega-a1u-xpro/Kconfig
@@ -15,8 +15,10 @@ config BOARD_ATXMEGA_A1U_XPRO
     select HAS_PERIPH_CPUID
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
+    select HAS_PERIPH_I2C
     select HAS_PERIPH_NVM
     select HAS_PERIPH_PM
+    select HAS_PERIPH_SPI
     select HAS_PERIPH_TIMER
     select HAS_PERIPH_TIMER_PERIODIC
     select HAS_PERIPH_UART
diff --git a/boards/atxmega-a1u-xpro/include/board.h b/boards/atxmega-a1u-xpro/include/board.h
index 2314adc6ce..8ac664712d 100644
--- a/boards/atxmega-a1u-xpro/include/board.h
+++ b/boards/atxmega-a1u-xpro/include/board.h
@@ -88,7 +88,6 @@ extern "C" {
  *
  * @{
  */
-
 #define XTIMER_DEV          TIMER_DEV(0)
 #define XTIMER_CHAN         (0)
 #define XTIMER_WIDTH        (16)
diff --git a/boards/atxmega-a1u-xpro/include/periph_conf.h b/boards/atxmega-a1u-xpro/include/periph_conf.h
index e52ded321f..66c1c283ff 100644
--- a/boards/atxmega-a1u-xpro/include/periph_conf.h
+++ b/boards/atxmega-a1u-xpro/include/periph_conf.h
@@ -92,6 +92,44 @@ static const uart_conf_t uart_config[] = {
 #define UART_NUMOF        ARRAY_SIZE(uart_config)
 /** @} */
 
+/**
+ * @name I2C configuration
+ * @{
+ */
+static const i2c_conf_t i2c_config[] = {
+    {
+        .dev                = &TWIC,
+        .pwr                = PWR_RED_REG(PWR_PORT_C, PR_TWI_bm),
+        .sda_pin            = GPIO_PIN(PORT_C, 0),
+        .scl_pin            = GPIO_PIN(PORT_C, 1),
+        .speed              = I2C_SPEED_NORMAL,
+        .int_lvl            = CPU_INT_LVL_LOW,
+    },
+};
+
+#define I2C_0_ISR           TWIC_TWIM_vect
+
+#define I2C_NUMOF           ARRAY_SIZE(i2c_config)
+/** @} */
+
+/**
+ * @name    SPI configuration
+ * @{
+ */
+static const spi_conf_t spi_config[] = {
+    {
+        .dev            = &SPIC,
+        .pwr            = PWR_RED_REG(PWR_PORT_C, PR_SPI_bm),
+        .sck_pin        = GPIO_PIN(PORT_C, 7),
+        .miso_pin       = GPIO_PIN(PORT_C, 6),
+        .mosi_pin       = GPIO_PIN(PORT_C, 5),
+        .ss_pin         = GPIO_PIN(PORT_C, 4),
+    },
+};
+
+#define SPI_NUMOF         ARRAY_SIZE(spi_config)
+/** @} */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/boards/atxmega-a3bu-xplained/Kconfig b/boards/atxmega-a3bu-xplained/Kconfig
index 28d507b807..358a90bc9d 100644
--- a/boards/atxmega-a3bu-xplained/Kconfig
+++ b/boards/atxmega-a3bu-xplained/Kconfig
@@ -15,8 +15,10 @@ config BOARD_ATXMEGA_A3BU_XPLAINED
     select HAS_PERIPH_CPUID
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
+    select HAS_PERIPH_I2C
     select HAS_PERIPH_NVM
     select HAS_PERIPH_PM
+    select HAS_PERIPH_SPI
     select HAS_PERIPH_TIMER
     select HAS_PERIPH_TIMER_PERIODIC
     select HAS_PERIPH_UART
diff --git a/boards/atxmega-a3bu-xplained/include/periph_conf.h b/boards/atxmega-a3bu-xplained/include/periph_conf.h
index dd623388f5..a9106673cb 100644
--- a/boards/atxmega-a3bu-xplained/include/periph_conf.h
+++ b/boards/atxmega-a3bu-xplained/include/periph_conf.h
@@ -109,6 +109,44 @@ static const uart_conf_t uart_config[] = {
 #define UART_NUMOF        ARRAY_SIZE(uart_config)
 /** @} */
 
+/**
+ * @name I2C configuration
+ * @{
+ */
+static const i2c_conf_t i2c_config[] = {
+    {   /* J1 */
+        .dev                = &TWIC,
+        .pwr                = PWR_RED_REG(PWR_PORT_C, PR_TWI_bm),
+        .sda_pin            = GPIO_PIN(PORT_C, 0),
+        .scl_pin            = GPIO_PIN(PORT_C, 1),
+        .speed              = I2C_SPEED_NORMAL,
+        .int_lvl            = CPU_INT_LVL_LOW,
+    },
+};
+
+#define I2C_0_ISR           TWIC_TWIM_vect
+
+#define I2C_NUMOF           ARRAY_SIZE(i2c_config)
+/** @} */
+
+/**
+ * @name    SPI configuration
+ * @{
+ */
+static const spi_conf_t spi_config[] = {
+    {
+        .dev            = &SPIC,
+        .pwr            = PWR_RED_REG(PWR_PORT_C, PR_SPI_bm),
+        .sck_pin        = GPIO_PIN(PORT_C, 7),
+        .miso_pin       = GPIO_PIN(PORT_C, 6),
+        .mosi_pin       = GPIO_PIN(PORT_C, 5),
+        .ss_pin         = GPIO_PIN(PORT_C, 4),
+    },
+};
+
+#define SPI_NUMOF         ARRAY_SIZE(spi_config)
+/** @} */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/boards/bastwan/include/periph_conf.h b/boards/bastwan/include/periph_conf.h
index b353b4bddc..9cfd48eadb 100644
--- a/boards/bastwan/include/periph_conf.h
+++ b/boards/bastwan/include/periph_conf.h
@@ -48,7 +48,7 @@ static const tc32_conf_t timer_config[] = {
         .mclk = &MCLK->APBCMASK.reg,
         .mclk_mask = MCLK_APBCMASK_TC0 | MCLK_APBCMASK_TC1,
         .gclk_id = TC0_GCLK_ID,
-        .gclk_src = SAM0_GCLK_8MHZ,
+        .gclk_src = SAM0_GCLK_TIMER,
         .flags = TC_CTRLA_MODE_COUNT32,
     }
 };
diff --git a/boards/common/arduino-atmega/include/board_common.h b/boards/common/arduino-atmega/include/board_common.h
index 458145e893..e20ed8aa51 100644
--- a/boards/common/arduino-atmega/include/board_common.h
+++ b/boards/common/arduino-atmega/include/board_common.h
@@ -113,6 +113,8 @@ extern "C" {
 #define CONFIG_ZTIMER_USEC_DEV      (TIMER_DEV(0))
 #define CONFIG_ZTIMER_USEC_FREQ     (250000LU)
 #define CONFIG_ZTIMER_USEC_WIDTH    (16)
+#define CONFIG_ZTIMER_USEC_ADJUST_SET     (124)
+#define CONFIG_ZTIMER_USEC_ADJUST_SLEEP   (120)
 /** @} */
 
 /**
diff --git a/boards/common/esp8266/include/periph_conf_common.h b/boards/common/esp8266/include/periph_conf_common.h
index 7f90e018d5..2ca9c9cd82 100644
--- a/boards/common/esp8266/include/periph_conf_common.h
+++ b/boards/common/esp8266/include/periph_conf_common.h
@@ -208,17 +208,41 @@ static const spi_conf_t spi_config[] = {
 /**
  * @name   UART configuration
  *
- * All ESP8266 boards have exactly one UART device with fixed pin mapping.
- * This UART device is used for flashing and as a console interface.
- * Therefore, the number of UART devices is fixed and can not be overridden.
- * Used pins are determined by the MCU implementation and are defined here
- * only for documentation reasons.
+ * All ESP8266 boards have two UART devices with two options of pin mappings
+ * each, however most board will only expose only UART0 and in the GPIO1 and
+ * GPIO3 pins, although other combinations are possible. In particular, the
+ * boot ROM will map both GPIO1 and GPIO2 as TX for UART0 on boot, so either
+ * one can be used for serial communication or flashing the device.
+ * While UART1 is also available, the only option for UART1 RX pin (GPIO8) is
+ * used for the board flash, but UART1 TX can be used separately
+ *
+ * Pin mapping available:
+ *  UART0 TX:  GPIO1 and GPIO2  (both enabled by the boot ROM)
+ *  UART0 RX:  GPIO3
+ *  UART1 TX:  GPIO2 and GPIO7  (GPIO7 is used by the flash)
+ *  UART0 RX:  GPIO8            (GPIO8 is used by the flash)
+ *
+ * UART0 device is used for flashing and as a console interface. UART1 if
+ * UART1_TXD is defined can be used for communication with other peripherals at
+ * a different baudrate if desired.
  *
  * @{
  */
-
+#ifndef UART0_TXD
 #define UART0_TXD   GPIO1               /**< TxD pin of UART_DEV(0) */
+#endif /* UART0_TXD */
+
+#ifndef UART0_RXD
 #define UART0_RXD   GPIO3               /**< RxD pin of UART_DEV(0) */
+#endif /* UART0_RXD */
+
+#ifdef DOXYGEN
+#define UART1_TXD   GPIO2               /**< TxD pin of UART_DEV(1) */
+#endif /* DOXYGEN */
+
+#ifndef UART1_RXD
+#define UART1_RXD   GPIO_UNDEF          /**< RxD pin of UART_DEV(1) */
+#endif /* UART1_RXD */
 
 /**
  * @brief   Static array with configuration for declared UART devices
@@ -228,6 +252,12 @@ static const uart_conf_t uart_config[] = {
         .txd = UART0_TXD,
         .rxd = UART0_RXD,
     },
+#ifdef UART1_TXD
+    {
+        .txd = UART1_TXD,
+        .rxd = UART1_RXD,
+    },
+#endif /* UART1_TXD */
 };
 
 /**
diff --git a/boards/common/kw41z/Makefile.features b/boards/common/kw41z/Makefile.features
index 2967530f7d..bebaefb163 100644
--- a/boards/common/kw41z/Makefile.features
+++ b/boards/common/kw41z/Makefile.features
@@ -3,8 +3,8 @@ CPU_MODEL = mkw41z512vht4
 
 # Put defined MCU peripherals here (in alphabetical order)
 FEATURES_PROVIDED += periph_adc
-FEATURES_PROVIDED += periph_rtc
 FEATURES_PROVIDED += periph_rtt
+FEATURES_PROVIDED += periph_rtc
 FEATURES_PROVIDED += periph_timer
 FEATURES_PROVIDED += periph_uart
 
diff --git a/boards/common/nucleo/Kconfig b/boards/common/nucleo/Kconfig
new file mode 100644
index 0000000000..62dc8f8f61
--- /dev/null
+++ b/boards/common/nucleo/Kconfig
@@ -0,0 +1,17 @@
+# Copyright (c) 2021 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+if TEST_KCONFIG
+
+config MODULE_BOARDS_COMMON_NUCLEO
+    bool
+    default y
+    select MODULE_SAUL_GPIO if MODULE_SAUL_DEFAULT && HAS_PERIPH_GPIO
+    help
+        stm32 common nucleo code.
+
+endif # TEST_KCONFIG
diff --git a/boards/common/nucleo144/Kconfig b/boards/common/nucleo144/Kconfig
index b6ef23e689..ead4e3fe18 100644
--- a/boards/common/nucleo144/Kconfig
+++ b/boards/common/nucleo144/Kconfig
@@ -13,4 +13,5 @@ config BOARD_COMMON_NUCLEO144
     select BOARD_HAS_HSE if !CPU_FAM_L4 && !CPU_FAM_L5
     select BOARD_HAS_LSE
 
+source "$(RIOTBOARD)/common/nucleo/Kconfig"
 source "$(RIOTBOARD)/common/stm32/Kconfig"
diff --git a/boards/common/nucleo32/Kconfig b/boards/common/nucleo32/Kconfig
index 0d05550a33..bebcefa25e 100644
--- a/boards/common/nucleo32/Kconfig
+++ b/boards/common/nucleo32/Kconfig
@@ -12,4 +12,5 @@ config BOARD_COMMON_NUCLEO32
     # Clock configuration
     select BOARD_HAS_LSE if (CPU_FAM_L0 || CPU_FAM_L4) && !BOARD_NUCLEO_L011K4
 
+source "$(RIOTBOARD)/common/nucleo/Kconfig"
 source "$(RIOTBOARD)/common/stm32/Kconfig"
diff --git a/boards/common/nucleo64/Kconfig b/boards/common/nucleo64/Kconfig
index 705fd28cd1..a718be7db0 100644
--- a/boards/common/nucleo64/Kconfig
+++ b/boards/common/nucleo64/Kconfig
@@ -13,4 +13,5 @@ config BOARD_COMMON_NUCLEO64
     select BOARD_HAS_HSE if !CPU_FAM_G0 && !CPU_FAM_L0 && !CPU_FAM_L1 && !CPU_FAM_L4
     select BOARD_HAS_LSE if !BOARD_NUCLE0_L152RE
 
+source "$(RIOTBOARD)/common/nucleo/Kconfig"
 source "$(RIOTBOARD)/common/stm32/Kconfig"
diff --git a/boards/common/slwstk6000b/include/periph_conf.h b/boards/common/slwstk6000b/include/periph_conf.h
index 79ab2c8ee7..a72ddf5f5d 100644
--- a/boards/common/slwstk6000b/include/periph_conf.h
+++ b/boards/common/slwstk6000b/include/periph_conf.h
@@ -106,8 +106,9 @@ static const i2c_conf_t i2c_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/common/stm32/dist/stm32wl.cfg b/boards/common/stm32/dist/stm32wl.cfg
new file mode 100644
index 0000000000..0454003851
--- /dev/null
+++ b/boards/common/stm32/dist/stm32wl.cfg
@@ -0,0 +1,3 @@
+source [find target/stm32wlx.cfg]
+reset_config srst_only
+$_TARGETNAME configure -rtos auto
diff --git a/boards/common/stm32/include/cfg_timer_tim2.h b/boards/common/stm32/include/cfg_timer_tim2.h
index dee761f2fd..d7f6008c6f 100644
--- a/boards/common/stm32/include/cfg_timer_tim2.h
+++ b/boards/common/stm32/include/cfg_timer_tim2.h
@@ -38,7 +38,7 @@ static const timer_conf_t timer_config[] = {
         .max      = 0xffffffff,
 #endif
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-    defined(CPU_FAM_STM32G4)
+    defined(CPU_FAM_STM32WL) || defined(CPU_FAM_STM32G4)
         .rcc_mask = RCC_APB1ENR1_TIM2EN,
 #elif CPU_FAM_STM32MP1
         .rcc_mask = RCC_MC_APB1ENSETR_TIM2EN,
diff --git a/boards/e180-zg120b-tb/include/periph_conf.h b/boards/e180-zg120b-tb/include/periph_conf.h
index 72958a2f4d..09c9c7bd5d 100644
--- a/boards/e180-zg120b-tb/include/periph_conf.h
+++ b/boards/e180-zg120b-tb/include/periph_conf.h
@@ -84,8 +84,9 @@ static const adc_chan_conf_t adc_channel_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/esp32-wrover-kit/Makefile.dep b/boards/esp32-wrover-kit/Makefile.dep
index 29d6c99ba8..f6b6ba1bd4 100644
--- a/boards/esp32-wrover-kit/Makefile.dep
+++ b/boards/esp32-wrover-kit/Makefile.dep
@@ -1 +1,5 @@
+ifneq (,$(filter disp_dev,$(USEMODULE)))
+  USEMODULE += ili9341
+endif
+
 include $(RIOTBOARD)/common/esp32/Makefile.dep
diff --git a/boards/feather-nrf52840/Kconfig b/boards/feather-nrf52840/Kconfig
index 4fa49fb260..b7511ae069 100644
--- a/boards/feather-nrf52840/Kconfig
+++ b/boards/feather-nrf52840/Kconfig
@@ -16,5 +16,6 @@ config BOARD_FEATHER_NRF52840
     select HAS_PERIPH_SPI
     select HAS_PERIPH_UART
     select HAS_PERIPH_USBDEV
+    select HAS_HIGHLEVEL_STDIO
 
 source "$(RIOTBOARD)/common/nrf52/Kconfig"
diff --git a/boards/feather-nrf52840/Makefile.dep b/boards/feather-nrf52840/Makefile.dep
index ef53a3c083..3c0513a610 100644
--- a/boards/feather-nrf52840/Makefile.dep
+++ b/boards/feather-nrf52840/Makefile.dep
@@ -1,11 +1,7 @@
-# Use stdio_cdc_acm unless another stdio_% is already used
-ifeq (,$(filter stdio_% slipdev_stdio,$(USEMODULE)))
-  USEMODULE += stdio_cdc_acm
-endif
-
 ifneq (,$(filter saul_default,$(USEMODULE)))
   USEMODULE += saul_gpio
 endif
 
 # include common nrf52 dependencies
+include $(RIOTBOARD)/common/nrf52/bootloader_nrfutil.dep.mk
 include $(RIOTBOARD)/common/nrf52/Makefile.dep
diff --git a/boards/feather-nrf52840/Makefile.features b/boards/feather-nrf52840/Makefile.features
index e96ab8ee7c..1f4969f6d9 100644
--- a/boards/feather-nrf52840/Makefile.features
+++ b/boards/feather-nrf52840/Makefile.features
@@ -7,5 +7,6 @@ FEATURES_PROVIDED += periph_uart
 FEATURES_PROVIDED += periph_usbdev
 
 # Various other features (if any)
+FEATURES_PROVIDED += highlevel_stdio
 
 include $(RIOTBOARD)/common/nrf52/Makefile.features
diff --git a/boards/feather-nrf52840/Makefile.include b/boards/feather-nrf52840/Makefile.include
index d5f8440b24..93426bea1e 100644
--- a/boards/feather-nrf52840/Makefile.include
+++ b/boards/feather-nrf52840/Makefile.include
@@ -1,3 +1,24 @@
+PROGRAMMER ?= uf2conv
+
+UF2CONV_FLAGS = -f 0xADA52840
+
+ifeq (uf2conv,$(PROGRAMMER))
+
+  # Using uf2conv implies using the UF2 bootloader
+  #
+  # It has a static MBR at the first 4k, and a 38k UF2 Bootloader at
+  # the end, leaving 972k for the application. This overwrites any SoftDevice,
+  # but that's what the minimal working example does as well.
+  ROM_OFFSET = 0x1000
+  ROM_LEN    = 0xf3000
+
+  # Driver can take some time to get mounted
+  PREFLASH_DELAY ?= 3
+  include $(RIOTMAKE)/tools/usb_board_reset.mk
+endif
+
+PROGRAMMERS_SUPPORTED += uf2conv
+
 # HACK: replicate dependency resolution in Makefile.dep, only works
 # if `USEMODULE` or `DEFAULT_MODULE` is set by the command line or in the
 # application Makefile.
diff --git a/boards/feather-nrf52840/doc.txt b/boards/feather-nrf52840/doc.txt
index 80e3bbbc03..696519d3de 100644
--- a/boards/feather-nrf52840/doc.txt
+++ b/boards/feather-nrf52840/doc.txt
@@ -16,11 +16,32 @@ Low Energy and IEEE 802.15.4 support via the nRF52840 MCU.
 
 ### Flash the board
 
-See the **Flashing** section in @ref boards_common_nrf52. The easiest way is to
+The board is flashed using its on-board UF2 boot loader by default.
+The boot loader will present a mass storage device that has to be mounted to /media/MDK-DONGLE so
+`uf2conv.py` can find it. If you have an auto-mounter installed this will happen automatically.
+
+The rest of the process is automated in the usual `make flash` target.
+
+If RIOT is already running on the board, it will automatically reset the CPU and enter
+the bootloader.
+If some other firmware is running or RIOT crashed, you need to enter the bootloader
+manually by pressing the board's reset button while plugging the device into the
+
+Otherwise See the **Flashing** section in @ref boards_common_nrf52. The easiest way is to
 use an external Segger J-Link Programmer connected to the [SWD Connector].
 
 [SWD Connector]: https://learn.adafruit.com/introducing-the-adafruit-nrf52840-feather/pinouts#swd-connector-3-12
 
+#### Flashing the uf2 bootloader
+
+To flash the uf2 bootloader (if its no longer present on your BOARD) then with
+a jlink attached to your BOARD and `nrf52prog` installed:
+
+$ git clone git@github.com:adafruit/Adafruit_nRF52_Bootloader.git
+$ cd Adafruit_nRF52_Bootloader
+$ make BOARD=feather_nrf52840_express all
+$ make BOARD=feather_nrf52840_express flash
+
 ### Terminal
 To connect a terminal to the Feather, RIOT chooses Segger RTT per default.
 This lets you use the Segger J-Link Programmer as a serial interface to the
diff --git a/boards/feather-nrf52840/reset.c b/boards/feather-nrf52840/reset.c
new file mode 100644
index 0000000000..68fe19fa41
--- /dev/null
+++ b/boards/feather-nrf52840/reset.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C)  2020 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_feather-nrf52840
+ * @{
+ * @file
+ * @brief       Implementation for managing the nrfutil bootloader
+ *
+ * @author      Alexandre Abadie <alexandre.abadie@inria.fr>
+ *
+ * @}
+ */
+
+#ifdef MODULE_USB_BOARD_RESET
+
+#define USB_H_USER_IS_RIOT_INTERNAL
+
+#include "cpu.h"
+#include "usb_board_reset.h"
+
+/* Set the value used by the bootloader to select between boot in
+   application and boot in bootloader mode. */
+#define NRF52_DOUBLE_TAP_MAGIC_NUMBER       (0x57)
+
+void usb_board_reset_in_bootloader(void)
+{
+    NRF_POWER->GPREGRET = NRF52_DOUBLE_TAP_MAGIC_NUMBER;
+
+    /* Going with a hard reset rather than a pm_off, as that might be altered
+     * to do *anything* -- which is not safe any more now that we've forsaken
+     * the RAM content */
+    NVIC_SystemReset();
+}
+
+#endif /* MODULE_USB_BOARD_RESET */
diff --git a/boards/frdm-kl43z/include/board.h b/boards/frdm-kl43z/include/board.h
index 7baf7a6e48..fb714d871a 100644
--- a/boards/frdm-kl43z/include/board.h
+++ b/boards/frdm-kl43z/include/board.h
@@ -60,7 +60,7 @@ extern "C"
  * @name    xtimer configuration
  * @{
  */
-#if KINETIS_XTIMER_SOURCE_PIT
+#if IS_ACTIVE(KINETIS_XTIMER_SOURCE_PIT)
 /* PIT xtimer configuration */
 #define XTIMER_DEV                  (TIMER_PIT_DEV(0))
 #define XTIMER_CHAN                 (0)
diff --git a/boards/frdm-kw41z/include/board.h b/boards/frdm-kw41z/include/board.h
index b844b4d82c..414c26f86a 100644
--- a/boards/frdm-kw41z/include/board.h
+++ b/boards/frdm-kw41z/include/board.h
@@ -72,7 +72,7 @@ extern "C"
  * @name    xtimer configuration
  * @{
  */
-#if KINETIS_XTIMER_SOURCE_PIT
+#if IS_ACTIVE(KINETIS_XTIMER_SOURCE_PIT)
 /* PIT xtimer configuration */
 #define XTIMER_DEV                  (TIMER_PIT_DEV(0))
 #define XTIMER_CHAN                 (0)
diff --git a/boards/i-nucleo-lrwan1/Makefile.dep b/boards/i-nucleo-lrwan1/Makefile.dep
index c098354d39..5d45d9f981 100644
--- a/boards/i-nucleo-lrwan1/Makefile.dep
+++ b/boards/i-nucleo-lrwan1/Makefile.dep
@@ -1,5 +1,6 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 ifneq (,$(filter netdev_default,$(USEMODULE)))
   USEMODULE += sx1272
 endif
diff --git a/boards/ikea-tradfri/include/periph_conf.h b/boards/ikea-tradfri/include/periph_conf.h
index 4363398704..fe9e57d9cc 100644
--- a/boards/ikea-tradfri/include/periph_conf.h
+++ b/boards/ikea-tradfri/include/periph_conf.h
@@ -82,8 +82,9 @@ static const adc_chan_conf_t adc_channel_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/native/doc.txt b/boards/native/doc.txt
index a5c63e4aeb..2f891b5eac 100644
--- a/boards/native/doc.txt
+++ b/boards/native/doc.txt
@@ -12,7 +12,9 @@
 # Hardware
 - CPU: Host CPU
 - RAM: Host RAM
-- Flash: Host file system
+- Flash:
+    - for program execution: Host file system
+    - for the @ref drivers_periph_flashpage : emulated in RAM
 - Network: Tap Interface
 - UART: Runtime configurable - `/dev/tty*` are supported
 - Timers: Host timer
diff --git a/boards/native/include/eui_provider_params.h b/boards/native/include/eui_provider_params.h
index 0af230a2c9..ecedd6c61c 100644
--- a/boards/native/include/eui_provider_params.h
+++ b/boards/native/include/eui_provider_params.h
@@ -30,7 +30,9 @@ extern "C" {
  * @{
  */
 #define EUI64_PROVIDER_FUNC   native_cli_get_eui64
-#define EUI64_PROVIDER_TYPE   NETDEV_ANY
+#ifndef EUI64_PROVIDER_TYPE
+#define EUI64_PROVIDER_TYPE   NETDEV_SOCKET_ZEP
+#endif
 #define EUI64_PROVIDER_INDEX  NETDEV_INDEX_ANY
 /** @} */
 
diff --git a/boards/nrf52840dongle/Kconfig b/boards/nrf52840dongle/Kconfig
index a1252a996f..068de77552 100644
--- a/boards/nrf52840dongle/Kconfig
+++ b/boards/nrf52840dongle/Kconfig
@@ -12,6 +12,7 @@ config BOARD_NRF52840DONGLE
     default y
     select BOARD_COMMON_NRF52
     select CPU_MODEL_NRF52840XXAA
+    select HAS_PERIPH_I2C
     select HAS_PERIPH_PWM
     select HAS_PERIPH_UART
     select HAS_PERIPH_SPI
diff --git a/boards/nrf52840dongle/Makefile.features b/boards/nrf52840dongle/Makefile.features
index 22f0a1bed4..c50288397a 100644
--- a/boards/nrf52840dongle/Makefile.features
+++ b/boards/nrf52840dongle/Makefile.features
@@ -1,6 +1,7 @@
 CPU_MODEL = nrf52840xxaa
 
 # Put defined MCU peripherals here (in alphabetical order)
+FEATURES_PROVIDED += periph_i2c
 FEATURES_PROVIDED += periph_pwm
 FEATURES_PROVIDED += periph_uart
 FEATURES_PROVIDED += periph_usbdev
diff --git a/boards/nrf52840dongle/include/periph_conf.h b/boards/nrf52840dongle/include/periph_conf.h
index 2289bafc79..63c45c0d49 100644
--- a/boards/nrf52840dongle/include/periph_conf.h
+++ b/boards/nrf52840dongle/include/periph_conf.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2019 Christian Amsüss <chrysn@fsfe.org>
+ *               2021 Freie Universität Berlin
  *
  * This file is subject to the terms and conditions of the GNU Lesser
  * General Public License v2.1. See the file LICENSE in the top level
@@ -14,6 +15,7 @@
  * @brief       Peripheral configuration for the nRF52840-Dongle
  *
  * @author      Christian Amsüss <chrysn@fsfe.org>
+ * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>
  *
  */
 
@@ -24,7 +26,6 @@
 #include "cfg_clock_32_1.h"
 #include "cfg_rtt_default.h"
 #include "cfg_timer_default.h"
-#include "cfg_spi_default.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -67,11 +68,50 @@ static const uart_conf_t uart_config[] = {
  * @{
  */
 static const pwm_conf_t pwm_config[] = {
-    { NRF_PWM0, { GPIO_PIN(0, 6), GPIO_PIN(0, 8), GPIO_PIN(1, 9), GPIO_PIN(0, 12) } }
+    {
+        NRF_PWM0,
+        {
+            GPIO_PIN(0, 6),
+            GPIO_PIN(0, 8),
+            GPIO_PIN(1, 9),
+            GPIO_PIN(0, 12),
+        },
+    },
 };
 #define PWM_NUMOF           ARRAY_SIZE(pwm_config)
 /** @} */
 
+/**
+ * @name    SPI configuration
+ * @{
+ */
+static const spi_conf_t spi_config[] = {
+    {
+        .dev  = NRF_SPIM0,
+        .sclk = GPIO_PIN(0, 20),
+        .mosi = GPIO_PIN(0, 22),
+        .miso = GPIO_PIN(0, 24),
+    }
+};
+
+#define SPI_NUMOF           ARRAY_SIZE(spi_config)
+/** @} */
+
+/**
+ * @name    I2C configuration
+ * @{
+ */
+static const i2c_conf_t i2c_config[] = {
+    {
+        .dev = NRF_TWIM1,
+        .scl = GPIO_PIN(0, 29),
+        .sda = GPIO_PIN(0, 31),
+        .speed = I2C_SPEED_NORMAL
+    }
+};
+#define I2C_NUMOF           ARRAY_SIZE(i2c_config)
+/** @} */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/boards/nucleo-f303k8/Kconfig b/boards/nucleo-f303k8/Kconfig
index 65f3af3f8b..e9af6e7567 100644
--- a/boards/nucleo-f303k8/Kconfig
+++ b/boards/nucleo-f303k8/Kconfig
@@ -18,7 +18,6 @@ config BOARD_NUCLEO_F303K8
     select HAS_PERIPH_ADC
     select HAS_PERIPH_DMA
     select HAS_PERIPH_PWM
-    select HAS_PERIPH_RTC
     select HAS_PERIPH_SPI
     select HAS_PERIPH_TIMER
     select HAS_PERIPH_UART
diff --git a/boards/nucleo-f303k8/Makefile.features b/boards/nucleo-f303k8/Makefile.features
index 62da69a987..ed9a7f0886 100644
--- a/boards/nucleo-f303k8/Makefile.features
+++ b/boards/nucleo-f303k8/Makefile.features
@@ -5,7 +5,6 @@ CPU_MODEL = stm32f303k8
 FEATURES_PROVIDED += periph_adc
 FEATURES_PROVIDED += periph_dma
 FEATURES_PROVIDED += periph_pwm
-FEATURES_PROVIDED += periph_rtc
 FEATURES_PROVIDED += periph_spi
 FEATURES_PROVIDED += periph_timer
 FEATURES_PROVIDED += periph_uart
diff --git a/boards/nucleo-g431rb/Makefile.dep b/boards/nucleo-g431rb/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/nucleo-g431rb/Makefile.dep
+++ b/boards/nucleo-g431rb/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-g474re/Makefile.dep b/boards/nucleo-g474re/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/nucleo-g474re/Makefile.dep
+++ b/boards/nucleo-g474re/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-l433rc/Makefile.dep b/boards/nucleo-l433rc/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/nucleo-l433rc/Makefile.dep
+++ b/boards/nucleo-l433rc/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-l496zg/Makefile.dep b/boards/nucleo-l496zg/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/nucleo-l496zg/Makefile.dep
+++ b/boards/nucleo-l496zg/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-l4r5zi/Makefile.dep b/boards/nucleo-l4r5zi/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/nucleo-l4r5zi/Makefile.dep
+++ b/boards/nucleo-l4r5zi/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-l552ze-q/Makefile.dep b/boards/nucleo-l552ze-q/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/nucleo-l552ze-q/Makefile.dep
+++ b/boards/nucleo-l552ze-q/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-wl55jc/Kconfig b/boards/nucleo-wl55jc/Kconfig
new file mode 100644
index 0000000000..f9f6e0fb53
--- /dev/null
+++ b/boards/nucleo-wl55jc/Kconfig
@@ -0,0 +1,29 @@
+# Copyright (c) 2021 Freie Universität Berlin
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config BOARD
+    default "nucleo-wl55jc" if BOARD_NUCLEO_WL55JC
+
+config BOARD_NUCLEO_WL55JC
+    bool
+    default y
+    select BOARD_COMMON_NUCLEO64
+    select CPU_MODEL_STM32WL55JC
+
+    # Put defined MCU peripherals here (in alphabetical order)
+    select HAS_PERIPH_I2C
+    select HAS_PERIPH_LPUART
+    select HAS_PERIPH_RTT
+    select HAS_PERIPH_SPI
+    select HAS_PERIPH_TIMER
+    select HAS_PERIPH_UART
+
+    # Put other features for this board (in alphabetical order)
+    select HAS_ARDUINO
+    select HAS_RIOTBOOT
+
+source "$(RIOTBOARD)/common/nucleo64/Kconfig"
diff --git a/boards/nucleo-wl55jc/Makefile b/boards/nucleo-wl55jc/Makefile
new file mode 100644
index 0000000000..4dd17b1d0c
--- /dev/null
+++ b/boards/nucleo-wl55jc/Makefile
@@ -0,0 +1,4 @@
+MODULE = board
+DIRS = $(RIOTBOARD)/common/nucleo
+
+include $(RIOTBASE)/Makefile.base
diff --git a/boards/nucleo-wl55jc/Makefile.dep b/boards/nucleo-wl55jc/Makefile.dep
new file mode 100644
index 0000000000..2f80f9d9bb
--- /dev/null
+++ b/boards/nucleo-wl55jc/Makefile.dep
@@ -0,0 +1,4 @@
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
+include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/nucleo-wl55jc/Makefile.features b/boards/nucleo-wl55jc/Makefile.features
new file mode 100644
index 0000000000..a567d845b8
--- /dev/null
+++ b/boards/nucleo-wl55jc/Makefile.features
@@ -0,0 +1,16 @@
+CPU = stm32
+CPU_MODEL = stm32wl55jc
+
+# Put defined MCU peripherals here (in alphabetical order)
+FEATURES_PROVIDED += periph_i2c
+FEATURES_PROVIDED += periph_lpuart
+FEATURES_PROVIDED += periph_rtt
+FEATURES_PROVIDED += periph_spi
+FEATURES_PROVIDED += periph_timer
+FEATURES_PROVIDED += periph_uart
+
+# Put other features for this board (in alphabetical order)
+FEATURES_PROVIDED += riotboot
+
+# load the common Makefile.features for Nucleo boards
+include $(RIOTBOARD)/common/nucleo64/Makefile.features
diff --git a/boards/nucleo-wl55jc/Makefile.include b/boards/nucleo-wl55jc/Makefile.include
new file mode 100644
index 0000000000..822847ce1f
--- /dev/null
+++ b/boards/nucleo-wl55jc/Makefile.include
@@ -0,0 +1,18 @@
+# CPU2 defines a restricted memory region. This is not available for
+# CPU1 linking or general access, for now we define it by its default
+# value.
+# The value is descrbed in section 4.10.19 FLASH secure Flash start address
+# register (FLASH_SFR) in SFSA[6:0] register of reference manual.
+# 0x0003 F800 -> 254K -> 2K left for CPU2.
+CPU2_ROM_LEN = 2K
+
+# CPU2 can define restricted SRAM within SRAM2a and SRAM2b. These subregions
+# will generate busfaults if accessed by CPU1. For now we will assume that both
+# SRAM2a regions are completely dedicated to CPU2.
+# The value is described in section 4.10.20 FLASH secure SRAM start address and CPU2
+# reset vector register(FLASH_SRRVR) in SBRSA[4:0] of reference manual.
+# Section 4.6.4 CPU2 security (ESE) provides detailed information on the same.
+CPU2_RAM_LEN = 1K
+
+# load the common Makefile.include for Nucleo boards
+include $(RIOTBOARD)/common/nucleo64/Makefile.include
diff --git a/boards/nucleo-wl55jc/doc.txt b/boards/nucleo-wl55jc/doc.txt
new file mode 100644
index 0000000000..33f4bdc466
--- /dev/null
+++ b/boards/nucleo-wl55jc/doc.txt
@@ -0,0 +1,51 @@
+/**
+@defgroup    boards_nucleo-wl55jc STM32 Nucleo-WL55JC
+@ingroup     boards_common_nucleo64
+@brief       Support for the STM32 Nucleo-W55JCg
+
+### MCU
+
+
+| MCU        |   STM32WL55JC                                             |
+|:---------- |:--------------------------------------------------------- |
+| Family     | ARM Cortex-M4 / ARM Cortex-M0+ Dual core                  |
+| Vendor     | ST Microelectronics                                       |
+| RAM        | 64KiB                                                     |
+| Flash      | 256KiB                                                    |
+| Frequency  | up to 48MHz                                               |
+| FPU        | no                                                        |
+| Timers     | 10 (2x watchdog, 1 SysTick, 6x 16-bit, 1x 32-bit [TIM2])  |
+| ADCs       | 1x 12-bit (12 channel )                                   |
+| UARTs      | 3 (two UARTs and one Low-Power UART)                      |
+| SPIs       | 2                                                         |
+| I2Cs       | 3                                                         |
+| RTC        | 1                                                         |
+| Vcc        | 1.8 V - 3.6V                                              |
+| Datasheet  | [Datasheet](https://www.st.com/resource/en/datasheet/stm32wl55jc.pdf) |
+| Reference Manual | [Reference Manual](https://www.st.com/resource/en/reference_manual/dm00451556-stm32wl5x-advanced-armbased-32bit-mcus-with-subghz-radio-solution-stmicroelectronics.pdf) |
+| Programming Manual 1 | [Reference Manual - M4 ](https://www.st.com/resource/en/programming_manual/dm00046982-stm32-cortexm4-mcus-and-mpus-programming-manual-stmicroelectronics.pdf) |
+| Programming Manual 2 | [Reference Manual - M0](https://www.st.com/resource/en/programming_manual/dm00104451-cortexm0-programming-manual-for-stm32l0-stm32g0-stm32wl-and-stm32wb-series-stmicroelectronics.pdf) |
+| Board Manual   | [Board Manual](https://www.st.com/resource/en/data_brief/nucleo-wl55jc.pdf) |
+| Board Schematic | [Board Schematic](https://www.st.com/resource/en/user_manual/dm00622917-stm32wl-nucleo64-board-mb1389-stmicroelectronics.pdf) |
+
+## Flashing the device
+
+The ST Nucleo-wl55jc board includes an on-board ST-LINK V2 programmer. The
+easiest way to program the board is to use OpenOCD. Once you have installed
+OpenOCD (look [here](https://github.com/RIOT-OS/RIOT/wiki/OpenOCD) for
+installation instructions), you can flash the board simply by typing
+
+```
+make BOARD=nucleo-wl55jc flash
+```
+and debug via GDB by simply typing
+```
+make BOARD=nucleo-wl55jc debug
+```
+
+## Supported Toolchains
+
+For using the ST Nucleo-wl55jc board we strongly recommend the usage of the
+[GNU Tools for ARM Embedded Processors](https://launchpad.net/gcc-arm-embedded)
+toolchain.
+ */
diff --git a/boards/nucleo-wl55jc/include/arduino_board.h b/boards/nucleo-wl55jc/include/arduino_board.h
new file mode 100644
index 0000000000..15879fcc26
--- /dev/null
+++ b/boards/nucleo-wl55jc/include/arduino_board.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_nucleo-wl55jc
+ * @{
+ *
+ * @file
+ * @brief       Board specific configuration for the Arduino API
+ *
+ * @author      Akshai M <akshai.m@fu-berlin.de>
+ */
+
+#ifndef ARDUINO_BOARD_H
+#define ARDUINO_BOARD_H
+
+#include "arduino_pinmap.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   Look-up table for the Arduino's digital pins
+ */
+static const gpio_t arduino_pinmap[] = {
+    ARDUINO_PIN_0,
+    ARDUINO_PIN_1,
+    ARDUINO_PIN_2,
+    ARDUINO_PIN_3,
+    ARDUINO_PIN_4,
+    ARDUINO_PIN_5,
+    ARDUINO_PIN_6,
+    ARDUINO_PIN_7,
+    ARDUINO_PIN_8,
+    ARDUINO_PIN_9,
+    ARDUINO_PIN_10,
+    ARDUINO_PIN_11,
+    ARDUINO_PIN_12,
+    ARDUINO_PIN_13,
+    ARDUINO_PIN_A0,
+    ARDUINO_PIN_A1,
+    ARDUINO_PIN_A2,
+    ARDUINO_PIN_A3,
+    ARDUINO_PIN_A4,
+    ARDUINO_PIN_A5,
+};
+
+/**
+ * @brief   Look-up table for the Arduino's analog pins
+ */
+static const adc_t arduino_analog_map[] = {
+    ARDUINO_A0,
+    ARDUINO_A1,
+    ARDUINO_A2,
+    ARDUINO_A3,
+    ARDUINO_A4,
+    ARDUINO_A5,
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ARDUINO_BOARD_H */
+/** @} */
diff --git a/boards/nucleo-wl55jc/include/arduino_pinmap.h b/boards/nucleo-wl55jc/include/arduino_pinmap.h
new file mode 100644
index 0000000000..17ed0c44d2
--- /dev/null
+++ b/boards/nucleo-wl55jc/include/arduino_pinmap.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_nucleo-wl55jc
+ * @{
+ *
+ * @file
+ * @brief       Mapping from MCU pins to Arduino pins
+ *
+ * You can use the defines in this file for simplified interaction with the
+ * Arduino specific pin numbers.
+ *
+ * @author      Akshai M <akshai.m@fu-berlin.de>
+ *
+ */
+
+#ifndef ARDUINO_PINMAP_H
+#define ARDUINO_PINMAP_H
+
+#include "periph/gpio.h"
+#include "periph/adc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   Mapping of MCU pins to Arduino pins
+ * @{
+ */
+#define ARDUINO_PIN_0           GPIO_PIN(PORT_B, 7)
+#define ARDUINO_PIN_1           GPIO_PIN(PORT_B, 6)
+#define ARDUINO_PIN_2           GPIO_PIN(PORT_B, 12)
+#define ARDUINO_PIN_3           GPIO_PIN(PORT_B, 3)
+#define ARDUINO_PIN_4           GPIO_PIN(PORT_B, 5)
+#define ARDUINO_PIN_5           GPIO_PIN(PORT_B, 8)
+#define ARDUINO_PIN_6           GPIO_PIN(PORT_B, 10)
+#define ARDUINO_PIN_7           GPIO_PIN(PORT_C, 1)
+#define ARDUINO_PIN_8           GPIO_PIN(PORT_C, 2)
+#define ARDUINO_PIN_9           GPIO_PIN(PORT_A, 9)
+#define ARDUINO_PIN_10          GPIO_PIN(PORT_A, 4)
+#define ARDUINO_PIN_11          GPIO_PIN(PORT_A, 7)
+#define ARDUINO_PIN_12          GPIO_PIN(PORT_A, 6)
+#define ARDUINO_PIN_13          GPIO_PIN(PORT_A, 5)
+#define ARDUINO_PIN_14          GPIO_PIN(PORT_A, 11)
+#define ARDUINO_PIN_15          GPIO_PIN(PORT_A, 12)
+
+#define ARDUINO_PIN_A0          GPIO_PIN(PORT_B, 1)
+#define ARDUINO_PIN_A1          GPIO_PIN(PORT_B, 2)
+#define ARDUINO_PIN_A2          GPIO_PIN(PORT_A, 10)
+#define ARDUINO_PIN_A3          GPIO_PIN(PORT_B, 4)
+#define ARDUINO_PIN_A4          GPIO_PIN(PORT_B, 14)
+#define ARDUINO_PIN_A5          GPIO_PIN(PORT_B, 13)
+/** @ */
+
+/**
+ * @name    Mapping of Arduino analog pins to RIOT ADC lines
+ * @{
+ */
+#define ARDUINO_A0              ADC_LINE(0)
+#define ARDUINO_A1              ADC_LINE(1)
+#define ARDUINO_A2              ADC_LINE(2)
+#define ARDUINO_A3              ADC_LINE(3)
+#define ARDUINO_A4              ADC_LINE(4)
+#define ARDUINO_A5              ADC_LINE(5)
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ARDUINO_PINMAP_H */
+/** @} */
diff --git a/boards/nucleo-wl55jc/include/board.h b/boards/nucleo-wl55jc/include/board.h
new file mode 100644
index 0000000000..862e41c48a
--- /dev/null
+++ b/boards/nucleo-wl55jc/include/board.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_nucleo-wl55jc
+ * @{
+ *
+ * @file
+ * @brief       Pin definitions and board configuration options
+ *
+ * @author      Akshai M <akshai.m@fu-berlin.de>
+ * @author      Hauke Petersen <devel@haukepetersen.de>
+ */
+
+#ifndef BOARD_H
+#define BOARD_H
+
+#include "board_nucleo.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name    LED pin definitions and handlers
+ * @{
+ */
+#define LED0_PORT           GPIOB
+#define LED0_PIN            GPIO_PIN(PORT_B, 15)
+#define LED0_MASK           (1 << 15)
+#define LED0_ON             (LED0_PORT->BSRR = LED0_MASK)
+#define LED0_OFF            (LED0_PORT->BSRR = (LED0_MASK << 16))
+#define LED0_TOGGLE         (LED0_PORT->ODR  ^= LED0_MASK)
+
+#define LED1_PORT           GPIOB
+#define LED1_PIN            GPIO_PIN(PORT_B, 9)
+#define LED1_MASK           (1 << 9)
+#define LED1_ON             (LED0_PORT->BSRR = LED1_MASK)
+#define LED1_OFF            (LED0_PORT->BSRR = (LED1_MASK << 16))
+#define LED1_TOGGLE         (LED0_PORT->ODR  ^= LED1_MASK)
+
+#define LED2_PORT           GPIOB
+#define LED2_PIN            GPIO_PIN(PORT_B, 11)
+#define LED2_MASK           (1 << 11)
+#define LED2_ON             (LED0_PORT->BSRR = LED2_MASK)
+#define LED2_OFF            (LED0_PORT->BSRR = (LED2_MASK << 16))
+#define LED2_TOGGLE         (LED0_PORT->ODR  ^= LED2_MASK)
+/** @} */
+
+/* nucleo-wl55jc always use LED0, as there is no dual use of its pin */
+#ifndef AUTO_INIT_LED0
+#define AUTO_INIT_LED0
+#endif
+/** @} */
+
+/**
+ * @name    User button
+ * @{
+ */
+#define BTN0_PIN            GPIO_PIN(PORT_A, 0)
+#define BTN0_MODE           GPIO_IN_PU
+#define BTN1_PIN            GPIO_PIN(PORT_A, 1)
+#define BTN1_MODE           GPIO_IN_PU
+#define BTN2_PIN            GPIO_PIN(PORT_C, 6)
+#define BTN2_MODE           GPIO_IN_PU
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* BOARD_H */
+/** @} */
diff --git a/boards/nucleo-wl55jc/include/gpio_params.h b/boards/nucleo-wl55jc/include/gpio_params.h
new file mode 100644
index 0000000000..f464422bb3
--- /dev/null
+++ b/boards/nucleo-wl55jc/include/gpio_params.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_nucleo-wl55jc
+ * @{
+ *
+ * @file
+ * @brief       Board specific configuration of direct mapped GPIOs
+ *
+ * @author      Akshai M <akshai.m@fu-berlin.de>
+ * @author      Hauke Petersen <devel@haukepetersen.de>
+ *
+ */
+
+#ifndef GPIO_PARAMS_H
+#define GPIO_PARAMS_H
+
+#include "board.h"
+#include "saul/periph.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief    GPIO pin configuration
+ */
+static const  saul_gpio_params_t saul_gpio_params[] =
+{
+#ifdef AUTO_INIT_LED0
+    {
+        .name = "LED(blue)",
+        .pin = LED0_PIN,
+        .mode = GPIO_OUT
+    },
+#endif
+    {
+        .name = "LED(green)",
+        .pin = LED1_PIN,
+        .mode = GPIO_OUT
+    },
+    {
+        .name = "LED(red)",
+        .pin = LED2_PIN,
+        .mode = GPIO_OUT
+    },
+    {
+        .name = "Button(B1 User)",
+        .pin  = BTN0_PIN,
+        .mode = BTN0_MODE,
+        .flags = SAUL_GPIO_INVERTED,
+    },
+    {
+        .name = "Button(B2 User)",
+        .pin  = BTN1_PIN,
+        .mode = BTN1_MODE,
+        .flags = SAUL_GPIO_INVERTED,
+    },
+    {
+        .name = "Button(B3 User)",
+        .pin  = BTN2_PIN,
+        .mode = BTN2_MODE,
+        .flags = SAUL_GPIO_INVERTED,
+    },
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GPIO_PARAMS_H */
+/** @} */
diff --git a/boards/nucleo-wl55jc/include/periph_conf.h b/boards/nucleo-wl55jc/include/periph_conf.h
new file mode 100644
index 0000000000..e5d82ea71e
--- /dev/null
+++ b/boards/nucleo-wl55jc/include/periph_conf.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_nucleo-wl55jc
+ * @{
+ *
+ * @file
+ * @brief       Peripheral MCU configuration for the nucleo-wl55jc board
+ *
+ * @author      Akshai M <akshai.m@fu-berlin.de>
+ * @author      Hauke Petersen <devel@haukepetersen.de>
+ *
+ */
+
+#ifndef PERIPH_CONF_H
+#define PERIPH_CONF_H
+
+/* Add specific clock configuration (HSE, LSE) for this board here */
+#ifndef CONFIG_BOARD_HAS_LSE
+#define CONFIG_BOARD_HAS_LSE            1
+#endif
+
+/* This board provides a 32MHz HSE oscillator  */
+#ifndef CONFIG_BOARD_HAS_HSE
+#define CONFIG_BOARD_HAS_HSE            1
+#endif
+
+#define CLOCK_HSE                       MHZ(32)
+
+#include "periph_cpu.h"
+#include "clk_conf.h"
+#include "cfg_rtt_default.h"
+#include "cfg_timer_tim2.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name    UART configuration
+ * @{
+ */
+static const uart_conf_t uart_config[] = {
+    {
+        .dev        = LPUART1,
+        .rcc_mask   = RCC_APB1ENR2_LPUART1EN,
+        .rx_pin     = GPIO_PIN(PORT_A, 3),
+        .tx_pin     = GPIO_PIN(PORT_A, 2),
+        .rx_af      = GPIO_AF8,
+        .tx_af      = GPIO_AF8,
+        .bus        = APB12,
+        .irqn       = LPUART1_IRQn,
+        .type       = STM32_LPUART,
+        .clk_src    = 0, /* Use APB clock */
+    },
+    {
+        .dev        = USART1,
+        .rcc_mask   = RCC_APB2ENR_USART1EN,
+        .rx_pin     = GPIO_PIN(PORT_B, 7),
+        .tx_pin     = GPIO_PIN(PORT_B, 6),
+        .rx_af      = GPIO_AF7,
+        .tx_af      = GPIO_AF7,
+        .bus        = APB2,
+        .irqn       = USART1_IRQn,
+        .type       = STM32_USART,
+        .clk_src    = 0, /* Use APB clock */
+    },
+};
+
+#define UART_0_ISR          (isr_lpuart1)
+#define UART_1_ISR          (isr_usart1)
+
+#define UART_NUMOF          ARRAY_SIZE(uart_config)
+/** @} */
+/**
+ * @name    SPI configuration
+ * @{
+ */
+static const spi_conf_t spi_config[] = {
+    {
+        .dev      = SPI1,
+        .mosi_pin = GPIO_PIN(PORT_A, 7),
+        .miso_pin = GPIO_PIN(PORT_A, 6),
+        .sclk_pin = GPIO_PIN(PORT_A, 5),
+        .cs_pin   = GPIO_UNDEF,
+        .mosi_af  = GPIO_AF5,
+        .miso_af  = GPIO_AF5,
+        .sclk_af  = GPIO_AF5,
+        .cs_af    = GPIO_AF5,
+        .rccmask  = RCC_APB2ENR_SPI1EN,
+        .apbbus   = APB2,
+    }
+};
+
+#define SPI_NUMOF           ARRAY_SIZE(spi_config)
+/** @} */
+
+/**
+ * @name    I2C configuration
+ * @{
+ */
+static const i2c_conf_t i2c_config[] = {
+    {
+        .dev            = I2C2,
+        .speed          = I2C_SPEED_NORMAL,
+        .scl_pin        = GPIO_PIN(PORT_A, 12),
+        .sda_pin        = GPIO_PIN(PORT_A, 11),
+        .scl_af         = GPIO_AF4,
+        .sda_af         = GPIO_AF4,
+        .bus            = APB1,
+        .rcc_mask       = RCC_APB1ENR1_I2C2EN,
+        .irqn           = I2C2_ER_IRQn,
+    }
+};
+
+#define I2C_1_ISR           isr_i2c2_er
+
+#define I2C_NUMOF           ARRAY_SIZE(i2c_config)
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PERIPH_CONF_H */
+/** @} */
diff --git a/boards/openlabs-kw41z-mini/include/board.h b/boards/openlabs-kw41z-mini/include/board.h
index 5cd4a97940..c1b42768c5 100644
--- a/boards/openlabs-kw41z-mini/include/board.h
+++ b/boards/openlabs-kw41z-mini/include/board.h
@@ -50,7 +50,7 @@ extern "C"
  * @name    xtimer configuration
  * @{
  */
-#if KINETIS_XTIMER_SOURCE_PIT
+#if IS_ACTIVE(KINETIS_XTIMER_SOURCE_PIT)
 /* PIT xtimer configuration */
 #define XTIMER_DEV                  (TIMER_PIT_DEV(0))
 #define XTIMER_CHAN                 (0)
diff --git a/boards/p-nucleo-wb55/Makefile.dep b/boards/p-nucleo-wb55/Makefile.dep
index f41bf0f86b..2f80f9d9bb 100644
--- a/boards/p-nucleo-wb55/Makefile.dep
+++ b/boards/p-nucleo-wb55/Makefile.dep
@@ -1,3 +1,4 @@
-FEATURES_REQUIRED += periph_lpuart
-
+ifneq (,$(filter stdio_uart,$(USEMODULE)))
+  FEATURES_REQUIRED += periph_lpuart
+endif
 include $(RIOTBOARD)/common/nucleo/Makefile.dep
diff --git a/boards/pba-d-01-kw2x/Kconfig b/boards/pba-d-01-kw2x/Kconfig
index 366726b6a1..1190752761 100644
--- a/boards/pba-d-01-kw2x/Kconfig
+++ b/boards/pba-d-01-kw2x/Kconfig
@@ -15,7 +15,6 @@ config BOARD_PBA_D_01_KW2X
     select HAS_PERIPH_I2C
     select HAS_PERIPH_PWM
     select HAS_PERIPH_RTC
-    select HAS_PERIPH_RTT
     select HAS_PERIPH_SPI
     select HAS_PERIPH_TIMER
     select HAS_PERIPH_UART
diff --git a/boards/pba-d-01-kw2x/Makefile.features b/boards/pba-d-01-kw2x/Makefile.features
index 6e457f3120..71754e01ec 100644
--- a/boards/pba-d-01-kw2x/Makefile.features
+++ b/boards/pba-d-01-kw2x/Makefile.features
@@ -9,7 +9,6 @@ FEATURES_PROVIDED += periph_adc
 FEATURES_PROVIDED += periph_i2c
 FEATURES_PROVIDED += periph_pwm
 FEATURES_PROVIDED += periph_rtc
-FEATURES_PROVIDED += periph_rtt
 FEATURES_PROVIDED += periph_spi
 FEATURES_PROVIDED += periph_timer
 FEATURES_PROVIDED += periph_uart
diff --git a/boards/phynode-kw41z/include/board.h b/boards/phynode-kw41z/include/board.h
index ae9932a784..54d9e93459 100644
--- a/boards/phynode-kw41z/include/board.h
+++ b/boards/phynode-kw41z/include/board.h
@@ -87,7 +87,7 @@ extern "C"
  * @name    xtimer configuration
  * @{
  */
-#if KINETIS_XTIMER_SOURCE_PIT
+#if IS_ACTIVE(KINETIS_XTIMER_SOURCE_PIT)
 /* PIT xtimer configuration */
 #define XTIMER_DEV                  (TIMER_PIT_DEV(0))
 #define XTIMER_CHAN                 (0)
diff --git a/boards/same54-xpro/include/eui_provider_params.h b/boards/same54-xpro/include/eui_provider_params.h
index fbb7471c26..fe28dd4882 100644
--- a/boards/same54-xpro/include/eui_provider_params.h
+++ b/boards/same54-xpro/include/eui_provider_params.h
@@ -38,6 +38,9 @@ static inline int _at24mac_get_eui48(uint8_t index, eui48_t *addr)
  * @{
  */
 #define EUI48_PROVIDER_FUNC   _at24mac_get_eui48
+#ifndef EUI48_PROVIDER_TYPE
+#define EUI48_PROVIDER_TYPE   NETDEV_SAM0_ETH
+#endif
 /** @} */
 
 #ifdef __cplusplus
diff --git a/boards/saml21-xpro/include/periph_conf.h b/boards/saml21-xpro/include/periph_conf.h
index fffab55d02..7c228dee17 100644
--- a/boards/saml21-xpro/include/periph_conf.h
+++ b/boards/saml21-xpro/include/periph_conf.h
@@ -51,7 +51,7 @@ static const tc32_conf_t timer_config[] = {
         .mclk           = &MCLK->APBCMASK.reg,
         .mclk_mask      = MCLK_APBCMASK_TC0 | MCLK_APBCMASK_TC1,
         .gclk_id        = TC0_GCLK_ID,
-        .gclk_src       = SAM0_GCLK_8MHZ,
+        .gclk_src       = SAM0_GCLK_TIMER,
         .flags          = TC_CTRLA_MODE_COUNT32,
     }
 };
@@ -124,7 +124,7 @@ static const pwm_conf_t pwm_config[] = {
     { .tim  = TCC_CONFIG(TCC0),
       .chan = pwm_chan0_config,
       .chan_numof = ARRAY_SIZE(pwm_chan0_config),
-      .gclk_src = SAM0_GCLK_8MHZ,
+      .gclk_src = SAM0_GCLK_TIMER,
     },
 #endif
 };
@@ -222,7 +222,7 @@ static const adc_conf_chan_t adc_channels[] = {
  * @{
  */
                             /* Must not exceed 12 MHz */
-#define DAC_CLOCK           SAM0_GCLK_8MHZ
+#define DAC_CLOCK           SAM0_GCLK_TIMER
                             /* use Vcc as reference voltage */
 #define DAC_VREF            DAC_CTRLB_REFSEL_VDDANA
 /** @} */
diff --git a/boards/samr21-xpro/board.c b/boards/samr21-xpro/board.c
index d79525d62d..a398b4c020 100644
--- a/boards/samr21-xpro/board.c
+++ b/boards/samr21-xpro/board.c
@@ -41,12 +41,15 @@ void board_init(void)
     gpio_init(LED0_PIN, GPIO_OUT);
     LED0_OFF;
 
-    /* initialize the on-board antenna switch */
-    gpio_init(RFCTL1_PIN, GPIO_OUT);
-    gpio_init(RFCTL2_PIN, GPIO_OUT);
-    /* set default antenna switch configuration */
-    board_antenna_config(RFCTL_ANTENNA_DEFAULT);
-
     /* initialize the CPU */
     cpu_init();
+
+    /* initialize the on-board antenna switch */
+    if (IS_USED(MODULE_AT86RF233)) {
+        gpio_init(RFCTL1_PIN, GPIO_OUT);
+        gpio_init(RFCTL2_PIN, GPIO_OUT);
+
+        /* set default antenna switch configuration */
+        board_antenna_config(RFCTL_ANTENNA_DEFAULT);
+    }
 }
diff --git a/boards/samr30-xpro/include/periph_conf.h b/boards/samr30-xpro/include/periph_conf.h
index a64d0114cf..b5b2add878 100644
--- a/boards/samr30-xpro/include/periph_conf.h
+++ b/boards/samr30-xpro/include/periph_conf.h
@@ -41,7 +41,7 @@ static const tc32_conf_t timer_config[] = {
         .mclk           = &MCLK->APBCMASK.reg,
         .mclk_mask      = MCLK_APBCMASK_TC0 | MCLK_APBCMASK_TC1,
         .gclk_id        = TC0_GCLK_ID,
-        .gclk_src       = SAM0_GCLK_8MHZ,
+        .gclk_src       = SAM0_GCLK_TIMER,
         .flags          = TC_CTRLA_MODE_COUNT32,
     }
 };
diff --git a/boards/samr34-xpro/include/periph_conf.h b/boards/samr34-xpro/include/periph_conf.h
index 3a3ad94f3b..a9b296bea4 100644
--- a/boards/samr34-xpro/include/periph_conf.h
+++ b/boards/samr34-xpro/include/periph_conf.h
@@ -48,7 +48,7 @@ static const tc32_conf_t timer_config[] = {
         .mclk           = &MCLK->APBCMASK.reg,
         .mclk_mask      = MCLK_APBCMASK_TC0 | MCLK_APBCMASK_TC1,
         .gclk_id        = TC0_GCLK_ID,
-        .gclk_src       = SAM0_GCLK_8MHZ,
+        .gclk_src       = SAM0_GCLK_TIMER,
         .flags          = TC_CTRLA_MODE_COUNT32,
     }
 };
diff --git a/boards/seeeduino_xiao/Kconfig b/boards/seeeduino_xiao/Kconfig
new file mode 100644
index 0000000000..9b66a45884
--- /dev/null
+++ b/boards/seeeduino_xiao/Kconfig
@@ -0,0 +1,22 @@
+# Copyright (c) 2020 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+config BOARD
+    default "seeeduino_xiao" if BOARD_SEEEDUINO_XIAO
+
+config BOARD_SEEEDUINO_XIAO
+    bool
+    default y
+    select CPU_MODEL_SAMD21G18A
+    select HAS_HIGHLEVEL_STDIO
+    select HAS_PERIPH_ADC
+    select HAS_PERIPH_I2C
+    select HAS_PERIPH_RTC
+    select HAS_PERIPH_RTT
+    select HAS_PERIPH_SPI
+    select HAS_PERIPH_TIMER
+    select HAS_PERIPH_UART
+    select HAS_PERIPH_USBDEV
diff --git a/boards/seeeduino_xiao/Makefile b/boards/seeeduino_xiao/Makefile
new file mode 100644
index 0000000000..c05443c508
--- /dev/null
+++ b/boards/seeeduino_xiao/Makefile
@@ -0,0 +1,5 @@
+MODULE = board
+
+DIRS = $(RIOTBOARD)/common/samdx1-arduino-bootloader
+
+include $(RIOTBASE)/Makefile.base
diff --git a/boards/seeeduino_xiao/Makefile.dep b/boards/seeeduino_xiao/Makefile.dep
new file mode 100644
index 0000000000..716e2eadfb
--- /dev/null
+++ b/boards/seeeduino_xiao/Makefile.dep
@@ -0,0 +1,6 @@
+ifneq (,$(filter saul_default,$(USEMODULE)))
+  USEMODULE += saul_gpio
+endif
+
+# setup the samd21 arduino bootloader related dependencies
+include $(RIOTBOARD)/common/samdx1-arduino-bootloader/Makefile.dep
diff --git a/boards/seeeduino_xiao/Makefile.features b/boards/seeeduino_xiao/Makefile.features
new file mode 100644
index 0000000000..0cc841b65b
--- /dev/null
+++ b/boards/seeeduino_xiao/Makefile.features
@@ -0,0 +1,13 @@
+CPU = samd21
+CPU_MODEL = samd21g18a
+
+# Put defined MCU peripherals here (in alphabetical order)
+FEATURES_PROVIDED += highlevel_stdio
+FEATURES_PROVIDED += periph_adc
+FEATURES_PROVIDED += periph_i2c
+FEATURES_PROVIDED += periph_rtc
+FEATURES_PROVIDED += periph_rtt
+FEATURES_PROVIDED += periph_spi
+FEATURES_PROVIDED += periph_timer
+FEATURES_PROVIDED += periph_uart
+FEATURES_PROVIDED += periph_usbdev
diff --git a/boards/seeeduino_xiao/Makefile.include b/boards/seeeduino_xiao/Makefile.include
new file mode 100644
index 0000000000..d9b879af10
--- /dev/null
+++ b/boards/seeeduino_xiao/Makefile.include
@@ -0,0 +1,6 @@
+CFLAGS += -DBOOTLOADER_UF2
+
+# Include all definitions for flashing with bossa other USB
+include $(RIOTBOARD)/common/samdx1-arduino-bootloader/Makefile.include
+# Include handling of serial and non-bossa programmers (if selected by user)
+include $(RIOTMAKE)/boards/sam0.inc.mk
diff --git a/boards/seeeduino_xiao/board.c b/boards/seeeduino_xiao/board.c
new file mode 100644
index 0000000000..466f74fbeb
--- /dev/null
+++ b/boards/seeeduino_xiao/board.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C)    2021 Franz Freitag, Justus Krebs, Nick Weiler
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_seeeduino_xiao
+ * @{
+ *
+ * @file
+ * @brief       Board specific implementations for the Seeeduino XIAO board
+ *
+ * @author      Franz Freitag <franz.freitag@st.ovgu.de>
+ * @author      Justus Krebs <justus.krebs@st.ovgu.de>
+ * @author      Nick Weiler <nick.weiler@st.ovgu.de>
+ *
+ * @}
+ */
+
+#include "cpu.h"
+#include "board.h"
+#include "periph/gpio.h"
+#include "timex.h"
+
+void board_init(void)
+{
+    /* initialize the CPU */
+    cpu_init();
+
+    /* initialize the on-board LEDs */
+    gpio_init(LED0_PIN, GPIO_OUT);
+    gpio_init(LED1_PIN, GPIO_OUT);
+    gpio_init(LED2_PIN, GPIO_OUT);
+
+    LED0_OFF;
+    LED1_OFF;
+    LED2_OFF;
+}
diff --git a/boards/seeeduino_xiao/doc.txt b/boards/seeeduino_xiao/doc.txt
new file mode 100644
index 0000000000..d5ceab036b
--- /dev/null
+++ b/boards/seeeduino_xiao/doc.txt
@@ -0,0 +1,38 @@
+/**
+@defgroup    boards_seeeduino_xiao Seeeduino XIAO
+@ingroup     boards
+@brief       Support for the Seeeduino XIAO.
+
+### General information
+
+The Seeeduino XIAO is the smallest member of the Seeeduino family. It carries the powerful ATSAMD21G18A-MU which is a low-power microcontrollers. On the other hand, this little board has good performance in processing but needs less power. As a matter of fact, it is designed in a tiny size and can be used for wearable devices and small projects.
+
+Seeeduino XIAO has 14 GPIO PINs, which can be used for 11 digital interfaces, 11 mock interfaces, 10 PWM interfaces (d1-d10), 1 DAC output pin D0, 1 SWD pad interface, 1 I2C interface, 1 SPI interface, 1 UART interface, Serial communication indicator (T/R), Blink light (L). The colors of LEDs(Power,L,RX,TX) are green, yellow, blue and blue. Moreover, Seeeduino XIAO has a Type-C interface which can supply power and download code. There are two reset button, you can short connect them to reset the board.
+
+-- General description of the [wiki](https://wiki.seeedstudio.com/Seeeduino-XIAO/)
+
+### Pinout
+
+![XIAO pinout](https://files.seeedstudio.com/wiki/Seeeduino-XIAO/img/Seeeduino-XIAO-pinout.jpg)
+
+### Flash the board
+
+Use `BOARD=seeeduino_xiao` with the `make` command.<br/>
+
+Example with `default` application:
+```
+     make BOARD=seeeduino_xiao -C examples/default flash
+```
+
+RIOT will automatically trigger a reset to the bootloader, but this only works if RIOT is still
+running on the board.
+If your application has crashed or got erased, `make flash` will not be able to trigger a bootloader reset.
+
+To manually enter the bootloader, short the RST pins with a short line or tweezers
+You know you've successfully entered the bootloader when the orange LED flickers on and light up.
+
+![Reset Sequence](https://files.seeedstudio.com/wiki/Seeeduino-XIAO/img/XIAO-reset.gif)
+
+Sometimes flashing fails and the board gets stuck in the bootloader.
+In this case, just run `make flash` again when the device is not busy anymore.
+ */
diff --git a/boards/seeeduino_xiao/include/board.h b/boards/seeeduino_xiao/include/board.h
new file mode 100644
index 0000000000..62df333f87
--- /dev/null
+++ b/boards/seeeduino_xiao/include/board.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C)    2021 Franz Freitag, Justus Krebs, Nick Weiler
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_seeeduino_xiao
+ * @brief       Support for the Seeeduino XIAO board.
+ * @{
+ *
+ * @file
+ * @brief       Board specific definitions for the Seeeduino XIAO
+ *
+ * @author      Franz Freitag <franz.freitag@st.ovgu.de>
+ * @author      Justus Krebs <justus.krebs@st.ovgu.de>
+ * @author      Nick Weiler <nick.weiler@st.ovgu.de>
+ */
+
+#ifndef BOARD_H
+#define BOARD_H
+
+#include "cpu.h"
+#include "periph_conf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name    LED pin definitions and handlers
+ * @{
+ */
+#define LED_PORT            PORT->Group[PA]
+
+#define LED0_PIN            GPIO_PIN(PA, 18)
+#define LED0_MASK           (1 << 18)
+#define LED0_NAME           "LED(BLUE_RX)"
+
+#define LED0_OFF            (LED_PORT.OUTSET.reg = LED0_MASK)
+#define LED0_ON             (LED_PORT.OUTCLR.reg = LED0_MASK)
+#define LED0_TOGGLE         (LED_PORT.OUTTGL.reg = LED0_MASK)
+
+#define LED1_PIN            GPIO_PIN(PA, 19)
+#define LED1_MASK           (1 << 19)
+#define LED1_NAME           "LED(BLUE_TX)"
+
+#define LED1_OFF            (LED_PORT.OUTSET.reg = LED1_MASK)
+#define LED1_ON             (LED_PORT.OUTCLR.reg = LED1_MASK)
+#define LED1_TOGGLE         (LED_PORT.OUTTGL.reg = LED1_MASK)
+
+#define LED2_PIN            GPIO_PIN(PA, 17)
+#define LED2_MASK           (1 << 17)
+#define LED2_NAME           "LED(YELLOW_USER)"
+
+#define LED2_OFF            (LED_PORT.OUTSET.reg = LED2_MASK)
+#define LED2_ON             (LED_PORT.OUTCLR.reg = LED2_MASK)
+#define LED2_TOGGLE         (LED_PORT.OUTTGL.reg = LED2_MASK)
+/** @} */
+
+/**
+ * @name USB configuration
+ * @{
+ */
+#define INTERNAL_PERIPHERAL_VID         (0x239A)
+#define INTERNAL_PERIPHERAL_PID         (0x0057)
+/** @} */
+
+/**
+ * @brief   Initialize board specific hardware, including clock, LEDs and std-IO
+ */
+void board_init(void);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* BOARD_H */
+/** @} */
diff --git a/boards/seeeduino_xiao/include/gpio_params.h b/boards/seeeduino_xiao/include/gpio_params.h
new file mode 100644
index 0000000000..0ca6a57546
--- /dev/null
+++ b/boards/seeeduino_xiao/include/gpio_params.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C)  2021 Franz Freitag, Justus Krebs, Nick Weiler
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_seeeduino_xiao
+ * @{
+ *
+ * @file
+ * @brief       Board specific configuration of direct mapped GPIOs
+ *
+ * @author      Franz Freitag <franz.freitag@st.ovgu.de>
+ * @author      Justus Krebs <justus.krebs@st.ovgu.de>
+ * @author      Nick Weiler <nick.weiler@st.ovgu.de>
+ */
+
+#ifndef GPIO_PARAMS_H
+#define GPIO_PARAMS_H
+
+#include "board.h"
+#include "saul/periph.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief    GPIO pin configuration
+ */
+static const  saul_gpio_params_t saul_gpio_params[] =
+{
+    {
+        .name = LED0_NAME,
+        .pin = LED0_PIN,
+        .mode = GPIO_OUT,
+        .flags = SAUL_GPIO_INVERTED,
+    },
+    {
+        .name = LED1_NAME,
+        .pin = LED1_PIN,
+        .mode = GPIO_OUT,
+        .flags = SAUL_GPIO_INVERTED,
+    },
+    {
+        .name = LED2_NAME,
+        .pin = LED2_PIN,
+        .mode = GPIO_OUT,
+        .flags = SAUL_GPIO_INVERTED,
+    }
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GPIO_PARAMS_H */
+/** @} */
diff --git a/boards/seeeduino_xiao/include/periph_conf.h b/boards/seeeduino_xiao/include/periph_conf.h
new file mode 100644
index 0000000000..5a144d09ee
--- /dev/null
+++ b/boards/seeeduino_xiao/include/periph_conf.h
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C)  2021  Franz Freitag, Justus Krebs, Nick Weiler
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     boards_seeeduino_xiao
+ * @{
+ *
+ * @file
+ * @brief       Configuration of CPU peripherals for the Serpente board
+ *
+ * @author      Franz Freitag <franz.freitag@st.ovgu.de>
+ * @author      Justus Krebs <justus.krebs@st.ovgu.de>
+ * @author      Nick Weiler <nick.weiler@st.ovgu.de>
+ */
+
+#ifndef PERIPH_CONF_H
+#define PERIPH_CONF_H
+
+#include <stdint.h>
+
+#include "cpu.h"
+#include "periph_cpu.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name    External oscillator and clock configuration
+ *
+ * For selection of the used CORECLOCK, we have implemented two choices:
+ *
+ * - usage of the PLL fed by the internal 8MHz oscillator divided by 8
+ * - usage of the internal 8MHz oscillator directly, divided by N if needed
+ *
+ *
+ * The PLL option allows for the usage of a wider frequency range and a more
+ * stable clock with less jitter. This is why we use this option as default.
+ *
+ * The target frequency is computed from the PLL multiplier and the PLL divisor.
+ * Use the following formula to compute your values:
+ *
+ * CORECLOCK = ((PLL_MUL + 1) * 1MHz) / PLL_DIV
+ *
+ * NOTE: The PLL circuit does not run with less than 32MHz while the maximum PLL
+ *       frequency is 96MHz. So PLL_MULL must be between 31 and 95!
+ *
+ *
+ * The internal Oscillator used directly can lead to a slightly better power
+ * efficiency to the cost of a less stable clock. Use this option when you know
+ * what you are doing! The actual core frequency is adjusted as follows:
+ *
+ * CORECLOCK = 8MHz / DIV
+ *
+ * NOTE: A core clock frequency below 1MHz is not recommended
+ *
+ * @{
+ */
+#define CLOCK_USE_PLL       (1)
+
+#if CLOCK_USE_PLL
+/* edit these values to adjust the PLL output frequency */
+#define CLOCK_PLL_MUL       (47U)               /* must be >= 31 & <= 95 */
+#define CLOCK_PLL_DIV       (1U)                /* adjust to your needs */
+#define CLOCK_CORECLOCK     (((CLOCK_PLL_MUL + 1) * 1000000U) / CLOCK_PLL_DIV)
+#else
+/* edit this value to your needs */
+#define CLOCK_DIV           (1U)
+/* generate the actual core clock frequency */
+#define CLOCK_CORECLOCK     (8000000 / CLOCK_DIV)
+#endif
+/** @} */
+
+/**
+ * @name    Timer peripheral configuration
+ * @{
+ */
+static const tc32_conf_t timer_config[] = {
+    {   /* Timer 0 - System Clock */
+        .dev            = TC3,
+        .irq            = TC3_IRQn,
+        .pm_mask        = PM_APBCMASK_TC3,
+        .gclk_ctrl      = GCLK_CLKCTRL_ID_TCC2_TC3,
+#if CLOCK_USE_PLL || CLOCK_USE_XOSC32_DFLL
+        .gclk_src       = SAM0_GCLK_1MHZ,
+#else
+        .gclk_src       = SAM0_GCLK_MAIN,
+#endif
+        .flags          = TC_CTRLA_MODE_COUNT16,
+    },
+    {   /* Timer 1 */
+        .dev            = TC4,
+        .irq            = TC4_IRQn,
+        .pm_mask        = PM_APBCMASK_TC4 | PM_APBCMASK_TC5,
+        .gclk_ctrl      = GCLK_CLKCTRL_ID_TC4_TC5,
+#if CLOCK_USE_PLL || CLOCK_USE_XOSC32_DFLL
+        .gclk_src       = SAM0_GCLK_1MHZ,
+#else
+        .gclk_src       = SAM0_GCLK_MAIN,
+#endif
+        .flags          = TC_CTRLA_MODE_COUNT32,
+    }
+};
+
+#define TIMER_0_MAX_VALUE   0xffff
+
+/* interrupt function name mapping */
+#define TIMER_0_ISR         isr_tc3
+#define TIMER_1_ISR         isr_tc4
+
+#define TIMER_NUMOF         ARRAY_SIZE(timer_config)
+/** @} */
+
+/**
+ * @name    UART configuration
+ * @{
+ */
+static const uart_conf_t uart_config[] = {
+    {
+        .dev      = &SERCOM4->USART,
+        .rx_pin   = GPIO_PIN(PB, 9),    /* D5 */
+        .tx_pin   = GPIO_PIN(PB, 8),    /* D4 */
+        .mux      = GPIO_MUX_D,
+        .rx_pad   = UART_PAD_RX_1,
+        .tx_pad   = UART_PAD_TX_0,
+        .flags    = UART_FLAG_NONE,
+        .gclk_src = SAM0_GCLK_MAIN,
+    }
+};
+
+/* interrupt function name mapping */
+#define UART_0_ISR          isr_sercom4
+
+#define UART_NUMOF          ARRAY_SIZE(uart_config)
+/** @} */
+
+/**
+ * @name SPI configuration
+ * @{
+ */
+static const spi_conf_t spi_config[] = {
+    {   /* D0 … D2 (user pins) */
+        .dev      = &SERCOM0->SPI,
+        .miso_pin = GPIO_PIN(PA, 5),    /* D9 */
+        .mosi_pin = GPIO_PIN(PA, 6),    /* D10 */
+        .clk_pin  = GPIO_PIN(PA, 7),    /* D8 */
+        .miso_mux = GPIO_MUX_D,
+        .mosi_mux = GPIO_MUX_D,
+        .clk_mux  = GPIO_MUX_D,
+        .miso_pad = SPI_PAD_MISO_1,
+        .mosi_pad = SPI_PAD_MOSI_2_SCK_3,
+        .gclk_src = SAM0_GCLK_MAIN,
+#ifdef MODULE_PERIPH_DMA
+        .tx_trigger = SERCOM0_DMAC_ID_TX,
+        .rx_trigger = SERCOM0_DMAC_ID_RX,
+#endif
+    },
+};
+
+#define SPI_NUMOF           ARRAY_SIZE(spi_config)
+/** @} */
+
+/**
+ * @name    I2C configuration
+ * @{
+ */
+static const i2c_conf_t i2c_config[] = {
+    {
+        .dev      = &(SERCOM2->I2CM),
+        .speed    = I2C_SPEED_NORMAL,
+        .scl_pin  = GPIO_PIN(PA, 9),    /* D5 */
+        .sda_pin  = GPIO_PIN(PA, 8),    /* D4 */
+        .mux      = GPIO_MUX_D,
+        .gclk_src = SAM0_GCLK_MAIN,
+        .flags    = I2C_FLAG_NONE
+     }
+};
+#define I2C_NUMOF           ARRAY_SIZE(i2c_config)
+/** @} */
+
+/**
+ * @name    RTT configuration
+ * @{
+ */
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (32768U)    /* in Hz. For changes see `rtt.c` */
+#endif
+/** @} */
+
+/**
+ * @name    ADC Default values
+ * @{
+ */
+#define ADC_PRESCALER                       ADC_CTRLB_PRESCALER_DIV512
+
+#define ADC_NEG_INPUT                       ADC_INPUTCTRL_MUXNEG_GND
+#define ADC_GAIN_FACTOR_DEFAULT             ADC_INPUTCTRL_GAIN_1X
+#define ADC_REF_DEFAULT                     ADC_REFCTRL_REFSEL_INT1V
+
+static const adc_conf_chan_t adc_channels[] = {
+    /* port, pin, muxpos */
+    {GPIO_PIN(PA, 2), ADC_INPUTCTRL_MUXPOS_PIN0},
+    {GPIO_PIN(PA, 4), ADC_INPUTCTRL_MUXPOS_PIN4},
+    {GPIO_PIN(PA, 5), ADC_INPUTCTRL_MUXPOS_PIN5},
+    {GPIO_PIN(PA, 6), ADC_INPUTCTRL_MUXPOS_PIN6},
+    {GPIO_PIN(PA, 7), ADC_INPUTCTRL_MUXPOS_PIN7},
+    {GPIO_PIN(PA, 8), ADC_INPUTCTRL_MUXPOS_PIN16},
+    {GPIO_PIN(PA, 9), ADC_INPUTCTRL_MUXPOS_PIN17},
+    {GPIO_PIN(PB, 8), ADC_INPUTCTRL_MUXPOS_PIN2},
+    {GPIO_PIN(PB, 9), ADC_INPUTCTRL_MUXPOS_PIN3}
+};
+
+#define ADC_NUMOF           ARRAY_SIZE(adc_channels)
+/** @} */
+
+/**
+ * @name USB peripheral configuration
+ * @{
+ */
+static const sam0_common_usb_config_t sam_usbdev_config[] = {
+    {
+        .dm     = GPIO_PIN(PA, 24),
+        .dp     = GPIO_PIN(PA, 25),
+        .d_mux  = GPIO_MUX_G,
+        .device = &USB->DEVICE,
+        .gclk_src = SAM0_GCLK_MAIN,
+    }
+};
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PERIPH_CONF_H */
+/** @} */
diff --git a/boards/slstk3400a/include/periph_conf.h b/boards/slstk3400a/include/periph_conf.h
index 57ecf93429..cedc320c3f 100644
--- a/boards/slstk3400a/include/periph_conf.h
+++ b/boards/slstk3400a/include/periph_conf.h
@@ -101,8 +101,9 @@ static const i2c_conf_t i2c_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/slstk3401a/include/periph_conf.h b/boards/slstk3401a/include/periph_conf.h
index cb3753937e..c6541c9535 100644
--- a/boards/slstk3401a/include/periph_conf.h
+++ b/boards/slstk3401a/include/periph_conf.h
@@ -113,8 +113,9 @@ static const i2c_conf_t i2c_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/slstk3402a/include/periph_conf.h b/boards/slstk3402a/include/periph_conf.h
index 4db7ef2723..b69cd8773a 100644
--- a/boards/slstk3402a/include/periph_conf.h
+++ b/boards/slstk3402a/include/periph_conf.h
@@ -104,8 +104,9 @@ static const i2c_conf_t i2c_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/sltb001a/include/periph_conf.h b/boards/sltb001a/include/periph_conf.h
index f1438857de..42760a8240 100644
--- a/boards/sltb001a/include/periph_conf.h
+++ b/boards/sltb001a/include/periph_conf.h
@@ -113,8 +113,9 @@ static const i2c_conf_t i2c_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/slwstk6220a/include/periph_conf.h b/boards/slwstk6220a/include/periph_conf.h
index 29c701f613..34a9c29b39 100644
--- a/boards/slwstk6220a/include/periph_conf.h
+++ b/boards/slwstk6220a/include/periph_conf.h
@@ -154,8 +154,9 @@ static const pwm_conf_t pwm_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/stk3200/include/periph_conf.h b/boards/stk3200/include/periph_conf.h
index 0df111484b..90fa76cb75 100644
--- a/boards/stk3200/include/periph_conf.h
+++ b/boards/stk3200/include/periph_conf.h
@@ -100,8 +100,9 @@ static const i2c_conf_t i2c_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/stk3600/include/periph_conf.h b/boards/stk3600/include/periph_conf.h
index 56b71d9b7a..5242626ad0 100644
--- a/boards/stk3600/include/periph_conf.h
+++ b/boards/stk3600/include/periph_conf.h
@@ -159,8 +159,9 @@ static const pwm_conf_t pwm_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/stk3700/include/periph_conf.h b/boards/stk3700/include/periph_conf.h
index 506bbf6251..c66959c2dd 100644
--- a/boards/stk3700/include/periph_conf.h
+++ b/boards/stk3700/include/periph_conf.h
@@ -159,8 +159,9 @@ static const pwm_conf_t pwm_config[] = {
  * @name    RTT configuration
  * @{
  */
-#define RTT_MAX_VALUE       (0xFFFFFF)
-#define RTT_FREQUENCY       (1U)
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       (1U)              /* in Hz */
+#endif
 /** @} */
 
 /**
diff --git a/boards/usb-kw41z/include/board.h b/boards/usb-kw41z/include/board.h
index e08553dd92..0b334c6c43 100644
--- a/boards/usb-kw41z/include/board.h
+++ b/boards/usb-kw41z/include/board.h
@@ -83,7 +83,7 @@ extern "C"
  * @name    xtimer configuration
  * @{
  */
-#if KINETIS_XTIMER_SOURCE_PIT
+#if IS_ACTIVE(KINETIS_XTIMER_SOURCE_PIT)
 /* PIT xtimer configuration */
 #define XTIMER_DEV                  (TIMER_PIT_DEV(0))
 #define XTIMER_CHAN                 (0)
diff --git a/boards/yarm/include/periph_conf.h b/boards/yarm/include/periph_conf.h
index c013543bee..b1d8fad031 100644
--- a/boards/yarm/include/periph_conf.h
+++ b/boards/yarm/include/periph_conf.h
@@ -48,7 +48,7 @@ static const tc32_conf_t timer_config[] = {
         .mclk           = &MCLK->APBCMASK.reg,
         .mclk_mask      = MCLK_APBCMASK_TC0 | MCLK_APBCMASK_TC1,
         .gclk_id        = TC0_GCLK_ID,
-        .gclk_src       = SAM0_GCLK_8MHZ,
+        .gclk_src       = SAM0_GCLK_TIMER,
         .flags          = TC_CTRLA_MODE_COUNT32,
     }
 };
diff --git a/boards/z1/include/board.h b/boards/z1/include/board.h
index 1e308b7eeb..4320edcf0b 100644
--- a/boards/z1/include/board.h
+++ b/boards/z1/include/board.h
@@ -50,6 +50,14 @@ extern "C" {
 #define XTIMER_BACKOFF              (40)
 /** @} */
 
+/**
+ * @name    ztimer configuration values
+ * @{
+ */
+#define CONFIG_ZTIMER_USEC_ADJUST_SET     (96)
+#define CONFIG_ZTIMER_USEC_ADJUST_SLEEP   (97)
+/** @} */
+
 /**
  * @name    CPU core configuration
  * @{
diff --git a/core/include/lifo.h b/core/include/lifo.h
deleted file mode 100644
index bcf723cc69..0000000000
--- a/core/include/lifo.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2013 Freie Universität Berlin
- *
- * This file is subject to the terms and conditions of the GNU Lesser
- * General Public License v2.1. See the file LICENSE in the top level
- * directory for more details.
- */
-
-/**
- * @ingroup     core_util
- * @{
- *
- * @file
- * @brief   LIFO buffer API, read long description carefully
- * @author  Heiko Will <hwill@inf.fu-berlin.de>
- * @deprecated Is no longer used in RIOT.
- *             Has very tight constrains making new use unlikely.
- *             Will be removed after release 2021.04.
- *
- * @details This LIFO implementation very efficiently handles integer values.
- *          The caveat is that it **can only handle values between 0 and its own
- *          size - 1**. Also it can only handle up to one element of each value.
- *          If you insert a value twice the LIFO will break.
- */
-
-#ifndef LIFO_H
-#define LIFO_H
-
-#include "log.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @brief   Check if the given lifo is empty.
- *
- * @param[in] array The lifo array to check.
- *
- * @return  1, if empty
- * @return  0, otherwise.
- */
-static inline int lifo_empty(int *array)
-{
-    return array[0] == -1;
-}
-
-/**
- * @brief               Initialize a lifo array.
- *
- * @pre `array != NULL`
- *
- * @param[in,out] array An array of size *n* + 1. Must not be `NULL`.
- * @param[in] n         Maximum integer value the lifo is able to store.
- */
-static inline void lifo_init(int *array, int n)
-{
-    LOG_DEBUG("lifo_init(%i)\n", n);
-    for (int i = 0; i <= n; i++) {
-        array[i] = -1;
-    }
-}
-
-/**
- * @brief               Insert an element into the lifo
- *
- * @pre `array != NULL`
- *
- * @param[in,out] array An integer array of least *i* + 1 size that **does not
- *                      already contain *i***. Must not be `NULL`.
- * @param[in] i         The integer value to store, between 0 and the size of
- *                      the array - 1, must not be stored already.
- *
- */
-static inline void lifo_insert(int *array, int i)
-{
-    LOG_DEBUG("lifo_insert(%i)\n", i);
-
-    int index = i + 1;
-
-#ifdef DEVELHELP
-    if ((array[index] != -1) && (array[0] != -1)) {
-        LOG_WARNING(
-            "lifo_insert: overwriting array[%i] == %i with %i\n\n\n"
-            "\t\tThe lifo is broken now.\n\n\n", index,
-            array[index], array[0]);
-    }
-#endif
-
-    array[index] = array[0];
-    array[0] = i;
-}
-
-/**
- * @brief           Extract the least recently inserted element from the lifo.
- *
- * @pre `array != NULL`
- *
- * @param[in] array An integer array. Must not be NULL.
- *
- * @return          -1, if the lifo is empty.
- * @return          the least recently inserted element, otherwise.
- */
-static inline int lifo_get(int *array)
-{
-    LOG_DEBUG("lifo_get\n");
-    int head = array[0];
-
-    if (head != -1) {
-        array[0] = array[head + 1];
-    }
-
-#ifdef DEVELHELP
-    /* make sure a double insert does not result in an infinite
-     * resource of values */
-    array[head + 1] = -1;
-#endif
-
-    LOG_DEBUG("lifo_get: returning %i\n", head);
-    return head;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* LIFO_H */
-/** @} */
diff --git a/core/msg.c b/core/msg.c
index b924ac3b05..09bafaf6cb 100644
--- a/core/msg.c
+++ b/core/msg.c
@@ -460,23 +460,27 @@ void msg_init_queue(msg_t *array, int num)
 void msg_queue_print(void)
 {
     unsigned state = irq_disable();
-
     thread_t *thread = thread_get_active();
+
+    int msg_counter = msg_avail();
+
+    if (msg_counter <= -1) {
+        /* no msg queue */
+        printf("No message queue\n");
+        return;
+    }
     cib_t *msg_queue = &thread->msg_queue;
     msg_t *msg_array = thread->msg_array;
-    unsigned int i = msg_queue->read_count & msg_queue->mask;
+    int first_msg = cib_peek(msg_queue);
 
     printf("Message queue of thread %" PRIkernel_pid "\n", thread->pid);
-    printf("    size: %u (avail: %u)\n", msg_queue->mask + 1,
-           cib_avail(msg_queue));
+    printf("    size: %u (avail: %d)\n", msg_queue->mask + 1, msg_counter);
 
-    for (; i != (msg_queue->write_count & msg_queue->mask);
-         i = (i + 1) & msg_queue->mask) {
-        msg_t *m = &msg_array[i];
+    for (int i = 0; i < msg_counter; i++) {
+        msg_t *m = &msg_array[(first_msg + i) & msg_queue->mask];
         printf("    * %u: sender: %" PRIkernel_pid ", type: 0x%04" PRIu16
                ", content: %" PRIu32 " (%p)\n", i, m->sender_pid, m->type,
                m->content.value, m->content.ptr);
     }
-
     irq_restore(state);
 }
diff --git a/cpu/arm7_common/Makefile.dep b/cpu/arm7_common/Makefile.dep
index 93fe31908b..06e7ec95d5 100644
--- a/cpu/arm7_common/Makefile.dep
+++ b/cpu/arm7_common/Makefile.dep
@@ -4,7 +4,7 @@ USEMODULE += arm7_common_periph
 FEATURES_REQUIRED_ANY += newlib|picolibc
 ifneq (,$(filter newlib,$(USEMODULE)))
   # use the nano-specs of Newlib when available
-  USEMODULE += newlib_nano
+  DEFAULT_MODULE += newlib_nano
 endif
 
 # Make calls to malloc and friends thread-safe
diff --git a/cpu/atmega_common/Kconfig b/cpu/atmega_common/Kconfig
index 599b319719..a35a7f3258 100644
--- a/cpu/atmega_common/Kconfig
+++ b/cpu/atmega_common/Kconfig
@@ -20,8 +20,10 @@ config CPU_COMMON_ATMEGA
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_PM
+    select HAS_PERIPH_RTC_MS
     select HAS_PERIPH_RTT_SET_COUNTER
     select HAS_PERIPH_TIMER_PERIODIC
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_WDT
     select HAS_PUF_SRAM
 
diff --git a/cpu/atmega_common/Makefile.features b/cpu/atmega_common/Makefile.features
index 7b58b012bd..1987a53914 100644
--- a/cpu/atmega_common/Makefile.features
+++ b/cpu/atmega_common/Makefile.features
@@ -10,8 +10,10 @@ FEATURES_PROVIDED += periph_cpuid
 FEATURES_PROVIDED += periph_eeprom
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_pm
+FEATURES_PROVIDED += periph_rtc_ms
 FEATURES_PROVIDED += periph_rtt_set_counter
 FEATURES_PROVIDED += periph_timer_periodic
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_wdt
 FEATURES_PROVIDED += puf_sram
 
diff --git a/cpu/atmega_common/periph/rtc.c b/cpu/atmega_common/periph/rtc.c
index 08ad449461..dfea732364 100644
--- a/cpu/atmega_common/periph/rtc.c
+++ b/cpu/atmega_common/periph/rtc.c
@@ -27,7 +27,6 @@
 static struct tm tm_now __attribute__((section(".noinit")));
 static struct tm tm_alarm __attribute__((section(".noinit")));
 
-static bool isr_flag;
 static rtc_alarm_cb_t alarm_cb;
 static void *alarm_cb_arg;
 
@@ -36,9 +35,7 @@ ISR(TIMER2_OVF_vect)
 {
     avr8_enter_isr();
 
-    isr_flag = !isr_flag;
-
-    if (++tm_now.tm_sec > 60) {
+    if (++tm_now.tm_sec > 59) {
         rtc_tm_normalize(&tm_now);
     }
 
@@ -89,15 +86,41 @@ int rtc_set_time(struct tm *time)
 
 int rtc_get_time(struct tm *time)
 {
-    bool tmp = isr_flag;
+    uint8_t before;
+
+    /* loop in case of overflow */
+    do {
+        before = TCNT2;
 
-    *time = tm_now;
+        /* prevent compiler from reordering memory access to tm_now,
+         * including moving it out of the loop
+         */
+        __asm__ volatile ("" : : : "memory");
 
-    /* check if interrupt happened while
-       reading the time struct */
-    if (isr_flag != tmp) {
         *time = tm_now;
-    }
+    } while (before > TCNT2);
+
+    return 0;
+}
+
+int rtc_get_time_ms(struct tm *time, uint16_t *ms)
+{
+    uint8_t cnt_before, cnt_after;
+
+    /* loop in case of overflow */
+    do {
+        cnt_before = TCNT2;
+
+        /* prevent compiler from reordering memory access to tm_now,
+         * including moving it out of the loop
+         */
+        __asm__ volatile ("" : : : "memory");
+        *time = tm_now;
+
+        cnt_after  = TCNT2;
+    } while (cnt_before > cnt_after);
+
+    *ms = (cnt_after * 1000UL) >> 8;
 
     return 0;
 }
diff --git a/cpu/atxmega/Makefile.features b/cpu/atxmega/Makefile.features
index a08cfd24e2..48ace1cc10 100644
--- a/cpu/atxmega/Makefile.features
+++ b/cpu/atxmega/Makefile.features
@@ -6,7 +6,9 @@ include $(RIOTCPU)/avr8_common/Makefile.features
 FEATURES_PROVIDED += cpu_core_atxmega
 FEATURES_PROVIDED += periph_cpuid
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
+FEATURES_PROVIDED += periph_i2c
 FEATURES_PROVIDED += periph_nvm
 FEATURES_PROVIDED += periph_pm
+FEATURES_PROVIDED += periph_spi
 FEATURES_PROVIDED += periph_timer periph_timer_periodic
 FEATURES_PROVIDED += periph_uart
diff --git a/cpu/atxmega/include/periph_cpu.h b/cpu/atxmega/include/periph_cpu.h
index f41ad112c2..901a2326f1 100644
--- a/cpu/atxmega/include/periph_cpu.h
+++ b/cpu/atxmega/include/periph_cpu.h
@@ -264,6 +264,96 @@ typedef struct {
     cpu_int_lvl_t int_lvl[TIMER_CH_MAX_NUMOF];  /**< Interrupt channels level */
 } timer_conf_t;
 
+/**
+ * @name    Override I2C clock speed values
+ * @{
+ */
+#define HAVE_I2C_SPEED_T
+typedef enum {
+    I2C_SPEED_LOW       =   10000ul, /**< low speed mode:     ~10 kbit/s */
+    I2C_SPEED_NORMAL    =  100000ul, /**< normal mode:       ~100 kbit/s */
+    I2C_SPEED_FAST      =  400000ul, /**< fast mode:         ~400 kbit/s */
+    I2C_SPEED_FAST_PLUS = 1000000ul, /**< fast plus mode:   ~1000 kbit/s */
+    /* High speed is not supported without external hardware hacks */
+    I2C_SPEED_HIGH      = 3400000ul, /**< high speed mode:  ~3400 kbit/s */
+} i2c_speed_t;
+/** @} */
+
+/**
+ * @name   Use shared I2C functions
+ * @{
+ */
+#define PERIPH_I2C_NEED_READ_REG
+#define PERIPH_I2C_NEED_READ_REGS
+#define PERIPH_I2C_NEED_WRITE_REG
+#define PERIPH_I2C_NEED_WRITE_REGS
+/** @} */
+
+/**
+ * @brief   I2C configuration structure
+ */
+typedef struct {
+    TWI_t *dev;             /**< Pointer to hardware module registers */
+    pwr_reduction_t pwr;    /**< Power Management */
+    gpio_t sda_pin;         /**< SDA GPIO pin */
+    gpio_t scl_pin;         /**< SCL GPIO pin */
+    i2c_speed_t speed;      /**< Configured bus speed, actual speed may be lower but never higher */
+    cpu_int_lvl_t int_lvl;  /**< Serial Interrupt Level */
+} i2c_conf_t;
+
+/**
+ * @brief   Enable common SPI functions
+ * @{
+ */
+#define PERIPH_SPI_NEEDS_INIT_CS
+#define PERIPH_SPI_NEEDS_TRANSFER_BYTE
+#define PERIPH_SPI_NEEDS_TRANSFER_REG
+#define PERIPH_SPI_NEEDS_TRANSFER_REGS
+/** @} */
+
+/**
+ * @brief   Define global value for undefined SPI device
+ * @{
+ */
+#define SPI_UNDEF               (UCHAR_MAX)
+/** @} */
+
+/**
+ * @brief Define spi_t data type to save data
+ * @{
+ */
+#define HAVE_SPI_T
+typedef uint8_t spi_t;
+/** @} */
+
+/**
+ * @brief  SPI device configuration
+ * @{
+ */
+typedef struct {
+    SPI_t *dev;                     /**< pointer to the used SPI device */
+    pwr_reduction_t pwr;            /**< Power Management */
+    gpio_t sck_pin;                 /**< pin used for SCK */
+    gpio_t miso_pin;                /**< pin used for MISO */
+    gpio_t mosi_pin;                /**< pin used for MOSI */
+    gpio_t ss_pin;                  /**< pin used for SS line */
+} spi_conf_t;
+/** @} */
+
+/**
+ * @brief  Available SPI clock speeds
+ * @{
+ */
+#define HAVE_SPI_CLK_T
+typedef enum {
+    SPI_CLK_100KHZ = 100000U,       /**< drive the SPI bus with 100KHz */
+    SPI_CLK_400KHZ = 400000U,       /**< drive the SPI bus with 400KHz */
+    SPI_CLK_1MHZ   = 1000000U,      /**< drive the SPI bus with 1MHz */
+    SPI_CLK_5MHZ   = 5000000U,      /**< drive the SPI bus with 5MHz */
+    SPI_CLK_10MHZ  = 10000000U,     /**< drive the SPI bus with 10MHz */
+} spi_clk_t;
+/** @} */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/cpu/atxmega/periph/i2c.c b/cpu/atxmega/periph/i2c.c
new file mode 100644
index 0000000000..91195e7876
--- /dev/null
+++ b/cpu/atxmega/periph/i2c.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2021 Gerson Fernando Budke <nandojve@gmail.com>
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     cpu_atxmega
+ * @ingroup     cpu_atxmega_periph
+ * @{
+ *
+ * @file
+ * @brief       Low-level I2C driver implementation
+ *
+ * @author      Gerson Fernando Budke <nandojve@gmail.com>
+ *
+ * @}
+ */
+#include <errno.h>
+
+#include "cpu.h"
+#include "cpu_pm.h"
+#include "periph/i2c.h"
+#include "periph/gpio.h"
+#include "periph/pm.h"
+
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+/**
+ * @brief   Device Context allocation
+ */
+static struct {
+    mutex_t locks;
+    mutex_t xfer;
+    uint8_t *buffer;
+    size_t pos;
+    size_t len;
+    uint8_t flags;
+    int8_t status;
+} i2c_ctx[I2C_NUMOF];
+
+/**
+ * @brief   Get the pointer to the base register of the given I2C device
+ *
+ * @param[in] dev       I2C device identifier
+ *
+ * @return              base register address
+ */
+static inline TWI_t* dev(i2c_t dev)
+{
+    return ((TWI_t*) (i2c_config[dev].dev));
+}
+
+static inline uint8_t _i2c_calc_baud(i2c_t i2c)
+{
+    uint16_t ftwi = (((CLOCK_CORECLOCK / (2*i2c_config[i2c].speed))-5)+1);
+
+    if (ftwi > 255) {
+        DEBUG("[i2c] init: dev speed is lower than minimal speed supported.\n");
+        return 0;
+    }
+    if (ftwi < 1) {
+        DEBUG("[i2c] init: dev speed is high than maximum speed supported.\n");
+        return 0;
+    }
+
+    return ftwi & 0xff;
+}
+
+void i2c_init(i2c_t i2c)
+{
+    uint8_t baudrate;
+
+    if (i2c >= I2C_NUMOF) {
+        DEBUG("[i2c] init: dev is invalid.\n");
+        return;
+    }
+
+    baudrate = _i2c_calc_baud(i2c);
+    if (baudrate == 0) {
+        DEBUG("[i2c] init: baudrate is invalid.\n");
+        return;
+    }
+
+    mutex_init(&i2c_ctx[i2c].locks);
+    mutex_init(&i2c_ctx[i2c].xfer);
+    mutex_lock(&i2c_ctx[i2c].xfer);
+    i2c_init_pins(i2c);
+
+    pm_periph_enable(i2c_config[i2c].pwr);
+    dev(i2c)->MASTER.BAUD = baudrate;
+    pm_periph_disable(i2c_config[i2c].pwr);
+}
+
+void i2c_init_pins(i2c_t i2c)
+{
+    gpio_init(i2c_config[i2c].sda_pin, GPIO_OPC_WRD_AND_PULL);
+    gpio_init(i2c_config[i2c].scl_pin, GPIO_OPC_WRD_AND_PULL);
+}
+
+int i2c_acquire(i2c_t i2c)
+{
+    DEBUG("acquire\n");
+    pm_block(3);
+    mutex_lock(&i2c_ctx[i2c].locks);
+    pm_periph_enable(i2c_config[i2c].pwr);
+
+    dev(i2c)->MASTER.CTRLA = (i2c_config[i2c].int_lvl << TWI_MASTER_INTLVL_gp)
+                           | TWI_MASTER_RIEN_bm
+                           | TWI_MASTER_WIEN_bm
+                           | TWI_MASTER_ENABLE_bm;
+    dev(i2c)->MASTER.STATUS = TWI_MASTER_BUSSTATE_IDLE_gc;
+
+    return 0;
+}
+
+void i2c_release(i2c_t i2c)
+{
+    dev(i2c)->MASTER.CTRLA = 0;
+    pm_periph_disable(i2c_config[i2c].pwr);
+    mutex_unlock(&i2c_ctx[i2c].locks);
+    pm_unblock(3);
+    DEBUG("release\n");
+}
+
+static int _i2c_transaction(i2c_t i2c, uint16_t addr, const void *data,
+                            size_t len, uint8_t flags, bool is_read)
+{
+    if (flags & I2C_ADDR10) {
+        DEBUG("[i2c] xfer: no 10 bit address support.\n");
+        return -EOPNOTSUPP;
+    }
+    if (data == NULL || len == 0) {
+        DEBUG("[i2c] xfer: invalid parameter.\n");
+        return -EINVAL;
+    }
+
+    i2c_ctx[i2c].buffer = (uint8_t *) data;
+    i2c_ctx[i2c].pos = 0;
+    i2c_ctx[i2c].len = len;
+    i2c_ctx[i2c].flags = flags;
+
+    dev(i2c)->MASTER.ADDR = (addr << 1) | (is_read ? 0x01 : 0x00);
+
+    mutex_lock(&i2c_ctx[i2c].xfer);
+
+    DEBUG("[i2c] xfer: status = %d\n", i2c_ctx[i2c].status);
+
+    return i2c_ctx[i2c].status;
+}
+
+int i2c_write_bytes(i2c_t i2c, uint16_t addr, const void *data, size_t len,
+                    uint8_t flags)
+{
+    return _i2c_transaction(i2c, addr, data, len, flags, false);
+}
+
+int i2c_read_bytes(i2c_t i2c, uint16_t addr, void *data, size_t len,
+                   uint8_t flags)
+{
+    return _i2c_transaction(i2c, addr, data, len, flags, true);
+}
+
+/**
+ * @internal
+ *
+ * @brief TWI master write interrupt handler.
+ *
+ *  Handles TWI transactions (master write) and responses to (N)ACK.
+ */
+static inline void _i2c_write_handler(int i2c)
+{
+    if (i2c_ctx[i2c].pos < i2c_ctx[i2c].len) {
+        const uint8_t* const data = i2c_ctx[i2c].buffer;
+        dev(i2c)->MASTER.DATA = data[i2c_ctx[i2c].pos++];
+    }
+    else {
+        /* Send STOP condition to complete the transaction. */
+        if (!(i2c_ctx[i2c].flags & I2C_NOSTOP)) {
+            dev(i2c)->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
+        }
+
+        i2c_ctx[i2c].status = 0;
+        mutex_unlock(&i2c_ctx[i2c].xfer);
+    }
+}
+
+/**
+ * @internal
+ *
+ * @brief TWI master read interrupt handler.
+ *
+ * This is the master read interrupt handler that takes care of reading bytes
+ * from the TWI slave device.
+ */
+static inline void _i2c_read_handler(int i2c)
+{
+    if (i2c_ctx[i2c].pos < i2c_ctx[i2c].len) {
+        uint8_t* const data = i2c_ctx[i2c].buffer;
+        data[i2c_ctx[i2c].pos++] = dev(i2c)->MASTER.DATA;
+
+        /* If there is more to read, issue ACK and start a byte read.
+         * Otherwise, issue NACK and STOP to complete the transaction.
+         */
+        if (i2c_ctx[i2c].pos < i2c_ctx[i2c].len) {
+            dev(i2c)->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
+        }
+        else {
+            uint8_t control_c = TWI_MASTER_ACKACT_bm;
+
+            if (!(i2c_ctx[i2c].flags & I2C_NOSTOP)) {
+                control_c |= TWI_MASTER_CMD_STOP_gc;
+            }
+
+            dev(i2c)->MASTER.CTRLC = control_c;
+
+            i2c_ctx[i2c].status = 0;
+            mutex_unlock(&i2c_ctx[i2c].xfer);
+        }
+    } else {
+        /* Issue STOP and buffer overflow condition. */
+        dev(i2c)->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
+
+        i2c_ctx[i2c].status = -ENOMEM;
+        mutex_unlock(&i2c_ctx[i2c].xfer);
+    }
+}
+
+/**
+ * @internal
+ *
+ * @brief Common TWI master interrupt service routine.
+ *
+ *  Check current status and calls the appropriate handler.
+ */
+static inline void isr_handler(int i2c)
+{
+    avr8_enter_isr();
+
+    int8_t const m_status = dev(i2c)->MASTER.STATUS;
+
+    if (m_status & TWI_MASTER_ARBLOST_bm) {
+        dev(i2c)->MASTER.STATUS = m_status | TWI_MASTER_ARBLOST_bm;
+        dev(i2c)->MASTER.CTRLC  = TWI_MASTER_CMD_STOP_gc;
+        i2c_ctx[i2c].status = -EBUSY;
+        mutex_unlock(&i2c_ctx[i2c].xfer);
+    }
+    else if ((m_status & TWI_MASTER_BUSERR_bm)
+         ||  (m_status & TWI_MASTER_RXACK_bm)) {
+
+        dev(i2c)->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
+        i2c_ctx[i2c].status = ((m_status & TWI_MASTER_BUSERR_bm) > 0)
+                            ? -EIO
+                            : -ENXIO;
+        mutex_unlock(&i2c_ctx[i2c].xfer);
+    }
+    else if (m_status & TWI_MASTER_WIF_bm) {
+        _i2c_write_handler(i2c);
+    }
+    else if (m_status & TWI_MASTER_RIF_bm) {
+        _i2c_read_handler(i2c);
+    }
+    else {
+        i2c_ctx[i2c].status = -EPROTO;
+        mutex_unlock(&i2c_ctx[i2c].xfer);
+    }
+
+    avr8_exit_isr();
+}
+
+#ifdef I2C_0_ISR
+ISR(I2C_0_ISR, ISR_BLOCK)
+{
+    isr_handler(0);
+}
+#endif /* I2C_0_ISR */
+
+#ifdef I2C_1_ISR
+ISR(I2C_1_ISR, ISR_BLOCK)
+{
+    isr_handler(1);
+}
+#endif /* I2C_1_ISR */
+
+#ifdef I2C_2_ISR
+ISR(I2C_2_ISR, ISR_BLOCK)
+{
+    isr_handler(2);
+}
+#endif /* I2C_2_ISR */
+
+#ifdef I2C_3_ISR
+ISR(I2C_3_ISR, ISR_BLOCK)
+{
+    isr_handler(3);
+}
+#endif /* I2C_3_ISR */
diff --git a/cpu/atxmega/periph/spi.c b/cpu/atxmega/periph/spi.c
new file mode 100644
index 0000000000..cc0d57dfc7
--- /dev/null
+++ b/cpu/atxmega/periph/spi.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2021 Gerson Fernando Budke <nandojve@gmail.com>
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     cpu_atxmega
+ * @ingroup     cpu_atxmega_periph
+ * @{
+ *
+ * @file
+ * @brief       Low-level SPI driver implementation
+ *
+ * @author      Gerson Fernando Budke <nandojve@gmail.com>
+ *
+ * @}
+ */
+
+#include "cpu.h"
+#include "cpu_pm.h"
+#include "mutex.h"
+#include "periph/spi.h"
+#include "pm_layered.h"
+
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+static void _print_buffer(const char* s, const uint8_t* buffer, uint16_t len)
+{
+    uint16_t i;
+
+    if (buffer == NULL) {
+        DEBUG("%s - no buffer\n", s);
+        return;
+    }
+
+    DEBUG("%s\n", s);
+
+    for (i = 0; i < len; i++) {
+        if ((i % 16) == 0 && i != 0) {
+            DEBUG("\n");
+        }
+        else if ((i % 8) == 0) {
+            DEBUG(" ");
+        }
+
+        DEBUG("%02x ", buffer[i]);
+    }
+
+    DEBUG("\n");
+}
+
+/**
+ * @brief   Allocation device locks
+ */
+static mutex_t locks[SPI_NUMOF];
+
+/**
+ * @brief   Get the pointer to the base register of the given SPI device
+ *
+ * @param[in] dev       SPI device identifier
+ *
+ * @return              base register address
+ */
+static inline SPI_t* dev(spi_t bus)
+{
+    return (SPI_t*)spi_config[bus].dev;
+}
+
+void spi_init(spi_t bus)
+{
+    mutex_init(&locks[bus]);
+    spi_init_pins(bus);
+
+    DEBUG("init\n");
+}
+
+void spi_init_pins(spi_t bus)
+{
+    /* SS pin always should be output even when it is not used */
+    spi_init_cs(bus, spi_config[bus].ss_pin);
+    gpio_init(spi_config[bus].sck_pin, GPIO_OUT);
+    gpio_init(spi_config[bus].miso_pin, GPIO_IN);
+    gpio_init(spi_config[bus].mosi_pin, GPIO_OUT);
+}
+
+int spi_acquire(spi_t bus, spi_cs_t cs, spi_mode_t mode, spi_clk_t clk)
+{
+    (void)cs;
+    (void)clk;
+
+    DEBUG("acquire\n");
+
+    pm_block(3);
+    mutex_lock(&locks[bus]);
+    pm_periph_enable(spi_config[bus].pwr);
+
+    dev(bus)->CTRL = SPI_CLK2X_bm
+                   | SPI_ENABLE_bm
+                   | SPI_MASTER_bm
+                   | (mode << SPI_MODE_gp)
+                   | SPI_PRESCALER0_bm;
+
+    (void)dev(bus)->STATUS;
+    (void)dev(bus)->DATA;
+
+    return SPI_OK;
+}
+
+void spi_release(spi_t bus)
+{
+    dev(bus)->CTRL &= ~SPI_ENABLE_bm;
+    pm_periph_disable(spi_config[bus].pwr);
+    mutex_unlock(&locks[bus]);
+    pm_unblock(3);
+
+    DEBUG("release\n");
+}
+
+void spi_transfer_bytes(spi_t bus, spi_cs_t cs, bool cont,
+                        const void *out, void *in, size_t len)
+{
+    uint8_t *out_buf = (uint8_t *)out;
+    uint8_t *in_buf = (uint8_t *)in;
+
+    if (IS_ACTIVE(ENABLE_DEBUG)) {
+        _print_buffer("bytes - out", out, len);
+    }
+
+    if (cs != SPI_CS_UNDEF) {
+        gpio_clear((gpio_t) cs);
+    }
+
+    for (size_t i = 0; i < len; i++) {
+        uint8_t tmp = (out_buf) ? out_buf[i] : 0;
+
+        dev(bus)->DATA = tmp;
+
+        while (!(dev(bus)->STATUS & SPI_IF_bm)){}
+
+        tmp = dev(bus)->DATA;
+
+        if (in_buf) {
+            in_buf[i] = tmp;
+        }
+    }
+
+    if ((!cont) && (cs != SPI_CS_UNDEF)) {
+        gpio_set((gpio_t) cs);
+    }
+
+    if (IS_ACTIVE(ENABLE_DEBUG)) {
+        _print_buffer("bytes - in", in, len);
+    }
+}
diff --git a/cpu/avr8_common/avr_libc_extra/include/errno.h b/cpu/avr8_common/avr_libc_extra/include/errno.h
index a8b21f75bb..0277ad9073 100644
--- a/cpu/avr8_common/avr_libc_extra/include/errno.h
+++ b/cpu/avr8_common/avr_libc_extra/include/errno.h
@@ -84,7 +84,7 @@ extern int errno;
 #define ECONNRESET      (15)    /**< Connection reset. */
 #define EDEADLK         (16)    /**< Resource deadlock would occur. */
 #define EDESTADDRREQ    (17)    /**< Destination address required. */
-#define EDOM            (18)    /**< Mathematics argument out of domain of function. */
+#define EMFILE          (18)    /**< File descriptor value too large. */
 #define EDQUOT          (19)    /**< Reserved. */
 #define EEXIST          (20)    /**< File exists. */
 #define EFAULT          (21)    /**< Bad address. */
@@ -99,8 +99,8 @@ extern int errno;
 #define EISCONN         (30)    /**< Socket is connected. */
 #define EISDIR          (31)    /**< Is a directory. */
 #define ELOOP           (32)    /**< Too many levels of symbolic links. */
-#define EMFILE          (33)    /**< File descriptor value too large. */
-#define EMLINK          (34)    /**< Too many links. */
+#define EDOM            (33)    /**< Mathematics argument out of domain of function. */
+#define ERANGE          (34)    /**< Result too large. */
 #define EMSGSIZE        (35)    /**< Message too large. */
 #define EMULTIHOP       (36)    /**< Reserved. */
 #define ENAMETOOLONG    (37)    /**< Filename too long. */
@@ -138,7 +138,7 @@ extern int errno;
 #define EPROTO          (69)    /**< Protocol error. */
 #define EPROTONOSUPPORT (70)    /**< Protocol not supported. */
 #define EPROTOTYPE      (71)    /**< Protocol wrong type for socket. */
-#define ERANGE          (72)    /**< Result too large. */
+#define EMLINK          (72)    /**< Too many links. */
 #define EROFS           (73)    /**< Read-only file system. */
 #define ESPIPE          (74)    /**< Invalid seek. */
 #define ESRCH           (75)    /**< No such process. */
diff --git a/cpu/cc2538/Kconfig b/cpu/cc2538/Kconfig
index c60d306680..104746b8d7 100644
--- a/cpu/cc2538/Kconfig
+++ b/cpu/cc2538/Kconfig
@@ -19,6 +19,7 @@ config CPU_FAM_CC2538
     select HAS_PERIPH_RTT_SET_COUNTER
     select HAS_PERIPH_UART_MODECFG
     select HAS_PERIPH_UART_NONBLOCKING
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_WDT
 
 ## CPU Models
diff --git a/cpu/cc2538/Makefile.features b/cpu/cc2538/Makefile.features
index cafaf3ec9a..0fd7200a4f 100644
--- a/cpu/cc2538/Makefile.features
+++ b/cpu/cc2538/Makefile.features
@@ -9,6 +9,7 @@ FEATURES_PROVIDED += periph_hwrng
 FEATURES_PROVIDED += periph_rtt_set_counter
 FEATURES_PROVIDED += periph_uart_modecfg
 FEATURES_PROVIDED += periph_uart_nonblocking
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_wdt
 
 FEATURES_PROVIDED += cortexm_mpu
diff --git a/cpu/cc2538/include/cc2538_rf.h b/cpu/cc2538/include/cc2538_rf.h
index a30c44f1c4..ebaca7f9a4 100644
--- a/cpu/cc2538/include/cc2538_rf.h
+++ b/cpu/cc2538/include/cc2538_rf.h
@@ -107,7 +107,10 @@ extern "C" {
 #define CC2538_RSSI_OFFSET          (-73)  /**< Signal strength offset value */
 #define CC2538_RF_SENSITIVITY       (-97)  /**< dBm typical, normal conditions */
 
+#define CC2538_ACCEPT_FT_0_BEACON        (1 << 3) /**< enable or disable the BEACON filter */
+#define CC2538_ACCEPT_FT_1_DATA          (1 << 4) /**< enable or disable the DATA filter */
 #define CC2538_ACCEPT_FT_2_ACK           (1 << 5) /**< enable or disable the ACK filter */
+#define CC2538_ACCEPT_FT_3_CMD           (1 << 6) /**< enable or disable the CMD filter */
 #define CC2538_STATE_SFD_WAIT_RANGE_MIN  (0x03U)  /**< min range value of SFD wait state */
 #define CC2538_STATE_SFD_WAIT_RANGE_MAX  (0x06U)  /**< max range value of SFD wait state */
 #define CC2538_FRMCTRL1_PENDING_OR_MASK  (0x04)   /**< mask for enabling or disabling the
diff --git a/cpu/cc2538/radio/cc2538_rf.c b/cpu/cc2538/radio/cc2538_rf.c
index 076d238dcd..570378538e 100644
--- a/cpu/cc2538/radio/cc2538_rf.c
+++ b/cpu/cc2538/radio/cc2538_rf.c
@@ -174,6 +174,9 @@ void cc2538_init(void)
     /* setup mac timer */
     _cc2538_setup_mac_timer();
 
+    /* Enable Auto ACK */
+    RFCORE->XREG_FRMCTRL0bits.AUTOACK = !IS_ACTIVE(CONFIG_IEEE802154_AUTO_ACK_DISABLE);
+
     /* Flush the receive and transmit FIFOs */
     RFCORE_SFR_RFST = ISFLUSHTX;
     RFCORE_SFR_RFST = ISFLUSHRX;
diff --git a/cpu/cc2538/radio/cc2538_rf_radio_ops.c b/cpu/cc2538/radio/cc2538_rf_radio_ops.c
index 529f0192b7..69bcad1a5d 100644
--- a/cpu/cc2538/radio/cc2538_rf_radio_ops.c
+++ b/cpu/cc2538/radio/cc2538_rf_radio_ops.c
@@ -352,7 +352,7 @@ void cc2538_irq_handler(void)
             /* Disable RX while the frame has not been processed */
             RFCORE_XREG_RXMASKCLR = 0xFF;
             /* If AUTOACK is enabled and the ACK request bit is set */
-            if (RFCORE->XREG_FRMCTRL0bits.AUTOACK &&
+            if (!IS_ACTIVE(CONFIG_IEEE802154_AUTO_ACK_DISABLE) &&
                 (rfcore_peek_rx_fifo(1) & IEEE802154_FCF_ACK_REQ)) {
                 /* The next SFD will be the ACK's, ignore it */
                 cc2538_sfd_listen = false;
@@ -400,31 +400,51 @@ static int _off(ieee802154_dev_t *dev)
     return -ENOTSUP;
 }
 
-static int _set_hw_addr_filter(ieee802154_dev_t *dev, const network_uint16_t *short_addr,
-                               const eui64_t *ext_addr, const uint16_t *pan_id)
+static int _config_addr_filter(ieee802154_dev_t *dev, ieee802154_af_cmd_t cmd, const void *value)
 {
     (void) dev;
-    if (short_addr) {
-        RFCORE_FFSM_SHORT_ADDR0 = short_addr->u8[1];
-        RFCORE_FFSM_SHORT_ADDR1 = short_addr->u8[0];
+    const network_uint16_t *short_addr = value;
+    const eui64_t *ext_addr = value;
+    const uint16_t *pan_id = value;
+    switch(cmd) {
+        case IEEE802154_AF_SHORT_ADDR:
+            RFCORE_FFSM_SHORT_ADDR0 = short_addr->u8[1];
+            RFCORE_FFSM_SHORT_ADDR1 = short_addr->u8[0];
+            break;
+        case IEEE802154_AF_EXT_ADDR:
+            RFCORE_FFSM_EXT_ADDR0 = ext_addr->uint8[7];
+            RFCORE_FFSM_EXT_ADDR1 = ext_addr->uint8[6];
+            RFCORE_FFSM_EXT_ADDR2 = ext_addr->uint8[5];
+            RFCORE_FFSM_EXT_ADDR3 = ext_addr->uint8[4];
+            RFCORE_FFSM_EXT_ADDR4 = ext_addr->uint8[3];
+            RFCORE_FFSM_EXT_ADDR5 = ext_addr->uint8[2];
+            RFCORE_FFSM_EXT_ADDR6 = ext_addr->uint8[1];
+            RFCORE_FFSM_EXT_ADDR7 = ext_addr->uint8[0];
+            break;
+        case IEEE802154_AF_PANID:
+            RFCORE_FFSM_PAN_ID0 = *pan_id;
+            RFCORE_FFSM_PAN_ID1 = (*pan_id) >> 8;
+            break;
+        case IEEE802154_AF_PAN_COORD:
+            return -ENOTSUP;
     }
 
-    if (ext_addr) {
-        RFCORE_FFSM_EXT_ADDR0 = ext_addr->uint8[7];
-        RFCORE_FFSM_EXT_ADDR1 = ext_addr->uint8[6];
-        RFCORE_FFSM_EXT_ADDR2 = ext_addr->uint8[5];
-        RFCORE_FFSM_EXT_ADDR3 = ext_addr->uint8[4];
-        RFCORE_FFSM_EXT_ADDR4 = ext_addr->uint8[3];
-        RFCORE_FFSM_EXT_ADDR5 = ext_addr->uint8[2];
-        RFCORE_FFSM_EXT_ADDR6 = ext_addr->uint8[1];
-        RFCORE_FFSM_EXT_ADDR7 = ext_addr->uint8[0];
-    }
+    return 0;
+}
 
-    if (pan_id) {
-        RFCORE_FFSM_PAN_ID0 = *pan_id;
-        RFCORE_FFSM_PAN_ID1 = (*pan_id) >> 8;
+static int _config_src_addr_match(ieee802154_dev_t *dev, ieee802154_src_match_t cmd, const void *value)
+{
+    (void) dev;
+    switch(cmd) {
+        case IEEE802154_SRC_MATCH_EN:
+            RFCORE_XREG_FRMCTRL1 &= ~CC2538_FRMCTRL1_PENDING_OR_MASK;
+            if (*((const bool*) value) == true) {
+                RFCORE_XREG_FRMCTRL1 |= CC2538_FRMCTRL1_PENDING_OR_MASK;
+            }
+            break;
+        default:
+            return -ENOTSUP;
     }
-
     return 0;
 }
 
@@ -468,56 +488,47 @@ static int _set_cca_mode(ieee802154_dev_t *dev, ieee802154_cca_mode_t mode)
     return 0;
 }
 
-static int _set_rx_mode(ieee802154_dev_t *dev, ieee802154_rx_mode_t mode)
+static int _set_csma_params(ieee802154_dev_t *dev, const ieee802154_csma_be_t *bd, int8_t retries)
 {
     (void) dev;
-
-    bool promisc = false;
-    bool ack_filter = true;
-    switch (mode) {
-        case IEEE802154_RX_AACK_DISABLED:
-            RFCORE->XREG_FRMCTRL0bits.AUTOACK = 0;
-            break;
-        case IEEE802154_RX_AACK_ENABLED:
-            RFCORE->XREG_FRMCTRL0bits.AUTOACK = 1;
-            RFCORE_XREG_FRMCTRL1 &= ~CC2538_FRMCTRL1_PENDING_OR_MASK;
-            break;
-        case IEEE802154_RX_AACK_FRAME_PENDING:
-            RFCORE->XREG_FRMCTRL0bits.AUTOACK = 1;
-            RFCORE_XREG_FRMCTRL1 |= CC2538_FRMCTRL1_PENDING_OR_MASK;
-            break;
-        case IEEE802154_RX_PROMISC:
-            promisc = true;
-            break;
-        case IEEE802154_RX_WAIT_FOR_ACK:
-            ack_filter = false;
-            break;
+    if (bd) {
+        cc2538_min_be = bd->min;
+        cc2538_max_be = bd->max;
     }
 
-    if (ack_filter) {
-        RFCORE_XREG_FRMFILT1 &= ~CC2538_ACCEPT_FT_2_ACK;
-    }
-    else {
-        RFCORE_XREG_FRMFILT1 |= CC2538_ACCEPT_FT_2_ACK;
-    }
+    cc2538_csma_ca_retries = retries;
 
-    cc2538_set_monitor(promisc);
     return 0;
 }
 
-static int _set_csma_params(ieee802154_dev_t *dev, const ieee802154_csma_be_t *bd, int8_t retries)
+static int _set_frame_filter_mode(ieee802154_dev_t *dev, ieee802154_filter_mode_t mode)
 {
     (void) dev;
-    if (bd) {
-        cc2538_min_be = bd->min;
-        cc2538_max_be = bd->max;
+
+    uint8_t flags = 0;
+    bool promisc = false;
+    switch (mode) {
+        case IEEE802154_FILTER_ACCEPT:
+            flags =   CC2538_ACCEPT_FT_0_BEACON
+                    | CC2538_ACCEPT_FT_1_DATA
+                    | CC2538_ACCEPT_FT_3_CMD;
+            break;
+        case IEEE802154_FILTER_PROMISC:
+            promisc = true;
+            break;
+        case IEEE802154_FILTER_ACK_ONLY:
+            flags = CC2538_ACCEPT_FT_2_ACK;
+            break;
+        default:
+            return -ENOTSUP;
     }
 
-    cc2538_csma_ca_retries = retries;
+    RFCORE_XREG_FRMFILT1 |= flags;
+    cc2538_set_monitor(promisc);
 
     return 0;
-}
 
+}
 static const ieee802154_radio_ops_t cc2538_rf_ops = {
     .caps = IEEE802154_CAP_24_GHZ
           | IEEE802154_CAP_AUTO_CSMA
@@ -543,7 +554,8 @@ static const ieee802154_radio_ops_t cc2538_rf_ops = {
     .set_cca_threshold = _set_cca_threshold,
     .set_cca_mode = _set_cca_mode,
     .config_phy = _config_phy,
-    .set_hw_addr_filter = _set_hw_addr_filter,
+    .config_addr_filter = _config_addr_filter,
+    .config_src_addr_match = _config_src_addr_match,
     .set_csma_params = _set_csma_params,
-    .set_rx_mode = _set_rx_mode,
+    .set_frame_filter_mode = _set_frame_filter_mode,
 };
diff --git a/cpu/cortexm_common/Makefile.dep b/cpu/cortexm_common/Makefile.dep
index 856befb6c1..d6ca0bb457 100644
--- a/cpu/cortexm_common/Makefile.dep
+++ b/cpu/cortexm_common/Makefile.dep
@@ -7,7 +7,7 @@ USEMODULE += cortexm_common_periph
 FEATURES_REQUIRED_ANY += newlib|picolibc
 ifneq (,$(filter newlib,$(USEMODULE)))
   # use the nano-specs of Newlib when available
-  USEMODULE += newlib_nano
+  DEFAULT_MODULE += newlib_nano
 endif
 
 # Export the peripheral drivers to be linked into the final binary:
diff --git a/cpu/cortexm_common/cortexm_init.c b/cpu/cortexm_common/cortexm_init.c
index 719ca0e1ee..68d6be68d9 100644
--- a/cpu/cortexm_common/cortexm_init.c
+++ b/cpu/cortexm_common/cortexm_init.c
@@ -70,8 +70,6 @@ CORTEXM_STATIC_INLINE void cortexm_init_misc(void)
 
 void cortexm_init(void)
 {
-    cortexm_init_fpu();
-
     /* configure the vector table location to internal flash */
 #if defined(CPU_CORE_CORTEX_M3) || defined(CPU_CORE_CORTEX_M33) || \
     defined(CPU_CORE_CORTEX_M4) || defined(CPU_CORE_CORTEX_M4F) || \
diff --git a/cpu/cortexm_common/vectors_cortexm.c b/cpu/cortexm_common/vectors_cortexm.c
index c158c12242..989b0207bb 100644
--- a/cpu/cortexm_common/vectors_cortexm.c
+++ b/cpu/cortexm_common/vectors_cortexm.c
@@ -99,6 +99,8 @@ void reset_handler_default(void)
     uint32_t *dst;
     const uint32_t *src = &_etext;
 
+    cortexm_init_fpu();
+
 #ifdef MODULE_PUF_SRAM
     puf_sram_init((uint8_t *)&_srelocate, SEED_RAM_LEN);
 #endif
diff --git a/cpu/efm32/Kconfig b/cpu/efm32/Kconfig
index b807643e82..44a5f2a59b 100644
--- a/cpu/efm32/Kconfig
+++ b/cpu/efm32/Kconfig
@@ -14,6 +14,7 @@ config CPU_COMMON_EFM32
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_RTT_SET_COUNTER
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_WDT
 
 config CPU_EFM32_SERIES0
diff --git a/cpu/efm32/Makefile.features b/cpu/efm32/Makefile.features
index 2f6363f8f9..2d182abfda 100644
--- a/cpu/efm32/Makefile.features
+++ b/cpu/efm32/Makefile.features
@@ -14,6 +14,7 @@ FEATURES_PROVIDED += periph_flashpage
 FEATURES_PROVIDED += periph_flashpage_pagewise
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_rtt_set_counter
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_wdt
 
 FEATURES_CONFLICT += periph_rtc:periph_rtt
diff --git a/cpu/efm32/include/periph_cpu.h b/cpu/efm32/include/periph_cpu.h
index 864a61e5e2..071a3982f6 100644
--- a/cpu/efm32/include/periph_cpu.h
+++ b/cpu/efm32/include/periph_cpu.h
@@ -32,6 +32,7 @@
 #include "em_timer.h"
 #include "em_usart.h"
 #include "em_wdog.h"
+#include "em_rtc.h"
 #if defined(_SILICON_LABS_32B_SERIES_0)
 #include "em_dac.h"
 #endif
@@ -119,6 +120,23 @@ typedef struct {
 } dac_chan_conf_t;
 #endif
 
+/**
+ * @name    Real time counter configuration
+ * @{
+ */
+/* RTT_MAX_VALUE some are 24bit, some are 32bit */
+#ifdef _RTC_CNT_MASK
+#define RTT_MAX_VALUE       _RTC_CNT_MASK        /* mask has all bits set ==> MAX*/
+#endif
+#ifdef _RTCC_CNT_MASK
+#define RTT_MAX_VALUE       _RTCC_CNT_MASK       /* mask has all bits set ==> MAX*/
+#endif
+#define RTT_MAX_FREQUENCY   (32768U)             /* in Hz */
+#define RTT_MIN_FREQUENCY   (1U)                 /* in Hz */
+#define RTT_CLOCK_FREQUENCY (32768U)             /* in Hz, LFCLK*/
+
+/** @} */
+
 /**
  * @brief   Define a custom type for GPIO pins.
  * @{
diff --git a/cpu/efm32/periph/rtt_series0.c b/cpu/efm32/periph/rtt_series0.c
index 86b8846169..abe3c3d10d 100644
--- a/cpu/efm32/periph/rtt_series0.c
+++ b/cpu/efm32/periph/rtt_series0.c
@@ -34,10 +34,47 @@ typedef struct {
 
 static rtt_state_t rtt_state;
 
+/* prescaler of 32768 = 1 s of resolution and overflow each 194 days */
+#if RTT_FREQUENCY == 1
+#define RTT_CMU_CLK_DIV cmuClkDiv_32768
+#elif RTT_FREQUENCY == 2
+#define RTT_CMU_CLK_DIV cmuClkDiv_16384
+#elif RTT_FREQUENCY == 4
+#define RTT_CMU_CLK_DIV cmuClkDiv_8192
+#elif RTT_FREQUENCY == 8
+#define RTT_CMU_CLK_DIV cmuClkDiv_4096
+#elif RTT_FREQUENCY == 16
+#define RTT_CMU_CLK_DIV cmuClkDiv_2048
+#elif RTT_FREQUENCY == 32
+#define RTT_CMU_CLK_DIV cmuClkDiv_1024
+#elif RTT_FREQUENCY == 64
+#define RTT_CMU_CLK_DIV cmuClkDiv_512
+#elif RTT_FREQUENCY == 128
+#define RTT_CMU_CLK_DIV cmuClkDiv_256
+#elif RTT_FREQUENCY == 256
+#define RTT_CMU_CLK_DIV cmuClkDiv_128
+#elif RTT_FREQUENCY == 512
+#define RTT_CMU_CLK_DIV cmuClkDiv_64
+#elif RTT_FREQUENCY == 1024
+#define RTT_CMU_CLK_DIV cmuClkDiv_32
+#elif RTT_FREQUENCY == 2048
+#define RTT_CMU_CLK_DIV cmuClkDiv_16
+#elif RTT_FREQUENCY == 4096
+#define RTT_CMU_CLK_DIV cmuClkDiv_8
+#elif RTT_FREQUENCY == 8192
+#define RTT_CMU_CLK_DIV cmuClkDiv_4
+#elif RTT_FREQUENCY == 16384
+#define RTT_CMU_CLK_DIV cmuClkDiv_2
+#elif RTT_FREQUENCY == 32768
+#define RTT_CMU_CLK_DIV cmuClkDiv_1
+#else
+#warning "no matching prescaler for RTT_FREQUENCY"
+#endif
+
 void rtt_init(void)
 {
-    /* prescaler of 32768 = 1 s of resolution and overflow each 194 days */
-    CMU_ClockDivSet(cmuClock_RTC, cmuClkDiv_32768);
+    /* setup prescaler */
+    CMU_ClockDivSet(cmuClock_RTC, RTT_CMU_CLK_DIV);
 
     /* enable clocks */
     CMU_ClockEnable(cmuClock_CORELE, true);
diff --git a/cpu/efm32/periph/rtt_series1.c b/cpu/efm32/periph/rtt_series1.c
index c67e60b2cf..cb1abd8d6b 100644
--- a/cpu/efm32/periph/rtt_series1.c
+++ b/cpu/efm32/periph/rtt_series1.c
@@ -35,6 +35,43 @@ typedef struct {
 
 static rtt_state_t rtt_state;
 
+/* prescaler of 32768 = 1 s of resolution and overflow each 194 days */
+#if RTT_FREQUENCY == 1
+#define RTT_CMU_CLK_DIV rtccCntPresc_32768
+#elif RTT_FREQUENCY == 2
+#define RTT_CMU_CLK_DIV rtccCntPresc_16384
+#elif RTT_FREQUENCY == 4
+#define RTT_CMU_CLK_DIV rtccCntPresc_8192
+#elif RTT_FREQUENCY == 8
+#define RTT_CMU_CLK_DIV rtccCntPresc_4096
+#elif RTT_FREQUENCY == 16
+#define RTT_CMU_CLK_DIV rtccCntPresc_2048
+#elif RTT_FREQUENCY == 32
+#define RTT_CMU_CLK_DIV rtccCntPresc_1024
+#elif RTT_FREQUENCY == 64
+#define RTT_CMU_CLK_DIV rtccCntPresc_512
+#elif RTT_FREQUENCY == 128
+#define RTT_CMU_CLK_DIV rtccCntPresc_256
+#elif RTT_FREQUENCY == 256
+#define RTT_CMU_CLK_DIV rtccCntPresc_128
+#elif RTT_FREQUENCY == 512
+#define RTT_CMU_CLK_DIV rtccCntPresc_64
+#elif RTT_FREQUENCY == 1024
+#define RTT_CMU_CLK_DIV rtccCntPresc_32
+#elif RTT_FREQUENCY == 2048
+#define RTT_CMU_CLK_DIV rtccCntPresc_16
+#elif RTT_FREQUENCY == 4096
+#define RTT_CMU_CLK_DIV rtccCntPresc_8
+#elif RTT_FREQUENCY == 8192
+#define RTT_CMU_CLK_DIV rtccCntPresc_4
+#elif RTT_FREQUENCY == 16384
+#define RTT_CMU_CLK_DIV rtccCntPresc_2
+#elif RTT_FREQUENCY == 32768
+#define RTT_CMU_CLK_DIV rtccCntPresc_1
+#else
+#warning "no matching prescaler for RTT_FREQUENCY"
+#endif
+
 void rtt_init(void)
 {
     /* enable clocks */
@@ -45,7 +82,7 @@ void rtt_init(void)
     RTCC_Init_TypeDef init = RTCC_INIT_DEFAULT;
 
     init.enable = false;
-    init.presc = rtccCntPresc_32768;
+    init.presc = RTT_CMU_CLK_DIV;
 
     RTCC_Reset();
     RTCC_Init(&init);
diff --git a/cpu/esp32/Kconfig b/cpu/esp32/Kconfig
index e3c15435df..0ad815e2a0 100644
--- a/cpu/esp32/Kconfig
+++ b/cpu/esp32/Kconfig
@@ -19,6 +19,7 @@ config CPU_FAM_ESP32
     select HAS_PERIPH_RTC
     select HAS_PERIPH_RTT
     select HAS_PERIPH_RTT_SET_COUNTER
+    select HAS_PERIPH_RTT_OVERFLOW
 
 ## CPU Models
 config CPU_MODEL_ESP32_WROOM_32
diff --git a/cpu/esp32/Makefile.dep b/cpu/esp32/Makefile.dep
index 99a0fcb39c..0c1ee1aed3 100644
--- a/cpu/esp32/Makefile.dep
+++ b/cpu/esp32/Makefile.dep
@@ -7,7 +7,7 @@ USEMODULE += esp_idf_esp32
 USEMODULE += esp_idf_soc
 
 ifneq (,$(filter newlib,$(USEMODULE)))
-  USEMODULE += newlib_nano
+  DEFAULT_MODULE += newlib_nano
 endif
 
 ifneq (,$(filter esp_eth,$(USEMODULE)))
diff --git a/cpu/esp32/Makefile.features b/cpu/esp32/Makefile.features
index 699f7b2126..a2b3f037b3 100644
--- a/cpu/esp32/Makefile.features
+++ b/cpu/esp32/Makefile.features
@@ -10,3 +10,4 @@ FEATURES_PROVIDED += periph_adc_ctrl
 FEATURES_PROVIDED += periph_rtc
 FEATURES_PROVIDED += periph_rtt
 FEATURES_PROVIDED += periph_rtt_set_counter
+FEATURES_PROVIDED += periph_rtt_overflow
diff --git a/cpu/esp32/include/sdk_conf.h b/cpu/esp32/include/sdk_conf.h
index e6a7aa29a3..94c4112358 100644
--- a/cpu/esp32/include/sdk_conf.h
+++ b/cpu/esp32/include/sdk_conf.h
@@ -28,12 +28,18 @@
 extern "C" {
 #endif
 
+/**
+* @name    Clock configuration
+* @{
+*/
 /**
  * @brief   Defines the CPU frequency [values = 2, 40, 80, 160 and 240]
  */
 #ifndef CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ
 #define CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ   80
 #endif
+#define CLOCK_CORECLOCK     (1000000UL * CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ)
+/** @} */
 
 /**
  * Default console configuration
diff --git a/cpu/esp32/vendor/esp-idf/heap/heap_trace.c b/cpu/esp32/vendor/esp-idf/heap/heap_trace.c
index de703f5f4c..577a09da3a 100644
--- a/cpu/esp32/vendor/esp-idf/heap/heap_trace.c
+++ b/cpu/esp32/vendor/esp-idf/heap/heap_trace.c
@@ -407,10 +407,13 @@ IRAM_ATTR void *__wrap_realloc(void *p, size_t size)
 
 IRAM_ATTR void *__wrap_calloc(size_t nmemb, size_t size)
 {
-    size = size * nmemb;
-    void *result = trace_malloc(size, 0, TRACE_MALLOC_DEFAULT);
+    size_t total_size;
+    if (__builtin_mul_overflow(nmemb, size, &total_size)) {
+        return NULL;
+    }
+    void *result = trace_malloc(total_size, 0, TRACE_MALLOC_DEFAULT);
     if (result != NULL) {
-        memset(result, 0, size);
+        memset(result, 0, total_size);
     }
     return result;
 }
diff --git a/cpu/esp8266/Kconfig b/cpu/esp8266/Kconfig
index f04a07cc21..261e7fb25b 100644
--- a/cpu/esp8266/Kconfig
+++ b/cpu/esp8266/Kconfig
@@ -16,6 +16,7 @@ config CPU_FAM_ESP8266
     select HAS_CPU_ESP8266
     select HAS_PERIPH_RTC
     select HAS_PERIPH_RTT
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_RTT_SET_COUNTER
 
 ## CPU Models
diff --git a/cpu/esp8266/Makefile.features b/cpu/esp8266/Makefile.features
index a927f8502e..02e6197daa 100644
--- a/cpu/esp8266/Makefile.features
+++ b/cpu/esp8266/Makefile.features
@@ -7,4 +7,5 @@ include $(RIOTCPU)/esp_common/Makefile.features
 FEATURES_PROVIDED += arch_esp8266
 FEATURES_PROVIDED += periph_rtt
 FEATURES_PROVIDED += periph_rtc
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_rtt_set_counter
diff --git a/cpu/esp8266/Makefile.include b/cpu/esp8266/Makefile.include
index 4c8a32152e..e58310f446 100644
--- a/cpu/esp8266/Makefile.include
+++ b/cpu/esp8266/Makefile.include
@@ -51,7 +51,7 @@ CFLAGS += -D__ESP_FILE__=__FILE__
 
 ifneq (,$(filter esp_gdbstub,$(USEMODULE)))
   GDBSTUB_DIR ?= $(RIOTCPU)/$(CPU)/vendor/esp-gdbstub
-  CFLAGS += -DGDBSTUB_BREAK_ON_INIT=1)
+  CFLAGS += -DGDBSTUB_BREAK_ON_INIT=1
   INCLUDES += -I$(GDBSTUB_DIR)
 endif
 
diff --git a/cpu/esp8266/include/cpu_conf.h b/cpu/esp8266/include/cpu_conf.h
index 6b943fad40..380f710684 100644
--- a/cpu/esp8266/include/cpu_conf.h
+++ b/cpu/esp8266/include/cpu_conf.h
@@ -29,6 +29,10 @@
 extern "C" {
 #endif
 
+/**
+* @name    Clock configuration
+* @{
+*/
 /**
  * @brief   Defines the CPU frequency in MHz
  *
@@ -37,6 +41,8 @@ extern "C" {
 #ifndef ESP8266_CPU_FREQUENCY
 #define ESP8266_CPU_FREQUENCY   (80)
 #endif
+#define CLOCK_CORECLOCK         (1000000UL * ESP8266_CPU_FREQUENCY)
+/** @} */
 
 /**
  * @name   Stack size configurations
diff --git a/cpu/esp8266/include/periph_cpu.h b/cpu/esp8266/include/periph_cpu.h
index 4ec7c46965..01836bee74 100644
--- a/cpu/esp8266/include/periph_cpu.h
+++ b/cpu/esp8266/include/periph_cpu.h
@@ -20,6 +20,7 @@
 #define PERIPH_CPU_H
 
 #include <stdint.h>
+#include <limits.h>
 
 #include "eagle_soc.h"
 
@@ -302,7 +303,7 @@ typedef struct {
 /**
  * @brief   Maximum number of UART interfaces
  */
-#define UART_NUMOF_MAX  (1)
+#define UART_NUMOF_MAX  (2)
 /** @} */
 
 #ifdef __cplusplus
diff --git a/cpu/esp8266/periph/gpio.c b/cpu/esp8266/periph/gpio.c
index 60e7604edb..0bedcfd360 100644
--- a/cpu/esp8266/periph/gpio.c
+++ b/cpu/esp8266/periph/gpio.c
@@ -52,9 +52,11 @@ gpio_pin_usage_t _gpio_pin_usage [GPIO_PIN_NUMOF] =
 {
    _GPIO,   /* gpio0 */
 
-   _UART,   /* gpio1  UART0 RxD */
-   _GPIO,   /* gpio2 */
-   _UART,   /* gpio3  UART0 TxD */
+   /* UART0 is initialized by the boot ROM, this only reflects our selection so
+    * other devices don't step on it. */
+   UART0_TXD == GPIO1 ? _UART : _GPIO,   /* gpio1 */
+   UART0_TXD == GPIO2 ? _UART : _GPIO,   /* gpio2 */
+   UART0_RXD == GPIO3 ? _UART : _GPIO,   /* gpio3 */
    _GPIO,   /* gpio4 */
    _GPIO,   /* gpio5 */
    _SPIF,   /* gpio6  SPI flash CLK */
diff --git a/cpu/esp_common/Makefile.include b/cpu/esp_common/Makefile.include
index 63109cc4ec..6d34b99845 100644
--- a/cpu/esp_common/Makefile.include
+++ b/cpu/esp_common/Makefile.include
@@ -85,6 +85,12 @@ LINKFLAGS += -L$(ESP_SDK_DIR)/components/$(CPU)
 LINKFLAGS += -L$(ESP_SDK_DIR)/components/$(CPU)/lib
 LINKFLAGS += -nostdlib -Wl,-gc-sections -Wl,-static
 
+ifeq (,$(filter esp_idf_heap,$(USEMODULE)))
+  # use the wrapper functions for calloc to add correct overflow detection missing
+  # in the newlib's version.
+  LINKFLAGS += -Wl,-wrap=_calloc_r
+endif
+
 # LINKFLAGS += -Wl,--verbose
 # LINKFLAGS += -Wl,--print-gc-sections
 
diff --git a/cpu/esp_common/periph/i2c_sw.c b/cpu/esp_common/periph/i2c_sw.c
index 197ccdf7fe..e4eaf52a5b 100644
--- a/cpu/esp_common/periph/i2c_sw.c
+++ b/cpu/esp_common/periph/i2c_sw.c
@@ -62,8 +62,17 @@
 #include "esp/gpio_regs.h"
 #include "sdk/ets.h"
 
+/**
+ * @brief Clock stretching counter.
+ *
+ * Set to 0 to disable clock stretching. This will cause SCL to be always driven
+ * instead of open-drain, which allows using GPIO15 (normally pulled down to
+ * boot) to be used as SCL.
+ */
+#ifndef I2C_CLOCK_STRETCH
 /* max clock stretching counter (ca. 10 ms) */
 #define I2C_CLOCK_STRETCH 40000
+#endif /* I2C_CLOCK_STRETCH */
 
 /* following functions have to be declared as extern since it is not possible */
 /* to include user_interface.h due to conflicts with gpio_init */
@@ -213,9 +222,12 @@ void i2c_init(i2c_t dev)
      * - LOW : The GPIO is temporarily switched to GPIO_OD_PU mode. In this
      *         mode, the output value 0, which is written during
      *         initialization, actively drives the pin to low.
+     *
+     * When I2C_CLOCK_STRETCH is 0 (disabled), SCL is instead an always driven
+     * output GPIO with no pull-up.
      */
-    if (gpio_init(_i2c_bus[dev].scl, GPIO_IN_PU) ||
-        gpio_init(_i2c_bus[dev].sda, GPIO_IN_PU)) {
+    if (gpio_init(_i2c_bus[dev].scl, I2C_CLOCK_STRETCH ? GPIO_IN_PU : GPIO_OUT)
+        || gpio_init(_i2c_bus[dev].sda, GPIO_IN_PU)) {
         return;
     }
 #endif /* MCU_ESP32 */
@@ -435,11 +447,16 @@ static inline void _i2c_scl_high(_i2c_bus_t* bus)
     /* set SCL signal high (pin is in open-drain mode and pulled-up) */
     GPIO_SET(out_w1ts, out1_w1ts, bus->scl);
 #else /* MCU_ESP32 */
+#if I2C_CLOCK_STRETCH > 0
     /*
      * set SCL signal high (switch back to GPIO_IN_PU mode, that is the pin is
      * in open-drain mode and pulled-up to high)
      */
     GPIO.ENABLE_OUT_CLEAR = bus->scl_bit;
+#else /* I2C_CLOCK_STRETCH > 0 */
+    /* No clock stretching supported, always drive the SCL pin. */
+    GPIO.OUT_SET = bus->scl_bit;
+#endif /* I2C_CLOCK_STRETCH > 0 */
 #endif /* MCU_ESP32 */
 }
 
@@ -449,11 +466,16 @@ static inline void _i2c_scl_low(_i2c_bus_t* bus)
     /* set SCL signal low (actively driven to low) */
     GPIO_SET(out_w1tc, out1_w1tc, bus->scl);
 #else /* MCU_ESP32 */
+#if I2C_CLOCK_STRETCH > 0
     /*
      * set SCL signal low (switch temporarily to GPIO_OD_PU where the
      * written output value 0 drives the pin actively to low)
      */
     GPIO.ENABLE_OUT_SET = bus->scl_bit;
+#else /* I2C_CLOCK_STRETCH > 0 */
+    /* No clock stretching supported, always drive the SCL pin. */
+    GPIO.OUT_CLEAR = bus->scl_bit;
+#endif /* I2C_CLOCK_STRETCH > 0 */
 #endif /* MCU_ESP32 */
 }
 
diff --git a/cpu/esp_common/periph/uart.c b/cpu/esp_common/periph/uart.c
index 9e7316215b..1367bae82c 100644
--- a/cpu/esp_common/periph/uart.c
+++ b/cpu/esp_common/periph/uart.c
@@ -36,13 +36,13 @@
 #include "esp/common_macros.h"
 #include "rom/ets_sys.h"
 #include "xtensa/xtensa_api.h"
+#include "gpio_arch.h"
 
 #define ENABLE_DEBUG 0
 #include "debug.h"
 
 #ifdef MCU_ESP32
 
-#include "gpio_arch.h"
 #include "driver/periph_ctrl.h"
 #include "soc/gpio_reg.h"
 #include "soc/gpio_sig_map.h"
@@ -56,6 +56,7 @@
 
 #else /* MCU_ESP32 */
 
+#include "esp/iomux_regs.h"
 #include "esp8266/uart_struct.h"
 
 #ifdef MODULE_ESP_QEMU
@@ -98,7 +99,9 @@ static struct uart_hw_t _uarts[] = {
         .signal_txd = U0TXD_OUT_IDX,
         .signal_rxd = U0RXD_IN_IDX,
         .int_src = ETS_UART0_INTR_SOURCE
+#endif /* MCU_ESP32 */
     },
+#if defined(UART1_TXD) || defined(MCU_ESP32)
     {
         .regs = &UART1,
         .used = false,
@@ -106,11 +109,15 @@ static struct uart_hw_t _uarts[] = {
         .data = UART_DATA_BITS_8,
         .stop = UART_STOP_BITS_1,
         .parity = UART_PARITY_NONE,
+#ifdef MCU_ESP32
         .mod = PERIPH_UART1_MODULE,
         .signal_txd = U1TXD_OUT_IDX,
         .signal_rxd = U1RXD_IN_IDX,
         .int_src = ETS_UART1_INTR_SOURCE
+#endif /* MCU_ESP32 */
     },
+#endif /* defined(UART1_TXD) || defined(MCU_ESP32) */
+#ifdef MCU_ESP32
     {
         .regs = &UART2,
         .used = false,
@@ -122,8 +129,8 @@ static struct uart_hw_t _uarts[] = {
         .signal_txd = U2TXD_OUT_IDX,
         .signal_rxd = U2RXD_IN_IDX,
         .int_src = ETS_UART2_INTR_SOURCE
-#endif /* MCU_ESP32 */
     },
+#endif /* MCU_ESP32 */
 };
 
 /* declaration of external functions */
@@ -146,7 +153,6 @@ int uart_init(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_cb, void *arg)
     assert(uart < UART_NUMOF_MAX);
     assert(uart < UART_NUMOF);
 
-#ifdef MCU_ESP32
     /* UART1 and UART2 have configurable pins */
     if ((UART_NUMOF > 0 && uart == UART_DEV(1)) ||
         (UART_NUMOF > 1 && uart == UART_DEV(2))) {
@@ -160,8 +166,10 @@ int uart_init(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_cb, void *arg)
         }
 
         /* try to initialize the pins as GPIOs first */
-        if (gpio_init(uart_config[uart].txd, GPIO_OUT) ||
-            gpio_init(uart_config[uart].rxd, GPIO_IN)) {
+        if ((uart_config[uart].txd != GPIO_UNDEF &&
+             gpio_init(uart_config[uart].txd, GPIO_OUT)) ||
+            (uart_config[uart].rxd != GPIO_UNDEF &&
+             gpio_init(uart_config[uart].rxd, GPIO_IN))) {
             return -1;
         }
 
@@ -169,6 +177,7 @@ int uart_init(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_cb, void *arg)
         gpio_set_pin_usage(uart_config[uart].txd, _UART);
         gpio_set_pin_usage(uart_config[uart].rxd, _UART);
 
+#ifdef MCU_ESP32
         /* connect TxD pin to the TxD output signal through the GPIO matrix */
         GPIO.func_out_sel_cfg[uart_config[uart].txd].func_sel = _uarts[uart].signal_txd;
 
@@ -176,8 +185,21 @@ int uart_init(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_cb, void *arg)
         GPIO.func_in_sel_cfg[_uarts[uart].signal_rxd].sig_in_sel = 1;
         GPIO.func_in_sel_cfg[_uarts[uart].signal_rxd].sig_in_inv = 0;
         GPIO.func_in_sel_cfg[_uarts[uart].signal_rxd].func_sel = uart_config[uart].rxd;
-    }
+#else
+        if (uart_config[uart].txd != GPIO_UNDEF) {
+            uint8_t mux = _gpio_to_iomux[uart_config[uart].txd];
+            IOMUX.PIN[mux] = (IOMUX.PIN[mux] & ~IOMUX_PIN_FUNC_MASK) |
+                             IOMUX_FUNC(uart_config[uart].txd == GPIO2 ? 2 : 4);
+        }
+        if (uart_config[uart].rxd != GPIO_UNDEF) {
+            /* There's really only GPIO8 / FUNC(4) for this, but it is normally
+             * unusable because it is used by the internal flash. */
+            uint8_t mux = _gpio_to_iomux[uart_config[uart].rxd];
+            IOMUX.PIN[mux] = (IOMUX.PIN[mux] & ~IOMUX_PIN_FUNC_MASK) |
+                             IOMUX_FUNC(4);
+        }
 #endif
+    }
     _uarts[uart].baudrate = baudrate;
 
     /* register interrupt context */
diff --git a/cpu/esp_common/syscalls.c b/cpu/esp_common/syscalls.c
index 9bc337dc61..ea42a718b7 100644
--- a/cpu/esp_common/syscalls.c
+++ b/cpu/esp_common/syscalls.c
@@ -289,6 +289,25 @@ void* IRAM_ATTR __wrap__calloc_r(struct _reent *r, size_t count, size_t size)
 
 #else /* MODULE_ESP_IDF_HEAP */
 
+void* IRAM_ATTR __wrap__calloc_r(struct _reent *r, size_t nmemb, size_t size)
+{
+    /* The xtensa support has not yet upstreamed to newlib. Hence, the fixed
+     * calloc implementation of newlib >= 4.0.0 is not available to the ESP
+     * platform. We fix this by implementing calloc on top of malloc ourselves */
+    size_t total_size;
+    if (__builtin_mul_overflow(nmemb, size, &total_size)) {
+        return NULL;
+    }
+
+    void *res = _malloc_r(r, total_size);
+
+    if (res) {
+        memset(res, 0, total_size);
+    }
+
+    return res;
+}
+
 /* for compatibility with ESP-IDF heap functions */
 
 void* _heap_caps_malloc(size_t size, uint32_t caps, const char *file, size_t line)
diff --git a/cpu/fe310/Kconfig b/cpu/fe310/Kconfig
index a768f0161d..f4db3d974f 100644
--- a/cpu/fe310/Kconfig
+++ b/cpu/fe310/Kconfig
@@ -13,6 +13,7 @@ config CPU_FAM_FE310
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_PM
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_RTT_SET_COUNTER
     select HAS_PERIPH_WDT
 
diff --git a/cpu/fe310/Makefile.dep b/cpu/fe310/Makefile.dep
index 477c4ba4c6..b3097f251e 100644
--- a/cpu/fe310/Makefile.dep
+++ b/cpu/fe310/Makefile.dep
@@ -1,7 +1,7 @@
 
 FEATURES_REQUIRED_ANY += newlib|picolibc
 ifneq (,$(filter newlib,$(USEMODULE)))
-  USEMODULE += newlib_nano
+  DEFAULT_MODULE += newlib_nano
   USEMODULE += newlib_syscalls_default
 endif
 
diff --git a/cpu/fe310/Makefile.features b/cpu/fe310/Makefile.features
index 0d8c7eca27..f7d14f0f5d 100644
--- a/cpu/fe310/Makefile.features
+++ b/cpu/fe310/Makefile.features
@@ -1,6 +1,7 @@
 FEATURES_PROVIDED += periph_cpuid
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_pm
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_rtt_set_counter
 FEATURES_PROVIDED += periph_wdt
 
diff --git a/cpu/kinetis/Kconfig b/cpu/kinetis/Kconfig
index 8ba10bbc46..85cfac3622 100644
--- a/cpu/kinetis/Kconfig
+++ b/cpu/kinetis/Kconfig
@@ -11,7 +11,6 @@ config CPU_COMMON_KINETIS
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_PM
-    select HAS_PERIPH_RTT_SET_COUNTER
 
 config CPU_FAM_EA
     bool
diff --git a/cpu/kinetis/Makefile.dep b/cpu/kinetis/Makefile.dep
index 309c3ffd60..e5297bd6dc 100644
--- a/cpu/kinetis/Makefile.dep
+++ b/cpu/kinetis/Makefile.dep
@@ -1,5 +1,5 @@
-ifneq (,$(filter periph_rtc,$(USEMODULE)))
-  USEMODULE += periph_rtt
+ifneq (,$(filter periph_rtt,$(USEMODULE)))
+  USEMODULE += periph_timer
 endif
 ifneq (,$(filter periph_i2c,$(USEMODULE)))
   USEMODULE += core_thread_flags
diff --git a/cpu/kinetis/Makefile.features b/cpu/kinetis/Makefile.features
index 853bb78bb5..33484b682f 100644
--- a/cpu/kinetis/Makefile.features
+++ b/cpu/kinetis/Makefile.features
@@ -14,7 +14,6 @@ endif
 
 FEATURES_PROVIDED += periph_gpio
 FEATURES_PROVIDED += periph_gpio_irq
-FEATURES_PROVIDED += periph_rtt_set_counter
 
 # Parse parameters from CPU_MODEL using the kinetis-info.mk script in the same
 # directory as this Makefile.
diff --git a/cpu/kinetis/include/periph_cpu.h b/cpu/kinetis/include/periph_cpu.h
index 200ce22d2c..02ac59b0ca 100644
--- a/cpu/kinetis/include/periph_cpu.h
+++ b/cpu/kinetis/include/periph_cpu.h
@@ -157,18 +157,6 @@ enum {
 #endif
 /** @} */
 
-#ifdef RTC
-/* All Kinetis CPUs have exactly one RTC hardware module, except for the KL02
- * family which don't have an RTC at all */
-/**
- * @name RTT and RTC configuration
- * @{
- */
-#define RTT_FREQUENCY                (1)
-#define RTT_MAX_VALUE                (0xffffffff)
-/** @} */
-#endif
-
 #ifndef DOXYGEN
 /**
  * @name    GPIO pin modes
@@ -500,6 +488,30 @@ enum {
 #endif /* KINETIS_HAVE_LPTMR */
 /** @} */
 
+/**
+ * @name RTT configuration
+ * @{
+ */
+#define RTT_DEV             (TIMER_LPTMR_DEV(0))
+#define RTT_MAX_VALUE       (0x0000ffff)
+#define RTT_CLOCK_FREQUENCY (32768U)             /* in Hz */
+#define RTT_MAX_FREQUENCY   (32768U)             /* in Hz */
+#define RTT_MIN_FREQUENCY   (1U)                 /* in Hz */
+#ifndef RTT_FREQUENCY
+#define RTT_FREQUENCY       RTT_MAX_FREQUENCY
+#endif
+#if IS_USED(PERIPH_RTT)
+/* On kinetis periph_rtt is built on top on an LPTIMER so if used it
+   will conflict with xtimer, if a LPTIMER backend and RTT are needed
+   consider using ztimer */
+#define KINETIS_XTIMER_SOURCE_PIT   1
+#endif
+/* When setting a new compare value, the value must be at least 5 more
+   than the current sleep timer value. Otherwise, the timer compare
+   event may be lost. */
+/** @} */
+
+
 /**
  * @brief UART hardware module types
  */
diff --git a/cpu/kinetis/periph/rtc.c b/cpu/kinetis/periph/rtc.c
index 93b2eedc61..d14cb16bdb 100644
--- a/cpu/kinetis/periph/rtc.c
+++ b/cpu/kinetis/periph/rtc.c
@@ -20,47 +20,80 @@
  * @}
  */
 
+#include "bit.h"
 #include "cpu.h"
 #include "periph/rtc.h"
-#include "periph/rtt.h"
 #include "periph_conf.h"
 
 #define ENABLE_DEBUG 0
 #include "debug.h"
 
-typedef struct {
-    rtc_alarm_cb_t cb;        /**< callback called from RTC interrupt */
-} rtc_state_t;
-
-static rtc_state_t rtc_callback;
-
-/**
- * @brief Wrapper function to call RTC callback from RTT interrupt
- *
- * @param[inout] arg    argument passed from the RTT interrupt
- */
-static void rtc_cb(void *arg);
+static rtc_alarm_cb_t rtc_callback = NULL;
+static rtc_alarm_cb_t rtc_arg;
 
 void rtc_init(void)
 {
-    rtt_init();
+    rtc_callback = NULL;
+
+   /* Enable module clock gate */
+    RTC_CLKEN();
+
+    /* At this point, the CPU core may be clocked by a clock derived from the
+     * RTC oscillator, avoid touching the oscillator enable bit (OSCE) in RTC_CR */
+
+    /* Enable user mode access */
+    bit_set32(&RTC->CR, RTC_CR_SUP_SHIFT);
+
+    /* Disable all RTC interrupts. */
+    RTC->IER = 0;
+
+    /* The RTC module is only reset on VBAT power on reset, we try to preserve
+     * the seconds counter between reboots */
+    if (RTC->SR & RTC_SR_TIF_MASK) {
+        /* Time Invalid Flag is set, clear TIF by writing TSR */
+
+        /* Stop counter to make TSR writable */
+        bit_clear32(&RTC->SR, RTC_SR_TCE_SHIFT);
+
+        RTC->TSR = 0;
+    }
+
+    /* Clear the alarm flag TAF by writing a new alarm target to TAR */
+    RTC->TAR = 0xffffffff;
+
+    /* Enable RTC interrupts */
+    NVIC_EnableIRQ(RTC_IRQn);
+
 }
 
 int rtc_set_time(struct tm *time)
 {
     uint32_t t = rtc_mktime(time);
 
-    rtt_set_counter(t);
+    /* Disable time counter before writing to the timestamp register */
+    bit_clear32(&RTC->SR, RTC_SR_TCE_SHIFT);
+    RTC->TPR = 0;
+    /* write TSR after TPR, as clearing TPR bit 14 will increment TSR */
+    RTC->TSR = t;
+    /* Enable when done */
+    bit_set32(&RTC->SR, RTC_SR_TCE_SHIFT);
 
     return 0;
 }
 
 int rtc_get_time(struct tm *time)
 {
-    uint32_t t = rtt_get_counter();
-
+    uint32_t t;
+    for (int i = 0; i < 3; i++) {
+        /* Read twice to make sure we get a stable reading */
+        t = RTC->TSR;
+
+        if (t == RTC->TSR) {
+            return t;
+        }
+    }
+    /* Fallback just return unstable reading */
     rtc_localtime(t, time);
-
     return 0;
 }
 
@@ -68,16 +101,30 @@ int rtc_set_alarm(struct tm *time, rtc_alarm_cb_t cb, void *arg)
 {
     uint32_t t = rtc_mktime(time);
 
-    rtc_callback.cb = cb;
+    /* The alarm is triggered when TSR matches TAR, and TSR increments. This
+     * seem counterintuitive as most users expect the alarm to trigger
+     * immediately when the counter becomes equal to the alarm time.
+     *
+     * Workaround: Set TAF to alarm - 1
+     */
+
+    /* Disable Timer Alarm Interrupt */
+    bit_clear32(&RTC->IER, RTC_IER_TAIE_SHIFT);
+
+    RTC->TAR = t - 1;
 
-    rtt_set_alarm(t, rtc_cb, arg);
+    rtc_callback = cb;
+    rtc_arg = arg;
+
+    /* Enable Timer Alarm Interrupt */
+    bit_set32(&RTC->IER, RTC_IER_TAIE_SHIFT);
 
     return 0;
 }
 
 int rtc_get_alarm(struct tm *time)
 {
-    uint32_t t = rtt_get_alarm();
+    uint32_t t =  RTC->TAR + 1;
 
     rtc_localtime(t, time);
 
@@ -86,23 +133,32 @@ int rtc_get_alarm(struct tm *time)
 
 void rtc_clear_alarm(void)
 {
-    rtt_clear_alarm();
-    rtc_callback.cb = NULL;
+    /* Disable Timer Alarm Interrupt */
+    bit_clear32(&RTC->IER, RTC_IER_TAIE_SHIFT);
+    rtc_callback = NULL;
 }
 
 void rtc_poweron(void)
 {
-    rtt_poweron();
+    /* Enable Time Counter */
+    bit_set32(&RTC->SR, RTC_SR_TCE_SHIFT);
 }
 
 void rtc_poweroff(void)
 {
-    rtt_poweroff();
+    /* Disable Time Counter */
+    bit_clear32(&RTC->SR, RTC_SR_TCE_SHIFT);
 }
 
-static void rtc_cb(void *arg)
+void isr_rtc(void)
 {
-    if (rtc_callback.cb != NULL) {
-        rtc_callback.cb(arg);
+    if (RTC->SR & RTC_SR_TAF_MASK) {
+        if (rtc_callback != NULL) {
+            /* Disable Timer Alarm Interrupt */
+            bit_clear32(&RTC->IER, RTC_IER_TAIE_SHIFT);
+            rtc_callback(rtc_arg);
+        }
     }
+
+    cortexm_isr_end();
 }
diff --git a/cpu/kinetis/periph/rtt.c b/cpu/kinetis/periph/rtt.c
index c5048d49db..59079f2a38 100644
--- a/cpu/kinetis/periph/rtt.c
+++ b/cpu/kinetis/periph/rtt.c
@@ -14,13 +14,6 @@
  * @{
  *
  * @file
- * @brief       Low-level RTT interface implementation for Freescale Kinetis
- *              MCUs. NXP's RTC module is what RIOT calls a Real-Time
- *              Timer (RTT), a simple counter which counts seconds; RIOT Real-
- *              Time Clocks (RTC) counts seconds, minutes, hours etc. We provide
- *              an RTT->RTC wrapper layer in a separate file to allow using the
- *              RTT as a system real time clock.
- *
  * @author      Johann Fischer <j.fischer@phytec.de>
  * @author      Joakim Nohlgård <joakim.nohlgard@eistec.se>
  *
@@ -31,154 +24,62 @@
 #include "cpu.h"
 #include "bit.h"
 #include "periph/rtt.h"
+#include "periph/timer.h"
 #include "periph_conf.h"
 
 #define ENABLE_DEBUG 0
 #include "debug.h"
 
-typedef struct {
-    rtt_cb_t alarm_cb;              /**< callback called from RTC alarm */
-    void *alarm_arg;                /**< argument passed to the callback */
-    rtt_cb_t overflow_cb;           /**< callback called when RTC overflows */
-    void *overflow_arg;             /**< argument passed to the callback */
-} rtt_state_t;
-
-static rtt_state_t rtt_callback;
+static rtt_cb_t alarm_cb = NULL;       /**< callback called from RTC alarm */
+static void *alarm_arg;                /**< argument passed to the callback */
+static uint32_t alarm_value = 0;
 
-void rtt_init(void)
+static void _rtt_cb(void *arg, int channel)
 {
-    /* Enable module clock gate */
-    RTC_CLKEN();
-
-    /* At this point, the CPU core may be clocked by a clock derived from the
-     * RTC oscillator, avoid touching the oscillator enable bit (OSCE) in RTC_CR */
-
-    /* Enable user mode access */
-    bit_set32(&RTC->CR, RTC_CR_SUP_SHIFT);
-
-    /* Disable all RTC interrupts. */
-    RTC->IER = 0;
-
-    /* The RTC module is only reset on VBAT power on reset, we try to preserve
-     * the seconds counter between reboots */
-    if (RTC->SR & RTC_SR_TIF_MASK) {
-        /* Time Invalid Flag is set, clear TIF by writing TSR */
-
-        /* Stop counter to make TSR writable */
-        bit_clear32(&RTC->SR, RTC_SR_TCE_SHIFT);
-
-        RTC->TSR = 0;
+    (void) arg;
+    (void) channel;
+    if (alarm_cb != NULL) {
+        alarm_cb(alarm_arg);
     }
-
-    /* Clear the alarm flag TAF by writing a new alarm target to TAR */
-    RTC->TAR = 0xffffffff;
-
-    /* Enable RTC interrupts */
-    NVIC_EnableIRQ(RTC_IRQn);
-
-    rtt_poweron();
-}
-
-void rtt_set_overflow_cb(rtt_cb_t cb, void *arg)
-{
-    rtt_callback.overflow_cb = cb;
-    rtt_callback.overflow_arg = arg;
-    bit_set32(&RTC->IER, RTC_IER_TOIE_SHIFT);
 }
 
-void rtt_clear_overflow_cb(void)
+void rtt_init(void)
 {
-    bit_clear32(&RTC->IER, RTC_IER_TOIE_SHIFT);
+    timer_init(RTT_DEV, RTT_FREQUENCY, _rtt_cb, NULL);
+    alarm_value = 0;
 }
 
 uint32_t rtt_get_counter(void)
 {
-    uint32_t t;
-    for (int i = 0; i < 3; i++) {
-        /* Read twice to make sure we get a stable reading */
-        t = RTC->TSR;
-
-        if (t == RTC->TSR) {
-            return t;
-        }
-    }
-    /* Fallback if we are not getting stable readings */
-    return t;
-}
-
-void rtt_set_counter(uint32_t counter)
-{
-    /* Disable time counter before writing to the timestamp register */
-    bit_clear32(&RTC->SR, RTC_SR_TCE_SHIFT);
-    RTC->TPR = 0;
-    /* write TSR after TPR, as clearing TPR bit 14 will increment TSR */
-    RTC->TSR = counter;
-    /* Enable when done */
-    bit_set32(&RTC->SR, RTC_SR_TCE_SHIFT);
+    return timer_read(RTT_DEV);
 }
 
-
 void rtt_set_alarm(uint32_t alarm, rtt_cb_t cb, void *arg)
 {
-    /* The alarm is triggered when TSR matches TAR, and TSR increments. This
-     * seem counterintuitive as most users expect the alarm to trigger
-     * immediately when the counter becomes equal to the alarm time.
-     *
-     * Workaround: Set TAF to alarm - 1
-     */
-
-    /* Disable Timer Alarm Interrupt */
-    bit_clear32(&RTC->IER, RTC_IER_TAIE_SHIFT);
-
-    RTC->TAR = alarm - 1;
-
-    rtt_callback.alarm_cb = cb;
-    rtt_callback.alarm_arg = arg;
-
-    /* Enable Timer Alarm Interrupt */
-    bit_set32(&RTC->IER, RTC_IER_TAIE_SHIFT);
+    unsigned state = irq_disable();
+    alarm_arg = arg;
+    alarm_cb = cb;
+    alarm_value = alarm;
+    timer_set_absolute(RTT_DEV, 0, alarm % RTT_MAX_VALUE);
+    irq_restore(state);
 }
 
 uint32_t rtt_get_alarm(void)
 {
-    return RTC->TAR + 1;
+    return alarm_value;
 }
 
 void rtt_clear_alarm(void)
 {
-    /* Disable Timer Alarm Interrupt */
-    bit_clear32(&RTC->IER, RTC_IER_TAIE_SHIFT);
+    timer_clear(RTT_DEV, 0);
 }
 
-/* RTC module has independent power suply. We can not really turn it on/off. */
-
 void rtt_poweron(void)
 {
-    /* Enable Time Counter */
-    bit_set32(&RTC->SR, RTC_SR_TCE_SHIFT);
+    timer_start(RTT_DEV);
 }
 
 void rtt_poweroff(void)
 {
-    /* Disable Time Counter */
-    bit_clear32(&RTC->SR, RTC_SR_TCE_SHIFT);
-}
-
-void isr_rtc(void)
-{
-    if (RTC->SR & RTC_SR_TAF_MASK) {
-        if (rtt_callback.alarm_cb != NULL) {
-            /* Disable Timer Alarm Interrupt */
-            bit_clear32(&RTC->IER, RTC_IER_TAIE_SHIFT);
-            rtt_callback.alarm_cb(rtt_callback.alarm_arg);
-        }
-    }
-
-    if (RTC->SR & RTC_SR_TOF_MASK) {
-        if (rtt_callback.overflow_cb != NULL) {
-            rtt_callback.overflow_cb(rtt_callback.overflow_arg);
-        }
-    }
-
-    cortexm_isr_end();
+    timer_stop(RTT_DEV);
 }
diff --git a/cpu/lpc23xx/Kconfig b/cpu/lpc23xx/Kconfig
index 53951c9a7b..e44ce63356 100644
--- a/cpu/lpc23xx/Kconfig
+++ b/cpu/lpc23xx/Kconfig
@@ -11,9 +11,11 @@ config CPU_FAM_LPC23XX
     select HAS_BACKUP_RAM
     select HAS_CPU_LPC23XX
     select HAS_PERIPH_DAC
+    select HAS_PERIPH_FLASHPAGE
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_TIMER_PERIODIC
+    select HAS_PERIPH_RTC_MS
 
 ## CPU Models
 config CPU_MODEL_LPC2387
diff --git a/cpu/lpc23xx/Makefile.features b/cpu/lpc23xx/Makefile.features
index 25463d61a0..850654fb2d 100644
--- a/cpu/lpc23xx/Makefile.features
+++ b/cpu/lpc23xx/Makefile.features
@@ -1,7 +1,9 @@
 # Put defined MCU peripherals here (in alphabetical order)
 FEATURES_PROVIDED += backup_ram
 FEATURES_PROVIDED += periph_dac
+FEATURES_PROVIDED += periph_flashpage
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_timer_periodic
+FEATURES_PROVIDED += periph_rtc_ms
 
 include $(RIOTCPU)/arm7_common/Makefile.features
diff --git a/cpu/lpc23xx/include/cpu_conf.h b/cpu/lpc23xx/include/cpu_conf.h
index 729870a1af..03890e98f3 100644
--- a/cpu/lpc23xx/include/cpu_conf.h
+++ b/cpu/lpc23xx/include/cpu_conf.h
@@ -143,6 +143,28 @@ extern "C" {
  */
 #define BACKUP_RAM_DATA __attribute__((section(".backup.data")))
 
+/**
+ * @brief   lpc23xx has non-uniform pages
+ */
+#define PERIPH_FLASHPAGE_CUSTOM_PAGESIZES
+
+/**
+ * @brief   FLASH base address
+ */
+#define CPU_FLASH_BASE          (0x0U)
+
+/**
+ * @brief   Flash page configuration
+ * @{
+ */
+#define PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_ADDR
+#define PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_PAGE
+
+#define FLASHPAGE_NUMOF                 (27)
+#define FLASHPAGE_WRITE_BLOCK_SIZE      (256)
+#define FLASHPAGE_WRITE_BLOCK_ALIGNMENT (256)
+/** @} */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/cpu/lpc23xx/periph/flashpage.c b/cpu/lpc23xx/periph/flashpage.c
new file mode 100644
index 0000000000..d35ceedcaa
--- /dev/null
+++ b/cpu/lpc23xx/periph/flashpage.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2014 INRIA
+ * Copyright (C) 2020 Beuth Hochschule für Technik Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     cpu_lpc23xx
+ * @ingroup     drivers_periph_flashpage
+ * @{
+ *
+ * @file
+ * @brief       Low-level flash page driver implementation
+ *
+ * @author      Oliver Hahm <oliver.hahm@inria.fr>
+ * @author      Benjamin Valentin <benpicco@beuth-hochschule.de>
+ *
+ * @}
+ */
+
+#include "assert.h"
+#include "cpu.h"
+#include "iap.h"
+#include "irq.h"
+#include "periph/flashpage.h"
+
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+/* typedefinition for IAP entry function */
+typedef void (*IAP)(unsigned int[], unsigned int[]);
+static const IAP IAP_Entry = (IAP)0x7ffffff1;
+
+static uint32_t iap(uint32_t code, uint32_t p1, uint32_t p2, uint32_t p3, uint32_t p4)
+{
+    /* contains parameters for IAP command */
+    static unsigned int iap_command[5];
+    /* contains results */
+    static unsigned int iap_result[2];
+
+    iap_command[0] = code;      /* set command code */
+    iap_command[1] = p1;        /* set 1st param */
+    iap_command[2] = p2;        /* set 2nd param */
+    iap_command[3] = p3;        /* set 3rd param */
+    iap_command[4] = p4;        /* set 4th param */
+
+    IAP_Entry(iap_command, iap_result); /* IAP entry point */
+    return *iap_result;
+}
+
+/******************************************************************************
+ * Function:    check_sector
+ *
+ * Description: This command is used to blank check a sector or multiple sectors
+ *              of on-chip Flash memory. To blank check a single sector use the
+ *              same "Start" and "End" sector numbers.
+ *
+ *              Command code: 53
+ *              Param0: Start Sector Number
+ *              Param1: End Sector Number (should be greater than equal to the start
+ *                      sector number)
+ *
+ * Parameters:  long sect_start:    Param0
+ *              long sect_end:      Param1
+ *
+ * Return:      Code    CMD_SUCCESS
+ *                      BUSY
+ *                      SECTOR_NOT_BLANK
+ *                      INVALID_SECTOR
+ *
+ *              Result0: Offset of the first non blank word location if the status
+ *              code is SECTOR_NOT_BLANK.
+ *              Result1: Contents of non blank wird location.
+ *****************************************************************************/
+static uint32_t blank_check_sector(uint32_t sect_start, uint32_t sect_end)
+{
+    return iap(BLANK_CHECK_SECTOR, sect_start, sect_end, 0, 0);
+}
+
+/******************************************************************************
+ * Function:    copy_ram_to_flash
+ *
+ * Description: This command is used to program the flash memory. the affected should be
+ *              prepared first by calling "Prepare Sector for Write Operation" command. the
+ *              affected sectors are automatically protected again once the copy command is
+ *              successfully executed. the boot sector cannot be written by this command.
+ *
+ *              Command code: 51
+ *              Param0: (DST) Destination Flash address where data bytes are to be written.
+ *                      This address should be a 256 byte boundary.
+ *              Param1: (SRC) Source RAM address from which data byre are to be read.
+ *              Param2: Number of bytes to be written. Should be 256 | 512 | 1024 | 4096 | 8192.
+ *              Param3: System Clock Frequency (CCLK) in KHz.
+ *
+ * Parameters:  long tmp_adr_dst:   Param0
+ *              long tmp_adr_src:   Param1
+ *              long tmp_size:      Param2
+ *
+ * Return:      Code    CMD_SUCCESS
+ *                      or SRC_ADDR_ERROR (Address not on word boundary)
+ *                      or DST_ADDR_ERROR (Address not on correct boundary)
+ *                      or SRC_ADDR_NOT_MAPPED
+ *                      or DST_ADDR_NOT_MAPPED
+ *                      or COUNT_ERROR (Byte count is not 256 | 512 | 1024 | 4096 | 8192)
+ *                      or SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION
+ *                      or BUSY
+ *****************************************************************************/
+static uint32_t copy_ram_to_flash(void *dst, const void *src, size_t tmp_size)
+{
+    return iap(COPY_RAM_TO_FLASH, (uintptr_t)dst, (uintptr_t)src, tmp_size, _XTAL);
+}
+
+/******************************************************************************
+ * Function:    Prepare_Sector
+ *
+ * Description: This command must be executed before executing "Copy RAM to Flash"
+ *              or "Erase Sector(s)" command.
+ *              Successful execution of the "Copy RAM to Flash" or "Erase Sector(s)" command causes
+ *              relevant sectors to be protected again.
+ *              The boot sector can not be prepared by this command.
+ *              To prepare a single sector use the same "Start" and "End" sector numbers.
+ *
+ *              Command code: 50
+ *              Param0: Start Sector Number
+ *              Param1: End Sector Number: Should be greater than or equal to start sector number.
+ *
+ * Parameters:  long sect_start:    Param0
+ *              long sect_end:      Param1
+ *
+ * Return:      Code    CMD_SUCCESS
+ *                      or BUSY
+ *                      or INVALID_SECTOR
+ *****************************************************************************/
+static uint32_t prepare_sectors(uint32_t sect_start, uint32_t sect_end)
+{
+    return iap(PREPARE_SECTOR_FOR_WRITE_OPERATION, sect_start, sect_end, 0, 0);
+}
+
+/******************************************************************************
+ * Function:    erase_sectors
+ *
+ * Description: This command is used to erase a sector or multiple sectors of on-chip Flash memory.
+ *              The boot sector can not be erased by this command.
+ *              To erase a single sector use the same "Start" and "End" sector numbers.
+ *
+ *              Command code: 52
+ *              Param0: Start Sector Number
+ *              Param1: End Sector Number: Should be greater than or equal to start sector number.
+ *              Param2: System Clock Frequency (CCLK) in KHz.
+ *
+ * Parameters:  long sect_start:    Param0
+ *              long sect_end:      Param1
+ *
+ * Return:      Code    CMD_SUCCESS
+ *                      or BUSY
+ *                      or SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION
+ *                      or INVALID_SECTOR
+ *****************************************************************************/
+static uint32_t erase_sectors(uint32_t sect_start, uint32_t sect_end)
+{
+    return iap(ERASE_SECTOR, sect_start, sect_end, _XTAL, 0);
+}
+
+/******************************************************************************
+ * Function:    compare
+ *
+ * Description: This command is used to compare the memory contents at two locations.
+ *              Compare result may not be correct when source or destination address
+ *              contains any of the first 64 bytes starting from address zero.
+ *              First 64 bytes can be re-mapped to RAM.
+ *
+ *              Command Code: 56
+ *              Param0(DST): Starting Flash or RAM address from where data bytes are to be
+ *                              address should be a word boundary.
+ *              Param1(SRC): Starting Flash or RAM address from where data bytes are to be
+ *                              address should be a word boundary.
+ *              Param2: Number of bytes to be compared. Count should be in multiple of 4.
+ *
+ * Parameters:  long tmp_adr_dst
+ *              long tmp_adr_src
+ *              long tmp_size
+ *
+ * Return:      Code    CMD_SUCCESS
+ *                      or COMPARE_ERROR
+ *                      or COUNT_ERROR (Byte count is not multiple of 4)
+ *                      or ADDR_ERROR
+ *                      or ADDR_NOT_MAPPED
+ *
+ *              Result0: Offset of the first mismatch if the Status Code is COMPARE_ERROR.
+ *****************************************************************************/
+__attribute__((unused))
+static uint32_t compare(uint32_t tmp_adr_dst, uint32_t tmp_adr_src, uint32_t tmp_size)
+{
+    return iap(COMPARE, tmp_adr_dst, tmp_adr_src, tmp_size, 0);
+}
+
+size_t flashpage_size(unsigned page)
+{
+    if (page < 8 || page > 21) {
+        return 0x1000;
+    }
+
+    return 0x8000;
+}
+
+void flashpage_erase(unsigned sec)
+{
+    /* check sector */
+    if (!blank_check_sector(sec, sec)) {
+        DEBUG("Sector %u already blank\n", sec);
+        return;
+    }
+
+    /* prepare sector */
+    if (prepare_sectors(sec, sec)) {
+        DEBUG("ERROR: PREPARE_SECTOR_FOR_WRITE_OPERATION\n");
+        return;
+    }
+
+    unsigned state = irq_disable();
+
+    /* erase sector */
+    if (erase_sectors(sec, sec)) {
+        DEBUG("ERROR: ERASE SECTOR\n");
+    }
+
+    irq_restore(state);
+}
+
+void flashpage_write(void *target_addr, const void *data, size_t len)
+{
+    char err;
+    uint8_t sec = flashpage_page(target_addr);
+
+    /* prepare sector */
+    err = prepare_sectors(sec, sec);
+    if (err) {
+        DEBUG("ERROR: PREPARE_SECTOR_FOR_WRITE_OPERATION: %u\n", err);
+        return;
+    }
+
+    /*  write flash */
+    unsigned state = irq_disable();
+    err = copy_ram_to_flash(target_addr, data, len);
+    irq_restore(state);
+
+    if (err) {
+        DEBUG("ERROR: COPY_RAM_TO_FLASH: %u\n", err);
+    }
+}
diff --git a/cpu/lpc23xx/periph/rtc.c b/cpu/lpc23xx/periph/rtc.c
index 2680d1806a..475aba0aa7 100644
--- a/cpu/lpc23xx/periph/rtc.c
+++ b/cpu/lpc23xx/periph/rtc.c
@@ -28,6 +28,7 @@
 #include "periph/rtc.h"
 #include "VIC.h"
 #include "lpc23xx.h"
+#include "timex.h"
 
 #define ENABLE_DEBUG 0
 #include "debug.h"
@@ -110,6 +111,22 @@ int rtc_get_time(struct tm *localt)
     return 0;
 }
 
+int rtc_get_time_ms(struct tm *time, uint16_t *ms)
+{
+    uint16_t ccr_before, ccr_after;
+
+    /* loop in case of overflow */
+    do {
+        ccr_before = RTC_CCR >> 1;
+        rtc_get_time(time);
+        ccr_after = RTC_CCR >> 1;
+    } while (ccr_before > ccr_after);
+
+    /* CCR is 15-bit counter, increments second with each overflow */
+    *ms = (ccr_after * MS_PER_SEC) >> 15;
+
+    return 0;
+}
 
 int rtc_set_alarm(struct tm *localt, rtc_alarm_cb_t cb, void *arg)
 {
diff --git a/cpu/msp430_common/Makefile.dep b/cpu/msp430_common/Makefile.dep
index 907a9870bc..1292b4bbdc 100644
--- a/cpu/msp430_common/Makefile.dep
+++ b/cpu/msp430_common/Makefile.dep
@@ -1,7 +1,7 @@
 USEMODULE += msp430_common msp430_common_periph
 
 ifneq (,$(filter newlib,$(USEMODULE)))
-  USEMODULE += newlib_nano
+  DEFAULT_MODULE += newlib_nano
 endif
 
 # Make calls to malloc and friends thread-safe
diff --git a/cpu/native/Kconfig b/cpu/native/Kconfig
index 32866d92fb..2250080b7e 100644
--- a/cpu/native/Kconfig
+++ b/cpu/native/Kconfig
@@ -88,4 +88,5 @@ rsource "backtrace/Kconfig"
 
 endmenu # Native modules
 
+rsource "mtd/Kconfig"
 rsource "periph/Kconfig"
diff --git a/cpu/native/include/cpu_conf.h b/cpu/native/include/cpu_conf.h
index c94cd898c9..3865a0c3b4 100644
--- a/cpu/native/include/cpu_conf.h
+++ b/cpu/native/include/cpu_conf.h
@@ -28,25 +28,47 @@ extern "C" {
  * @{
  */
 #ifdef __MACH__ /* OSX */
+#ifndef THREAD_STACKSIZE_DEFAULT
 #define THREAD_STACKSIZE_DEFAULT            (163840)
+#endif
+#ifndef THREAD_STACKSIZE_IDLE
 #define THREAD_STACKSIZE_IDLE               (163840)
+#endif
+#ifndef THREAD_EXTRA_STACKSIZE_PRINTF
 #define THREAD_EXTRA_STACKSIZE_PRINTF       (81920)
+#endif
+#ifndef THREAD_EXTRA_STACKSIZE_PRINTF_FLOAT
 #define THREAD_EXTRA_STACKSIZE_PRINTF_FLOAT (81920)
+#endif
 /* for core/include/thread.h */
+#ifndef THREAD_STACKSIZE_MINIMUM
 #define THREAD_STACKSIZE_MINIMUM            (163840)
-/* native internal */
-#define THREAD_STACKSIZE_MINIMUM            (163840)
+#endif
+#ifndef ISR_STACKSIZE
 #define ISR_STACKSIZE                       (163840)
+#endif
 
 #else /* Linux etc. */
+#ifndef THREAD_STACKSIZE_DEFAULT
 #define THREAD_STACKSIZE_DEFAULT            (8192)
+#endif
+#ifndef THREAD_STACKSIZE_IDLE
 #define THREAD_STACKSIZE_IDLE               (8192)
+#endif
+#ifndef THREAD_EXTRA_STACKSIZE_PRINTF
 #define THREAD_EXTRA_STACKSIZE_PRINTF       (4096)
+#endif
+#ifndef THREAD_EXTRA_STACKSIZE_PRINTF_FLOAT
 #define THREAD_EXTRA_STACKSIZE_PRINTF_FLOAT (4096)
+#endif
 /* for core/include/thread.h */
+#ifndef THREAD_STACKSIZE_MINIMUM
 #define THREAD_STACKSIZE_MINIMUM            (8192)
+#endif
 /* native internal */
+#ifndef ISR_STACKSIZE
 #define ISR_STACKSIZE                       (8192)
+#endif
 #endif /* OS */
 /** @} */
 
diff --git a/cpu/native/mtd/Kconfig b/cpu/native/mtd/Kconfig
new file mode 100644
index 0000000000..a97959fb3e
--- /dev/null
+++ b/cpu/native/mtd/Kconfig
@@ -0,0 +1,12 @@
+# Copyright (c) 2021 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config MODULE_MTD_NATIVE
+    bool
+    default y if MODULE_MTD
+    depends on NATIVE_OS_LINUX
+    depends on TEST_KCONFIG
diff --git a/cpu/nrf52/radio/nrf802154/nrf802154.c b/cpu/nrf52/radio/nrf802154/nrf802154.c
index 38d81244eb..54fb8dae44 100644
--- a/cpu/nrf52/radio/nrf802154/nrf802154.c
+++ b/cpu/nrf52/radio/nrf802154/nrf802154.c
@@ -492,8 +492,10 @@ void isr_radio(void)
                 /* only process packet if event callback is set and CRC is valid */
                 if ((nrf802154_dev->netdev.event_callback) &&
                     (NRF_RADIO->CRCSTATUS == 1) &&
-                    (netdev_ieee802154_dst_filter(nrf802154_dev,
-                                                  &rxbuf[1]) == 0)) {
+                    (ieee802154_dst_filter(&rxbuf[1],
+                                           nrf802154_dev->pan,
+                                           (network_uint16_t*) nrf802154_dev->short_addr,
+                                           nrf802154_dev->long_addr) == 0)) {
                     _state |= RX_COMPLETE;
                 }
                 else {
diff --git a/cpu/nrf52/radio/nrf802154/nrf802154_radio.c b/cpu/nrf52/radio/nrf802154/nrf802154_radio.c
index 58fe27b39f..43023eb529 100644
--- a/cpu/nrf52/radio/nrf802154/nrf802154_radio.c
+++ b/cpu/nrf52/radio/nrf802154/nrf802154_radio.c
@@ -91,6 +91,7 @@ static struct {
     bool cca_send   : 1;    /**< whether the next transmission uses CCA or not */
     bool ack_filter : 1;    /**< whether the ACK filter is activated or not */
     bool promisc    : 1;    /**< whether the device is in promiscuous mode or not */
+    bool pending    : 1;    /**< whether there pending bit should be set in the ACK frame or not */
 } cfg = {
     .cca_send   = true,
     .ack_filter = true,
@@ -431,6 +432,11 @@ static void _timer_cb(void *arg, int chan)
 
     if (chan == MAC_TIMER_CHAN_ACK) {
         /* Copy sqn */
+        ack[1] = IEEE802154_FCF_TYPE_ACK;
+        if (cfg.pending) {
+            ack[1] |= IEEE802154_FCF_FRAME_PEND;
+        }
+
         ack[3] = rxbuf[3];
 
         NRF_RADIO->PACKETPTR = (uint32_t) &ack;
@@ -517,7 +523,7 @@ void isr_radio(void)
         case STATE_RX:
             if (NRF_RADIO->CRCSTATUS) {
                 bool l2filter_passed = _l2filter(rxbuf+1);
-                bool is_auto_ack_en = ack[1];
+                bool is_auto_ack_en = !IS_ACTIVE(CONFIG_IEEE802154_AUTO_ACK_DISABLE);
                 bool is_ack = rxbuf[1] & IEEE802154_FCF_TYPE_ACK;
                 bool ack_req = rxbuf[1] & IEEE802154_FCF_ACK_REQ;
 
@@ -699,26 +705,41 @@ int _set_cca_mode(ieee802154_dev_t *dev, ieee802154_cca_mode_t mode)
     return 0;
 }
 
-static int _set_hw_addr_filter(ieee802154_dev_t *dev, const network_uint16_t *short_addr,
-                              const eui64_t *ext_addr, const uint16_t *pan_id)
+static int _config_addr_filter(ieee802154_dev_t *dev, ieee802154_af_cmd_t cmd, const void *value)
 {
     (void) dev;
-    if (short_addr) {
-        memcpy(nrf802154_short_addr, short_addr, IEEE802154_SHORT_ADDRESS_LEN);
+    const uint16_t *pan_id = value;
+    switch(cmd) {
+        case IEEE802154_AF_SHORT_ADDR:
+            memcpy(nrf802154_short_addr, value, IEEE802154_SHORT_ADDRESS_LEN);
+            break;
+        case IEEE802154_AF_EXT_ADDR:
+            memcpy(nrf802154_long_addr, value, IEEE802154_LONG_ADDRESS_LEN);
+            break;
+        case IEEE802154_AF_PANID:
+            nrf802154_pan_id = *pan_id;
+            break;
+        case IEEE802154_AF_PAN_COORD:
+            return -ENOTSUP;
     }
 
-    if (ext_addr) {
-        memcpy(nrf802154_long_addr, ext_addr, IEEE802154_LONG_ADDRESS_LEN);
-    }
+    return 0;
+}
 
-    if (pan_id) {
-        nrf802154_pan_id = *pan_id;
+static int _config_src_addr_match(ieee802154_dev_t *dev, ieee802154_src_match_t cmd, const void *value)
+{
+    (void) dev;
+    switch(cmd) {
+        case IEEE802154_SRC_MATCH_EN:
+            cfg.pending = *((const bool*) value);
+            break;
+        default:
+            return -ENOTSUP;
     }
-
     return 0;
 }
 
-static int _set_rx_mode(ieee802154_dev_t *dev, ieee802154_rx_mode_t mode)
+static int _set_frame_filter_mode(ieee802154_dev_t *dev, ieee802154_filter_mode_t mode)
 {
     (void) dev;
 
@@ -726,21 +747,16 @@ static int _set_rx_mode(ieee802154_dev_t *dev, ieee802154_rx_mode_t mode)
     bool _promisc = false;
 
     switch (mode) {
-    case IEEE802154_RX_AACK_DISABLED:
-        ack[1] = 0;
-        break;
-    case IEEE802154_RX_AACK_ENABLED:
-        ack[1] = IEEE802154_FCF_TYPE_ACK;
-        break;
-    case IEEE802154_RX_AACK_FRAME_PENDING:
-        ack[1] = IEEE802154_FCF_TYPE_ACK | IEEE802154_FCF_FRAME_PEND;
-        break;
-    case IEEE802154_RX_PROMISC:
-        _promisc = true;
-        break;
-    case IEEE802154_RX_WAIT_FOR_ACK:
-        ackf = false;
-        break;
+        case IEEE802154_FILTER_ACCEPT:
+            break;
+        case IEEE802154_FILTER_PROMISC:
+            _promisc = true;
+            break;
+        case IEEE802154_FILTER_ACK_ONLY:
+            ackf = false;
+            break;
+        default:
+            return -ENOTSUP;
     }
 
     cfg.ack_filter = ackf;
@@ -800,7 +816,8 @@ static const ieee802154_radio_ops_t nrf802154_ops = {
     .set_cca_threshold = set_cca_threshold,
     .set_cca_mode = _set_cca_mode,
     .config_phy = _config_phy,
-    .set_hw_addr_filter = _set_hw_addr_filter,
     .set_csma_params = _set_csma_params,
-    .set_rx_mode = _set_rx_mode,
+    .config_addr_filter = _config_addr_filter,
+    .config_src_addr_match = _config_src_addr_match,
+    .set_frame_filter_mode = _set_frame_filter_mode,
 };
diff --git a/cpu/nrf5x_common/Kconfig b/cpu/nrf5x_common/Kconfig
index 15322b17bf..df6ec6e8bd 100644
--- a/cpu/nrf5x_common/Kconfig
+++ b/cpu/nrf5x_common/Kconfig
@@ -15,6 +15,7 @@ config CPU_COMMON_NRF5X
     select HAS_PERIPH_HWRNG
     select HAS_PERIPH_TEMPERATURE
     select HAS_PERIPH_TIMER_PERIODIC
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_UART_MODECFG
     select HAS_PERIPH_WDT
     select HAS_PERIPH_WDT_CB
diff --git a/cpu/nrf5x_common/Makefile.features b/cpu/nrf5x_common/Makefile.features
index 30f8cf3aa7..ae38490add 100644
--- a/cpu/nrf5x_common/Makefile.features
+++ b/cpu/nrf5x_common/Makefile.features
@@ -6,6 +6,7 @@ FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_hwrng
 FEATURES_PROVIDED += periph_temperature
 FEATURES_PROVIDED += periph_timer_periodic
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_uart_modecfg
 FEATURES_PROVIDED += periph_wdt periph_wdt_cb
 
diff --git a/cpu/riscv_common/irq_arch.c b/cpu/riscv_common/irq_arch.c
index 5b3507a84f..f17391b551 100644
--- a/cpu/riscv_common/irq_arch.c
+++ b/cpu/riscv_common/irq_arch.c
@@ -70,7 +70,7 @@ void riscv_irq_init(void)
 /**
  * @brief Global trap and interrupt handler
  */
-void handle_trap(uint32_t mcause)
+static void __attribute((used)) handle_trap(uint32_t mcause)
 {
     /*  Tell RIOT to set sched_context_switch_request instead of
      *  calling thread_yield(). */
diff --git a/cpu/sam0_common/Kconfig b/cpu/sam0_common/Kconfig
index 24942c4cdb..cb0248f79c 100644
--- a/cpu/sam0_common/Kconfig
+++ b/cpu/sam0_common/Kconfig
@@ -15,6 +15,7 @@ config CPU_COMMON_SAM0
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_I2C_RECONFIGURE
     select HAS_PERIPH_RTT_SET_COUNTER
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_SPI_RECONFIGURE
     select HAS_PERIPH_TIMER_PERIODIC
     select HAS_PERIPH_UART_MODECFG
diff --git a/cpu/sam0_common/Makefile.features b/cpu/sam0_common/Makefile.features
index 51d75bdd26..49a6e245e9 100644
--- a/cpu/sam0_common/Makefile.features
+++ b/cpu/sam0_common/Makefile.features
@@ -13,6 +13,7 @@ FEATURES_PROVIDED += periph_flashpage_rwee
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_i2c_reconfigure
 FEATURES_PROVIDED += periph_rtt_set_counter
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_spi_reconfigure
 FEATURES_PROVIDED += periph_timer_periodic # implements timer_set_periodic()
 FEATURES_PROVIDED += periph_uart_modecfg
diff --git a/cpu/sam0_common/include/periph_cpu_common.h b/cpu/sam0_common/include/periph_cpu_common.h
index ac56558cb7..08254d8224 100644
--- a/cpu/sam0_common/include/periph_cpu_common.h
+++ b/cpu/sam0_common/include/periph_cpu_common.h
@@ -178,8 +178,6 @@ typedef enum {
     UART_FLAG_NONE            = 0x0,    /**< No flags set */
     UART_FLAG_RUN_STANDBY     = 0x1,    /**< run SERCOM in standby mode */
     UART_FLAG_WAKEUP          = 0x2,    /**< wake from sleep on receive */
-    UART_FLAG_RXINV           = 0x4,    /**< invert RX signal */
-    UART_FLAG_TXINV           = 0x8,    /**< invert TX signal */
 } uart_flag_t;
 
 #ifndef DOXYGEN
diff --git a/cpu/sam0_common/periph/i2c.c b/cpu/sam0_common/periph/i2c.c
index 8d980128d4..176f9e0af6 100644
--- a/cpu/sam0_common/periph/i2c.c
+++ b/cpu/sam0_common/periph/i2c.c
@@ -262,8 +262,14 @@ int i2c_read_bytes(i2c_t dev, uint16_t addr,
         return ret;
     }
     /* Ensure all bytes has been read */
-    while ((bus(dev)->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk)
-           != BUSSTATE_IDLE) {}
+    if (flags & I2C_NOSTOP) {
+        while ((bus(dev)->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk)
+                != BUSSTATE_OWNER) {}
+    }
+    else {
+        while ((bus(dev)->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk)
+                != BUSSTATE_IDLE) {}
+    }
     /* return number of bytes sent */
     return 0;
 }
diff --git a/cpu/sam0_common/periph/rtc_rtt.c b/cpu/sam0_common/periph/rtc_rtt.c
index 407314c18c..bb0c2d6705 100644
--- a/cpu/sam0_common/periph/rtc_rtt.c
+++ b/cpu/sam0_common/periph/rtc_rtt.c
@@ -84,6 +84,7 @@ static void _wait_syncbusy(void)
     }
 }
 
+#if defined(MODULE_PERIPH_RTC) || defined(MODULE_PERIPH_RTT)
 static void _read_req(void)
 {
 #ifdef RTC_READREQ_RREQ
@@ -91,6 +92,7 @@ static void _read_req(void)
     _wait_syncbusy();
 #endif
 }
+#endif
 
 static void _poweron(void)
 {
@@ -111,6 +113,7 @@ static bool _power_is_on(void)
 #endif
 }
 
+__attribute__((unused))
 static void _poweroff(void)
 {
 #ifdef MCLK
@@ -142,6 +145,7 @@ static inline void _rtt_reset(void)
 }
 
 #ifdef CPU_COMMON_SAMD21
+#ifdef MODULE_PERIPH_RTC
 static void _rtc_clock_setup(void)
 {
     /* Use 1024 Hz GCLK */
@@ -150,7 +154,9 @@ static void _rtc_clock_setup(void)
                       | GCLK_CLKCTRL_ID_RTC;
     while (GCLK->STATUS.bit.SYNCBUSY) {}
 }
+#endif /* MODULE_PERIPH_RTC */
 
+#ifdef MODULE_PERIPH_RTT
 static void _rtt_clock_setup(void)
 {
     /* Use 32 kHz GCLK */
@@ -159,9 +165,11 @@ static void _rtt_clock_setup(void)
                       | GCLK_CLKCTRL_ID_RTC;
     while (GCLK->STATUS.bit.SYNCBUSY) {}
 }
+#endif /* MODULE_PERIPH_RTT */
 
 #else /* CPU_COMMON_SAMD21 - Clock Setup */
 
+#ifdef MODULE_PERIPH_RTC
 static void _rtc_clock_setup(void)
 {
     /* RTC source clock is external oscillator at 1kHz */
@@ -182,7 +190,9 @@ static void _rtc_clock_setup(void)
 #error "No clock source for RTC selected. "
 #endif
 }
+#endif /* MODULE_PERIPH_RTC */
 
+#if defined(MODULE_PERIPH_RTT) || RTC_NUM_OF_TAMPERS
 static void _rtt_clock_setup(void)
 {
     /* RTC source clock is external oscillator at 32kHz */
@@ -202,8 +212,10 @@ static void _rtt_clock_setup(void)
 #error "No clock source for RTT selected. "
 #endif
 }
+#endif /* MODULE_PERIPH_RTT */
 #endif /* !CPU_COMMON_SAMD21 - Clock Setup */
 
+#ifdef MODULE_PERIPH_RTC
 static void _rtc_init(void)
 {
 #ifdef REG_RTC_MODE2_CTRLA
@@ -251,7 +263,9 @@ void rtc_init(void)
 
     NVIC_EnableIRQ(RTC_IRQn);
 }
+#endif /* MODULE_PERIPH_RTC */
 
+#ifdef MODULE_PERIPH_RTT
 void rtt_init(void)
 {
     _rtt_clock_setup();
@@ -277,6 +291,7 @@ void rtt_init(void)
 
     NVIC_EnableIRQ(RTC_IRQn);
 }
+#endif /* MODULE_PERIPH_RTT */
 
 #if RTC_NUM_OF_TAMPERS
 
@@ -406,43 +421,7 @@ uint8_t rtc_tamper_pin_mask(gpio_t pin)
 }
 #endif /* RTC_NUM_OF_TAMPERS */
 
-void rtt_set_overflow_cb(rtt_cb_t cb, void *arg)
-{
-    /* clear overflow cb to avoid race while assigning */
-    rtt_clear_overflow_cb();
-
-    /* set callback variables */
-    overflow_cb.cb  = cb;
-    overflow_cb.arg = arg;
-
-    /* enable overflow interrupt */
-    RTC->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_OVF;
-}
-void rtt_clear_overflow_cb(void)
-{
-    /* disable overflow interrupt */
-    RTC->MODE0.INTENCLR.reg = RTC_MODE0_INTENCLR_OVF;
-}
-
-uint32_t rtt_get_counter(void)
-{
-    _wait_syncbusy();
-    _read_req();
-    return RTC->MODE0.COUNT.reg;
-}
-
-void rtt_set_counter(uint32_t count)
-{
-    RTC->MODE0.COUNT.reg = count;
-    _wait_syncbusy();
-}
-
-uint32_t rtt_get_alarm(void)
-{
-    _wait_syncbusy();
-    return RTC->MODE0.COMP[0].reg;
-}
-
+#ifdef MODULE_PERIPH_RTC
 int rtc_get_alarm(struct tm *time)
 {
     RTC_MODE2_ALARM_Type alarm;
@@ -545,6 +524,61 @@ int rtc_set_time(struct tm *time)
     return 0;
 }
 
+void rtc_clear_alarm(void)
+{
+    /* disable alarm interrupt */
+    RTC->MODE2.INTENCLR.reg = RTC_MODE2_INTENCLR_ALARM0;
+}
+
+void rtc_poweron(void)
+{
+    _poweron();
+}
+
+void rtc_poweroff(void)
+{
+    _poweroff();
+}
+#endif /* MODULE_PERIPH_RTC */
+
+#ifdef MODULE_PERIPH_RTT
+void rtt_set_overflow_cb(rtt_cb_t cb, void *arg)
+{
+    /* clear overflow cb to avoid race while assigning */
+    rtt_clear_overflow_cb();
+
+    /* set callback variables */
+    overflow_cb.cb  = cb;
+    overflow_cb.arg = arg;
+
+    /* enable overflow interrupt */
+    RTC->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_OVF;
+}
+void rtt_clear_overflow_cb(void)
+{
+    /* disable overflow interrupt */
+    RTC->MODE0.INTENCLR.reg = RTC_MODE0_INTENCLR_OVF;
+}
+
+uint32_t rtt_get_counter(void)
+{
+    _wait_syncbusy();
+    _read_req();
+    return RTC->MODE0.COUNT.reg;
+}
+
+void rtt_set_counter(uint32_t count)
+{
+    RTC->MODE0.COUNT.reg = count;
+    _wait_syncbusy();
+}
+
+uint32_t rtt_get_alarm(void)
+{
+    _wait_syncbusy();
+    return RTC->MODE0.COMP[0].reg;
+}
+
 void rtt_set_alarm(uint32_t alarm, rtt_cb_t cb, void *arg)
 {
     /* disable interrupt to avoid race */
@@ -563,37 +597,22 @@ void rtt_set_alarm(uint32_t alarm, rtt_cb_t cb, void *arg)
     RTC->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
 }
 
-void rtc_clear_alarm(void)
-{
-    /* disable alarm interrupt */
-    RTC->MODE2.INTENCLR.reg = RTC_MODE2_INTENCLR_ALARM0;
-}
-
 void rtt_clear_alarm(void)
 {
     /* disable compare interrupt */
     RTC->MODE0.INTENCLR.reg = RTC_MODE0_INTENCLR_CMP0;
 }
 
-void rtc_poweron(void)
-{
-    _poweron();
-}
-
 void rtt_poweron(void)
 {
     _poweron();
 }
 
-void rtc_poweroff(void)
-{
-    _poweroff();
-}
-
 void rtt_poweroff(void)
 {
     _poweroff();
 }
+#endif /* MODULE_PERIPH_RTT */
 
 static void _isr_rtc(void)
 {
diff --git a/cpu/sam0_common/periph/uart.c b/cpu/sam0_common/periph/uart.c
index 48ddeb9dc6..658e47c158 100644
--- a/cpu/sam0_common/periph/uart.c
+++ b/cpu/sam0_common/periph/uart.c
@@ -190,18 +190,6 @@ int uart_init(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_cb, void *arg)
     if (uart_config[uart].flags & UART_FLAG_RUN_STANDBY) {
         dev(uart)->CTRLA.reg |= SERCOM_USART_CTRLA_RUNSTDBY;
     }
-#ifdef SERCOM_USART_CTRLA_RXINV
-    /* COM100-61: The TXINV and RXINV bits in the CTRLA register have inverted functionality. */
-    if (uart_config[uart].flags & UART_FLAG_TXINV) {
-        dev(uart)->CTRLA.reg |= SERCOM_USART_CTRLA_RXINV;
-    }
-#endif
-#ifdef SERCOM_USART_CTRLA_TXINV
-    /* COM100-61: The TXINV and RXINV bits in the CTRLA register have inverted functionality. */
-    if (uart_config[uart].flags & UART_FLAG_RXINV) {
-        dev(uart)->CTRLA.reg |= SERCOM_USART_CTRLA_TXINV;
-    }
-#endif
 
     /* calculate and set baudrate */
     _set_baud(uart, baudrate);
diff --git a/cpu/sam0_common/sam0_eth/eth-netdev.c b/cpu/sam0_common/sam0_eth/eth-netdev.c
index a84db83996..37a20dc42f 100644
--- a/cpu/sam0_common/sam0_eth/eth-netdev.c
+++ b/cpu/sam0_common/sam0_eth/eth-netdev.c
@@ -151,7 +151,7 @@ void isr_gmac(void)
     tsr = GMAC->TSR.reg;
     rsr = GMAC->RSR.reg;
 
-    if (rsr == GMAC_RSR_REC) {
+    if (rsr & GMAC_RSR_REC) {
         netdev_trigger_event_isr(_sam0_eth_dev.netdev);
     }
 
diff --git a/cpu/saml21/cpu.c b/cpu/saml21/cpu.c
index bf407e9176..f4b53bf6b7 100644
--- a/cpu/saml21/cpu.c
+++ b/cpu/saml21/cpu.c
@@ -37,8 +37,10 @@
 
 #if (CLOCK_CORECLOCK == 48000000U) || defined (MODULE_PERIPH_USBDEV)
 #define USE_DFLL        (1)
+#define GCLK_GENCTRL_SRC_MAIN GCLK_GENCTRL_SRC_DFLL48M
 #else
 #define USE_DFLL        (0)
+#define GCLK_GENCTRL_SRC_MAIN GCLK_GENCTRL_SRC_OSC16M
 #endif
 
 static void _gclk_setup(int gclk, uint32_t reg)
@@ -99,8 +101,12 @@ uint32_t sam0_gclk_freq(uint8_t id)
     switch (id) {
     case SAM0_GCLK_MAIN:
         return CLOCK_CORECLOCK;
-    case SAM0_GCLK_8MHZ:
+    case SAM0_GCLK_TIMER:
+#if (CLOCK_CORECLOCK == 48000000U) || (CLOCK_CORECLOCK == 16000000U) || (CLOCK_CORECLOCK == 8000000U)
         return 8000000;
+#else
+        return 4000000;
+#endif
     case SAM0_GCLK_32KHZ:
         return 32768;
     case SAM0_GCLK_48MHZ:
@@ -244,11 +250,24 @@ void cpu_init(void)
     while (GCLK->CTRLA.reg & GCLK_CTRLA_SWRST) {}
     while (GCLK->SYNCBUSY.reg & GCLK_SYNCBUSY_SWRST) {}
 
+#if (CLOCK_CORECLOCK > 12000000U)
     PM->PLCFG.reg = PM_PLCFG_PLSEL_PL2;
     while (!PM->INTFLAG.bit.PLRDY) {}
+#endif
+
+    /* set OSC16M according to CLOCK_CORECLOCK */
+#if (CLOCK_CORECLOCK == 48000000U) || (CLOCK_CORECLOCK == 16000000U)
+    OSCCTRL->OSC16MCTRL.bit.FSEL = OSCCTRL_OSC16MCTRL_FSEL_16_Val;
+#elif (CLOCK_CORECLOCK == 12000000U)
+    OSCCTRL->OSC16MCTRL.bit.FSEL = OSCCTRL_OSC16MCTRL_FSEL_12_Val;
+#elif (CLOCK_CORECLOCK == 8000000U)
+    OSCCTRL->OSC16MCTRL.bit.FSEL = OSCCTRL_OSC16MCTRL_FSEL_8_Val;
+#elif (CLOCK_CORECLOCK == 4000000U)
+    OSCCTRL->OSC16MCTRL.bit.FSEL = OSCCTRL_OSC16MCTRL_FSEL_4_Val;
+#else
+#error "Please select a valid CPU frequency"
+#endif
 
-    /* set OSC16M to 16MHz */
-    OSCCTRL->OSC16MCTRL.bit.FSEL = 3;
     OSCCTRL->OSC16MCTRL.bit.ONDEMAND = 1;
     OSCCTRL->OSC16MCTRL.bit.RUNSTDBY = 0;
 
@@ -264,13 +283,7 @@ void cpu_init(void)
     _dfll_setup();
 
     /* Setup GCLK generators */
-#if (CLOCK_CORECLOCK == 16000000U)
-    _gclk_setup(SAM0_GCLK_MAIN, GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_OSC16M);
-#elif (CLOCK_CORECLOCK == 48000000U)
-    _gclk_setup(SAM0_GCLK_MAIN, GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_DFLL48M);
-#else
-#error "Please select a valid CPU frequency"
-#endif
+    _gclk_setup(SAM0_GCLK_MAIN, GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_MAIN);
 
     /* Ensure APB Backup domain clock is within the 6MHZ limit, BUPDIV value
        must be a power of 2 and between 1(2^0) and 128(2^7) */
@@ -282,8 +295,8 @@ void cpu_init(void)
         }
     }
     /* clock used by timers */
-    _gclk_setup(SAM0_GCLK_8MHZ, GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_OSC16M
-                | GCLK_GENCTRL_DIV(2));
+    _gclk_setup(SAM0_GCLK_TIMER, GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_MAIN
+                | GCLK_GENCTRL_DIV(CLOCK_CORECLOCK/sam0_gclk_freq(SAM0_GCLK_TIMER)));
 
 #ifdef MODULE_PERIPH_PM
     PM->CTRLA.reg = PM_CTRLA_MASK & (~PM_CTRLA_IORET);
diff --git a/cpu/saml21/include/periph_cpu.h b/cpu/saml21/include/periph_cpu.h
index e383212ac3..9bf0dd50e6 100644
--- a/cpu/saml21/include/periph_cpu.h
+++ b/cpu/saml21/include/periph_cpu.h
@@ -44,7 +44,7 @@ extern "C" {
  */
 enum {
     SAM0_GCLK_MAIN  = 0,                 /**< Main clock */
-    SAM0_GCLK_8MHZ  = 1,                 /**< 8MHz clock */
+    SAM0_GCLK_TIMER = 1,                 /**< 4/8MHz clock for timers */
     SAM0_GCLK_32KHZ = 2,                 /**< 32 kHz clock */
     SAM0_GCLK_48MHZ = 3,                 /**< 48MHz clock */
 };
diff --git a/cpu/stm32/Kconfig b/cpu/stm32/Kconfig
index 653249abe9..8ab8c6e5f1 100644
--- a/cpu/stm32/Kconfig
+++ b/cpu/stm32/Kconfig
@@ -12,6 +12,7 @@ config CPU_STM32
     select HAS_PERIPH_GPIO
     select HAS_PERIPH_GPIO_IRQ
     select HAS_PERIPH_TIMER_PERIODIC
+    select HAS_PERIPH_RTT_OVERFLOW
     select HAS_PERIPH_UART_MODECFG
     select HAS_PERIPH_UART_NONBLOCKING
 
@@ -35,4 +36,12 @@ orsource "kconfigs/*/Kconfig"
 orsource "kconfigs/*/Kconfig.lines"
 orsource "kconfigs/*/Kconfig.models"
 
+if TEST_KCONFIG
+
+rsource "periph/Kconfig"
+rsource "stmclk/Kconfig"
+rsource "vectors/Kconfig"
+
+endif # TEST_KCONFIG
+
 source "$(RIOTCPU)/cortexm_common/Kconfig"
diff --git a/cpu/stm32/Makefile.features b/cpu/stm32/Makefile.features
index ac635c9b11..030649304f 100644
--- a/cpu/stm32/Makefile.features
+++ b/cpu/stm32/Makefile.features
@@ -8,10 +8,11 @@ FEATURES_PROVIDED += cpu_stm32$(CPU_FAM)
 FEATURES_PROVIDED += periph_cpuid
 FEATURES_PROVIDED += periph_gpio periph_gpio_irq
 FEATURES_PROVIDED += periph_timer_periodic
+FEATURES_PROVIDED += periph_rtt_overflow
 FEATURES_PROVIDED += periph_uart_modecfg
 FEATURES_PROVIDED += periph_uart_nonblocking
 
-ifneq (,$(filter $(CPU_FAM),f0 f1 f3 g0 g4 l0 l1 l4 l5 wb))
+ifneq (,$(filter $(CPU_FAM),f0 f1 f3 g0 g4 l0 l1 l4 l5 wb wl))
   FEATURES_PROVIDED += periph_flashpage
   FEATURES_PROVIDED += periph_flashpage_pagewise
 endif
@@ -50,4 +51,11 @@ ifneq (,$(filter $(CPU_MODEL),$(STM32_WITH_MPU)))
   FEATURES_PROVIDED += cortexm_mpu
 endif
 
+# Add stm32 configs after including cortexm_common so stm32 takes precendence
+# This configuration enables modules that are only available when using Kconfig
+# module modelling
+ifeq (1, $(TEST_KCONFIG))
+  KCONFIG_ADD_CONFIG += $(RIOTCPU)/stm32/stm32.config
+endif
+
 include $(RIOTCPU)/cortexm_common/Makefile.features
diff --git a/cpu/stm32/Makefile.include b/cpu/stm32/Makefile.include
index 613edb9633..7259e63ba2 100644
--- a/cpu/stm32/Makefile.include
+++ b/cpu/stm32/Makefile.include
@@ -12,7 +12,7 @@ KB := 1024
 ROM_LEN_K := $(shell echo $(ROM_LEN) | sed 's/K//')
 RAM_LEN_K := $(shell echo $(RAM_LEN) | sed 's/K//')
 
-ifeq (stm32wb55rg,$(CPU_MODEL))
+ifneq (,$(filter w%,$(CPU_FAM)))
   # adjust RAM_LEN and ROM_LEN according to CPU2 RAM_LEN and ROM_LEN
   CPU2_RAM_LEN_K := $(shell echo $(CPU2_RAM_LEN) | sed 's/K//')
   RAM_LEN := $(shell echo $$(( ($(RAM_LEN_K) - $(CPU2_RAM_LEN_K) ) * $(KB) )))
diff --git a/cpu/stm32/cpu_common.c b/cpu/stm32/cpu_common.c
index a42207d6ca..0e85de875c 100644
--- a/cpu/stm32/cpu_common.c
+++ b/cpu/stm32/cpu_common.c
@@ -68,7 +68,8 @@ void periph_clk_en(bus_t bus, uint32_t mask)
     switch (bus) {
         case APB1:
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
             RCC->APB1ENR1 |= mask;
 #elif defined(CPU_FAM_STM32G0)
             RCC->APBENR1 |= mask;
@@ -87,8 +88,14 @@ void periph_clk_en(bus_t bus, uint32_t mask)
 #endif
             break;
 #endif
+#if defined(CPU_FAM_STM32WL)
+        case APB3:
+            RCC->APB3ENR |= mask;
+            break;
+#endif
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
         case APB12:
             RCC->APB1ENR2 |= mask;
             break;
@@ -112,7 +119,7 @@ void periph_clk_en(bus_t bus, uint32_t mask)
 #elif defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
       defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32F7) || \
       defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-      defined(CPU_FAM_STM32L5)
+      defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
         case AHB1:
             RCC->AHB1ENR |= mask;
             break;
@@ -144,7 +151,8 @@ void periph_clk_dis(bus_t bus, uint32_t mask)
     switch (bus) {
         case APB1:
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
             RCC->APB1ENR1 &= ~(mask);
 #elif defined(CPU_FAM_STM32G0)
             RCC->APBENR1 &= ~(mask);
@@ -165,7 +173,8 @@ void periph_clk_dis(bus_t bus, uint32_t mask)
             break;
 #endif
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
         case APB12:
             RCC->APB1ENR2 &= ~(mask);
             break;
@@ -189,7 +198,7 @@ void periph_clk_dis(bus_t bus, uint32_t mask)
 #elif defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
       defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32F7) || \
       defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-      defined(CPU_FAM_STM32L5)
+      defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
         case AHB1:
             RCC->AHB1ENR &= ~(mask);
             break;
diff --git a/cpu/stm32/cpu_init.c b/cpu/stm32/cpu_init.c
index 7e1ae66947..b94613888a 100644
--- a/cpu/stm32/cpu_init.c
+++ b/cpu/stm32/cpu_init.c
@@ -63,6 +63,10 @@
 #define GPIO_CLK              (AHB)
 #define GPIO_CLK_ENR          (RCC->AHBENR)
 #define GPIO_CLK_ENR_MASK     (0xFFFF0000)
+#elif defined(CPU_FAM_STM32WL)
+#define GPIO_CLK              (AHB2)
+#define GPIO_CLK_ENR          (RCC->AHB2ENR)
+#define GPIO_CLK_ENR_MASK     (0x00000087)
 #elif defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
       defined(CPU_FAM_STM32F7)
 #define GPIO_CLK              (AHB1)
@@ -152,7 +156,8 @@ void cpu_init(void)
     /* initialize the Cortex-M core */
     cortexm_init();
     /* enable PWR module */
-#if !defined(CPU_FAM_STM32WB) && !defined(CPU_FAM_STM32MP1)
+#if !defined(CPU_FAM_STM32WB) && !defined(CPU_FAM_STM32MP1) &&  \
+    !defined(CPU_FAM_STM32WL)
     periph_clk_en(APB1, BIT_APB_PWREN);
 #endif
 #if defined(CPU_FAM_STM32F0) || defined(CPU_FAM_STM32F1) || \
diff --git a/cpu/stm32/dist/irqs/gen_irqs.py b/cpu/stm32/dist/irqs/gen_irqs.py
index 8192ea662b..7a8e45881a 100755
--- a/cpu/stm32/dist/irqs/gen_irqs.py
+++ b/cpu/stm32/dist/irqs/gen_irqs.py
@@ -58,7 +58,7 @@ def list_cpu_lines(cpu_fam):
         headers.remove("partition_stm32l5xx.h")
     headers.remove("stm32{}xx.h".format(cpu_fam))
     headers.remove("system_stm32{}xx.h".format(cpu_fam))
-    return [header.split(".")[0] for header in headers]
+    return sorted([header.split(".")[0] for header in headers])
 
 
 def irq_numof(cpu_fam, cpu_line):
@@ -86,7 +86,8 @@ def irq_numof(cpu_fam, cpu_line):
         ):
             continue
         # Stop at the end of the IRQn_Type enum definition
-        if "IRQn_Type" in line:
+        if "IRQn_Type" in line \
+                and "#else" not in cmsis_content[line_idx + 1].decode():
             break
 
     # Ensure we are on a valid line, otherwise search in earlier lines
diff --git a/cpu/stm32/dist/irqs/gen_vectors.py b/cpu/stm32/dist/irqs/gen_vectors.py
index 537920916a..cff84b4c40 100755
--- a/cpu/stm32/dist/irqs/gen_vectors.py
+++ b/cpu/stm32/dist/irqs/gen_vectors.py
@@ -75,6 +75,7 @@ def parse_cmsis(cpu_line):
             continue
         # start filling lines after interrupt Doxygen comment
         if "typedef enum" in line:
+            irq_lines = []  # Cleanup any previous content
             use_line = True
 
         # use a regexp to get the available IRQs
diff --git a/cpu/stm32/dist/kconfig/Kconfig.lines.j2 b/cpu/stm32/dist/kconfig/Kconfig.lines.j2
index faf09d5208..2a1dbb3f30 100644
--- a/cpu/stm32/dist/kconfig/Kconfig.lines.j2
+++ b/cpu/stm32/dist/kconfig/Kconfig.lines.j2
@@ -1,4 +1,4 @@
-# Copyright (c) 2020 Inria
+# Copyright (c) {{ year }} Inria
 #
 # This file is subject to the terms and conditions of the GNU Lesser
 # General Public License v2.1. See the file LICENSE in the top level
diff --git a/cpu/stm32/dist/kconfig/Kconfig.models.j2 b/cpu/stm32/dist/kconfig/Kconfig.models.j2
index 321f655bc4..fa2665bda5 100644
--- a/cpu/stm32/dist/kconfig/Kconfig.models.j2
+++ b/cpu/stm32/dist/kconfig/Kconfig.models.j2
@@ -1,4 +1,4 @@
-# Copyright (c) 2020 Inria
+# Copyright (c) {{ year }} Inria
 #
 # This file is subject to the terms and conditions of the GNU Lesser
 # General Public License v2.1. See the file LICENSE in the top level
diff --git a/cpu/stm32/dist/kconfig/gen_kconfig.py b/cpu/stm32/dist/kconfig/gen_kconfig.py
index 8780ca5cce..8fef1a471b 100755
--- a/cpu/stm32/dist/kconfig/gen_kconfig.py
+++ b/cpu/stm32/dist/kconfig/gen_kconfig.py
@@ -8,8 +8,10 @@
 
 import os
 import argparse
+import datetime
+import warnings
 
-import xlrd
+from openpyxl import load_workbook
 from jinja2 import FileSystemLoader, Environment
 
 
@@ -18,22 +20,26 @@ RIOTBASE = os.getenv(
     "RIOTBASE", os.path.abspath(os.path.join(CURRENT_DIR, "../../../..")))
 STM32_KCONFIG_DIR = os.path.join(RIOTBASE, "cpu/stm32/kconfigs")
 STM32_VENDOR_DIR = os.path.join(RIOTBASE, "cpu/stm32/include/vendor/cmsis")
+MODEL_COLUMN = 1
 
 
 def parse_sheet(cpu_fam, sheets):
     """Parse the Excel sheet and return a dict."""
     models = []
     for sheet in sheets:
-        # Load the content of the xlsx sheet
-        work_book = xlrd.open_workbook(sheet)
-        sheet = work_book.sheet_by_name('ProductsList')
+        # filter warning raised by openpyxl
+        with warnings.catch_warnings(record=True):
+            warnings.simplefilter("always")
+            # Load the content of the xlsx sheet
+            sheet = load_workbook(filename=sheet, data_only=True).active
 
         # Extract models from sheet
-        for rownum in range(sheet.nrows):
-            row = sheet.row_values(rownum)
-            if not row[0].startswith("STM32"):
+        for idx, row in enumerate(sheet.rows):
+            # Row index starts at 1
+            model = str(sheet.cell(row=idx + 1, column=MODEL_COLUMN).value)
+            if not model.startswith("STM32"):
                 continue
-            models.append(row[0].replace("-", "_"))
+            models.append(model.replace("-", "_"))
     return sorted(models)
 
 
@@ -110,6 +116,7 @@ def generate_kconfig(kconfig, context, overwrite, verbose):
     template_file = os.path.join("Kconfig.{}.j2".format(kconfig))
     env.globals.update(zip=zip)
     template = env.get_template(template_file)
+    context.update({"year": datetime.datetime.now().year})
     render = template.render(**context)
 
     kconfig_dir = os.path.join(STM32_KCONFIG_DIR, context["fam"])
diff --git a/cpu/stm32/dist/kconfig/requirements.txt b/cpu/stm32/dist/kconfig/requirements.txt
index 35ec90e4f7..fd02b050ae 100644
--- a/cpu/stm32/dist/kconfig/requirements.txt
+++ b/cpu/stm32/dist/kconfig/requirements.txt
@@ -1,2 +1,2 @@
-xlrd
+openpyxl
 jinja2
diff --git a/cpu/stm32/include/clk/cfg_clock_common_lx_wb.h b/cpu/stm32/include/clk/cfg_clock_common_lx_wx.h
similarity index 91%
rename from cpu/stm32/include/clk/cfg_clock_common_lx_wb.h
rename to cpu/stm32/include/clk/cfg_clock_common_lx_wx.h
index 72533e3e83..a100cfb3f4 100644
--- a/cpu/stm32/include/clk/cfg_clock_common_lx_wb.h
+++ b/cpu/stm32/include/clk/cfg_clock_common_lx_wx.h
@@ -13,22 +13,22 @@
  * @{
  *
  * @file
- * @brief       Base STM32Lx/WB clock configuration
+ * @brief       Base STM32Lx/Wx clock configuration
  *
  * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>
  * @author      Vincent Dupont <vincent@otakeys.com>
  * @author      Alexandre Abadie <alexandre.abadie@inria.fr>
  */
 
-#ifndef CLK_CFG_CLOCK_COMMON_LX_WB_H
-#define CLK_CFG_CLOCK_COMMON_LX_WB_H
+#ifndef CLK_CFG_CLOCK_COMMON_LX_WX_H
+#define CLK_CFG_CLOCK_COMMON_LX_WX_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /**
- * @name    Clock system configuration (L0/L1/L4/L5/WB)
+ * @name    Clock system configuration (L0/L1/L4/L5/WB/WL)
  * @{
  */
 /* Select the desired system clock source between PLL, HSE or HSI */
@@ -87,5 +87,5 @@ extern "C" {
 }
 #endif
 
-#endif /* CLK_CFG_CLOCK_COMMON_LX_WB_H */
+#endif /* CLK_CFG_CLOCK_COMMON_LX_WX_H */
 /** @} */
diff --git a/cpu/stm32/include/clk/clk_conf.h b/cpu/stm32/include/clk/clk_conf.h
index 0056d47869..28160d2fc6 100644
--- a/cpu/stm32/include/clk/clk_conf.h
+++ b/cpu/stm32/include/clk/clk_conf.h
@@ -30,7 +30,7 @@
 #include "cfg_clock_common_fx_gx_mp1.h"
 #else /* CPU_FAM_STM32L0 || CPU_FAM_STM32L1 || CPU_FAM_STM32L4 ||
        * CPU_FAM_STM32L5 || CPU_FAM_STM32WB */
-#include "cfg_clock_common_lx_wb.h"
+#include "cfg_clock_common_lx_wx.h"
 #endif
 
 #if defined(CPU_FAM_STM32F0) || defined(CPU_FAM_STM32F1) || \
@@ -44,8 +44,8 @@
 #elif defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32L1)
 #include "l0l1/cfg_clock_default.h"
 #elif defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32L5) || \
-      defined(CPU_FAM_STM32WB)
-#include "l4l5wb/cfg_clock_default.h"
+      defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
+#include "l4l5wx/cfg_clock_default.h"
 #elif defined(CPU_FAM_STM32MP1)
 #include "mp1/cfg_clock_default.h"
 #else
diff --git a/cpu/stm32/include/clk/l4l5wb/cfg_clock_default.h b/cpu/stm32/include/clk/l4l5wx/cfg_clock_default.h
similarity index 88%
rename from cpu/stm32/include/clk/l4l5wb/cfg_clock_default.h
rename to cpu/stm32/include/clk/l4l5wx/cfg_clock_default.h
index 22bbb95f2d..b8652f3d4c 100644
--- a/cpu/stm32/include/clk/l4l5wb/cfg_clock_default.h
+++ b/cpu/stm32/include/clk/l4l5wx/cfg_clock_default.h
@@ -18,8 +18,8 @@
  * @author      Alexandre Abadie <alexandre.abadie@inria.fr>
  */
 
-#ifndef CLK_L4L5WB_CFG_CLOCK_DEFAULT_H
-#define CLK_L4L5WB_CFG_CLOCK_DEFAULT_H
+#ifndef CLK_L4L5WX_CFG_CLOCK_DEFAULT_H
+#define CLK_L4L5WX_CFG_CLOCK_DEFAULT_H
 
 #ifdef __cplusplus
 extern "C" {
@@ -73,7 +73,13 @@ extern "C" {
 #endif
 #ifndef CONFIG_CLOCK_PLL_N
 #if IS_ACTIVE(CONFIG_CLOCK_PLL_SRC_HSE) && (CLOCK_HSE == MHZ(32))
+/* For STM32WL, VCO output frequency ((PLL input clock frequency / PLLM ) x PLLN )
+   must be between 96 and 344 MHz. PLLN can have values <=127 & >=6 */
+#if IS_ACTIVE(CPU_FAM_STM32WL)
+#define CONFIG_CLOCK_PLL_N              (12)
+#else
 #define CONFIG_CLOCK_PLL_N              (16)
+#endif /* CPU_FAM_STM32WL */
 #elif IS_ACTIVE(CONFIG_CLOCK_PLL_SRC_HSI) || \
       (IS_ACTIVE(CONFIG_CLOCK_PLL_SRC_HSE) && (CLOCK_HSE == MHZ(16)))
 #define CONFIG_CLOCK_PLL_N              (32)
@@ -126,7 +132,9 @@ extern "C" {
         ((CLOCK_PLL_SRC / CONFIG_CLOCK_PLL_M) * CONFIG_CLOCK_PLL_N) / CONFIG_CLOCK_PLL_R
 
 /* Set max allowed sysclk */
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WL)
+#define CLOCK_CORECLOCK_MAX             MHZ(48)
+#elif defined(CPU_FAM_STM32WB)
 #define CLOCK_CORECLOCK_MAX             MHZ(64)
 #elif defined(CPU_FAM_STM32L5)
 #define CLOCK_CORECLOCK_MAX             MHZ(110)
@@ -141,7 +149,9 @@ extern "C" {
 #endif
 
 #if CLOCK_CORECLOCK > CLOCK_CORECLOCK_MAX
-#if CLOCK_CORECLOCK_MAX == MHZ(64)
+#if CLOCK_CORECLOCK_MAX == MHZ(48)
+#error "SYSCLK cannot exceed 48MHz"
+#elif CLOCK_CORECLOCK_MAX == MHZ(64)
 #error "SYSCLK cannot exceed 64MHz"
 #elif CLOCK_CORECLOCK_MAX == MHZ(80)
 #error "SYSCLK cannot exceed 80MHz"
@@ -155,20 +165,20 @@ extern "C" {
 #endif /* CLOCK_CORECLOCK > CLOCK_CORECLOCK_MAX */
 #endif /* CONFIG_USE_CLOCK_PLL */
 
-#define CLOCK_AHB                       CLOCK_CORECLOCK /* HCLK, max: 64/80/120MHz */
+#define CLOCK_AHB                       CLOCK_CORECLOCK /* HCLK, max: 48/64/80/120MHz */
 
 #ifndef CONFIG_CLOCK_APB1_DIV
 #define CONFIG_CLOCK_APB1_DIV           (4)
 #endif
-#define CLOCK_APB1                      (CLOCK_AHB / CONFIG_CLOCK_APB1_DIV)     /* PCLK1, max: 64/80/120MHz */
+#define CLOCK_APB1                      (CLOCK_AHB / CONFIG_CLOCK_APB1_DIV)     /* PCLK1, max: 48/64/80/120MHz */
 #ifndef CONFIG_CLOCK_APB2_DIV
 #define CONFIG_CLOCK_APB2_DIV           (2)
 #endif
-#define CLOCK_APB2                      (CLOCK_AHB / CONFIG_CLOCK_APB2_DIV)     /* PCLK1, max: 64/80/120MHz */
+#define CLOCK_APB2                      (CLOCK_AHB / CONFIG_CLOCK_APB2_DIV)     /* PCLK1, max: 48/64/80/120MHz */
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* CLK_L4L5WB_CFG_CLOCK_DEFAULT_H */
+#endif /* CLK_L4L5WX_CFG_CLOCK_DEFAULT_H */
 /** @} */
diff --git a/cpu/stm32/include/cpu_conf.h b/cpu/stm32/include/cpu_conf.h
index d83500e7d5..34e9137776 100644
--- a/cpu/stm32/include/cpu_conf.h
+++ b/cpu/stm32/include/cpu_conf.h
@@ -67,6 +67,9 @@
 #elif CPU_FAM_STM32WB
 #include "stm32wbxx.h"
 #include "irqs/wb/irqs.h"
+#elif CPU_FAM_STM32WL
+#include "stm32wlxx.h"
+#include "irqs/wl/irqs.h"
 #else
 #error Not supported CPU family
 #endif
@@ -103,7 +106,7 @@ extern "C" {
    || defined(CPU_LINE_STM32F030xC) || defined(CPU_LINE_STM32F103xE) \
    || defined(CPU_FAM_STM32F3) || defined(CPU_FAM_STM32L4) \
    || defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) \
-   || defined(CPU_FAM_STM32L5)
+   || defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define FLASHPAGE_SIZE                  (2048U)
 #elif defined(CPU_LINE_STM32F051x8) || defined(CPU_LINE_STM32F042x6) \
    || defined(CPU_LINE_STM32F070xB) || defined(CPU_LINE_STM32F030x8) \
@@ -127,6 +130,7 @@ extern "C" {
 #if defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
     defined(CPU_FAM_STM32F7)
 #define PERIPH_FLASHPAGE_CUSTOM_PAGESIZES
+#define PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_ADDR
 
 /**
  * @brief stm32 dual bank configuration
@@ -192,7 +196,7 @@ extern "C" {
  */
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define FLASHPAGE_WRITE_BLOCK_SIZE            (8U)
 typedef uint64_t stm32_flashpage_block_t;
 #elif defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32L1) || \
@@ -207,7 +211,7 @@ typedef uint16_t stm32_flashpage_block_t;
 
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define FLASHPAGE_WRITE_BLOCK_ALIGNMENT       (8U)
 #else
 /* Writing should be always 4 bytes aligned */
diff --git a/cpu/stm32/include/cpu_conf_stm32_common.h b/cpu/stm32/include/cpu_conf_stm32_common.h
index 37b2917ccf..60ad25940f 100644
--- a/cpu/stm32/include/cpu_conf_stm32_common.h
+++ b/cpu/stm32/include/cpu_conf_stm32_common.h
@@ -31,7 +31,8 @@ extern "C" {
     defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32L0) || \
     defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32L4) || \
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-    defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
 
 /**
  * @brief   Timing register settings
@@ -42,7 +43,7 @@ static const i2c_timing_param_t timing_params[] = {
 #if defined(CPU_FAM_STM32F0) || defined(CPU_FAM_STM32F7) || \
     defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPI_FAM_STM32WL)
     [ I2C_SPEED_NORMAL ]    = {
         .presc  = 0xB,
         .scll   = 0x13,     /* t_SCLL   = 5.0us  */
diff --git a/cpu/stm32/include/periph/wl/periph_cpu.h b/cpu/stm32/include/periph/wl/periph_cpu.h
new file mode 100644
index 0000000000..c3ae86de89
--- /dev/null
+++ b/cpu/stm32/include/periph/wl/periph_cpu.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup         cpu_stm32
+ * @{
+ *
+ * @file
+ * @brief           STM32WL CPU specific definitions for internal peripheral handling
+ *
+ * @author          Akshai M <akshai.m@fu-berlin.de>
+ *
+ */
+
+#ifndef PERIPH_WL_PERIPH_CPU_H
+#define PERIPH_WL_PERIPH_CPU_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef DOXYGEN
+
+/**
+ * @brief   Starting address of the ROM bootloader
+ *          see application note AN2606 ( Table 143 : System memory)
+ */
+#define STM32_BOOTLOADER_ADDR   (0x1FFF0000)
+
+#endif /* ndef DOXYGEN */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PERIPH_WL_PERIPH_CPU_H */
+/** @} */
diff --git a/cpu/stm32/include/periph_cpu.h b/cpu/stm32/include/periph_cpu.h
index 325eb13f24..a3caf8be85 100644
--- a/cpu/stm32/include/periph_cpu.h
+++ b/cpu/stm32/include/periph_cpu.h
@@ -52,6 +52,8 @@
 #include "periph/l5/periph_cpu.h"
 #elif defined(CPU_FAM_STM32WB)
 #include "periph/wb/periph_cpu.h"
+#elif defined(CPU_FAM_STM32WL)
+#include "periph/wl/periph_cpu.h"
 #endif
 
 #ifdef __cplusplus
@@ -70,7 +72,7 @@ extern "C" {
       defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32L4) || \
       defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
       defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5) || \
-      defined(CPU_FAM_STM32MP1)
+      defined(CPU_FAM_STM32MP1) || defined(CPU_FAM_STM32WL)
 #define CLOCK_LSI           (32000U)
 #else
 #error "error: LSI clock speed not defined for your target CPU"
@@ -170,9 +172,12 @@ extern "C" {
 typedef enum {
     APB1,           /**< APB1 bus */
     APB2,           /**< APB2 bus */
+#if defined(CPU_FAM_STM32WL)
+    APB3,
+#endif
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
     APB12,          /**< AHB1 bus, second register */
 #endif
 #if defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32G0)
@@ -184,7 +189,7 @@ typedef enum {
 #elif defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
       defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32F7) || \
       defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-      defined(CPU_FAM_STM32L5)
+      defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
     AHB1,           /**< AHB1 bus */
     AHB2,           /**< AHB2 bus */
     AHB3,           /**< AHB3 bus */
@@ -681,7 +686,8 @@ typedef struct {
 #endif
 #if defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32L4) || \
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32MP1)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32MP1) || \
+    defined(CPU_FAM_STM32WL)
     uart_type_t type;       /**< hardware module type (USART or LPUART) */
     uint32_t clk_src;       /**< clock source used for UART */
 #endif
@@ -734,7 +740,7 @@ typedef enum {
     defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32L0) || \
     defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
     I2C_SPEED_FAST_PLUS,    /**< fast plus mode: ~1Mbit/s */
 #endif
 } i2c_speed_t;
@@ -770,7 +776,7 @@ typedef struct {
     defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32L0) || \
     defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 /**
  * @brief   Structure for I2C timing register settings
  *
diff --git a/cpu/stm32/include/vendor/Makefile b/cpu/stm32/include/vendor/Makefile
index 8690f774ef..ee011e54c4 100644
--- a/cpu/stm32/include/vendor/Makefile
+++ b/cpu/stm32/include/vendor/Makefile
@@ -16,6 +16,7 @@ PKG_VERSION_l1=4a2f3cd6ea4bbc8e36daff0c7574b0fc1dfb7df7  # v2.3.0
 PKG_VERSION_l4=e442c72651e8d4757f6562acc14da949644944ce  # v1.6.1
 PKG_VERSION_l5=d922865fc0326a102c26211c44b8e42f52c1e53d  # v1.0.3
 PKG_VERSION_wb=44490652c88a513ec9a892c328db0246cf113987  # v1.4.0
+PKG_VERSION_wl=35631ff4d3a3cc361241af5f62190d0ea43bd65b  # v1.0.0
 
 PKG_VERSION=$(PKG_VERSION_$(CPU_FAM))
 PKG_LICENSE=Apache-2
diff --git a/cpu/stm32/kconfigs/wl/Kconfig b/cpu/stm32/kconfigs/wl/Kconfig
new file mode 100644
index 0000000000..8729dbb112
--- /dev/null
+++ b/cpu/stm32/kconfigs/wl/Kconfig
@@ -0,0 +1,24 @@
+# Copyright (c) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config CPU_FAM_WL
+    bool
+    select CPU_STM32
+    select CPU_CORE_CORTEX_M4
+    select HAS_CPU_STM32WL
+    select HAS_PERIPH_FLASHPAGE
+    select HAS_PERIPH_FLASHPAGE_PAGEWISE
+    select HAS_PERIPH_WDT
+    select HAS_BOOTLOADER_STM32
+
+config CPU_FAM
+    default "wl" if CPU_FAM_WL
+
+config HAS_CPU_STM32WL
+    bool
+    help
+        Indicates that the cpu being used belongs to the 'stm32wl' family.
diff --git a/cpu/stm32/kconfigs/wl/Kconfig.lines b/cpu/stm32/kconfigs/wl/Kconfig.lines
new file mode 100644
index 0000000000..c8f60d632f
--- /dev/null
+++ b/cpu/stm32/kconfigs/wl/Kconfig.lines
@@ -0,0 +1,27 @@
+# Copyright (c) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+# This file was auto-generated from ST ProductsList.xlsx sheet using the
+# script in cpu/stm32/dist/kconfig/gen_kconfig.py
+# See cpu/stm32/dist/kconfig/README.md for details
+
+# CPU lines
+config CPU_LINE_STM32WL54XX
+    bool
+    select CPU_FAM_WL
+
+config CPU_LINE_STM32WL55XX
+    bool
+    select CPU_FAM_WL
+
+config CPU_LINE_STM32WLE4XX
+    bool
+    select CPU_FAM_WL
+
+config CPU_LINE_STM32WLE5XX
+    bool
+    select CPU_FAM_WL
diff --git a/cpu/stm32/kconfigs/wl/Kconfig.models b/cpu/stm32/kconfigs/wl/Kconfig.models
new file mode 100644
index 0000000000..113c7bf36d
--- /dev/null
+++ b/cpu/stm32/kconfigs/wl/Kconfig.models
@@ -0,0 +1,74 @@
+# Copyright (c) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+# This file was auto-generated from ST ProductsList.xlsx sheet using the
+# script in cpu/stm32/dist/kconfig/gen_kconfig.py
+# See cpu/stm32/dist/kconfig/README.md for details
+
+# CPU models
+config CPU_MODEL_STM32WL54CC
+    bool
+    select CPU_LINE_STM32WL54XX
+
+config CPU_MODEL_STM32WL54JC
+    bool
+    select CPU_LINE_STM32WL54XX
+
+config CPU_MODEL_STM32WL55CC
+    bool
+    select CPU_LINE_STM32WL55XX
+
+config CPU_MODEL_STM32WL55JC
+    bool
+    select CPU_LINE_STM32WL55XX
+
+config CPU_MODEL_STM32WLE4CC
+    bool
+    select CPU_LINE_STM32WLE4XX
+
+config CPU_MODEL_STM32WLE4JC
+    bool
+    select CPU_LINE_STM32WLE4XX
+
+config CPU_MODEL_STM32WLE5C8
+    bool
+    select CPU_LINE_STM32WLE5XX
+
+config CPU_MODEL_STM32WLE5CB
+    bool
+    select CPU_LINE_STM32WLE5XX
+
+config CPU_MODEL_STM32WLE5CC
+    bool
+    select CPU_LINE_STM32WLE5XX
+
+config CPU_MODEL_STM32WLE5J8
+    bool
+    select CPU_LINE_STM32WLE5XX
+
+config CPU_MODEL_STM32WLE5JB
+    bool
+    select CPU_LINE_STM32WLE5XX
+
+config CPU_MODEL_STM32WLE5JC
+    bool
+    select CPU_LINE_STM32WLE5XX
+
+# Configure CPU model
+config CPU_MODEL
+    default "stm32wl54cc" if CPU_MODEL_STM32WL54CC
+    default "stm32wl54jc" if CPU_MODEL_STM32WL54JC
+    default "stm32wl55cc" if CPU_MODEL_STM32WL55CC
+    default "stm32wl55jc" if CPU_MODEL_STM32WL55JC
+    default "stm32wle4cc" if CPU_MODEL_STM32WLE4CC
+    default "stm32wle4jc" if CPU_MODEL_STM32WLE4JC
+    default "stm32wle5c8" if CPU_MODEL_STM32WLE5C8
+    default "stm32wle5cb" if CPU_MODEL_STM32WLE5CB
+    default "stm32wle5cc" if CPU_MODEL_STM32WLE5CC
+    default "stm32wle5j8" if CPU_MODEL_STM32WLE5J8
+    default "stm32wle5jb" if CPU_MODEL_STM32WLE5JB
+    default "stm32wle5jc" if CPU_MODEL_STM32WLE5JC
diff --git a/cpu/stm32/periph/Kconfig b/cpu/stm32/periph/Kconfig
new file mode 100644
index 0000000000..24c613286f
--- /dev/null
+++ b/cpu/stm32/periph/Kconfig
@@ -0,0 +1,28 @@
+# Copyright (c) 2021 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config MODULE_PERIPH
+    bool
+    default y
+    select MODULE_XTIMER if MODULE_PERIPH_USBDEV
+    help
+        stm32 common peripheral code.
+
+config MODULE_PERIPH_UART_NONBLOCKING
+    depends on HAS_PERIPH_UART_NONBLOCKING
+    depends on MODULE_PERIPH_UART
+    select MODULE_TSRB
+
+config MODULE_PERIPH_CAN
+    bool
+    depends on HAS_PERIPH_CAN
+    depends on HAS_PERIPH_GPIO
+    depends on HAS_PERIPH_GPIO_IRQ
+    select MODULE_PERIPH_GPIO_IRQ
+    select MODULE_PERIPH_I2C
+    help
+        STM32 CAN peripheral controller.
diff --git a/cpu/stm32/periph/Makefile b/cpu/stm32/periph/Makefile
index 5184150cdd..83c291a1b2 100644
--- a/cpu/stm32/periph/Makefile
+++ b/cpu/stm32/periph/Makefile
@@ -2,10 +2,12 @@ MODULE = periph
 
 # Select the specific implementation for `periph_i2c`
 ifneq (,$(filter periph_i2c,$(USEMODULE)))
-  ifneq (,$(filter $(CPU_FAM),f0 f3 f7 g0 g4 l0 l4 l5 wb))
+  ifneq (,$(filter $(CPU_FAM),f0 f3 f7 g0 g4 l0 l4 l5 wb wl))
     SRC += i2c_1.c
-  else # f1/f2/f4/l1
+  else ifneq (,$(filter $(CPU_FAM),f1 f2 f4 l1))
     SRC += i2c_2.c
+  else
+    $(error STM32 series I2C implementation not found.)
   endif
 endif
 
diff --git a/cpu/stm32/periph/adc_f3.c b/cpu/stm32/periph/adc_f3.c
index 60bec03dee..87c29fdb63 100644
--- a/cpu/stm32/periph/adc_f3.c
+++ b/cpu/stm32/periph/adc_f3.c
@@ -14,7 +14,7 @@
  * @file
  * @brief       Low-level ADC driver implementation
  *
- * @author      Hugues Larrive <hugues.larrive@laas.fr>
+ * @author      Hugues Larrive <hugues.larrive@pm.me>
  *
  * @}
  */
diff --git a/cpu/stm32/periph/flash_common.c b/cpu/stm32/periph/flash_common.c
index ca6faf5748..6e5265830d 100644
--- a/cpu/stm32/periph/flash_common.c
+++ b/cpu/stm32/periph/flash_common.c
@@ -42,7 +42,7 @@
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
     defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
-    defined(CPU_FAM_STM32F7)
+    defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32WL)
 #define FLASH_KEY1             ((uint32_t)0x45670123)
 #define FLASH_KEY2             ((uint32_t)0xCDEF89AB)
 #endif
diff --git a/cpu/stm32/periph/flashpage.c b/cpu/stm32/periph/flashpage.c
index 7afa590ac0..2a56276457 100644
--- a/cpu/stm32/periph/flashpage.c
+++ b/cpu/stm32/periph/flashpage.c
@@ -110,10 +110,12 @@ static void _erase_page(void *page_addr)
 #elif defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
       defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
       defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32F2) || \
-      defined(CPU_FAM_STM32F4) || defined(CPU_FAM_STM32F7)
+      defined(CPU_FAM_STM32F4) || defined(CPU_FAM_STM32F7) || \
+      defined(CPU_FAM_STM32WL)
     DEBUG("[flashpage] erase: setting the page address\n");
     uint8_t pn;
-#if (FLASHPAGE_NUMOF <= MAX_PAGES_PER_BANK) || defined(CPU_FAM_STM32WB)
+#if (FLASHPAGE_NUMOF <= MAX_PAGES_PER_BANK) || defined(CPU_FAM_STM32WB) || \
+    defined(CPU_FAM_STM32WL)
     pn = (uint8_t)flashpage_page(page_addr);
 #else
     uint16_t page = flashpage_page(page_addr);
@@ -188,7 +190,7 @@ void flashpage_erase(unsigned page)
     assert(page < (int)FLASHPAGE_NUMOF);
 
     /* ensure there is no attempt to write to CPU2 protected area */
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
     assert(page < (int)(FLASH->SFR & FLASH_SFR_SFSA));
 #endif
 
@@ -234,6 +236,12 @@ void flashpage_write(void *target_addr, const void *data, size_t len)
     bool instruction_cache = FLASH->ACR & FLASH_ACR_ICEN;
     if (instruction_cache) {
         FLASH->ACR &= ~FLASH_ACR_ICEN;
+#if defined(CPU_FAM_STM32WL)
+        /* Reset the instruction cache after it has been disabled. This
+           operation is required as the cpu stalls after a flash write operation
+           for unknown reasons in STM32WL55JC */
+        FLASH->ACR |= FLASH_ACR_ICRST;
+#endif
     }
 #endif
 
@@ -253,7 +261,7 @@ void flashpage_write(void *target_addr, const void *data, size_t len)
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
     defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5) || \
     defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
-    defined(CPU_FAM_STM32F7)
+    defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32WL)
     /* set PG bit and program page to flash */
     CNTRL_REG |= FLASH_CR_PG;
 #endif
@@ -273,7 +281,7 @@ void flashpage_write(void *target_addr, const void *data, size_t len)
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
     defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5) || \
     defined(CPU_FAM_STM32F2) || defined(CPU_FAM_STM32F4) || \
-    defined(CPU_FAM_STM32F7)
+    defined(CPU_FAM_STM32F7) || defined(CPU_FAM_STM32WL)
     CNTRL_REG &= ~(FLASH_CR_PG);
 #endif
     DEBUG("[flashpage_raw] write: done writing data\n");
@@ -320,16 +328,6 @@ size_t flashpage_size(unsigned page)
     }
 }
 
-void *flashpage_addr(unsigned page)
-{
-    uintptr_t addr = CPU_FLASH_BASE;
-    while (page) {
-        addr += flashpage_size(--page);
-    }
-
-    return (void*)addr;
-}
-
 unsigned flashpage_page(void *addr)
 {
     /* Calculates the flashpage number based on the address for the
diff --git a/cpu/stm32/periph/gpio_all.c b/cpu/stm32/periph/gpio_all.c
index 560909e5f3..5fd33a0615 100644
--- a/cpu/stm32/periph/gpio_all.c
+++ b/cpu/stm32/periph/gpio_all.c
@@ -46,7 +46,7 @@ static gpio_isr_ctx_t isr_ctx[EXTI_NUMOF];
 
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define EXTI_REG_RTSR       (EXTI->RTSR1)
 #define EXTI_REG_FTSR       (EXTI->FTSR1)
 #define EXTI_REG_PR         (EXTI->PR1)
@@ -102,7 +102,8 @@ static inline void port_init_clock(GPIO_TypeDef *port, gpio_t pin)
 #elif defined (CPU_FAM_STM32L0) || defined(CPU_FAM_STM32G0)
     periph_clk_en(IOP, (RCC_IOPENR_GPIOAEN << _port_num(pin)));
 #elif defined (CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-      defined (CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+      defined (CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+      defined (CPU_FAM_STM32WL)
     periph_clk_en(AHB2, (RCC_AHB2ENR_GPIOAEN << _port_num(pin)));
 #ifdef PWR_CR2_IOSV
     if (port == GPIOG) {
@@ -170,7 +171,8 @@ void gpio_init_analog(gpio_t pin)
 #elif defined (CPU_FAM_STM32L0) || defined(CPU_FAM_STM32G0)
     periph_clk_en(IOP, (RCC_IOPENR_GPIOAEN << _port_num(pin)));
 #elif defined (CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-      defined (CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+      defined (CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+      defined (CPU_FAM_STM32WL)
     periph_clk_en(AHB2, (RCC_AHB2ENR_GPIOAEN << _port_num(pin)));
 #elif defined(CPU_FAM_STM32MP1)
     periph_clk_en(AHB4, (RCC_MC_AHB4ENSETR_GPIOAEN << _port_num(pin)));
@@ -236,7 +238,8 @@ int gpio_init_int(gpio_t pin, gpio_mode_t mode, gpio_flank_t flank,
     isr_ctx[pin_num].arg = arg;
 
     /* enable clock of the SYSCFG module for EXTI configuration */
-#if !defined(CPU_FAM_STM32WB) && !defined(CPU_FAM_STM32MP1)
+#if !defined(CPU_FAM_STM32WB) && !defined(CPU_FAM_STM32MP1) && \
+    !defined(CPU_FAM_STM32WL)
 #ifdef CPU_FAM_STM32F0
     periph_clk_en(APB2, RCC_APB2ENR_SYSCFGCOMPEN);
 #elif defined(CPU_FAM_STM32G0)
@@ -338,15 +341,16 @@ void isr_exti(void)
 {
 #if defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5) || \
     defined(CPU_FAM_STM32MP1)
-    /* only generate interrupts against lines which have their IMR set */
-    uint32_t pending_rising_isr = (EXTI->RPR1 & EXTI_REG_IMR & EXTI_MASK);
-    uint32_t pending_falling_isr = (EXTI->FPR1 & EXTI_REG_IMR & EXTI_MASK);
+    /* get all interrupts handled by this ISR */
+    uint32_t pending_rising_isr = (EXTI->RPR1 & EXTI_MASK);
+    uint32_t pending_falling_isr = (EXTI->FPR1 & EXTI_MASK);
 
     /* clear by writing a 1 */
     EXTI->RPR1 = pending_rising_isr;
     EXTI->FPR1 = pending_falling_isr;
 
-    uint32_t pending_isr = pending_rising_isr | pending_falling_isr;
+    /* only generate interrupts against lines which have their IMR set */
+    uint32_t pending_isr = (pending_rising_isr | pending_falling_isr) & EXTI_REG_IMR;
 #else
     /* read all pending interrupts wired to isr_exti */
     uint32_t pending_isr = (EXTI_REG_PR & EXTI_MASK);
diff --git a/cpu/stm32/periph/gpio_f1.c b/cpu/stm32/periph/gpio_f1.c
index c0bda3393d..5f75da008a 100644
--- a/cpu/stm32/periph/gpio_f1.c
+++ b/cpu/stm32/periph/gpio_f1.c
@@ -242,12 +242,15 @@ void gpio_irq_disable(gpio_t pin)
 
 void isr_exti(void)
 {
-    /* only generate interrupts against lines which have their IMR set */
-    uint32_t pending_isr = (EXTI->PR & EXTI->IMR & GPIO_ISR_CHAN_MASK);
+    /* read all pending interrupts wired to isr_exti */
+    uint32_t pending_isr = (EXTI->PR & GPIO_ISR_CHAN_MASK);
 
     /* clear by writing a 1 */
     EXTI->PR = pending_isr;
 
+    /* only generate soft interrupts against lines which have their IMR set */
+    pending_isr &= EXTI->IMR;
+
     /* iterate over all set bits */
     uint8_t pin = 0;
     while (pending_isr) {
diff --git a/cpu/stm32/periph/pm.c b/cpu/stm32/periph/pm.c
index 91e72ca45e..055c4ec102 100644
--- a/cpu/stm32/periph/pm.c
+++ b/cpu/stm32/periph/pm.c
@@ -49,7 +49,8 @@
 #elif defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32G4) || \
       defined(CPU_FAM_STM32L5)
 #define PM_STOP_CONFIG  (PWR_CR1_LPMS_STOP1)
-#elif defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G0)
+#elif defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G0) || \
+      defined(CPU_FAM_STM32WL)
 #define PM_STOP_CONFIG  (PWR_CR1_LPMS_0)
 #elif defined(CPU_FAM_STM32F7)
 #define PM_STOP_CONFIG  (PWR_CR1_LPDS | PWR_CR1_FPDS | PWR_CR1_LPUDS)
@@ -71,7 +72,8 @@
 #elif defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32G4) || \
       defined(CPU_FAM_STM32L5)
 #define PM_STANDBY_CONFIG   (PWR_CR1_LPMS_STANDBY)
-#elif defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G0)
+#elif defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G0) || \
+      defined(CPU_FAM_STM32WL)
 #define PM_STANDBY_CONFIG   (PWR_CR1_LPMS_0 | PWR_CR1_LPMS_1)
 #elif defined(CPU_FAM_STM32F7)
 #define PM_STANDBY_CONFIG   (PWR_CR1_PDDS | PWR_CR1_CSBF)
@@ -84,7 +86,7 @@
 
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
     defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define PWR_CR_REG     PWR->CR1
 #define PWR_WUP_REG    PWR->CR3
 /* Allow overridable SRAM2 retention mode using CFLAGS */
@@ -113,7 +115,8 @@ void pm_set(unsigned mode)
             PWR_CR_REG &= ~(PM_STOP_CONFIG | PM_STANDBY_CONFIG);
             PWR_CR_REG |= PM_STANDBY_CONFIG;
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || \
-    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G4) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
 #if STM32L4_SRAM2_RETENTION
             PWR->CR3 |= PWR_CR3_RRS;
 #else
diff --git a/cpu/stm32/periph/rtt_all.c b/cpu/stm32/periph/rtt_all.c
index 9e4ff785ab..5a02439634 100644
--- a/cpu/stm32/periph/rtt_all.c
+++ b/cpu/stm32/periph/rtt_all.c
@@ -15,7 +15,7 @@
  * @brief       RTT implementation using LPTIM1
  *
  * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>
- *
+ * @author      Andres Diaz    <andres.diaz@andeselectronics.cl>
  * @}
  */
 
@@ -59,6 +59,14 @@
 #else
 #define CLOCK_SRC_CFG       (RCC_DCKCFGR2_LPTIM1SEL_0)
 #endif
+#elif defined(CPU_FAM_STM32L5)
+#define CLOCK_SRC_REG       RCC->CCIPR1
+#define CLOCK_SRC_MASK      RCC_CCIPR1_LPTIM1SEL
+#if IS_ACTIVE(CONFIG_BOARD_HAS_LSE)
+#define CLOCK_SRC_CFG       (RCC_CCIPR1_LPTIM1SEL_1 | RCC_CCIPR1_LPTIM1SEL_0)
+#else
+#define CLOCK_SRC_CFG       (RCC_CCIPR1_LPTIM1SEL_0)
+#endif
 #else
 #define CLOCK_SRC_REG       RCC->CCIPR
 #define CLOCK_SRC_MASK      RCC_CCIPR_LPTIM1SEL
@@ -76,10 +84,10 @@ register. */
 #define EXTI_IMR2_IM32      (1 << 0)
 #endif
 
-#if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32L5)
 #define IMR_REG             IMR2
 #define EXTI_IMR_BIT        EXTI_IMR2_IM32
-#elif defined(CPU_FAM_STM32G0)
+#elif defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32WL)
 #define IMR_REG             IMR1
 #define EXTI_IMR_BIT        EXTI_IMR1_IM29
 #elif defined(CPU_FAM_STM32G4)
@@ -108,7 +116,9 @@ static void *to_arg;
 
 void rtt_init(void)
 {
+    /* Enable the low speed clock (LSE) */
     stmclk_enable_lfclk();
+
     /* power on the selected LPTIMER */
     rtt_poweron();
 
@@ -128,7 +138,8 @@ void rtt_init(void)
     EXTI->IMR_REG |= EXTI_IMR_BIT;
 #if !defined(CPU_FAM_STM32L4) && !defined(CPU_FAM_STM32L0) && \
     !defined(CPU_FAM_STM32WB) && !defined(CPU_FAM_STM32G4) && \
-    !defined(CPU_FAM_STM32G0)
+    !defined(CPU_FAM_STM32G0) && !defined(CPU_FAM_STM32WL) && \
+    !defined(CPU_FAM_STM32L5)
     EXTI->FTSR_REG &= ~(EXTI_FTSR_BIT);
     EXTI->RTSR_REG |= EXTI_RTSR_BIT;
     EXTI->PR_REG = EXTI_PR_BIT;
@@ -239,7 +250,8 @@ void isr_lptim1(void)
     LPTIM1->ICR = (LPTIM_ICR_ARRMCF | LPTIM_ICR_CMPMCF);
 #if !defined(CPU_FAM_STM32L4) && !defined(CPU_FAM_STM32L0) && \
     !defined(CPU_FAM_STM32WB) && !defined(CPU_FAM_STM32G4) && \
-    !defined(CPU_FAM_STM32G0)
+    !defined(CPU_FAM_STM32G0) && !defined(CPU_FAM_STM32WL) && \
+    !defined(CPU_FAM_STM32L5)
     EXTI->PR_REG = EXTI_PR_BIT; /* only clear the associated bit */
 #endif
 
diff --git a/cpu/stm32/periph/spi.c b/cpu/stm32/periph/spi.c
index 8491755394..1b083c66e4 100644
--- a/cpu/stm32/periph/spi.c
+++ b/cpu/stm32/periph/spi.c
@@ -237,16 +237,16 @@ int spi_acquire(spi_t bus, spi_cs_t cs, spi_mode_t mode, spi_clk_t clk)
                   spi_config[bus].tx_dma_chan,
                   (uint32_t*)&(dev(bus)->DR),
                   DMA_MEM_TO_PERIPH,
-                  0,
-                  DMA_DATA_WIDTH_BYTE);
+                  DMA_DATA_WIDTH_BYTE,
+                  0);
 
         dma_acquire(spi_config[bus].rx_dma);
         dma_setup(spi_config[bus].rx_dma,
                   spi_config[bus].rx_dma_chan,
                   (uint32_t*)&(dev(bus)->DR),
                   DMA_PERIPH_TO_MEM,
-                  0,
-                  DMA_DATA_WIDTH_BYTE);
+                  DMA_DATA_WIDTH_BYTE,
+                  0);
     }
 #endif
     dev(bus)->CR1 = cr1_settings;
diff --git a/cpu/stm32/periph/uart.c b/cpu/stm32/periph/uart.c
index 44f57c8b77..194cfcde41 100644
--- a/cpu/stm32/periph/uart.c
+++ b/cpu/stm32/periph/uart.c
@@ -35,7 +35,7 @@
 #include "pm_layered.h"
 
 #if defined(CPU_LINE_STM32L4R5xx) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define ISR_REG     ISR
 #define ISR_TXE     USART_ISR_TXE_TXFNF
 #define ISR_RXNE    USART_ISR_RXNE_RXFNE
@@ -62,7 +62,7 @@
 #endif
 
 #if defined(CPU_LINE_STM32L4R5xx) || defined(CPU_FAM_STM32G0) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #define RXENABLE            (USART_CR1_RE | USART_CR1_RXNEIE_RXFNEIE)
 #else
 #define RXENABLE            (USART_CR1_RE | USART_CR1_RXNEIE)
@@ -98,7 +98,7 @@ static inline USART_TypeDef *dev(uart_t uart)
 static inline void uart_init_usart(uart_t uart, uint32_t baudrate);
 #if defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32L4) || \
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #ifdef MODULE_PERIPH_LPUART
 static inline void uart_init_lpuart(uart_t uart, uint32_t baudrate);
 #endif
@@ -192,7 +192,7 @@ int uart_init(uart_t uart, uint32_t baudrate, uart_rx_cb_t rx_cb, void *arg)
 
 #if defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32L4) || \
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
     switch (uart_config[uart].type) {
         case STM32_USART:
             uart_init_usart(uart, baudrate);
@@ -322,7 +322,7 @@ static inline void uart_init_usart(uart_t uart, uint32_t baudrate)
 
 #if defined(CPU_FAM_STM32L0) || defined(CPU_FAM_STM32L4) || \
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-    defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32L5) || defined(CPU_FAM_STM32WL)
 #ifdef CPU_FAM_STM32L5
 #define RCC_CCIPR_LPUART1SEL_0  RCC_CCIPR1_LPUART1SEL_0
 #define RCC_CCIPR_LPUART1SEL_1  RCC_CCIPR1_LPUART1SEL_1
diff --git a/cpu/stm32/stm32.config b/cpu/stm32/stm32.config
new file mode 100644
index 0000000000..811b1f3712
--- /dev/null
+++ b/cpu/stm32/stm32.config
@@ -0,0 +1 @@
+CONFIG_MODULE_PM_LAYERED=y
diff --git a/cpu/stm32/stm32_info.mk b/cpu/stm32/stm32_info.mk
index c81f622f23..21d06e6850 100644
--- a/cpu/stm32/stm32_info.mk
+++ b/cpu/stm32/stm32_info.mk
@@ -8,7 +8,7 @@
 #  - STM32_PINCOUNT: R (64)
 #  - STM32_ROMSIZE: G (1024K)
 CPU_MODEL_UPPERCASE = $(call uppercase,$(CPU_MODEL))
-STM32_INFO     := $(shell echo $(CPU_MODEL_UPPERCASE) | sed -E -e 's/^STM32(F|L|W|G|MP)([0-7]|B)([A-Z0-9])([0-9])(.)(.)?(_A)?/\1 \2 \2\3\4 \3 \4 \5 \6 \7/')
+STM32_INFO     := $(shell echo $(CPU_MODEL_UPPERCASE) | sed -E -e 's/^STM32(F|L|W|G|MP)([0-7]|B|L)([A-Z0-9])([0-9])(.)(.)?(_A)?/\1 \2 \2\3\4 \3 \4 \5 \6 \7/')
 STM32_TYPE     = $(word 1, $(STM32_INFO))
 STM32_FAMILY   = $(word 2, $(STM32_INFO))
 STM32_MODEL    = $(word 3, $(STM32_INFO))
@@ -31,7 +31,7 @@ else ifneq (,$(filter $(CPU_FAM),f1 f2 l1))
   CPU_CORE = cortex-m3
 else ifneq (,$(filter $(CPU_FAM),f3 f4 l4 mp1))
   CPU_CORE = cortex-m4f
-else ifneq (,$(filter $(CPU_FAM),g4 wb))
+else ifneq (,$(filter $(CPU_FAM),g4 wb wl))
   CPU_CORE = cortex-m4
 else ifeq (f7,$(CPU_FAM))
   CPU_CORE = cortex-m7
diff --git a/cpu/stm32/stm32_mem_lengths.mk b/cpu/stm32/stm32_mem_lengths.mk
index f87649d245..54f7c9c928 100644
--- a/cpu/stm32/stm32_mem_lengths.mk
+++ b/cpu/stm32/stm32_mem_lengths.mk
@@ -273,6 +273,8 @@ else ifeq ($(STM32_TYPE), W)
         RAM_LEN = 256K
       endif
     endif
+  else ifeq ($(STM32_FAMILY), L)
+    RAM_LEN = 64K
   endif
 else ifeq ($(STM32_TYPE), MP)
   ifeq ($(STM32_FAMILY), 1)
diff --git a/cpu/stm32/stmclk/Kconfig b/cpu/stm32/stmclk/Kconfig
new file mode 100644
index 0000000000..846db93c84
--- /dev/null
+++ b/cpu/stm32/stmclk/Kconfig
@@ -0,0 +1,10 @@
+# Copyright (c) 2021 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config MODULE_STM32_CLK
+    bool
+    default y
diff --git a/cpu/stm32/stmclk/Makefile b/cpu/stm32/stmclk/Makefile
index f33f4111cd..7c8e2b386a 100644
--- a/cpu/stm32/stmclk/Makefile
+++ b/cpu/stm32/stmclk/Makefile
@@ -10,8 +10,8 @@ else ifneq (,$(filter $(CPU_FAM),f0 f1 f3))
   SRC += stmclk_f0f1f3.c
 else ifneq (,$(filter $(CPU_FAM),l0 l1))
   SRC += stmclk_l0l1.c
-else ifneq (,$(filter $(CPU_FAM),l4 wb))
-  SRC += stmclk_l4wb.c
+else ifneq (,$(filter $(CPU_FAM),l4 wb wl))
+  SRC += stmclk_l4wx.c
 else ifneq (,$(filter $(CPU_FAM),l5))
   SRC += stmclk_l5.c
 else ifneq (,$(filter $(CPU_FAM),g0 g4))
diff --git a/cpu/stm32/stmclk/stmclk_common.c b/cpu/stm32/stmclk/stmclk_common.c
index 70ed5dea1e..73453199c1 100644
--- a/cpu/stm32/stmclk/stmclk_common.c
+++ b/cpu/stm32/stmclk/stmclk_common.c
@@ -25,7 +25,8 @@
 
 #if defined(CPU_FAM_STM32L4) || defined(CPU_FAM_STM32F7) || \
     defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32G4) || \
-    defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5)
+    defined(CPU_FAM_STM32G0) || defined(CPU_FAM_STM32L5) || \
+    defined(CPU_FAM_STM32WL)
 #define REG_PWR_CR          CR1
 #define BIT_CR_DBP          PWR_CR1_DBP
 #else
@@ -70,6 +71,13 @@ void stmclk_enable_lfclk(void)
         stmclk_dbp_unlock();
         RCC->REG_LSE |= BIT_LSEON;
         while (!(RCC->REG_LSE & BIT_LSERDY)) {}
+
+    /* Set LSE system clock enable bit. This is required if LSE is to be used by
+       USARTx, LPUARTx, LPTIMx, TIMx, RNG, system LSCO, MCO, MSI PLL mode */
+#if defined(CPU_FAM_STM32WL) || defined (CPU_FAM_STM32L5)
+        RCC->BDCR |= RCC_BDCR_LSESYSEN;
+        while (!(RCC->BDCR & RCC_BDCR_LSESYSRDY)) {}
+#endif
         stmclk_dbp_lock();
     }
     else {
diff --git a/cpu/stm32/stmclk/stmclk_l4wb.c b/cpu/stm32/stmclk/stmclk_l4wx.c
similarity index 95%
rename from cpu/stm32/stmclk/stmclk_l4wb.c
rename to cpu/stm32/stmclk/stmclk_l4wx.c
index 5488bbdb94..cee9b41cb2 100644
--- a/cpu/stm32/stmclk/stmclk_l4wb.c
+++ b/cpu/stm32/stmclk/stmclk_l4wx.c
@@ -29,7 +29,7 @@
 #include "periph/gpio.h"
 
 /* map CMSIS defines not present in stm32wb55xx.h */
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
 #define RCC_PLLCFGR_PLLSRC_HSE      (RCC_PLLCFGR_PLLSRC_0 | RCC_PLLCFGR_PLLSRC_1)
 #define RCC_PLLCFGR_PLLSRC_HSI      (RCC_PLLCFGR_PLLSRC_1)
 #define RCC_PLLCFGR_PLLSRC_MSI      (RCC_PLLCFGR_PLLSRC_0)
@@ -67,7 +67,7 @@
 #endif
 #define PLL_N                       (CONFIG_CLOCK_PLL_N << RCC_PLLCFGR_PLLN_Pos)
 
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
 #if (CONFIG_CLOCK_PLL_R < 1 || CONFIG_CLOCK_PLL_R > 8)
 #error "PLL configuration: PLL R value is invalid"
 #else
@@ -87,7 +87,7 @@
 #endif
 #endif
 
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
 #if (CONFIG_CLOCK_PLL_Q < 1 || CONFIG_CLOCK_PLL_Q > 8)
 #error "PLL configuration: PLL Q value is invalid"
 #else
@@ -249,7 +249,7 @@
 #define CONFIG_CLOCK_MCO_PRE                    (1)
 #endif
 
-#ifdef CPU_FAM_STM32WB
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
 /* Define bitfields for MCO prescaler for compatibility with L4*/
 #define RCC_CFGR_MCOPRE_DIV1                    (0)
 #define RCC_CFGR_MCOPRE_DIV2                    (RCC_CFGR_MCOPRE_0)
@@ -273,7 +273,7 @@
 #endif
 
 /* Configure main and peripheral bus clock prescalers */
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
 #define CLOCK_AHB_DIV               (0)
 
 #if CONFIG_CLOCK_APB1_DIV == 1
@@ -330,9 +330,9 @@
 /* Configure 48MHz clock source */
 #define CLOCK_PLLQ                  ((CLOCK_PLL_SRC / CONFIG_CLOCK_PLL_M) * CONFIG_CLOCK_PLL_N) / CONFIG_CLOCK_PLL_Q
 
-#if CLOCK_PLLQ == MHZ(48)
+#if CLOCK_PLLQ == MHZ(48) && !defined(CPU_FAM_STM32WL)
 #define CLOCK48MHZ_USE_PLLQ         1
-#elif CONFIG_CLOCK_MSI == MHZ(48)
+#elif CONFIG_CLOCK_MSI == MHZ(48) && !defined(CPU_FAM_STM32WL)
 #define CLOCK48MHZ_USE_MSI          1
 #else
 #define CLOCK48MHZ_USE_PLLQ         0
@@ -431,12 +431,20 @@
  * @name    Deduct the needed flash wait states from the core clock frequency
  * @{
  */
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WL)
+#if (CLOCK_AHB <= 16000000)     /* VCORE range 2 */
+#define FLASH_WAITSTATES        ((CLOCK_AHB - 1) / 6000000U)
+#elif (CLOCK_AHB <= 48000000)   /* VCORE range 1 */
+#define FLASH_WAITSTATES        ((CLOCK_AHB - 1) / 18000000U)
+#else
+#define FLASH_WAITSTATES        FLASH_ACR_LATENCY_2
+#endif /* CPU_FAM_STM32WL */
+#elif defined(CPU_FAM_STM32WB)
 #if (CLOCK_AHB <= 64000000)
 #define FLASH_WAITSTATES        ((CLOCK_AHB - 1) / 18000000U)
 #else
 #define FLASH_WAITSTATES        FLASH_ACR_LATENCY_3WS
-#endif
+#endif /* CPU_FAM_STM32WB */
 #else
 #define FLASH_WAITSTATES        ((CLOCK_AHB - 1) / 16000000U)
 #endif
@@ -485,6 +493,11 @@ void stmclk_init_sysclk(void)
         - Use HSE as PLL input clock
     */
     if (IS_ACTIVE(CLOCK_ENABLE_HSE)) {
+
+    /* Use VDDTCXO regulator */
+#if defined(CPU_FAM_STM32WL)
+        RCC->CR |= (RCC_CR_HSEBYPPWR);
+#endif
         RCC->CR |= (RCC_CR_HSEON);
         while (!(RCC->CR & RCC_CR_HSERDY)) {}
     }
@@ -593,6 +606,13 @@ void stmclk_init_sysclk(void)
         stmclk_dbp_unlock();
         RCC->BDCR |= RCC_BDCR_LSEON;
         while (!(RCC->BDCR & RCC_BDCR_LSERDY)) {}
+
+    /* Set LSE system clock enable bit. This is required if LSE is to be used by
+       USARTx, LPUARTx, LPTIMx, TIMx, RNG, system LSCO, MCO, MSI PLL mode */
+#if defined(CPU_FAM_STM32WL)
+        RCC->BDCR |= RCC_BDCR_LSESYSEN;
+        while (!(RCC->BDCR & RCC_BDCR_LSESYSRDY)) {}
+#endif
         stmclk_dbp_lock();
     }
 
diff --git a/cpu/stm32/vectors/Kconfig b/cpu/stm32/vectors/Kconfig
new file mode 100644
index 0000000000..93c7ab1081
--- /dev/null
+++ b/cpu/stm32/vectors/Kconfig
@@ -0,0 +1,10 @@
+# Copyright (c) 2021 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config MODULE_STM32_VECTORS
+    bool
+    default y
diff --git a/dist/pythonlibs/riotctrl_ctrl/__init__.py b/dist/pythonlibs/riotctrl_ctrl/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/dist/pythonlibs/riotctrl_ctrl/native.py b/dist/pythonlibs/riotctrl_ctrl/native.py
new file mode 100644
index 0000000000..bc44140cb3
--- /dev/null
+++ b/dist/pythonlibs/riotctrl_ctrl/native.py
@@ -0,0 +1,30 @@
+# Copyright (C) 2021 Freie Universität Berlin
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import riotctrl.ctrl
+
+import psutil
+
+
+class NativeRIOTCtrl(riotctrl.ctrl.RIOTCtrl):
+    """RIOTCtrl abstraction for a native node
+
+    This works exactly as a normal RIOTCtrl, with the exception that
+    `DEBUG_ADAPTER_ID` is set in the environment to the PID of the `native`
+    process, whenever a terminal is started. This allows for `reset()` to also
+    work for a the `native` instance.
+    """
+    def _set_debug_adapter_id(self, child):
+        if child.name().endswith('.elf'):
+            self.env['DEBUG_ADAPTER_ID'] = str(child.pid)
+            return True
+        return False
+
+    def start_term(self, *args, **kwargs):
+        super().start_term(*args, **kwargs)
+        for child in psutil.Process(pid=self._term_pid()).children():
+            if self._set_debug_adapter_id(child):
+                break
diff --git a/dist/pythonlibs/riotctrl_ctrl/requirements.txt b/dist/pythonlibs/riotctrl_ctrl/requirements.txt
new file mode 100644
index 0000000000..a2b3329f10
--- /dev/null
+++ b/dist/pythonlibs/riotctrl_ctrl/requirements.txt
@@ -0,0 +1,2 @@
+psutil
+riotctrl
diff --git a/dist/pythonlibs/riotctrl_ctrl/tests/test_native.py b/dist/pythonlibs/riotctrl_ctrl/tests/test_native.py
new file mode 100644
index 0000000000..190834b678
--- /dev/null
+++ b/dist/pythonlibs/riotctrl_ctrl/tests/test_native.py
@@ -0,0 +1,45 @@
+# Copyright (C) 2021 Freie Universität Berlin
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import os.path
+
+import riotctrl.ctrl
+
+import riotctrl_ctrl.native
+
+
+def test_reset():
+    env = {'DEBUG_ADAPTER_ID': '', 'BOARD': 'native'}
+    ctrl = riotctrl_ctrl.native.NativeRIOTCtrl(
+        application_directory=os.path.normpath(os.path.join(
+            os.path.abspath(__file__),
+            '..', '..', '..', '..', '..',
+            'examples', 'hello-world'
+        )),
+        env=env,
+    )
+    print(ctrl.application_directory)
+    assert not ctrl.env['DEBUG_ADAPTER_ID']
+    ctrl.make_run(['flash'])
+    with ctrl.run_term(reset=False):
+        # DEBUG_ADAPTER_ID is now a PID
+        assert int(ctrl.env['DEBUG_ADAPTER_ID'])
+        ctrl.term.expect_exact('Hello World!')
+        ctrl.reset()
+        ctrl.term.expect_exact('!! REBOOT !!')
+        ctrl.term.expect_exact('Hello World!')
+
+
+def test_w_factory():
+    env = {'BOARD': 'native'}
+    factory = riotctrl.ctrl.RIOTCtrlBoardFactory(
+        board_cls={'native': riotctrl_ctrl.native.NativeRIOTCtrl}
+    )
+    assert 'native' in factory.board_cls
+    ctrl = factory.get_ctrl(env=env)
+    # pylint: disable=unidiomatic-typecheck
+    # in this case we want to know the exact type
+    assert type(ctrl) is riotctrl_ctrl.native.NativeRIOTCtrl
diff --git a/dist/pythonlibs/riotctrl_ctrl/tox.ini b/dist/pythonlibs/riotctrl_ctrl/tox.ini
new file mode 100644
index 0000000000..1b8ac29b71
--- /dev/null
+++ b/dist/pythonlibs/riotctrl_ctrl/tox.ini
@@ -0,0 +1,20 @@
+[tox]
+envlist = test,flake8
+skipsdist = True
+
+[testenv]
+commands =
+    test:       {[testenv:test]commands}
+    flake8:     {[testenv:flake8]commands}
+
+[testenv:test]
+deps =
+    pytest
+    -rrequirements.txt
+commands =
+    pytest -v --doctest-modules
+
+[testenv:flake8]
+deps = flake8
+commands =
+    flake8 .
diff --git a/dist/testbed-support/iotlab-debug.sh b/dist/testbed-support/iotlab-debug.sh
new file mode 100755
index 0000000000..b63a5f5872
--- /dev/null
+++ b/dist/testbed-support/iotlab-debug.sh
@@ -0,0 +1,70 @@
+#!/usr/bin/env bash
+
+# This script wraps IoT-LAB remote debugging tools so they can be used with
+# debug and debug-server targets.
+
+# @author       Alexandre Abadie <alexandre.abadie@inria.fr>
+
+IOTLAB_NODE=$1
+IOTLAB_NODE_LIST=$2
+IOTLAB_AUTHORITY=$3
+IOTLAB_EXP_ID=$4
+ELFFILE=$5
+SERVER_ONLY=$6
+
+# GDB command, usually a separate command for each platform (e.g. arm-none-eabi-gdb)
+: "${GDB:=gdb-multiarch}"
+# Debugger client command, can be used to wrap GDB in a front-end
+: "${DBG:=${GDB}}"
+# Default GDB port
+: "${GDB_PORT:=3333}"
+
+# If run from the SSH frontend the remote is the iotlab node hostname. If run
+# locally, the GDB server is exposed via an SSH tunnel, so the GDB remote is
+# localhost in this case.
+if [ ! -z "${IOT_LAB_FRONTEND_FQDN}" ]
+then
+    GDB_REMOTE=${IOTLAB_NODE}
+    # Use a blocking interactive command to simulate the SSH tunnel
+    REMOTE_ACCESS_COMMAND="tee &"
+else
+    GDB_REMOTE=localhost
+    REMOTE_ACCESS_COMMAND="ssh -L 3333:${IOTLAB_NODE}:${GDB_PORT} -N ${IOTLAB_AUTHORITY} &"
+fi
+
+# Default debugger flags,
+: "${DBG_FLAGS:=-q -ex \"target remote ${GDB_REMOTE}:${GDB_PORT}\"}"
+
+# temporary file that contains the iotlab SSH tunnel pid
+IOTLAB_DEBUG_PIDFILE=$(mktemp -t "iotlab_debug_pid.XXXXXXXXXX")
+# will be called by trap
+cleanup() {
+    # shellcheck disable=SC2086
+    iotlab-node --jmespath='keys(@)[0]' --format='lambda ret: exit(int(ret))' --debug-stop ${IOTLAB_EXP_ID} ${IOTLAB_NODE_LIST}
+    # shellcheck disable=SC2046
+    kill $(cat "${IOTLAB_DEBUG_PIDFILE}")
+    rm -f "${IOTLAB_DEBUG_PIDFILE}"
+    exit 0
+}
+# cleanup after script terminates
+trap 'cleanup ${IOTLAB_DEBUG_PIDFILE}' EXIT
+
+# Start the GDB server on the IoT-LAB node
+# shellcheck disable=SC2086
+iotlab-node --jmespath='keys(@)[0]' --format='lambda ret: exit(int(ret))' --debug-start ${IOTLAB_EXP_ID} ${IOTLAB_NODE_LIST}
+
+# open SSH tunnel to GDB server running on the IoT-LAB node
+sh -c "\
+    ${REMOTE_ACCESS_COMMAND} \
+    echo \$! > ${IOTLAB_DEBUG_PIDFILE}" &
+
+if [ ! -z "${SERVER_ONLY}" ]
+then
+    # Block until CTRL-C is sent
+    read -r -d ""
+else
+    # don't trap on Ctrl+C, because GDB keeps running
+    trap '' INT
+    # Start the debugger and connect to the GDB server
+    sh -c "${DBG} ${DBG_FLAGS} ${ELFFILE}"
+fi
diff --git a/dist/testbed-support/makefile.iotlab.archi.inc.mk b/dist/testbed-support/makefile.iotlab.archi.inc.mk
new file mode 100644
index 0000000000..5c5992613a
--- /dev/null
+++ b/dist/testbed-support/makefile.iotlab.archi.inc.mk
@@ -0,0 +1,20 @@
+# board-archi mapping
+IOTLAB_ARCHI_arduino-zero   = arduino-zero:xbee
+IOTLAB_ARCHI_b-l072z-lrwan1 = st-lrwan1:sx1276
+IOTLAB_ARCHI_b-l475e-iot01a = st-iotnode:multi
+IOTLAB_ARCHI_dwm1001        = dwm1001:dw1000
+IOTLAB_ARCHI_firefly        = firefly:multi
+IOTLAB_ARCHI_frdm-kw41z     = frdm-kw41z:multi
+IOTLAB_ARCHI_iotlab-a8-m3   = a8:at86rf231
+IOTLAB_ARCHI_iotlab-m3      = m3:at86rf231
+IOTLAB_ARCHI_microbit       = microbit:ble
+IOTLAB_ARCHI_nrf51dk        = nrf51dk:ble
+IOTLAB_ARCHI_nrf52dk        = nrf52dk:ble
+IOTLAB_ARCHI_nrf52832-mdk   = nrf52832mdk:ble
+IOTLAB_ARCHI_nrf52840dk     = nrf52840dk:multi
+IOTLAB_ARCHI_nrf52840-mdk   = nrf52840mdk:multi
+IOTLAB_ARCHI_pba-d-01-kw2x  = phynode:kw2xrf
+IOTLAB_ARCHI_samr21-xpro    = samr21:at86rf233
+IOTLAB_ARCHI_samr30-xpro    = samr30:at86rf212b
+IOTLAB_ARCHI_zigduino       = zigduino:atmega128rfa1
+IOTLAB_ARCHI := $(IOTLAB_ARCHI_$(BOARD))
diff --git a/dist/testbed-support/makefile.iotlab.single.inc.mk b/dist/testbed-support/makefile.iotlab.single.inc.mk
index cf90d3f2db..b831b1873e 100644
--- a/dist/testbed-support/makefile.iotlab.single.inc.mk
+++ b/dist/testbed-support/makefile.iotlab.single.inc.mk
@@ -44,44 +44,47 @@ ifeq (,$(IOTLAB_NODE))
   $(warning    Example: m3-380.grenoble.iot-lab.info or a8-1.grenoble.iot-lab.info)
   $(warning  * <type>-<number> when run from iot-lab frontend)
   $(warning    Example: m3-380 or a8-1)
-  $(warning  * 'auto' or 'auto-ssh' to try auto-detecting the node from your experiment
+  $(warning  * 'auto' to try auto-detecting the node from your experiment
   $(error)
 endif
 
+ifeq (auto-ssh,$(IOTLAB_NODE))
+  $(info $(COLOR_YELLOW)IOTLAB_NODE=auto-ssh is deprecated and will be removed after \
+         2010.07 is released, use IOTLAB_NODE=auto instead$(COLOR_RESET))
+  override IOTLAB_NODE := auto
+endif
+
 IOTLAB_AUTH ?= $(HOME)/.iotlabrc
 IOTLAB_USER ?= $(shell cut -f1 -d: $(IOTLAB_AUTH))
 
+ifneq (0,$(shell command -v iotlab-experiment -h 2>&1 > /dev/null ; echo $$?))
+  $(info $(COLOR_RED)'iotlab-experiment' command is not available \
+	        please consider installing it from \
+	        https://pypi.python.org/pypi/iotlabcli$(COLOR_RESET))
+  $(error )
+endif
+
+ifeq (iotlab-a8-m3,$(BOARD))
+  ifneq (,$(filter flash% reset,$(MAKECMDGOALS)))
+    ifneq (0,$(shell command -v iotlab-ssh -h 2>&1 > /dev/null ; echo $$?))
+      $(info $(COLOR_RED)'iotlab-ssh' command is not available \
+	          please consider installing it from \
+	          https://pypi.python.org/pypi/iotlabsshcli$(COLOR_RESET))
+      $(error )
+    endif
+  endif
+endif
+
 # Optional Experiment id. Required when having multiple experiments
 IOTLAB_EXP_ID ?=
 
 # Specify experiment-id option if provided
 _IOTLAB_EXP_ID := $(if $(IOTLAB_EXP_ID),--id $(IOTLAB_EXP_ID))
 
-# Number of the node to take from the list in 'auto' and 'auto-ssh' mode
+# Number of the node to take from the list in 'auto' mode
 # Default to 1 so the first one
 IOTLAB_NODE_AUTO_NUM ?= 1
 
-# board-archi mapping
-IOTLAB_ARCHI_arduino-zero   = arduino-zero:xbee
-IOTLAB_ARCHI_b-l072z-lrwan1 = st-lrwan1:sx1276
-IOTLAB_ARCHI_b-l475e-iot01a = st-iotnode:multi
-IOTLAB_ARCHI_dwm1001        = dwm1001:dw1000
-IOTLAB_ARCHI_firefly        = firefly:multi
-IOTLAB_ARCHI_frdm-kw41z     = frdm-kw41z:multi
-IOTLAB_ARCHI_iotlab-a8-m3   = a8:at86rf231
-IOTLAB_ARCHI_iotlab-m3      = m3:at86rf231
-IOTLAB_ARCHI_microbit       = microbit:ble
-IOTLAB_ARCHI_nrf51dk        = nrf51dk:ble
-IOTLAB_ARCHI_nrf52dk        = nrf52dk:ble
-IOTLAB_ARCHI_nrf52832-mdk   = nrf52832mdk:ble
-IOTLAB_ARCHI_nrf52840dk     = nrf52840dk:multi
-IOTLAB_ARCHI_nrf52840-mdk   = nrf52840mdk:multi
-IOTLAB_ARCHI_pba-d-01-kw2x  = phynode:kw2xrf
-IOTLAB_ARCHI_samr21-xpro    = samr21:at86rf233
-IOTLAB_ARCHI_samr30-xpro    = samr30:at86rf212b
-IOTLAB_ARCHI_zigduino       = zigduino:atmega128rfa1
-IOTLAB_ARCHI := $(IOTLAB_ARCHI_$(BOARD))
-
 # There are several deprecated and incompatible features used here that were
 # introduced between versions 2 and 3 of the IoT-LAB cli tools.
 # For backward compatibility, we manage these changes here.
@@ -109,18 +112,18 @@ endif
 #    * Check correctly deployed nodes with 'deploymentresults == "0"'
 #    * Select nodes by architucture using the board-archi mapping
 #    * Nodes for current server in 'auto'
-ifneq (,$(filter auto auto-ssh,$(IOTLAB_NODE)))
+ifeq (auto,$(IOTLAB_NODE))
   ifeq (,$(IOTLAB_ARCHI))
     $(error Could not find 'archi' for $(BOARD), update mapping in $(lastword $(MAKEFILE_LIST)))
   endif
 
-  ifeq (auto,$(IOTLAB_NODE))
-    _NODES_DEPLOYED := $(filter %.$(shell hostname).iot-lab.info, $(_NODES_DEPLOYED))
+  ifneq (,$(IOT_LAB_FRONTEND_FQDN))
+    _NODES_DEPLOYED := $(filter %.$(IOT_LAB_FRONTEND_FQDN), $(_NODES_DEPLOYED))
   endif
   _NODES_FOR_BOARD = $(shell iotlab-experiment --jmespath="items[?archi=='$(IOTLAB_ARCHI)'].network_address" --format='" ".join' get $(_IOTLAB_EXP_ID) $(_NODES_LIST_OPTION))
 
   _IOTLAB_NODE := $(word $(IOTLAB_NODE_AUTO_NUM),$(filter $(_NODES_DEPLOYED),$(_NODES_FOR_BOARD)))
-  ifeq (auto,$(IOTLAB_NODE))
+  ifneq (,$(IOT_LAB_FRONTEND_FQDN))
     override IOTLAB_NODE := $(firstword $(subst ., ,$(_IOTLAB_NODE)))
   else
     override IOTLAB_NODE := $(_IOTLAB_NODE)
@@ -129,24 +132,31 @@ ifneq (,$(filter auto auto-ssh,$(IOTLAB_NODE)))
   ifeq (,$(IOTLAB_NODE))
     $(error Could not automatically find a node for BOARD=$(BOARD))
   endif
-  override IOTLAB_NODE := $(patsubst node-%,%,$(IOTLAB_NODE))
 endif
 
-
-# If the IOTLAB_NODE format is:
-# * 'type-num.iot.lab.info' assume it is run from your computer
-# * 'type-num' assume it is run from iot-lab frontend
-ifneq (,$(filter %.iot-lab.info, $(IOTLAB_NODE)))
-  _IOTLAB_ON_FRONTEND =
-else
-  _IOTLAB_ON_FRONTEND = 1
+# Handle IOTLAB_NODE specified with comma separated form
+# saclay,m3,1 => m3-1.saclay.iot-lab.info)
+IOTLAB_NODE_COMMA := $(subst $(comma), ,$(IOTLAB_NODE))
+ifneq ($(IOTLAB_NODE_COMMA),$(IOTLAB_NODE))
+  _IOTLAB_NODE_TYPE := $(word 2, $(IOTLAB_NODE_COMMA))
+  _IOTLAB_NODE_ID := $(firstword $(subst +, ,$(subst -, ,$(word 3, $(IOTLAB_NODE_COMMA)))))
+  _IOTLAB_SITE := $(word 1, $(IOTLAB_NODE_COMMA))
+  override IOTLAB_NODE := $(_IOTLAB_NODE_TYPE)-$(_IOTLAB_NODE_ID).$(_IOTLAB_SITE).iot-lab.info
+
+  # If launched from an IoT-LAB frontend, check that the frontends are matching
+  ifneq (,$(IOT_LAB_FRONTEND_FQDN))
+    ifneq ($(IOT_LAB_FRONTEND_FQDN),$(_IOTLAB_SITE).iot-lab.info)
+      $(error $(COLOR_RED)IoT-LAB Frontend doesn't match ($(IOT_LAB_FRONTEND_FQDN) != $(_IOTLAB_SITE).iot-lab.info)$(COLOR_RESET))
+    endif
+  endif
 endif
+
 # Work with node url without 'node-'
 override IOTLAB_NODE := $(patsubst node-%,%,$(IOTLAB_NODE))
 
-
 # Create node list and optionally frontend url
-ifeq (,$(_IOTLAB_ON_FRONTEND))
+ifeq (,$(IOT_LAB_FRONTEND_FQDN))
+  # Running from a local computer
   # m3-380.grenoble.iot-lab.info    -> grenoble,m3,380
   # a8-1.grenoble.iot-lab.info      -> grenoble,a8,1
   _NODELIST_SED := 's/\([^.]*\)-\([^.]*\).\([^.]*\).*/\3,\1,\2/'
@@ -156,6 +166,7 @@ ifeq (,$(_IOTLAB_ON_FRONTEND))
   _IOTLAB_SERVER := $(shell echo '$(IOTLAB_NODE)' | sed 's/[^.]*.//')
   _IOTLAB_AUTHORITY = $(IOTLAB_USER)@$(_IOTLAB_SERVER)
 else
+  # Running from an IoT-LAB frontend
   # m3-380    -> $(hostname),m3,380
   # a8-1      -> $(hostname),a8,1
   _NODELIST_SED := 's/\([^.]*\)-\([^.]*\)/$(shell hostname),\1,\2/'
@@ -164,7 +175,7 @@ endif
 
 
 # Display value of IOTLAB_NODE, useful to get the value calculated when using
-# IOTLAB_NODE=auto or auto-ssh
+# IOTLAB_NODE=auto
 .PHONY: info-iotlab-node
 info-iotlab-node:
 	@echo $(IOTLAB_NODE)
@@ -181,7 +192,7 @@ ifneq (iotlab-a8-m3,$(BOARD))
   FFLAGS      = $(_NODE_FMT) $(_IOTLAB_EXP_ID) $(_IOTLAB_NODELIST) $(_NODES_FLASH_OPTION) $(FLASHFILE)
   RESET_FLAGS = $(_NODE_FMT) $(_IOTLAB_EXP_ID) $(_IOTLAB_NODELIST) --reset
 
-  ifeq (,$(_IOTLAB_ON_FRONTEND))
+  ifeq (,$(IOT_LAB_FRONTEND_FQDN))
     TERMPROG  = ssh
     TERMFLAGS = -t $(_IOTLAB_AUTHORITY) 'socat - tcp:$(IOTLAB_NODE):20000'
   else
@@ -195,11 +206,11 @@ else
   FLASHER     = iotlab-ssh
   RESET       = iotlab-ssh
   _NODE_FMT   = --jmespath='keys(values(@)[0])[0]' --fmt='int'
-  FFLAGS      = $(_NODE_FMT) $(_IOTLAB_EXP_ID) flash-m3 $(_IOTLAB_NODELIST) $(FLASHFILE)
-  RESET_FLAGS = $(_NODE_FMT) $(_IOTLAB_EXP_ID) reset-m3 $(_IOTLAB_NODELIST)
+  FFLAGS      = $(_NODE_FMT) $(_IOTLAB_EXP_ID) flash $(_IOTLAB_NODELIST) $(FLASHFILE)
+  RESET_FLAGS = $(_NODE_FMT) $(_IOTLAB_EXP_ID) reset $(_IOTLAB_NODELIST)
 
   TERMPROG  = ssh
-  ifeq (,$(_IOTLAB_ON_FRONTEND))
+  ifeq (,$(IOT_LAB_FRONTEND_FQDN))
     # Proxy ssh through the iot-lab frontend
     TERMFLAGS = -oProxyCommand='ssh $(_IOTLAB_AUTHORITY) -W %h:%p'
   else
@@ -210,8 +221,16 @@ else
 
 endif
 
-# Debugger not supported
-DEBUGGER =
-DEBUGGER_FLAGS =
-DEBUGSERVER =
-DEBUGSERVER_FLAGS =
+ifneq (,$(filter firefly iotlab-a8-m3 zigduino,$(BOARD)))
+  # Debugger not supported on these boards
+  DEBUGGER =
+  DEBUGGER_FLAGS =
+  DEBUGSERVER =
+  DEBUGSERVER_FLAGS =
+else
+  DEBUGGER_COMMON_FLAGS = "$(firstword $(subst ., ,$(IOTLAB_NODE)))" "$(_IOTLAB_NODELIST)" "$(_IOTLAB_AUTHORITY)" "$(_IOTLAB_EXP_ID)"
+  DEBUGGER = $(RIOTBASE)/dist/testbed-support/iotlab-debug.sh
+  DEBUGGER_FLAGS = $(DEBUGGER_COMMON_FLAGS) "$(ELFFILE)"
+  DEBUGSERVER = $(DEBUGGER)
+  DEBUGSERVER_FLAGS = $(DEBUGGER_COMMON_FLAGS) "" "1"
+endif
diff --git a/dist/tools/avarice/debug.sh b/dist/tools/avarice/debug.sh
index d56cbc4dc8..e2bbbaa5e5 100755
--- a/dist/tools/avarice/debug.sh
+++ b/dist/tools/avarice/debug.sh
@@ -3,9 +3,9 @@
 # The setsid command is needed so that Ctrl+C in GDB doesn't kill avarice
 : ${SETSID:=setsid}
 
-if avr-gdb -v > /dev/null; then
+if avr-gdb -v &> /dev/null; then
     GDB=avr-gdb
-elif gdb-multiarch -v > /dev/null; then
+elif gdb-multiarch -v &> /dev/null; then
     GDB=gdb-multiarch
 else
     echo "Couldn't find multiarch GDB or AVR GDB. Check \$PATH."
diff --git a/dist/tools/dhcpv6-pd_ia/pkg/__init__.py b/dist/tools/dhcpv6-pd_ia/pkg/__init__.py
index cfb69d8726..abbb2311fb 100644
--- a/dist/tools/dhcpv6-pd_ia/pkg/__init__.py
+++ b/dist/tools/dhcpv6-pd_ia/pkg/__init__.py
@@ -42,7 +42,7 @@ class PackageManagerFactory(object):
         system = platform.system()
         if system == "Linux":
             system = cls._get_linux_distro()
-        if system in ["Debian", "Ubuntu"]:
+        if system in ["Debian", "Ubuntu", "Linux Mint"]:
             return Apt("Debian")
         if system in ["Arch Linux"]:
             return PacMan("Arch")
diff --git a/dist/tools/edbg/Makefile b/dist/tools/edbg/Makefile
index a5e15e48fe..2cdb84633d 100644
--- a/dist/tools/edbg/Makefile
+++ b/dist/tools/edbg/Makefile
@@ -1,6 +1,6 @@
 PKG_NAME=edbg
 PKG_URL=https://github.com/ataradov/edbg
-PKG_VERSION=99d15460fcff723f73b16c29c8ca14bff4b33b20
+PKG_VERSION=73eb74785d57d7828f0d180b4875146c8e840eba
 PKG_LICENSE=BSD-3-Clause
 
 # manually set some RIOT env vars, so this Makefile can be called stand-alone
diff --git a/dist/tools/kconfiglib/riot_kconfig.py b/dist/tools/kconfiglib/riot_kconfig.py
index bf51e0a78e..be86733d65 100644
--- a/dist/tools/kconfiglib/riot_kconfig.py
+++ b/dist/tools/kconfiglib/riot_kconfig.py
@@ -18,7 +18,7 @@ class RiotKconfig(Kconfig):
         for marker in doxygen_markers:
             node.help = node.help.replace(marker, "")
 
-    def write_autoconf(self, filename=None, header=None):
+    def write_autoconf(self, filename=None, header="/* RIOT Configuration File */\n"):
         """ Override to convert - to _ when writing autoconf.h """
         tmp_unique_defined_syms = self.unique_defined_syms.copy()
         for sym in self.unique_defined_syms:
diff --git a/dist/tools/uncrustify/whitelist.txt b/dist/tools/uncrustify/whitelist.txt
index d8f8fcb32e..62605e9de8 100644
--- a/dist/tools/uncrustify/whitelist.txt
+++ b/dist/tools/uncrustify/whitelist.txt
@@ -6,6 +6,8 @@ cpu/fe310/periph/.*\.c
 cpu/riscv_common/.*\.c
 cpu/riscv_common/include/.*\.h
 cpu/riscv_common/periph/.*\.c
+drivers/include/sx127x.h
+drivers/sx127x/.*\.c
 sys/riotboot/.*\.h
 sys/riotboot/.*\.c
 sys/congure.*\.c
@@ -16,3 +18,4 @@ sys/test_utils/result_output/*/.*\h
 sys/test_utils/include/result_output.h
 sys/ztimer/.*\.c
 sys/include/ztimer.*\.h
+tests/driver_sx127x/.*\.c
diff --git a/dist/tools/vera++/check.sh b/dist/tools/vera++/check.sh
index ce74912d48..61a5a7158b 100755
--- a/dist/tools/vera++/check.sh
+++ b/dist/tools/vera++/check.sh
@@ -16,7 +16,7 @@ CURDIR=$(cd "$(dirname "$0")" && pwd)
 # tests/pkg_utensor/models/deep_mlp_weight.hpp is an auto-generated file
 # with lots of commas so T009 takes very long. Since it is auto-generated, just
 # exclude it.
-EXCLUDE='^(.+/vendor/|dist/tools/coccinelle/include|dist/tools/fixdep/fixdep.c|dist/tools/lpc2k_pgm/src|tests/pkg_utensor/models)'
+EXCLUDE='^(.+/vendor/|dist/tools/coccinelle/include|dist/tools/fixdep/fixdep.c|dist/tools/lpc2k_pgm/src|tests/pkg_utensor/external_modules/models)'
 FILES=$(changed_files)
 
 if [ -z "${FILES}" ]; then
diff --git a/doc/doxygen/riot.doxyfile b/doc/doxygen/riot.doxyfile
index d6212b4ea2..96f46a9fdc 100644
--- a/doc/doxygen/riot.doxyfile
+++ b/doc/doxygen/riot.doxyfile
@@ -774,6 +774,7 @@ INPUT                  = ../../doc.txt \
                          src/using-cpp.md \
                          src/advanced-build-system-tricks.md \
                          src/emulators.md \
+                         src/release-cycle.md \
                          src/changelog.md \
                          ../../LOSTANDFOUND.md
 
diff --git a/doc/doxygen/src/creating-modules.md b/doc/doxygen/src/creating-modules.md
index a9c90cc257..d217f791e3 100644
--- a/doc/doxygen/src/creating-modules.md
+++ b/doc/doxygen/src/creating-modules.md
@@ -68,13 +68,19 @@ their dependencies.
 Modules outside of RIOTBASE                      {#modules-outside-of-riotbase}
 ===========================
 Modules can be defined outside `RIOTBASE`. In addition to add it to `USEMODULE`
-the user needs to add the module path to `EXTERNAL_MODULE_DIRS`.
+the user needs to add the directory (or directories) containing external modules
+to `EXTERNAL_MODULE_DIRS`.
 
-The external module can optionally define the following files:
+External modules can optionally define the following files:
 * `Makefile.include` file to set global build configuration like `CFLAGS` or add
   API headers include paths to the `USEMODULE_INCLUDES` variable.
 * `Makefile.dep` file to set module dependencies
 
+***NOTE:*** The name of an external module must be unique (both in regard to other
+            external modules, as well to native RIOT modules). Additionally, the
+            directory containing the module must match the module name, e.g.
+            module `foo` must be located in `<PATH_IN_EXTERNAL_MODULE_DIRS>/foo`.
+
 An example can be found in
 [`tests/external_module_dirs`](https://github.com/RIOT-OS/RIOT/tree/master/tests/external_module_dirs)
 
diff --git a/doc/doxygen/src/mainpage.md b/doc/doxygen/src/mainpage.md
index 26c3833741..543b40cae3 100644
--- a/doc/doxygen/src/mainpage.md
+++ b/doc/doxygen/src/mainpage.md
@@ -25,7 +25,7 @@ with  multithreading, IPC, system timers, mutexes etc.
 
 A good high-level overview can be found in the article
 [RIOT: An Open Source Operating System for Low-End Embedded Devices in
-the IoT](https://riot-os.org/docs/riot-ieeeiotjournal-2018.pdf)
+the IoT](https://www.riot-os.org/assets/pdfs/riot-ieeeiotjournal-2018.pdf)
 (IEEE Internet of Things Journal, December 2018).
 
 Contribute to RIOT                                        {#contribute-to-riot}
@@ -38,21 +38,13 @@ RIOT is developed by an open community that anyone is welcome to join:
  - Sign-up to our [forum](https://forum.riot-os.org/) to ask for help using RIOT
    or writing an application for RIOT, discuss kernel and network stack
    development as well as hardware support, or to show-case your latest project.
- - [Subscribe](http://lists.riot-os.org/mailman/listinfo/users) to
-   users@riot-os.org to ask for help using RIOT or writing an application for
-   RIOT (or to just stay in the loop). An archive of this list [is available
-   here](https://lists.riot-os.org/pipermail/users/).
- - [Subscribe](http://lists.riot-os.org/mailman/listinfo/devel) to
-   devel@riot-os.org to follow and discuss kernel and network stack
-   development, or hardware support. An archive of this list [is available
-   here](https://lists.riot-os.org/pipermail/devel/).
  - Follow us on [Twitter](https://twitter.com/RIOT_OS) for news from the RIOT
    community.
  - Regarding critical vulnerabilities we would appreciate if you give us a
    90-days head-start by reporting to security@riot-os.org, before making your
    information publicly available
- - Contact us on IRC for live support and discussions:
-   [irc.freenode.org \#riot-os](irc://irc.freenode.org/riot-os)
+ - Contact us on Matrix for live support and discussions:
+   [riot-os:matrix.org](https://matrix.to/#/#riot-os:matrix.org)
 
 
 The quickest start                                        {#the-quickest-start}
diff --git a/doc/doxygen/src/release-cycle.md b/doc/doxygen/src/release-cycle.md
new file mode 100644
index 0000000000..97e0aa3568
--- /dev/null
+++ b/doc/doxygen/src/release-cycle.md
@@ -0,0 +1,57 @@
+Release cycle                                                   {#release-cycle}
+=============
+
+RIOT has a new release every three months and is named after the month it
+was feature frozen in. E.g. `2021.01` was feature frozen in January 2021.
+Feature freeze means the branch off point of the `<YYYY.MM>-branch` with
+`<YYYY.MM>` being the releases name. As such, any new feature merged into the
+`master` after that point, will be part of the next release. That branch, which
+we will call the release branch in the following is then the stable branch of
+RIOT.
+
+After feature freeze, the current release candidate in the release branch is
+tested heavily. For more information on the release testing, have a look at our
+[release specifications][release specs]. Bug fixes that are made during this
+testing period are back ported from `master` to the release branch and a new
+release candidate might be created when a certain milestone is found. If all
+major bugs are fixed, the new RIOT release is signed off by the appointed
+release manager, usually within 2 weeks after the feature freeze.
+
+RIOT follows a rolling release cycle, meaning, that support and bug fixes are
+only provided for the most current release.
+
+Download a release                                                   {#download}
+==================
+
+You can download the source code of our releases [via Github][releases] as ZIP
+file or tarball. Alternatively, you can check them out if you already cloned
+RIOT with Git:
+
+~~~~~~~~~~~~~~~~~~~~
+$ git pull --tags
+$ git checkout <YYYY.MM>
+~~~~~~~~~~~~~~~~~~~~
+
+Point releases and hot fixes                                   {#point-releases}
+============================
+
+For major bug fixes, we may provide a point release `YYYY.MM.N` which results in
+a new ZIP file or tarball over at the [release page][releases]. However, minor
+bug fixes are only pushed to the release branch. You can fetch that via Git
+using
+
+~~~~~~~~~~~~~~~~~~~~
+$ git clone -b `<YYYY.MM>-branch` https://github.com/RIOT-OS/RIOT
+~~~~~~~~~~~~~~~~~~~~
+
+or
+
+~~~~~~~~~~~~~~~~~~~~
+$ git pull origin <YYYY.MM-branch>:<YYYY.MM-branch>
+$ git checkout <YYYY.MM-branch>
+~~~~~~~~~~~~~~~~~~~~
+
+if you have RIOT already cloned.
+
+[releases]: https://github.com/RIOT-OS/RIOT/releases
+[release specs]: https://github.com/RIOT-OS/Release-Specs
diff --git a/doc/memos/rdm0001.md b/doc/memos/rdm0001.md
index 86a0f79691..b4362cf747 100644
--- a/doc/memos/rdm0001.md
+++ b/doc/memos/rdm0001.md
@@ -321,7 +321,7 @@ www.gnu.org/philosophy/free-sw.en.html.](https://www.gnu.org/philosophy/free-sw.
 [3] [Emmanuel Baccelli, Oliver Hahm, Mesut Günes, Matthias Wählisch, Thomas C.
 Schmidt, "RIOT OS: Towards an OS for the Internet of Things," in Proceedings of
 the 32nd IEEE International Conference on Computer Communications (INFOCOM),
-Poster, p. 79–80, IEEE Press, April 2013.](https://www.riot-os.org/docs/riot-infocom2013-abstract.pdf) \
+Poster, p. 79–80, IEEE Press, April 2013.](https://www.riot-os.org/assets/pdfs/riot-infocom2013-abstract.pdf) \
 [4] [E. Baccelli, C. Gündogan, O. Hahm, P. Kietzmann, M. Lenders, H. Petersen,
 K. Schleiser, T.C. Schmidt, M. Wählisch: "RIOT: an Open Source Operating System
 for Low-end Embedded Devices in the IoT", IEEE Internet of Things Journal, Vol.
diff --git a/drivers/at86rf215/Makefile.dep b/drivers/at86rf215/Makefile.dep
index 2810697566..d079dfb38f 100644
--- a/drivers/at86rf215/Makefile.dep
+++ b/drivers/at86rf215/Makefile.dep
@@ -33,3 +33,7 @@ endif
 USEMODULE += xtimer
 USEMODULE += ieee802154
 USEMODULE += netdev_ieee802154
+
+ifneq (,$(filter gnrc_netif_timestamp,$(USEMODULE)))
+  USEMODULE += at86rf215_timestamp
+endif
diff --git a/drivers/at86rf215/at86rf215.c b/drivers/at86rf215/at86rf215.c
index 6a88d527d4..23c093e3ce 100644
--- a/drivers/at86rf215/at86rf215.c
+++ b/drivers/at86rf215/at86rf215.c
@@ -150,6 +150,10 @@ if (!IS_ACTIVE(CONFIG_AT86RF215_USE_CLOCK_OUTPUT)){
         reg |= AMCS_AACK_MASK;
     }
 
+    if (IS_USED(MODULE_AT86RF215_TIMESTAMP)) {
+        at86rf215_reg_write(dev, dev->BBC->RG_CNTC,
+                                 CNTC_EN_MASK | CNTC_CAPRXS_MASK);
+    }
     at86rf215_reg_write(dev, dev->BBC->RG_AMCS, reg);
 
     if (CONFIG_AT86RF215_DEFAULT_PHY_MODE == IEEE802154_PHY_OQPSK) {
diff --git a/drivers/at86rf215/at86rf215_netdev.c b/drivers/at86rf215/at86rf215_netdev.c
index 1582223d2b..07ba4cb0fb 100644
--- a/drivers/at86rf215/at86rf215_netdev.c
+++ b/drivers/at86rf215/at86rf215_netdev.c
@@ -199,6 +199,16 @@ static int _recv(netdev_t *netdev, void *buf, size_t len, void *info)
     if (info != NULL) {
         netdev_ieee802154_rx_info_t *radio_info = info;
         radio_info->rssi = (int8_t) at86rf215_reg_read(dev, dev->RF->RG_EDV);
+
+        if (IS_USED(MODULE_AT86RF215_TIMESTAMP)) {
+            uint32_t rx_timestamp;
+            at86rf215_reg_read_bytes(dev, dev->BBC->RG_CNT0, &rx_timestamp,
+                                    sizeof(rx_timestamp));
+
+            /* convert counter value to ns */
+            radio_info->timestamp = rx_timestamp * 1000ULL / 32;
+            radio_info->flags |= NETDEV_RX_IEEE802154_INFO_FLAG_TIMESTAMP;
+        }
     }
 
     return pkt_len;
diff --git a/drivers/at86rf2xx/at86rf2xx.c b/drivers/at86rf2xx/at86rf2xx.c
index 866877938d..e9c4ae7e58 100644
--- a/drivers/at86rf2xx/at86rf2xx.c
+++ b/drivers/at86rf2xx/at86rf2xx.c
@@ -233,10 +233,6 @@ void at86rf2xx_reset(at86rf2xx_t *dev)
     IS_USED(MODULE_AT86RF2XX_AES_SPI)
     dev->netdev.sec_ctx.dev.cipher_ops = &_at86rf2xx_cipher_ops;
     dev->netdev.sec_ctx.dev.ctx = dev;
-    /* All configurations of the security module, the SRAM content,
-       and keys are reset during DEEP_SLEEP or RESET state. */
-    at86rf2xx_aes_key_write_encrypt(dev,
-        dev->netdev.sec_ctx.cipher.context.context);
 #endif
 
     /* State to return after receiving or transmitting */
diff --git a/drivers/at86rf2xx/at86rf2xx_netdev.c b/drivers/at86rf2xx/at86rf2xx_netdev.c
index 6988dfbcfe..3cd109ace6 100644
--- a/drivers/at86rf2xx/at86rf2xx_netdev.c
+++ b/drivers/at86rf2xx/at86rf2xx_netdev.c
@@ -629,23 +629,6 @@ static int _set(netdev_t *netdev, netopt_t opt, const void *val, size_t len)
             break;
 
 #endif /* MODULE_NETDEV_IEEE802154_OQPSK */
-
-#if IS_USED(MODULE_AT86RF2XX_AES_SPI) && \
-    IS_USED(MODULE_IEEE802154_SECURITY)
-        case NETOPT_ENCRYPTION_KEY:
-            assert(len >= IEEE802154_SEC_KEY_LENGTH);
-            at86rf2xx_aes_key_write_encrypt(dev, val);
-            if (memcmp(dev->netdev.sec_ctx.cipher.context.context, val, len)) {
-                /* If the key changes, the frame conter can be reset to 0*/
-                dev->netdev.sec_ctx.frame_counter = 0;
-            }
-            memcpy(dev->netdev.sec_ctx.cipher.context.context, val,
-                   IEEE802154_SEC_KEY_LENGTH);
-            res = IEEE802154_SEC_KEY_LENGTH;
-            break;
-#endif /* IS_USED(MODULE_AT86RF2XX_AES_SPI) && \
-          IS_USED(MODULE_IEEE802154_SECURITY) */
-
         default:
             break;
     }
diff --git a/drivers/bmx280/Kconfig b/drivers/bmx280/Kconfig
index 71a78bc53c..125e1fc5df 100644
--- a/drivers/bmx280/Kconfig
+++ b/drivers/bmx280/Kconfig
@@ -46,4 +46,3 @@ endchoice
 config MODULE_BMX280
     bool
     depends on TEST_KCONFIG
-    select MODULE_XTIMER
diff --git a/drivers/bmx280/Makefile.dep b/drivers/bmx280/Makefile.dep
index d2f118d64b..f1af33c24a 100644
--- a/drivers/bmx280/Makefile.dep
+++ b/drivers/bmx280/Makefile.dep
@@ -1,5 +1,3 @@
-USEMODULE += xtimer
-
 ifneq (,$(filter bm%280_spi,$(USEMODULE)))
   FEATURES_REQUIRED += periph_spi
   FEATURES_REQUIRED += periph_gpio
diff --git a/drivers/bmx280/bmx280.c b/drivers/bmx280/bmx280.c
index d662dcbf12..389e7b5169 100644
--- a/drivers/bmx280/bmx280.c
+++ b/drivers/bmx280/bmx280.c
@@ -28,7 +28,6 @@
 #include "assert.h"
 #include "bmx280.h"
 #include "bmx280_internals.h"
-#include "xtimer.h"
 
 #define ENABLE_DEBUG        0
 #include "debug.h"
diff --git a/drivers/cc2420/Makefile.dep b/drivers/cc2420/Makefile.dep
index 648ad9141b..611bf7fdb2 100644
--- a/drivers/cc2420/Makefile.dep
+++ b/drivers/cc2420/Makefile.dep
@@ -1,5 +1,4 @@
 USEMODULE += xtimer
-USEMODULE += luid
 USEMODULE += ieee802154
 USEMODULE += netdev_ieee802154
 FEATURES_REQUIRED += periph_gpio
diff --git a/drivers/cc2420/cc2420.c b/drivers/cc2420/cc2420.c
index 2ce998b399..d190be3546 100644
--- a/drivers/cc2420/cc2420.c
+++ b/drivers/cc2420/cc2420.c
@@ -20,7 +20,6 @@
  * @}
  */
 
-#include "luid.h"
 #include "byteorder.h"
 #include "net/ieee802154.h"
 #include "net/gnrc.h"
@@ -32,32 +31,30 @@
 #define ENABLE_DEBUG 0
 #include "debug.h"
 
-
-void cc2420_setup(cc2420_t * dev, const cc2420_params_t *params)
+void cc2420_setup(cc2420_t * dev, const cc2420_params_t *params, uint8_t index)
 {
+    netdev_t *netdev = &dev->netdev.netdev;
+
     /* set pointer to the devices netdev functions */
-    dev->netdev.netdev.driver = &cc2420_driver;
+    netdev->driver = &cc2420_driver;
     /* pull in device configuration parameters */
     dev->params = *params;
     dev->state = CC2420_STATE_IDLE;
     /* reset device descriptor fields */
     dev->options = 0;
+
+    netdev_register(netdev, NETDEV_CC2420, index);
+    netdev_ieee802154_setup(&dev->netdev);
 }
 
 int cc2420_init(cc2420_t *dev)
 {
     uint16_t reg;
-    uint8_t addr[8];
 
     netdev_ieee802154_reset(&dev->netdev);
 
-    /* set default address, channel, PAN ID, and TX power */
-    luid_get(addr, sizeof(addr));
-    /* make sure we mark the address as non-multicast and not globally unique */
-    addr[0] &= ~(0x01);
-    addr[0] |= 0x02;
-    cc2420_set_addr_short(dev, &addr[6]);
-    cc2420_set_addr_long(dev, addr);
+    cc2420_set_addr_short(dev, dev->netdev.short_addr);
+    cc2420_set_addr_long(dev, dev->netdev.long_addr);
     cc2420_set_chan(dev, CC2420_CHAN_DEFAULT);
     cc2420_set_txpower(dev, CC2420_TXPOWER_DEFAULT);
 
@@ -92,7 +89,6 @@ int cc2420_init(cc2420_t *dev)
     return 0;
 }
 
-
 bool cc2420_cca(cc2420_t *dev)
 {
     while (!(cc2420_status(dev) & CC2420_STATUS_RSSI_VALID)) {}
diff --git a/drivers/ccs811/include/ccs811_params.h b/drivers/ccs811/include/ccs811_params.h
index f872bea719..96a5e36d36 100644
--- a/drivers/ccs811/include/ccs811_params.h
+++ b/drivers/ccs811/include/ccs811_params.h
@@ -56,8 +56,8 @@ extern "C" {
 #define CCS811_PARAMS    { .i2c_dev   = CCS811_PARAM_I2C_DEV,  \
                            .i2c_addr  = CCS811_PARAM_I2C_ADDR, \
                            .mode      = CCS811_PARAM_MODE,     \
-                           .int_mode  = CCS811_PARAM_INT_MODE, \
                            .int_pin   = CCS811_PARAM_INT_PIN,  \
+                           .int_mode  = CCS811_PARAM_INT_MODE, \
                            .wake_pin  = CCS811_PARAM_WAKE_PIN, \
                            .reset_pin = CCS811_PARAM_RESET_PIN \
                          }
diff --git a/drivers/disp_dev/Kconfig b/drivers/disp_dev/Kconfig
index 7e8345d158..0b595a5f67 100644
--- a/drivers/disp_dev/Kconfig
+++ b/drivers/disp_dev/Kconfig
@@ -8,3 +8,4 @@
 config MODULE_DISP_DEV
     bool "Display device generic API"
     depends on TEST_KCONFIG
+    imply MODULE_AUTO_INIT_SCREEN
diff --git a/drivers/disp_dev/Makefile.dep b/drivers/disp_dev/Makefile.dep
new file mode 100644
index 0000000000..3a3b8f47e4
--- /dev/null
+++ b/drivers/disp_dev/Makefile.dep
@@ -0,0 +1 @@
+DEFAULT_MODULE += auto_init_screen
diff --git a/drivers/ethos/Makefile.include b/drivers/ethos/Makefile.include
new file mode 100644
index 0000000000..a078cd774b
--- /dev/null
+++ b/drivers/ethos/Makefile.include
@@ -0,0 +1,2 @@
+USEMODULE_INCLUDES_ethos := $(LAST_MAKEFILEDIR)/include
+USEMODULE_INCLUDES += $(USEMODULE_INCLUDES_ethos)
diff --git a/drivers/ethos/ethos.c b/drivers/ethos/ethos.c
index 1230af2617..630ee54526 100644
--- a/drivers/ethos/ethos.c
+++ b/drivers/ethos/ethos.c
@@ -26,11 +26,11 @@
 #include "periph/uart.h"
 #include "tsrb.h"
 #include "irq.h"
-#include "luid.h"
 
 #include "net/netdev.h"
 #include "net/netdev/eth.h"
 #include "net/eui64.h"
+#include "net/eui_provider.h"
 #include "net/ethernet.h"
 
 #ifdef USE_ETHOS_FOR_STDIO
@@ -53,8 +53,8 @@ static const netdev_driver_t netdev_driver_ethos;
 static const uint8_t _esc_esc[] = {ETHOS_ESC_CHAR, (ETHOS_ESC_CHAR ^ 0x20)};
 static const uint8_t _esc_delim[] = {ETHOS_ESC_CHAR, (ETHOS_FRAME_DELIMITER ^ 0x20)};
 
-
-void ethos_setup(ethos_t *dev, const ethos_params_t *params)
+void ethos_setup(ethos_t *dev, const ethos_params_t *params, uint8_t idx,
+                 void *inbuf, size_t inbuf_size)
 {
     dev->netdev.driver = &netdev_driver_ethos;
     dev->uart = params->uart;
@@ -64,10 +64,11 @@ void ethos_setup(ethos_t *dev, const ethos_params_t *params)
     dev->last_framesize = 0;
     dev->accept_new = true;
 
-    tsrb_init(&dev->inbuf, params->buf, params->bufsize);
+    tsrb_init(&dev->inbuf, inbuf, inbuf_size);
     mutex_init(&dev->out_mutex);
 
-    luid_get_eui48((eui48_t *) &dev->mac_addr);
+    netdev_register(&dev->netdev, NETDEV_ETHOS, idx);
+    netdev_eui48_get(&dev->netdev, (eui48_t *)&dev->mac_addr);
 
     uart_init(params->uart, params->baudrate, ethos_isr, (void*)dev);
 
diff --git a/drivers/ethos/include/ethos_params.h b/drivers/ethos/include/ethos_params.h
new file mode 100644
index 0000000000..3474149817
--- /dev/null
+++ b/drivers/ethos/include/ethos_params.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 Kaspar Schleiser <kaspar@schleiser.de>
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup drivers_ethos
+ * @{
+ *
+ * @file
+ * @brief       Default configuration for the ethos device driver
+ *
+ * @author      Kaspar Schleiser <kaspar@schleiser.de>
+ */
+#ifndef ETHOS_PARAMS_H
+#define ETHOS_PARAMS_H
+
+#include "board.h"
+#include "ethos.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ETHOS_PARAMS
+#define ETHOS_PARAMS        { .uart = ETHOS_UART,   \
+                              .baudrate = ETHOS_BAUDRATE }
+#endif
+/** @} */
+
+/**
+ * @brief   ethos configuration
+ *
+ * The first element in this array will be used to multiplex stdio if
+ * `stdio_ethos` is included.
+ */
+static const ethos_params_t ethos_params[] = {
+    ETHOS_PARAMS
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ETHOS_PARAMS_H */
+/** @} */
diff --git a/drivers/include/cc2420.h b/drivers/include/cc2420.h
index e48959e0dd..a954e08ab2 100644
--- a/drivers/include/cc2420.h
+++ b/drivers/include/cc2420.h
@@ -101,11 +101,13 @@ typedef struct {
  *
  * @param[out] dev          device descriptor
  * @param[in]  params       device parameters
+ * @param[in]  index        index of @p params in a global parameter struct array.
+ *                          If initialized manually, pass a unique identifier instead.
  *
  * @return                  0 on success
  * @return                  -1 on error
  */
-void cc2420_setup(cc2420_t *dev, const cc2420_params_t *params);
+void cc2420_setup(cc2420_t *dev, const cc2420_params_t *params, uint8_t index);
 
 /**
  * @brief   Initialize a given CC2420 device
diff --git a/drivers/include/ethos.h b/drivers/include/ethos.h
index 9b39b5b4ab..6a36f8e3e9 100644
--- a/drivers/include/ethos.h
+++ b/drivers/include/ethos.h
@@ -102,8 +102,6 @@ typedef struct {
 typedef struct {
     uart_t uart;            /**< UART device to use */
     uint32_t baudrate;      /**< baudrate to UART device */
-    uint8_t *buf;           /**< buffer for incoming packets */
-    size_t bufsize;         /**< size of ethos_params_t::buf */
 } ethos_params_t;
 
 /**
@@ -117,8 +115,13 @@ typedef struct {
  *
  * @param[out]  dev         handle of the device to initialize
  * @param[in]   params      parameters for device initialization
+ * @param[in]   index       Index of @p params in a global parameter struct array.
+ *                          If initialized manually, pass a unique identifier instead.
+ * @param[in]   inbuf       buffer to store a received frame in
+ * @param[in]   inbuf_size  size of the receive buffer
  */
-void ethos_setup(ethos_t *dev, const ethos_params_t *params);
+void ethos_setup(ethos_t *dev, const ethos_params_t *params, uint8_t index,
+                 void *inbuf, size_t inbuf_size);
 
 /**
  * @brief   Send frame over serial port using ethos' framing
diff --git a/drivers/include/lis2dh12.h b/drivers/include/lis2dh12.h
index 3d54c0013a..b7bb106f91 100644
--- a/drivers/include/lis2dh12.h
+++ b/drivers/include/lis2dh12.h
@@ -63,10 +63,10 @@ extern "C" {
  * @brief   Available scale values
  */
 typedef enum {
-    LIS2DH12_SCALE_2G  = 0x00,      /**< +- 2g */
-    LIS2DH12_SCALE_4G  = 0x10,      /**< +- 4g */
-    LIS2DH12_SCALE_8G  = 0x20,      /**< +- 8g */
-    LIS2DH12_SCALE_16G = 0x30,      /**< +- 16g */
+    LIS2DH12_SCALE_2G  = 0x0,       /**< +- 2g */
+    LIS2DH12_SCALE_4G  = 0x1,       /**< +- 4g */
+    LIS2DH12_SCALE_8G  = 0x2,       /**< +- 8g */
+    LIS2DH12_SCALE_16G = 0x3,       /**< +- 16g */
 } lis2dh12_scale_t;
 
 /**
@@ -74,28 +74,35 @@ typedef enum {
  *
  */
 typedef enum {
-    LIS2DH12_RATE_1HZ   = 0x1,      /**< sample with 1Hz @ all power modes */
-    LIS2DH12_RATE_10HZ  = 0x2,      /**< sample with 10Hz @ all power modes */
-    LIS2DH12_RATE_25HZ  = 0x3,      /**< sample with 25Hz @ all power modes */
-    LIS2DH12_RATE_50HZ  = 0x4,      /**< sample with 50Hz @ all power modes */
-    LIS2DH12_RATE_100HZ = 0x5,      /**< sample with 100Hz @ all power modes */
-    LIS2DH12_RATE_200HZ = 0x6,      /**< sample with 200Hz @ all power modes */
-    LIS2DH12_RATE_400HZ = 0x7,      /**< sample with 400Hz @ all power modes */
-    LIS2DH12_RATE_1620HZ = 0x8,     /**< sample with 1620HZ @ Low Power*/
+    LIS2DH12_RATE_1HZ   = 0x1,      /**< sample with 1Hz @ all resolutions */
+    LIS2DH12_RATE_10HZ  = 0x2,      /**< sample with 10Hz @ all resolutions */
+    LIS2DH12_RATE_25HZ  = 0x3,      /**< sample with 25Hz @ all resolutions */
+    LIS2DH12_RATE_50HZ  = 0x4,      /**< sample with 50Hz @ all resolutions */
+    LIS2DH12_RATE_100HZ = 0x5,      /**< sample with 100Hz @ all resolutions */
+    LIS2DH12_RATE_200HZ = 0x6,      /**< sample with 200Hz @ all resolutions */
+    LIS2DH12_RATE_400HZ = 0x7,      /**< sample with 400Hz @ all resolutions */
+    LIS2DH12_RATE_1620HZ = 0x8,     /**< sample with 1620HZ @ 8-bit */
     LIS2DH12_RATE_VERYHIGH = 0x9,   /**< sample with 1344Hz @ High resolution or \
-                                        5376Hz @ Low Power*/
+                                        5376Hz @ 8-bit */
 } lis2dh12_rate_t;
 
 /**
- * @brief   Available power modes
+ * @brief   Available resolutions
  *
  */
 typedef enum {
     LIS2DH12_POWER_DOWN   = 0,  /**< power down the device */
-    LIS2DH12_POWER_LOW    = 1,  /**< low power mode */
-    LIS2DH12_POWER_NORMAL = 2,  /**< normal mode */
-    LIS2DH12_POWER_HIGH   = 3,  /**< high resolution */
-} lis2dh12_powermode_t;
+    LIS2DH12_POWER_LOW    = 1,  /**< 8-bit  mode */
+    LIS2DH12_POWER_NORMAL = 2,  /**< 10-bit mode */
+    LIS2DH12_POWER_HIGH   = 3,  /**< 12-bit mode */
+} lis2dh12_resolution_t;
+
+#define LIS2DH12_CLICK_X_SINGLE (1 << 0)    /**< single click on X axis */
+#define LIS2DH12_CLICK_X_DOUBLE (1 << 1)    /**< double click on X axis */
+#define LIS2DH12_CLICK_Y_SINGLE (1 << 2)    /**< single click on Y axis */
+#define LIS2DH12_CLICK_Y_DOUBLE (1 << 3)    /**< double click on Y axis */
+#define LIS2DH12_CLICK_Z_SINGLE (1 << 4)    /**< single click on Z axis */
+#define LIS2DH12_CLICK_Z_DOUBLE (1 << 5)    /**< double click on Z axis */
 
 /**
  * @brief   LIS2DH12 configuration parameters
@@ -114,7 +121,7 @@ typedef struct {
 #endif
     lis2dh12_scale_t scale;         /**< sampling sensitivity used */
     lis2dh12_rate_t rate;           /**< sampling rate used */
-    lis2dh12_powermode_t powermode; /**< power mode used*/
+    lis2dh12_resolution_t resolution; /**< resolution used */
 } lis2dh12_params_t;
 
 /**
@@ -170,7 +177,6 @@ typedef struct {
  */
 typedef struct {
     const lis2dh12_params_t *p;     /**< device configuration */
-    uint8_t comp;                   /**< scale compensation factor */
 } lis2dh12_t;
 
 /**
@@ -185,7 +191,6 @@ enum {
     LIS2DH12_NODATA= -4,            /**< no data available */
 };
 
-#if MODULE_LIS2DH12_INT || DOXYGEN
 /*
  * @brief Interrupt lines
  */
@@ -204,18 +209,18 @@ typedef struct {
     uint8_t int_duration:7;         /**< time between two interrupts ODR section in CTRL_REG1,
                                         duration in range 0-127 */
     uint8_t int_type;               /**< values for type of interrupts */
-    gpio_cb_t cb;                   /**< the callback to execute */
-    void *arg;                      /**< the callback argument */
 } lis2dh12_int_params_t;
-#endif /* MODULE_LIS2DH12_INT */
 
 /**
  * @brief   LIS2DH12 FIFO data struct
  */
-typedef struct {
-    int16_t X_AXIS;    /**< X raw data in FIFO */
-    int16_t Y_AXIS;    /**< Y raw data in FIFO */
-    int16_t Z_AXIS;    /**< Z raw data in FIFO */
+typedef union {
+    struct {
+        int16_t x;                      /**< X data in mili-g */
+        int16_t y;                      /**< Y data in mili-g */
+        int16_t z;                      /**< Z data in mili-g */
+    } axis;                             /**< named axis access */
+    int16_t data[3];                    /**< x, y, z data in mili-g */
 } lis2dh12_fifo_data_t;
 
 /**
@@ -239,33 +244,74 @@ typedef struct {
 
 /**
  * @brief   Export the SAUL interface for this driver
+ * @{
  */
 extern const saul_driver_t lis2dh12_saul_driver;
+extern const saul_driver_t lis2dh12_saul_temp_driver;
+/** @} */
 
 #if MODULE_LIS2DH12_INT || DOXYGEN
 /**
- * @brief   Set the interrupt values in LIS2DH12 sensor device
+ * @brief   Configure a threshold event
+ *          An Interrupt will be generated if acceleration exceeds the set threshold
+ *          around the current reference value.
  *
- * @param[in] dev      device descriptor
- * @param[in] params   device interrupt configuration
- * @param[in] int_line number of interrupt line (LIS2DH12_INT1 or LIS2DH12_INT2)
+ * @param[in] dev       device descriptor
+ * @param[in] mg        acceleration in mg
+ * @param[in] us        time in µs for which the threshold must be exceeded
+ * @param[in] axis      bitmap of axis / events to be monitored
+ * @param[in] event     Event slot (1 or 2)
+ * @param[in] pin       Interrupt pin to use (LIS2DH12_INT1/LIS2DH12_INT2)
+ */
+void lis2dh12_cfg_threshold_event(const lis2dh12_t *dev,
+                                  uint32_t mg, uint32_t us,
+                                  uint8_t axis, uint8_t event, uint8_t pin);
+
+/**
+ * @brief   Configure a click event
+ *          A click event is generated when the acceleration exceeds the set threshold
+ *          for less than @p us_limit µs.
+ *          A double click event is generated if a second click event occurs within
+ *          @p us_window µs after the first one.
  *
- * @return  LIS2DH12_OK on success
- * @return  LIS2DH12_NOBUS on bus errors
+ * @param[in] dev       device descriptor
+ * @param[in] mg        acceleration in mg
+ * @param[in] us_limit  upper limit for click duration in µs
+ * @param[in] us_latency  dead time after click event in µs
+ * @param[in] us_window time after @p us_latency in which the second click event
+ *                      must occur to register as double click
+ * @param[in] click     bit map of click axis / types
+ * @param[in] pin       Interrupt pin to use (LIS2DH12_INT1/LIS2DH12_INT2)
  */
-int lis2dh12_set_int(const lis2dh12_t *dev, const lis2dh12_int_params_t *params, uint8_t int_line);
+void lis2dh12_cfg_click_event(const lis2dh12_t *dev, uint32_t mg,
+                              uint32_t us_limit, uint32_t us_latency, uint32_t us_window,
+                              uint8_t click, uint8_t pin);
 
 /**
- * @brief   Read an interrupt event on LIS2DH12 sensor device
+ * @brief   Disable interrupt generation for an event
+ *          This disables an interrupt on @p pin if a previously configured  event occurs
+ *
+ * @param[in] dev       device descriptor
+ * @param[in] event     Event to disable (LIS2DH12_EVENT_1, LIS2DH12_EVENT_2
+ *                      or LIS2DH12_EVENT_CLICK)
+ * @param[in] pin       Interrupt pin to use (LIS2DH12_INT1/LIS2DH12_INT2)
+ */
+void lis2dh12_cfg_disable_event(const lis2dh12_t *dev, uint8_t event, uint8_t pin);
+
+/**
+ * @brief   Wait for an interrupt event
+ *          This function will block until an interrupt is received
  *
  * @param[in] dev      device descriptor
- * @param[out] data    device interrupt data
- * @param[in] int_line number of interrupt line (LIS2DH12_INT1 or LIS2DH12_INT2)
+ * @param[in] pin      Interrupt pin to monitor (LIS2DH12_INT1 or LIS2DH12_INT2)
+ * @param[in] stale_events  If true, this also reports events that were generated
+ *                      before this function was called and which are still in the
+ *                      fifo buffer.
  *
- * @return  LIS2DH12_OK on success
- * @return  LIS2DH12_NOBUS on bus errors
+ * @return  negative error
+ * @return  positive LIS2DH12_INT_SRC bit mask on success
  */
-int lis2dh12_read_int_src(const lis2dh12_t *dev, uint8_t *data, uint8_t int_line);
+int lis2dh12_wait_event(const lis2dh12_t *dev, uint8_t pin, bool stale_events);
 #endif /* MODULE_LIS2DH12_INT */
 
 /**
@@ -291,16 +337,6 @@ int lis2dh12_set_fifo(const lis2dh12_t *dev, const lis2dh12_fifo_t *config);
  */
 int lis2dh12_restart_fifo(const lis2dh12_t *dev);
 
-/**
- * @brief   Read the FIFO source register
- *
- * @param[in] dev       device descriptor
- * @param[out] data     LIS2DH12_FIFO_SRC_REG_t content, allocate one byte
- *
- * @return  LIS2DH12_OK on success
- */
-int lis2dh12_read_fifo_src(const lis2dh12_t *dev, LIS2DH12_FIFO_SRC_REG_t *data);
-
 /**
  * @brief   This function will read a given number of data from FIFO
  *          reads amount of data that is available in FIFO
@@ -330,12 +366,27 @@ int lis2dh12_init(lis2dh12_t *dev, const lis2dh12_params_t *params);
  * @brief   Read acceleration data from the given device
  *
  * @param[in]  dev      device descriptor
- * @param[out] data     acceleration data in mili-g, **MUST** hold 3 values
+ * @param[out] data     acceleration data in mili-g
+ *
+ * @return  LIS2DH12_OK on success
+ * @return  LIS2DH12_NOBUS on bus error
+ */
+int lis2dh12_read(const lis2dh12_t *dev, lis2dh12_fifo_data_t *data);
+
+/**
+ * @brief   Read temperature data from the given device
+ *
+ * @note    The temperature sensor is not calibrated.
+ *          Temperature values are only relative to a device specific
+ *          reference.
+ *
+ * @param[in]  dev      device descriptor
+ * @param[out] temp     temperature data in centi-°C
  *
  * @return  LIS2DH12_OK on success
  * @return  LIS2DH12_NOBUS on bus error
  */
-int lis2dh12_read(const lis2dh12_t *dev, int16_t *data);
+int lis2dh12_read_temperature(const lis2dh12_t *dev, int16_t *temp);
 
 /**
  * @brief   Clear the LIS2DH12 memory, clears all sampled data
@@ -347,7 +398,7 @@ int lis2dh12_read(const lis2dh12_t *dev, int16_t *data);
 int lis2dh12_clear_data(const lis2dh12_t *dev);
 
 /**
- * @brief   Change device scale value
+ * @brief   Change device measuring range
  *
  * @param[in] dev       device descriptor
  * @param[in] scale     change to given scale value
@@ -357,80 +408,77 @@ int lis2dh12_clear_data(const lis2dh12_t *dev);
 int lis2dh12_set_scale(lis2dh12_t *dev, lis2dh12_scale_t scale);
 
 /**
- * @brief   Change device sampling rate
+ * @brief   Get device measuring range
  *
  * @param[in] dev       device descriptor
- * @param[in] rate      change to given sampling rate
  *
- * @return  LIS2DH12_OK on success
+ * @return  Current device range
  */
-int lis2dh12_set_datarate(const lis2dh12_t *dev, lis2dh12_rate_t rate);
+lis2dh12_scale_t lis2dh12_get_scale(lis2dh12_t *dev);
 
 /**
- * @brief   Change device power mode
+ * @brief   Change device sampling rate
  *
- * @param[in] dev           device descriptor
- * @param[in] powermode     change to given power mode
+ * @param[in] dev       device descriptor
+ * @param[in] rate      change to given sampling rate
  *
  * @return  LIS2DH12_OK on success
  */
-int lis2dh12_set_powermode(const lis2dh12_t *dev, lis2dh12_powermode_t powermode);
+int lis2dh12_set_datarate(const lis2dh12_t *dev, lis2dh12_rate_t rate);
 
 /**
- * @brief   Configures the high pass filter
+ * @brief   Get device sampling rate in Hz
  *
  * @param[in] dev       device descriptor
- * @param[in] config    device high pass configuration
  *
- * @return  LIS2DH12_OK on success
+ * @return  current sampling rate in Hz
  */
-int lis2dh12_set_highpass(const lis2dh12_t *dev, const lis2dh12_highpass_t *config);
+uint16_t lis2dh12_get_datarate(const lis2dh12_t *dev);
 
 /**
- * @brief   Set the reference value to control the high-pass reference.
- *          In LIS2DH12_HP_MODE_REFERENCE the reference value is used to filter data
- *          on all axis. Subtracts reference value from acceleration.
- *          Note: LSB changes according to LIS2DH12_SCALE
+ * @brief   Change device resolution
  *
  * @param[in] dev           device descriptor
- * @param[in] reference     reference value [8 Bit]
+ * @param[in] resolution    change to given resolution
  *
  * @return  LIS2DH12_OK on success
  */
-int lis2dh12_set_reference(const lis2dh12_t *dev, uint8_t reference);
+int lis2dh12_set_resolution(const lis2dh12_t *dev, lis2dh12_resolution_t resolution);
 
 /**
- * @brief   Read the reference value
+ * @brief   Get device resolution
  *
- * @param[in] dev       device descriptor
- * @param[out] data     reference value read from device
+ * @param[in] dev           device descriptor
  *
- * @return  LIS2DH12_OK on success
+ * @return  Current device resolution settings
  */
-int lis2dh12_read_reference(const lis2dh12_t *dev, uint8_t *data);
+lis2dh12_resolution_t lis2dh12_get_resolution(const lis2dh12_t *dev);
 
 /**
- * @brief   Set click configuration
+ * @brief   Configures the high pass filter
  *
  * @param[in] dev       device descriptor
- * @param[in] config    device click configuration
+ * @param[in] config    device high pass configuration
  *
  * @return  LIS2DH12_OK on success
  */
-int lis2dh12_set_click(const lis2dh12_t *dev, const lis2dh12_click_t *config);
+int lis2dh12_set_highpass(const lis2dh12_t *dev, const lis2dh12_highpass_t *config);
 
 /**
- * @brief   Read click source register
+ * @brief   Set the reference value to control the high-pass reference.
+ *          In LIS2DH12_HP_MODE_REFERENCE the reference value is used to filter data
+ *          on all axis. Subtracts reference value from acceleration.
+ *          Note: LSB changes according to LIS2DH12_SCALE
  *
- * @param[in] dev       device descriptor
- * @param[out] data     LIS2DH12_CLICK_SRC_t content, allocate one byte
+ * @param[in] dev           device descriptor
+ * @param[in] reference     reference value [8 Bit]
  *
  * @return  LIS2DH12_OK on success
  */
-int lis2dh12_read_click_src(const lis2dh12_t *dev, LIS2DH12_CLICK_SRC_t *data);
+int lis2dh12_set_reference(const lis2dh12_t *dev, uint8_t reference);
 
 /**
- * @brief   Power on the given device and resets power mode and sampling rate
+ * @brief   Power on the given device and resets resolution and sampling rate
  *          to default values in the device descriptor parameters
  *
  * @param[in] dev       device descriptor
diff --git a/drivers/include/net/netdev.h b/drivers/include/net/netdev.h
index 588326c28a..9eb79a185e 100644
--- a/drivers/include/net/netdev.h
+++ b/drivers/include/net/netdev.h
@@ -319,6 +319,9 @@ typedef enum {
     NETDEV_NRF24L01P_NG,
     NETDEV_SOCKET_ZEP,
     NETDEV_SX126X,
+    NETDEV_CC2420,
+    NETDEV_ETHOS,
+    NETDEV_SLIPDEV,
     /* add more if needed */
 } netdev_type_t;
 /** @} */
diff --git a/drivers/include/net/netdev/ieee802154.h b/drivers/include/net/netdev/ieee802154.h
index 7af8c5dd90..5b06d025c1 100644
--- a/drivers/include/net/netdev/ieee802154.h
+++ b/drivers/include/net/netdev/ieee802154.h
@@ -67,6 +67,13 @@ extern "C" {
  * @}
  */
 
+ /**
+ * @name    Flags for use in @ref netdev_ieee802154_rx_info::flags
+ * @{
+ */
+#define NETDEV_RX_IEEE802154_INFO_FLAG_TIMESTAMP       (0x01)  /**< Timestamp valid */
+/** @} */
+
 /**
  * @brief   Option parameter to be used with @ref NETOPT_CCA_MODE to set
  *          the mode of the clear channel assessment (CCA) defined
@@ -119,7 +126,7 @@ typedef struct {
     uint8_t page;                           /**< channel page */
     uint16_t flags;                         /**< flags as defined above */
     int16_t txpower;                        /**< tx power in dBm */
-#if IS_USED(MODULE_IEEE802154_SECURITY) || defined (Doxygen)
+#if IS_USED(MODULE_IEEE802154_SECURITY) || defined(DOXYGEN)
     ieee802154_sec_context_t sec_ctx;       /**< security context */
 #endif
     /** @} */
@@ -128,7 +135,15 @@ typedef struct {
 /**
  * @brief   Received packet status information for IEEE 802.15.4 radios
  */
-typedef struct netdev_radio_rx_info netdev_ieee802154_rx_info_t;
+typedef struct netdev_ieee802154_rx_info {
+    uint64_t timestamp;     /**< Timestamp value of a received frame in ns */
+    int16_t rssi;           /**< RSSI of a received frame in dBm */
+    uint8_t lqi;            /**< LQI of a received frame */
+    uint8_t flags;          /**< Flags e.g. used to mark other fields as valid */
+#if IS_USED(MODULE_SOCK_AUX_TIMESTAP)
+    uint64_t timestamp;     /**< Timestamp value of a received frame in ns */
+#endif
+} netdev_ieee802154_rx_info_t;
 
 /**
  * @brief   Reset function for ieee802154 common fields
@@ -193,6 +208,9 @@ int netdev_ieee802154_set(netdev_ieee802154_t *dev, netopt_t opt, const void *va
  * this function is meant top be used by drivers that do not support address
  * filtering in hw
  *
+ * @deprecated  This function is currently deprecated and will be removed
+ * after Release 2022.01. Use @ref ieee802154_dst_filter instead.
+ *
  * @param[in] dev       network device descriptor
  * @param[in] mhr       mac header
  *
diff --git a/drivers/include/nrf24l01p_ng.h b/drivers/include/nrf24l01p_ng.h
index e0a361e8d8..4b3a873659 100644
--- a/drivers/include/nrf24l01p_ng.h
+++ b/drivers/include/nrf24l01p_ng.h
@@ -424,6 +424,17 @@ int nrf24l01p_ng_set_state(nrf24l01p_ng_t *dev, nrf24l01p_ng_state_t state);
  */
 nrf24l01p_ng_state_t nrf24l01p_ng_get_state(const nrf24l01p_ng_t *dev);
 
+/**
+ * @brief   Retrieve a unique layer-2 address for an nrf24l01p_ng instance
+ *
+ * @note    This function has __attribute__((weak)) so you can override this, e.g.
+ *          to construct an address. By default @ref luid_get_lb is used.
+ *
+ * @param[in]   dev     The device descriptor of the transceiver
+ * @param[out]  eui     Destination to write the address to
+ */
+void nrf24l01p_ng_eui_get(const netdev_t *dev, uint8_t *eui);
+
 #if IS_USED(MODULE_NRF24L01P_NG_DIAGNOSTICS)
 /**
  * @brief Get state variable as a string
diff --git a/drivers/include/pcd8544.h b/drivers/include/pcd8544.h
index 764a8b59fb..66a63983f5 100644
--- a/drivers/include/pcd8544.h
+++ b/drivers/include/pcd8544.h
@@ -122,6 +122,32 @@ void pcd8544_set_bias(const pcd8544_t *dev, uint8_t bias);
  */
 void pcd8544_write_img(const pcd8544_t *dev, const uint8_t img[]);
 
+/**
+ * @brief   Sets a single stackedpixel on the display
+ *
+ * The position of the 8 stacked pixels is specified in columns (x) and rows (y)
+ * Writes 8 pixels that are defined in data to the memory of the display
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] x             column_px absolute position to write pixel [0 - 83]
+ * @param[in] y             row from display to write pixel [0 - 5]
+ * @param[in] data          definition of 8 stacked pixels (y direction)
+ */
+void pcd8544_write_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data);
+
+/**
+ * @brief   Removes a single stackedpixel on the display
+ *
+ * The position of the 8 stacked pixels is specified in columns (x) and rows (y)
+ * Clears 8 pixels that are defined in data to the memory of the display
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] x             column_px absolute position to clear pixel [0 - 83]
+ * @param[in] y             row from display to clear pixel [0 - 5]
+ * @param[in] data          definition of 8 stacked pixels (y direction)
+ */
+void pcd8544_clear_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data);
+
 /**
  * @brief   Write a single ASCII character to the display
  *
@@ -149,6 +175,20 @@ void pcd8544_write_c(const pcd8544_t *dev, uint8_t x, uint8_t y, const char c);
  */
 void pcd8544_write_s(const pcd8544_t *dev, uint8_t x, uint8_t y, const char* str);
 
+/**
+ * @brief   Write a line to a given row on the display
+ *
+ * This function prints a given string to the given row and overwrites the rest with
+ * spaces. The position is given in terms of rows (y). If a string does not
+ * fit completely in the given position (it overflows its row), the overflowing
+ * part of the string is cut off.
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] y             row to write the string to [0 - 5]
+ * @param[in] str           string to write to the display
+ */
+void pcd8544_write_l(const pcd8544_t *dev, uint8_t y, const char* str);
+
 /**
  * @brief   Clear the current display (clear the display memory)
  *
diff --git a/drivers/include/periph/flashpage.h b/drivers/include/periph/flashpage.h
index 9080e3336c..25a3ce893f 100644
--- a/drivers/include/periph/flashpage.h
+++ b/drivers/include/periph/flashpage.h
@@ -105,6 +105,30 @@ extern "C" {
 #define PERIPH_FLASHPAGE_CUSTOM_PAGESIZES
 #endif
 
+/**
+ * @def     PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_ADDR
+ *
+ * @brief   If non-uniform flash page sizes are required, defined to signal
+ *          that the peripheral does not implement a custom @ref flashpage_addr
+ *          function and instead relies on the generic helper function that
+ *          relies on @ref flashpage_size.
+ */
+#ifdef DOXYGEN
+#define PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_ADDR
+#endif
+
+/**
+ * @def     PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_PAGE
+ *
+ * @brief   If non-uniform flash page sizes are required, defined to signal
+ *          that the peripheral does not implement a custom @ref flashpage_page
+ *          function and instead relies on the generic helper function that
+ *          relies on @ref flashpage_size.
+ */
+#ifdef DOXYGEN
+#define PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_PAGE
+#endif
+
 /**
  * @brief   Return values used in this interface
  */
diff --git a/drivers/include/periph/rtc.h b/drivers/include/periph/rtc.h
index 9a424fecc7..0071711999 100644
--- a/drivers/include/periph/rtc.h
+++ b/drivers/include/periph/rtc.h
@@ -90,6 +90,19 @@ int rtc_set_time(struct tm *time);
  */
 int rtc_get_time(struct tm *time);
 
+/**
+ * @brief Get current RTC time with sub-second component.
+ *        Requires the `periph_rtc_ms` feature.
+ *
+ * @param[out] time         Pointer to the struct to write the time to.
+ * @param[out] ms           Pointer to a variable to hold the microsecond
+ *                          component of the current RTC time.
+ *
+ * @return  0 for success
+ * @return -1 an error occurred
+ */
+int rtc_get_time_ms(struct tm *time, uint16_t *ms);
+
 /**
  * @brief Set an alarm for RTC to the specified value.
  *
diff --git a/drivers/include/si70xx.h b/drivers/include/si70xx.h
index 9d19286e0d..5fbbd6ffec 100644
--- a/drivers/include/si70xx.h
+++ b/drivers/include/si70xx.h
@@ -7,10 +7,19 @@
  */
 
 /**
- * @defgroup    drivers_si70xx Si7006/13/20/21 temperature and humidity sensors
+ * @defgroup    drivers_si70xx Si7006/13/20/21/5x temperature and humidity sensors
  * @ingroup     drivers_sensors
  * @ingroup     drivers_saul
- * @brief       Driver for the Si7006/13/20/21 temperature and humidity sensor
+ * @brief       Driver for the Si7006/13/20/21/5x temperature and humidity sensor
+ *
+ * The Si70xx driver supports a range of similar temperature and humidity
+ * sensors from Silicon Labs.
+ *
+ * The Si7006/13/20/21 sensors support both temperature and relative humidity
+ * reading, while the Si7050/1/3/4/5 sensors only provide a temperature reading
+ * varying in accuracy between +/- 0.1 C to +/- 1.0 C depending on the model.
+ *
+ * For any of the Si705x models, use the pseudo module @p si705x.
  *
  * This driver provides @ref drivers_saul capabilities.
  * @{
@@ -30,6 +39,17 @@
 extern "C" {
 #endif
 
+/**
+ * @brief Compile time macro telling whether the chip has a humidity sensor.
+ */
+#if MODULE_SI7050 || MODULE_SI7051 || MODULE_SI7053 || MODULE_SI7054 || \
+    MODULE_SI7055
+/* Si705x sensors don't have a humidity sensor hardware, only temperature. */
+#define SI70XX_HAS_HUMIDITY_SENSOR 0
+#else
+#define SI70XX_HAS_HUMIDITY_SENSOR 1
+#endif
+
 /**
  * @brief Driver return codes
  */
@@ -67,13 +87,17 @@ typedef struct {
  */
 int si70xx_init(si70xx_t *dev, const si70xx_params_t *params);
 
+#if SI70XX_HAS_HUMIDITY_SENSOR || DOXYGEN
 /**
  * @brief   Read the relative humidity from the sensor. Uses clock stretching.
  *
+ * This function is only available in models that have a humidity sensor.
+ *
  * @param[in] dev           device descriptor
  * @return                  relative humidity in centi-percent (times 100)
  */
 uint16_t si70xx_get_relative_humidity(const si70xx_t *dev);
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR || DOXYGEN */
 
 /**
  * @brief   Read the current temperature from the sensor. Uses clock stretching.
@@ -84,15 +108,19 @@ uint16_t si70xx_get_relative_humidity(const si70xx_t *dev);
  */
 int16_t si70xx_get_temperature(const si70xx_t *dev);
 
+#if SI70XX_HAS_HUMIDITY_SENSOR || DOXYGEN
 /**
  * @brief   Read the relative humidity and temperature from the sensor. Uses
  *          clock stretching.
  *
+ * This function is only available in models that have a humidity sensor.
+ *
  * @param[in] dev           device descriptor
  * @param[out] humidity     pointer to relative humidity (in centi-percent)
  * @param[out] temperature  pointer to temperature (in centi-degrees Celsius)
  */
 void si70xx_get_both(const si70xx_t *dev, uint16_t *humidity, int16_t *temperature);
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR || DOXYGEN */
 
 /**
  * @brief   Read the sensor serial number.
diff --git a/drivers/include/slipdev.h b/drivers/include/slipdev.h
index 1e304cd1a6..9c9c6984b6 100644
--- a/drivers/include/slipdev.h
+++ b/drivers/include/slipdev.h
@@ -105,8 +105,10 @@ typedef struct {
  *
  * @param[in] dev       device descriptor
  * @param[in] params    parameters for device initialization
+ * @param[in] index     index of @p params in a global parameter struct array.
+ *                      If initialized manually, pass a unique identifier instead.
  */
-void slipdev_setup(slipdev_t *dev, const slipdev_params_t *params);
+void slipdev_setup(slipdev_t *dev, const slipdev_params_t *params, uint8_t index);
 
 #ifdef __cplusplus
 }
diff --git a/drivers/include/soft_uart.h b/drivers/include/soft_uart.h
index 032ae4099b..e338cc45b6 100644
--- a/drivers/include/soft_uart.h
+++ b/drivers/include/soft_uart.h
@@ -23,7 +23,7 @@
  * @file
  * @brief       Software UART port descriptor definition
  *
- * @author      Benjamin Valentin <benjjamin.valentin@ml-pa.com>
+ * @author      Benjamin Valentin <benjamin.valentin@ml-pa.com>
  */
 
 #ifndef SOFT_UART_H
diff --git a/drivers/include/sx127x.h b/drivers/include/sx127x.h
index 8871685213..bddce07705 100644
--- a/drivers/include/sx127x.h
+++ b/drivers/include/sx127x.h
@@ -86,13 +86,13 @@ extern "C" {
 #define SX127X_RX_BUFFER_SIZE            (256)                  /**< RX buffer size */
 #define SX127X_RADIO_TX_POWER            (14U)                  /**< Radio power in dBm */
 
-#define SX127X_EVENT_HANDLER_STACK_SIZE  (2048U) /**< Stack size event handler */
-#define SX127X_IRQ_DIO0                  (1<<0)  /**< DIO0 IRQ */
-#define SX127X_IRQ_DIO1                  (1<<1)  /**< DIO1 IRQ */
-#define SX127X_IRQ_DIO2                  (1<<2)  /**< DIO2 IRQ */
-#define SX127X_IRQ_DIO3                  (1<<3)  /**< DIO3 IRQ */
-#define SX127X_IRQ_DIO4                  (1<<4)  /**< DIO4 IRQ */
-#define SX127X_IRQ_DIO5                  (1<<5)  /**< DIO5 IRQ */
+#define SX127X_EVENT_HANDLER_STACK_SIZE  (2048U)                /**< Stack size event handler */
+#define SX127X_IRQ_DIO0                  (1 << 0)               /**< DIO0 IRQ */
+#define SX127X_IRQ_DIO1                  (1 << 1)               /**< DIO1 IRQ */
+#define SX127X_IRQ_DIO2                  (1 << 2)               /**< DIO2 IRQ */
+#define SX127X_IRQ_DIO3                  (1 << 3)               /**< DIO3 IRQ */
+#define SX127X_IRQ_DIO4                  (1 << 4)               /**< DIO4 IRQ */
+#define SX127X_IRQ_DIO5                  (1 << 5)               /**< DIO5 IRQ */
 /** @} */
 
 /**
@@ -112,41 +112,41 @@ extern "C" {
  * @brief   SX127X initialization result.
  */
 enum {
-    SX127X_INIT_OK = 0,                /**< Initialization was successful */
-    SX127X_ERR_SPI,                    /**< Failed to initialize SPI bus or CS line */
-    SX127X_ERR_GPIOS,                  /**< Failed to initialize GPIOs */
-    SX127X_ERR_NODEV                   /**< No valid device version found */
+    SX127X_INIT_OK = 0,                 /**< Initialization was successful */
+    SX127X_ERR_SPI,                     /**< Failed to initialize SPI bus or CS line */
+    SX127X_ERR_GPIOS,                   /**< Failed to initialize GPIOs */
+    SX127X_ERR_NODEV                    /**< No valid device version found */
 };
 
 /**
  * @brief   Radio driver supported modems.
  */
 enum {
-    SX127X_MODEM_FSK = 0,              /**< FSK modem driver */
-    SX127X_MODEM_LORA,                 /**< LoRa modem driver */
+    SX127X_MODEM_FSK = 0,               /**< FSK modem driver */
+    SX127X_MODEM_LORA,                  /**< LoRa modem driver */
 };
 
 /**
  * @brief   Radio driver internal state machine states definition.
  */
 enum {
-    SX127X_RF_IDLE = 0,                /**< Idle state */
-    SX127X_RF_RX_RUNNING,              /**< Sending state */
-    SX127X_RF_TX_RUNNING,              /**< Receiving state */
-    SX127X_RF_CAD,                     /**< Channel activity detection state */
+    SX127X_RF_IDLE = 0,                 /**< Idle state */
+    SX127X_RF_RX_RUNNING,               /**< Sending state */
+    SX127X_RF_TX_RUNNING,               /**< Receiving state */
+    SX127X_RF_CAD,                      /**< Channel activity detection state */
 };
 
 /**
  * @brief   Event types.
  */
 enum {
-    SX127X_RX_DONE = 0,                /**< Receiving complete */
-    SX127X_TX_DONE,                    /**< Sending complete*/
-    SX127X_RX_TIMEOUT,                 /**< Receiving timeout */
-    SX127X_TX_TIMEOUT,                 /**< Sending timeout */
-    SX127X_RX_ERROR_CRC,               /**< Receiving CRC error */
-    SX127X_FHSS_CHANGE_CHANNEL,        /**< Channel change */
-    SX127X_CAD_DONE,                   /**< Channel activity detection complete */
+    SX127X_RX_DONE = 0,                 /**< Receiving complete */
+    SX127X_TX_DONE,                     /**< Sending complete*/
+    SX127X_RX_TIMEOUT,                  /**< Receiving timeout */
+    SX127X_TX_TIMEOUT,                  /**< Sending timeout */
+    SX127X_RX_ERROR_CRC,                /**< Receiving CRC error */
+    SX127X_FHSS_CHANGE_CHANNEL,         /**< Channel change */
+    SX127X_CAD_DONE,                    /**< Channel activity detection complete */
 };
 
 /**
@@ -157,8 +157,8 @@ enum {
  * The power amplifier mode depends on the module hardware configuration.
  */
 enum {
-    SX127X_PA_RFO = 0,                 /**< RFO HF or RFO LF */
-    SX127X_PA_BOOST,                   /**< Power amplifier boost (high power) */
+    SX127X_PA_RFO = 0,                  /**< RFO HF or RFO LF */
+    SX127X_PA_BOOST,                    /**< Power amplifier boost (high power) */
 };
 
 /**
@@ -177,25 +177,25 @@ enum {
  * @brief   LoRa configuration structure.
  */
 typedef struct {
-    uint16_t preamble_len;             /**< Length of preamble header */
-    int8_t power;                      /**< Signal power */
-    uint8_t bandwidth;                 /**< Signal bandwidth */
-    uint8_t datarate;                  /**< Spreading factor rate, e.g datarate */
-    uint8_t coderate;                  /**< Error coding rate */
-    uint8_t freq_hop_period;           /**< Frequency hop period */
-    uint8_t flags;                     /**< Boolean flags */
-    uint32_t rx_timeout;               /**< RX timeout in milliseconds */
-    uint32_t tx_timeout;               /**< TX timeout in milliseconds */
+    uint16_t preamble_len;              /**< Length of preamble header */
+    int8_t power;                       /**< Signal power */
+    uint8_t bandwidth;                  /**< Signal bandwidth */
+    uint8_t datarate;                   /**< Spreading factor rate, e.g datarate */
+    uint8_t coderate;                   /**< Error coding rate */
+    uint8_t freq_hop_period;            /**< Frequency hop period */
+    uint8_t flags;                      /**< Boolean flags */
+    uint32_t rx_timeout;                /**< RX timeout in milliseconds */
+    uint32_t tx_timeout;                /**< TX timeout in milliseconds */
 } sx127x_lora_settings_t;
 
 /**
  * @brief   Radio settings.
  */
 typedef struct {
-    uint32_t channel;                  /**< Radio channel */
-    uint8_t state;                     /**< Radio state */
-    uint8_t modem;                     /**< Driver model (FSK or LoRa) */
-    sx127x_lora_settings_t lora;       /**< LoRa settings */
+    uint32_t channel;                   /**< Radio channel */
+    uint8_t state;                      /**< Radio state */
+    uint8_t modem;                      /**< Driver model (FSK or LoRa) */
+    sx127x_lora_settings_t lora;        /**< LoRa settings */
 } sx127x_radio_settings_t;
 
 /**
@@ -203,30 +203,30 @@ typedef struct {
  */
 typedef struct {
     /* Data that will be passed to events handler in application */
-    ztimer_t tx_timeout_timer;         /**< TX operation timeout timer */
-    ztimer_t rx_timeout_timer;         /**< RX operation timeout timer */
-    uint32_t last_channel;             /**< Last channel in frequency hopping sequence */
-    bool is_last_cad_success;          /**< Sign of success of last CAD operation (activity detected) */
+    ztimer_t tx_timeout_timer;          /**< TX operation timeout timer */
+    ztimer_t rx_timeout_timer;          /**< RX operation timeout timer */
+    uint32_t last_channel;              /**< Last channel in frequency hopping sequence */
+    bool is_last_cad_success;           /**< Sign of success of last CAD operation (activity detected) */
 } sx127x_internal_t;
 
 /**
  * @brief   SX127X hardware and global parameters.
  */
 typedef struct {
-    spi_t spi;                         /**< SPI device */
-    gpio_t nss_pin;                    /**< SPI NSS pin */
-    gpio_t reset_pin;                  /**< Reset pin */
-    gpio_t dio0_pin;                   /**< Interrupt line DIO0 (Tx done) */
-    gpio_t dio1_pin;                   /**< Interrupt line DIO1 (Rx timeout) */
-    gpio_t dio2_pin;                   /**< Interrupt line DIO2 (FHSS channel change) */
-    gpio_t dio3_pin;                   /**< Interrupt line DIO3 (CAD done) */
-    gpio_t dio4_pin;                   /**< Interrupt line DIO4 (not used) */
-    gpio_t dio5_pin;                   /**< Interrupt line DIO5 (not used) */
+    spi_t spi;                          /**< SPI device */
+    gpio_t nss_pin;                     /**< SPI NSS pin */
+    gpio_t reset_pin;                   /**< Reset pin */
+    gpio_t dio0_pin;                    /**< Interrupt line DIO0 (Tx done) */
+    gpio_t dio1_pin;                    /**< Interrupt line DIO1 (Rx timeout) */
+    gpio_t dio2_pin;                    /**< Interrupt line DIO2 (FHSS channel change) */
+    gpio_t dio3_pin;                    /**< Interrupt line DIO3 (CAD done) */
+    gpio_t dio4_pin;                    /**< Interrupt line DIO4 (not used) */
+    gpio_t dio5_pin;                    /**< Interrupt line DIO5 (not used) */
 #if defined(SX127X_USE_TX_SWITCH) || defined(SX127X_USE_RX_SWITCH)
-    gpio_t rx_switch_pin;              /**< Rx antenna switch */
-    gpio_t tx_switch_pin;              /**< Tx antenna switch */
+    gpio_t rx_switch_pin;               /**< Rx antenna switch */
+    gpio_t tx_switch_pin;               /**< Tx antenna switch */
 #endif
-    uint8_t paselect;                  /**< Power amplifier mode (RFO or PABOOST) */
+    uint8_t paselect;                   /**< Power amplifier mode (RFO or PABOOST) */
 } sx127x_params_t;
 
 /**
@@ -239,11 +239,11 @@ typedef uint8_t sx127x_flags_t;
  * @extends netdev_t
  */
 typedef struct {
-    netdev_t netdev;                   /**< Netdev parent struct */
-    sx127x_radio_settings_t settings;  /**< Radio settings */
-    sx127x_params_t params;            /**< Device driver parameters */
-    sx127x_internal_t _internal;       /**< Internal sx127x data used within the driver */
-    sx127x_flags_t irq;                /**< Device IRQ flags */
+    netdev_t netdev;                    /**< Netdev parent struct */
+    sx127x_radio_settings_t settings;   /**< Radio settings */
+    sx127x_params_t params;             /**< Device driver parameters */
+    sx127x_internal_t _internal;        /**< Internal sx127x data used within the driver */
+    sx127x_flags_t irq;                 /**< Device IRQ flags */
 } sx127x_t;
 
 /**
diff --git a/drivers/lis2dh12/include/lis2dh12_params.h b/drivers/lis2dh12/include/lis2dh12_params.h
index 1a57f400b6..14f284df5e 100644
--- a/drivers/lis2dh12/include/lis2dh12_params.h
+++ b/drivers/lis2dh12/include/lis2dh12_params.h
@@ -67,8 +67,8 @@ extern "C" {
 #ifndef LIS2DH12_PARAM_RATE
 #define LIS2DH12_PARAM_RATE         LIS2DH12_RATE_100HZ
 #endif
-#ifndef LIS2DH12_PARAM_POWERMODE
-#define LIS2DH12_PARAM_POWERMODE    LIS2DH12_POWER_NORMAL
+#ifndef LIS2DH12_PARAM_RESOLUTION
+#define LIS2DH12_PARAM_RESOLUTION   LIS2DH12_POWER_NORMAL
 #endif
 
 #ifndef LIS2DH12_PARAMS
@@ -79,14 +79,14 @@ extern "C" {
                                     .int2_pin = LIS2DH12_PARAM_INT_PIN2,  \
                                     .scale = LIS2DH12_PARAM_SCALE,  \
                                     .rate  = LIS2DH12_PARAM_RATE,  \
-                                    .powermode = LIS2DH12_PARAM_POWERMODE,  \
+                                    .resolution = LIS2DH12_PARAM_RESOLUTION,  \
                                 }
 #else /* MODULE_LIS2DH12_INT */
 #define LIS2DH12_PARAMS         {  \
                                     LIS2DH12_PARAMS_BUSCFG,  \
                                     .scale = LIS2DH12_PARAM_SCALE,  \
                                     .rate  = LIS2DH12_PARAM_RATE,  \
-                                    .powermode = LIS2DH12_PARAM_POWERMODE,  \
+                                    .resolution = LIS2DH12_PARAM_RESOLUTION,  \
                                 }
 #endif /* MODULE_LIS2DH12_INT */
 #endif /* LIS2DH12_PARAMS */
diff --git a/drivers/lis2dh12/include/lis2dh12_registers.h b/drivers/lis2dh12/include/lis2dh12_registers.h
index 893714a2af..530434f285 100644
--- a/drivers/lis2dh12/include/lis2dh12_registers.h
+++ b/drivers/lis2dh12/include/lis2dh12_registers.h
@@ -33,6 +33,14 @@ enum {
     LIS2DH12_STATUS_REG_AUX_TOR = 0x40,   /**< Temperature data overrun */
 };
 
+/**
+ * @brief   STATUS_REG_TEMP definitions
+ */
+enum {
+    LIS2DH12_TEMP_CFG_REG_DISABLE = 0x00, /**< Temperature sensor disable */
+    LIS2DH12_TEMP_CFG_REG_ENABLE  = 0xC0, /**< Temperature sensor enable  */
+};
+
 /**
  * @brief   STATUS_REG definitions
  */
@@ -94,8 +102,36 @@ enum {
     LIS2DH12_INT_TYPE_I2_IA2       = 0x20, /**< IA2 on INT2 */
     LIS2DH12_INT_TYPE_I2_IA1       = 0x40, /**< IA1 on INT2 */
     LIS2DH12_INT_TYPE_I2_CLICK     = 0x80, /**< click interrupt on INT2 */
+
+    LIS2DH12_INT_TYPE_IA2          = 0x20, /**< Event 2 */
+    LIS2DH12_INT_TYPE_IA1          = 0x40, /**< Event 1 */
+    LIS2DH12_INT_TYPE_CLICK        = 0x80, /**< click interrupt */
+};
+
+/**
+ * @brief   Event slots
+ */
+enum {
+    LIS2DH12_EVENT_1               = 0x1, /**< first event slot */
+    LIS2DH12_EVENT_2               = 0x2, /**< second event slot */
+    LIS2DH12_EVENT_CLICK           = 0x3, /**< click event */
 };
 
+/**
+ * @brief   Extract interrupt flags for Event Slot 1
+ */
+#define LIS2DH12_INT_SRC_1(ret)     (((uint32_t)(ret) >>  0) & 0x7F)
+
+/**
+ * @brief   Extract interrupt flags for Event Slot 2
+ */
+#define LIS2DH12_INT_SRC_2(ret)     (((uint32_t)(ret) >>  8) & 0x7F)
+
+/**
+ * @brief   Extract interrupt flags for Click Event
+ */
+#define LIS2DH12_INT_SRC_CLICK(ret) (((uint32_t)(ret) >> 16) & 0x7F)
+
 /**
  * @brief   CLICK_SRC definitions
  */
@@ -169,6 +205,13 @@ typedef union {
     uint8_t reg;        /**< Type used for register access */
 } LIS2DH12_CTRL_REG1_t;
 
+#define LIS2DH12_CTRL_REG2_HP_IA1   (1 << 0)
+#define LIS2DH12_CTRL_REG2_HP_IA2   (1 << 1)
+#define LIS2DH12_CTRL_REG2_HPCLICK  (1 << 2)
+#define LIS2DH12_CTRL_REG2_FDS      (1 << 3)
+
+#define LIS2DH12_CLICK_THS_LIR      (0x80)
+
 /**
  * @brief   CTRL_REG2 definitions
  */
diff --git a/drivers/lis2dh12/lis2dh12.c b/drivers/lis2dh12/lis2dh12.c
index 4126e512d1..963eb9be4c 100644
--- a/drivers/lis2dh12/lis2dh12.c
+++ b/drivers/lis2dh12/lis2dh12.c
@@ -14,10 +14,16 @@
  * @brief       LIS2DH12 accelerometer driver implementation
  *
  * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>
+ * @author      Jan Mohr <jan.mohr@ml-pa.com>
+ * @author      Benjamin Valentin <benjamin.valentin@ml-pa.com>
  * @}
  */
 
 #include "assert.h"
+#include "byteorder.h"
+#include "mutex.h"
+#include "timex.h"
+#include "xtimer.h"
 
 #include "lis2dh12.h"
 #include "lis2dh12_internal.h"
@@ -113,8 +119,7 @@ static uint8_t _read(const lis2dh12_t *dev, uint8_t reg)
     return tmp;
 }
 
-static void _read_burst(const lis2dh12_t *dev, uint8_t reg,
-                              void *data, size_t len)
+static void _read_burst(const lis2dh12_t *dev, uint8_t reg, void *data, size_t len)
 {
     i2c_read_regs(BUS, ADDR, (FLAG_AINC | reg), data, len, 0);
 }
@@ -127,13 +132,17 @@ static void _write(const lis2dh12_t *dev, uint8_t reg, uint8_t data)
 
 #endif  /* MODULE_LIS2DH12_SPI */
 
+static void _write_or(const lis2dh12_t *dev, uint8_t reg, uint8_t data)
+{
+    data |= _read(dev, reg);
+    _write(dev, reg, data);
+}
+
 int lis2dh12_init(lis2dh12_t *dev, const lis2dh12_params_t *params)
 {
     assert(dev && params);
 
     dev->p = params;
-    /* calculate shift amount to convert raw acceleration data */
-    dev->comp = 4 - (dev->p->scale >> 4);
 
     /* initialize the chip select line */
     if (_init_bus(dev) != LIS2DH12_OK) {
@@ -141,6 +150,15 @@ int lis2dh12_init(lis2dh12_t *dev, const lis2dh12_params_t *params)
         return LIS2DH12_NOBUS;
     }
 
+    /* set resolution */
+    lis2dh12_set_resolution(dev, dev->p->resolution);
+
+    /* clear stale data */
+    lis2dh12_clear_data(dev);
+
+    /* set data range */
+    lis2dh12_set_scale(dev, dev->p->scale);
+
     /* acquire the bus and verify that our parameters are valid */
     if (_acquire(dev) != BUS_OK) {
         DEBUG("[lis2dh12] error: unable to acquire the bus\n");
@@ -154,6 +172,13 @@ int lis2dh12_init(lis2dh12_t *dev, const lis2dh12_params_t *params)
         return LIS2DH12_NODEV;
     }
 
+    /* clear events */
+    _write(dev, REG_CTRL_REG3, 0);
+    _write(dev, REG_CTRL_REG6, 0);
+
+    /* disable fifo */
+    _write(dev, REG_FIFO_CTRL_REG, 0);
+
     /* enable all axes, set sampling rate and scale */
     LIS2DH12_CTRL_REG1_t reg1 = {0};
 
@@ -162,125 +187,317 @@ int lis2dh12_init(lis2dh12_t *dev, const lis2dh12_params_t *params)
     reg1.bit.Yen = 1;
     reg1.bit.Zen = 1;
 
-    _write(dev, REG_CTRL_REG4, dev->p->scale);
     _write(dev, REG_CTRL_REG1, reg1.reg);
 
-    _release(dev);
+    /* enable block data update */
+    _write(dev, REG_CTRL_REG4, 0x80);
 
-    /* set powermode */
-    lis2dh12_set_powermode(dev, dev->p->powermode);
+    _release(dev);
 
     DEBUG("[lis2dh12] initialization successful\n");
     return LIS2DH12_OK;
 }
 
-int lis2dh12_read(const lis2dh12_t *dev, int16_t *data)
+static void _get_fifo_data(const lis2dh12_t *dev, lis2dh12_fifo_data_t *dst, uint8_t comp)
 {
-    assert(dev && data);
+    _read_burst(dev, REG_OUT_X_L, dst, sizeof(*dst));
+
+    for (unsigned i = 0; i < 3; ++i) {
+        dst->data[i] >>= comp;
+    }
+}
 
-    /* allocate 6 byte to save the 6 RAW data registers */
-    uint8_t raw[6];
+int lis2dh12_read(const lis2dh12_t *dev, lis2dh12_fifo_data_t *data)
+{
+    assert(dev && data);
 
     /* read sampled data from the device */
     _acquire(dev);
 
+    uint8_t comp = 4 - ((_read(dev, REG_CTRL_REG4) >> 4) & 0x3);
+
     /* first check if valid data is available */
     if ((_read(dev, REG_STATUS_REG) & LIS2DH12_STATUS_REG_ZYXDA) == 0) {
         _release(dev);
         return LIS2DH12_NODATA;
     }
 
-    _read_burst(dev, REG_OUT_X_L, raw, 6);
+    _get_fifo_data(dev, data, comp);
     _release(dev);
 
-    /* calculate the actual g-values for the x, y, and z dimension */
-    for (int i = 0; i < 3; i++) {
-        data[i] = (int16_t)((raw[i*2 + 1] << 8) | raw[i*2]) >> dev->comp;
-    }
-
     return LIS2DH12_OK;
 }
 
-#ifdef MODULE_LIS2DH12_INT
-int lis2dh12_set_int(const lis2dh12_t *dev, const lis2dh12_int_params_t *params, uint8_t int_line)
+static const uint16_t mg_per_bit[] = {
+    16, /* scale = 2g  */
+    32, /* scale = 4g  */
+    62, /* scale = 8g  */
+    186 /* scale = 16g */
+};
+
+static const uint16_t hz_per_dr[] = {
+    0,      /* power down */
+    1,      /* Hz */
+    10,     /* Hz */
+    25,     /* Hz */
+    50,     /* Hz */
+    100,    /* Hz */
+    200,    /* Hz */
+    400,    /* Hz */
+    1620,   /* Hz */
+    5376,   /* Hz */
+};
+
+void lis2dh12_cfg_threshold_event(const lis2dh12_t *dev,
+                                  uint32_t mg, uint32_t us,
+                                  uint8_t axis, uint8_t event, uint8_t line)
 {
-    assert (int_line == LIS2DH12_INT1 || int_line == LIS2DH12_INT2);
-    assert (dev && params);
-    assert (params->cb);
+    assert(line == LIS2DH12_INT1 || line == LIS2DH12_INT2);
+    assert(event == LIS2DH12_EVENT_1 || event == LIS2DH12_EVENT_2);
+
+    _acquire(dev);
+
+    LIS2DH12_CTRL_REG2_t reg2;
+    reg2.reg = _read(dev, REG_CTRL_REG2);
+    uint8_t odr   = _read(dev, REG_CTRL_REG1) >> 4;
+    uint8_t scale = (_read(dev, REG_CTRL_REG4) >> 4) & 0x3;
+    uint8_t int_reg = 0;
+
+    /* read current interrupt configuration */
+    if (line == LIS2DH12_INT1) {
+        int_reg = _read(dev, REG_CTRL_REG3);
+    }
+    if (line == LIS2DH12_INT2) {
+        int_reg = _read(dev, REG_CTRL_REG6);
+    }
+
+    DEBUG("[%u] threshold: %"PRIu32" mg\n", event, mg);
+
+    /* read reference to set it to current data */
+    _read(dev, REG_REFERENCE);
+
+    /* configure interrupt */
+    switch (event) {
+    case LIS2DH12_EVENT_1:
+        /* apply high-pass to interrupt */
+        reg2.bit.HP_IA1 = 1;
+        int_reg |= LIS2DH12_INT_TYPE_IA1;
+
+        /* clear INT flags */
+        _read(dev, REG_INT1_SRC);
+
+        _write(dev, REG_INT1_CFG, axis);
+        _write(dev, REG_INT1_THS, mg / mg_per_bit[scale]);
+        _write(dev, REG_INT1_DURATION, (us * hz_per_dr[odr]) / US_PER_SEC);
+        break;
+    case LIS2DH12_EVENT_2:
+        /* apply high-pass to interrupt */
+        reg2.bit.HP_IA2 = 1;
+        int_reg |= LIS2DH12_INT_TYPE_IA2;
+
+        /* clear INT flags */
+        _read(dev, REG_INT2_SRC);
+
+        _write(dev, REG_INT2_CFG, axis);
+        _write(dev, REG_INT2_THS, mg / mg_per_bit[scale]);
+        _write(dev, REG_INT2_DURATION, (us * hz_per_dr[odr]) / US_PER_SEC);
+        break;
+    }
+
+    /* configure high-pass */
+    _write(dev, REG_CTRL_REG2, reg2.reg);
+
+    /* write back configuration */
+    if (line == LIS2DH12_INT1) {
+        _write(dev, REG_CTRL_REG3, int_reg);
+    }
+    if (line == LIS2DH12_INT2) {
+        _write(dev, REG_CTRL_REG6, int_reg);
+    }
+
+    _release(dev);
+}
 
+void lis2dh12_cfg_click_event(const lis2dh12_t *dev, uint32_t mg,
+                              uint32_t us_limit, uint32_t us_latency, uint32_t us_window,
+                              uint8_t click, uint8_t line)
+{
     _acquire(dev);
 
-    gpio_t pin = GPIO_UNDEF;
+    uint8_t odr   = _read(dev, REG_CTRL_REG1) >> 4;
+    uint8_t scale = (_read(dev, REG_CTRL_REG4) >> 4) & 0x3;
 
-    switch (int_line){
-        /* first interrupt line (INT1) */
-        case LIS2DH12_INT1:
-            pin = dev->p->int1_pin;
-            assert (gpio_is_valid(pin));
+    DEBUG("click threshold: %"PRIu32" mg\n", mg);
 
-            if (gpio_init_int(pin, GPIO_IN, GPIO_RISING, params->cb, params->arg)) {
-                return LIS2DH12_NOINT;
-            }
+    /* read reference to set it to current data */
+    _read(dev, REG_REFERENCE);
 
-            _write(dev, REG_CTRL_REG3, params->int_type);
-            _write(dev, REG_INT1_CFG, params->int_config);
-            _write(dev, REG_INT1_THS, params->int_threshold);
-            _write(dev, REG_INT1_DURATION, params->int_duration);
-            break;
-        /* second interrupt line (INT2) */
-        case LIS2DH12_INT2:
-            pin = dev->p->int2_pin;
-            assert (gpio_is_valid(pin));
+    /* select click axis & mode */
+    _write(dev, REG_CLICK_CFG, click);
 
-            if (gpio_init_int(pin, GPIO_IN, GPIO_RISING, params->cb, params->arg)) {
-                return LIS2DH12_NOINT;
-            }
+    /* enable interrupt latching */
+    _write(dev, REG_CLICK_THS, (mg / mg_per_bit[scale]) | LIS2DH12_CLICK_THS_LIR);
 
-            _write(dev, REG_CTRL_REG6, params->int_type);
-            _write(dev, REG_INT2_CFG, params->int_config);
-            _write(dev, REG_INT2_THS, params->int_threshold);
-            _write(dev, REG_INT2_DURATION, params->int_duration);
-            break;
+    /* set timing parameters */
+    _write(dev, REG_TIME_LIMIT,   (us_limit   * hz_per_dr[odr]) / US_PER_SEC);
+    _write(dev, REG_TIME_LATENCY, (us_latency * hz_per_dr[odr]) / US_PER_SEC);
+    _write(dev, REG_TIME_WINDOW,  (us_window  * hz_per_dr[odr]) / US_PER_SEC);
+
+    /* enable high-pass */
+    _write_or(dev, REG_CTRL_REG2, LIS2DH12_CTRL_REG2_HPCLICK);
+
+    /* clear INT flags */
+     _read(dev, REG_CLICK_SRC);
+
+    /* configure interrupt */
+    if (line == LIS2DH12_INT1) {
+        _write_or(dev, REG_CTRL_REG3, LIS2DH12_INT_TYPE_CLICK);
+    }
+    if (line == LIS2DH12_INT2) {
+        _write_or(dev, REG_CTRL_REG6, LIS2DH12_INT_TYPE_CLICK);
     }
 
     _release(dev);
+}
 
-    return LIS2DH12_OK;
+void lis2dh12_cfg_disable_event(const lis2dh12_t *dev, uint8_t event, uint8_t line)
+{
+    uint8_t reg = 0;
+
+    _release(dev);
+
+    /* read current interrupt configuration */
+    if (line == LIS2DH12_INT1) {
+        reg = _read(dev, REG_CTRL_REG3);
+    }
+    if (line == LIS2DH12_INT2) {
+        reg = _read(dev, REG_CTRL_REG6);
+    }
+
+    /* remove event */
+    if (event == LIS2DH12_EVENT_1) {
+        reg &= ~LIS2DH12_INT_TYPE_IA1;
+
+        /* clear INT flags */
+        _read(dev, REG_INT1_SRC);
+    }
+    if (event == LIS2DH12_EVENT_2) {
+        reg &= ~LIS2DH12_INT_TYPE_IA2;
+
+        /* clear INT flags */
+        _read(dev, REG_INT2_SRC);
+    }
+    if (event == LIS2DH12_EVENT_CLICK) {
+        reg &= ~LIS2DH12_INT_TYPE_CLICK;
+
+        /* clear INT flags */
+        _read(dev, REG_CLICK_SRC);
+    }
+
+    /* write back configuration */
+    if (line == LIS2DH12_INT1) {
+        _write(dev, REG_CTRL_REG3, reg);
+    }
+    if (line == LIS2DH12_INT2) {
+        _write(dev, REG_CTRL_REG6, reg);
+    }
+
+    _release(dev);
 }
 
-int lis2dh12_read_int_src(const lis2dh12_t *dev, uint8_t *data, uint8_t int_line)
+#ifdef MODULE_LIS2DH12_INT
+static void _cb(void *lock)
 {
-    assert(dev && data);
-    assert(int_line == LIS2DH12_INT1 || int_line == LIS2DH12_INT2);
+    mutex_unlock(lock);
+}
+
+static uint32_t _merge_int_flags(const lis2dh12_t *dev, uint8_t events)
+{
+    uint32_t int_src = 0;
+
+    /* merge interrupt flags (7 bit per event) into one word */
+    if (events & LIS2DH12_INT_TYPE_IA1) {
+        int_src |= (uint32_t)_read(dev, REG_INT1_SRC);
+    }
+    if (events & LIS2DH12_INT_TYPE_IA2) {
+        int_src |= (uint32_t)_read(dev, REG_INT2_SRC) << 8;
+    }
+    if (events & LIS2DH12_INT_TYPE_CLICK) {
+        int_src |= (uint32_t)_read(dev, REG_CLICK_SRC) << 16;
+    }
+
+    DEBUG("int_src: %"PRIx32"\n", int_src);
+
+    return int_src;
+}
+
+#define LIS2DH12_INT_SRC_ANY (((uint32_t)LIS2DH12_INT_SRC_IA <<  0) | \
+                              ((uint32_t)LIS2DH12_INT_SRC_IA <<  8) | \
+                              ((uint32_t)LIS2DH12_INT_SRC_IA << 16))
+
+int lis2dh12_wait_event(const lis2dh12_t *dev, uint8_t line, bool stale_events)
+{
+    uint32_t int_src;
+    uint8_t events = 0;
+    mutex_t lock = MUTEX_INIT_LOCKED;
+    gpio_t pin = line == LIS2DH12_INT2
+                       ? dev->p->int2_pin
+                       : dev->p->int1_pin;
 
     _acquire(dev);
 
-    switch (int_line) {
-        /* first interrupt line (INT1) */
-        case LIS2DH12_INT1:
-            *data = _read(dev, REG_INT1_SRC);
-            break;
-        /* second interrupt line (INT2) */
-        case LIS2DH12_INT2:
-            *data = _read(dev, REG_INT2_SRC);
-            break;
+    /* find out which events are configured */
+    if (line == LIS2DH12_INT1) {
+        events = _read(dev, REG_CTRL_REG3);
     }
+    if (line == LIS2DH12_INT2) {
+        events = _read(dev, REG_CTRL_REG6);
+    }
+
+    /* check for stale interrupt */
+    int_src = _merge_int_flags(dev, events);
 
     _release(dev);
 
-    return LIS2DH12_OK;
+    /* return early if stale interrupt is present */
+    if (stale_events && (int_src & LIS2DH12_INT_SRC_ANY)) {
+        return int_src;
+    }
+
+    /* enable interrupt pin */
+    assert(gpio_is_valid(pin));
+    if (gpio_init_int(pin, GPIO_IN, GPIO_RISING, _cb, &lock)) {
+        return LIS2DH12_NOINT;
+    }
+
+    /* wait for interrupt */
+    mutex_lock(&lock);
+    gpio_irq_disable(pin);
+
+    /* read interrupt source */
+    _acquire(dev);
+    int_src = _merge_int_flags(dev, events);
+    _release(dev);
+
+    return int_src;
 }
 #endif /* MODULE_LIS2DH12_INT */
 
-int lis2dh12_set_fifo(const lis2dh12_t *dev, const lis2dh12_fifo_t *config) {
+int lis2dh12_set_fifo(const lis2dh12_t *dev, const lis2dh12_fifo_t *config)
+{
 
     assert(dev && config);
 
     LIS2DH12_CTRL_REG5_t reg5 = {0};
     LIS2DH12_FIFO_CTRL_REG_t fifo_reg = {0};
 
+    reg5.bit.LIR_INT1 = 1;
+    reg5.bit.LIR_INT2 = 1;
+
     if (config->FIFO_mode != LIS2DH12_FIFO_MODE_BYPASS) {
         reg5.bit.FIFO_EN = 1;
+    } else {
+        reg5.bit.FIFO_EN = 0;
     }
     fifo_reg.bit.TR = config->FIFO_set_INT2;
     fifo_reg.bit.FM = config->FIFO_mode;
@@ -294,13 +511,14 @@ int lis2dh12_set_fifo(const lis2dh12_t *dev, const lis2dh12_fifo_t *config) {
     return LIS2DH12_OK;
 }
 
-int lis2dh12_restart_fifo(const lis2dh12_t *dev) {
+int lis2dh12_restart_fifo(const lis2dh12_t *dev)
+{
 
     assert(dev);
 
     _acquire(dev);
     uint8_t reg5 = _read(dev, REG_CTRL_REG5);
-    LIS2DH12_FIFO_CTRL_REG_t fifo_reg = {0};
+    LIS2DH12_FIFO_CTRL_REG_t fifo_reg;
     fifo_reg.reg = _read(dev, REG_FIFO_CTRL_REG);
 
     uint8_t fifo_mode_old = fifo_reg.bit.FM;
@@ -318,45 +536,28 @@ int lis2dh12_restart_fifo(const lis2dh12_t *dev) {
     return LIS2DH12_OK;
 }
 
-int lis2dh12_read_fifo_src(const lis2dh12_t *dev, LIS2DH12_FIFO_SRC_REG_t *data) {
-
-    assert(dev && data);
-
-    _acquire(dev);
-    data->reg = _read(dev, REG_FIFO_SRC_REG);
-    _release(dev);
-
-    return LIS2DH12_OK;
-}
-
 uint8_t lis2dh12_read_fifo_data(const lis2dh12_t *dev, lis2dh12_fifo_data_t *fifo_data,
-                                uint8_t number) {
-
+                                uint8_t number)
+{
     assert(dev && fifo_data);
     /* check max FIFO length */
     assert(number <= 32);
 
     _acquire(dev);
+
     /* check if number is available */
-    LIS2DH12_FIFO_SRC_REG_t src_reg = {0};
+    LIS2DH12_FIFO_SRC_REG_t src_reg;
     src_reg.reg = _read(dev, REG_FIFO_SRC_REG);
 
-    if (src_reg.bit.FSS <= number) {
+    if (src_reg.bit.FSS < number) {
         number = src_reg.bit.FSS;
     }
 
-    if (src_reg.bit.EMPTY) {
-        return 0;
-    }
+    uint8_t comp = 4 - ((_read(dev, REG_CTRL_REG4) >> 4) & 0x3);
 
     /* calculate X, Y and Z values */
-    for (uint8_t i = 0; i < number; i++){
-        fifo_data[i].X_AXIS = (int16_t)(_read(dev, REG_OUT_X_L) | (_read(dev, REG_OUT_X_H) << 8))
-                                >> dev->comp;
-        fifo_data[i].Y_AXIS = (int16_t)(_read(dev, REG_OUT_Y_L) | (_read(dev, REG_OUT_Y_H) << 8))
-                                >> dev->comp;
-        fifo_data[i].Z_AXIS = (int16_t)(_read(dev, REG_OUT_Z_L) | (_read(dev, REG_OUT_Z_H) << 8))
-                                >> dev->comp;
+    for (uint8_t i = 0; i < number; i++) {
+        _get_fifo_data(dev, &fifo_data[i], comp);
     }
 
     _release(dev);
@@ -364,12 +565,16 @@ uint8_t lis2dh12_read_fifo_data(const lis2dh12_t *dev, lis2dh12_fifo_data_t *fif
     return number;
 }
 
-int lis2dh12_clear_data(const lis2dh12_t *dev) {
+int lis2dh12_clear_data(const lis2dh12_t *dev)
+{
 
     assert(dev);
 
-    LIS2DH12_CTRL_REG5_t ctrl_reg5 = {0};
-    ctrl_reg5.bit.BOOT = 1;
+    LIS2DH12_CTRL_REG5_t ctrl_reg5 = {
+        .bit.BOOT = 1,
+        .bit.LIR_INT1 = 1,
+        .bit.LIR_INT2 = 1,
+    };
 
     _acquire(dev);
     _write(dev, REG_CTRL_REG5, ctrl_reg5.reg);
@@ -378,29 +583,44 @@ int lis2dh12_clear_data(const lis2dh12_t *dev) {
     return LIS2DH12_OK;
 }
 
-int lis2dh12_set_reference(const lis2dh12_t *dev, uint8_t reference) {
-
-    assert(dev);
+int lis2dh12_read_temperature(const lis2dh12_t *dev, int16_t *temp)
+{
+    uint8_t bytes[2];
 
     _acquire(dev);
-    _write(dev, REG_REFERENCE, reference);
+
+    /* enable temperature sensor */
+    if (!_read(dev, REG_TEMP_CFG_REG)) {
+        uint8_t odr = _read(dev, REG_CTRL_REG1) >> 4;
+        _write(dev, REG_TEMP_CFG_REG, LIS2DH12_TEMP_CFG_REG_ENABLE);
+        if (IS_USED(MODULE_XTIMER)) {
+            xtimer_msleep(MS_PER_SEC / hz_per_dr[odr]);
+        }
+    }
+
+    _read_burst(dev, REG_OUT_TEMP_L, bytes, sizeof(bytes));
     _release(dev);
 
-    return LIS2DH12_OK;
+    *temp =  100 * (int8_t)bytes[1];
+    *temp += (100 * bytes[0]) >> 8;
+
+    return 0;
 }
 
-int lis2dh12_read_reference(const lis2dh12_t *dev, uint8_t *data) {
+int lis2dh12_set_reference(const lis2dh12_t *dev, uint8_t reference)
+{
 
     assert(dev);
 
     _acquire(dev);
-    *data = _read(dev, REG_REFERENCE);
+    _write(dev, REG_REFERENCE, reference);
     _release(dev);
 
     return LIS2DH12_OK;
 }
 
-int lis2dh12_set_highpass(const lis2dh12_t *dev, const lis2dh12_highpass_t *config) {
+int lis2dh12_set_highpass(const lis2dh12_t *dev, const lis2dh12_highpass_t *config)
+{
 
     assert(dev && config);
 
@@ -420,67 +640,27 @@ int lis2dh12_set_highpass(const lis2dh12_t *dev, const lis2dh12_highpass_t *conf
     return LIS2DH12_OK;
 }
 
-int lis2dh12_set_click(const lis2dh12_t *dev, const lis2dh12_click_t *config) {
-    assert(dev);
-
-    LIS2DH12_CLICK_CFG_t click_CFG = {0};
-    if (config->enable_DOUBLE) {
-        click_CFG.bit.XD = config->enable_X_CLICK;
-        click_CFG.bit.YD = config->enable_Y_CLICK;
-        click_CFG.bit.ZD = config->enable_Z_CLICK;
-    }
-    else {
-        click_CFG.bit.XS = config->enable_X_CLICK;
-        click_CFG.bit.YS = config->enable_Y_CLICK;
-        click_CFG.bit.ZS = config->enable_Z_CLICK;
-    }
-
-    LIS2DH12_CLICK_THS_t click_thold  = {0};
-    click_thold.bit.LIR_CLICK = config->noINT_latency;
-    click_thold.bit.THS = config->CLICK_thold;
-
-    _acquire(dev);
-    _write(dev, REG_CLICK_CFG, click_CFG.reg);
-    _write(dev, REG_CLICK_THS, click_thold.reg);
-    _write(dev, REG_TIME_LIMIT, config->TIME_limit);
-    _write(dev, REG_TIME_LATENCY, config->TIME_latency);
-    _write(dev, REG_TIME_WINDOW, config->TIME_window);
-    _release(dev);
-
-    return LIS2DH12_OK;
-}
-
-int lis2dh12_read_click_src(const lis2dh12_t *dev, LIS2DH12_CLICK_SRC_t *data) {
-    assert(dev && data);
-
-    _acquire(dev);
-    data->reg = _read(dev, REG_CLICK_SRC);
-    _release(dev);
-
-    return LIS2DH12_OK;
-}
-
-int lis2dh12_set_powermode(const lis2dh12_t *dev, lis2dh12_powermode_t powermode) {
-
+int lis2dh12_set_resolution(const lis2dh12_t *dev, lis2dh12_resolution_t resolution)
+{
     assert(dev);
 
-    LIS2DH12_CTRL_REG1_t reg1 = {0};
-    LIS2DH12_CTRL_REG4_t reg4 = {0};
+    LIS2DH12_CTRL_REG1_t reg1;
+    LIS2DH12_CTRL_REG4_t reg4;
 
     _acquire(dev);
     reg1.reg = _read(dev, REG_CTRL_REG1);
     reg4.reg = _read(dev, REG_CTRL_REG4);
 
     /* set power mode */
-    if (powermode == LIS2DH12_POWER_LOW) {
+    if (resolution == LIS2DH12_POWER_LOW) {
         reg1.bit.LPen = 1;
         reg4.bit.HR = 0;
     }
-    else if (powermode == LIS2DH12_POWER_HIGH) {
+    else if (resolution == LIS2DH12_POWER_HIGH) {
         reg1.bit.LPen = 0;
         reg4.bit.HR = 1;
     }
-    else if (powermode == LIS2DH12_POWER_NORMAL) {
+    else if (resolution == LIS2DH12_POWER_NORMAL) {
         reg1.bit.LPen = 0;
         reg4.bit.HR = 0;
     }
@@ -495,51 +675,125 @@ int lis2dh12_set_powermode(const lis2dh12_t *dev, lis2dh12_powermode_t powermode
     return LIS2DH12_OK;
 }
 
-int lis2dh12_set_datarate(const lis2dh12_t *dev, lis2dh12_rate_t rate) {
+lis2dh12_resolution_t lis2dh12_get_resolution(const lis2dh12_t *dev)
+{
+    assert(dev);
+
+    LIS2DH12_CTRL_REG1_t reg1;
+    LIS2DH12_CTRL_REG4_t reg4;
+
+    _acquire(dev);
+    reg1.reg = _read(dev, REG_CTRL_REG1);
+    reg4.reg = _read(dev, REG_CTRL_REG4);
+    _release(dev);
+
+    if (!reg1.bit.ODR) {
+        return LIS2DH12_POWER_DOWN;
+    }
+    if (reg1.bit.LPen) {
+        return LIS2DH12_POWER_LOW;
+    }
+    if (reg4.bit.HR) {
+        return LIS2DH12_POWER_HIGH;
+    }
+    return LIS2DH12_POWER_NORMAL;
+}
+
+int lis2dh12_set_datarate(const lis2dh12_t *dev, lis2dh12_rate_t rate)
+{
 
     assert(dev);
     assert(rate <= 0x9);
 
-    LIS2DH12_CTRL_REG1_t reg1 = {0};
+    LIS2DH12_CTRL_REG1_t reg1;
 
     _acquire(dev);
     reg1.reg = _read(dev, REG_CTRL_REG1);
-
     reg1.bit.ODR = rate;
-
     _write(dev, REG_CTRL_REG1, reg1.reg);
     _release(dev);
 
     return LIS2DH12_OK;
 }
 
-int lis2dh12_set_scale(lis2dh12_t *dev, lis2dh12_scale_t scale) {
+uint16_t lis2dh12_get_datarate(const lis2dh12_t *dev)
+{
+    const uint16_t rates_hz[] = {
+        0,
+        1,
+        10,
+        25,
+        50,
+        100,
+        200,
+        400,
+    };
 
     assert(dev);
-    assert((scale>>4) <= 0x3);
 
-    LIS2DH12_CTRL_REG4_t reg4 = {0};
+    LIS2DH12_CTRL_REG1_t reg1;
 
     _acquire(dev);
-    reg4.reg = _read(dev, REG_CTRL_REG4);
+    reg1.reg = _read(dev, REG_CTRL_REG1);
+    _release(dev);
+
+    if (reg1.bit.ODR < ARRAY_SIZE(rates_hz)) {
+        return rates_hz[reg1.bit.ODR];
+    }
 
-    reg4.bit.FS = scale >> 4;
+    if (reg1.bit.LPen) {
+        if (reg1.bit.ODR == 8) {
+            return 1620;
+        }
+        if (reg1.bit.ODR == 9) {
+            return 5376;
+        }
+    }
+
+    if (reg1.bit.ODR == 9) {
+        return 1344;
+    }
 
+    return 0;
+}
+
+int lis2dh12_set_scale(lis2dh12_t *dev, lis2dh12_scale_t scale)
+{
+
+    assert(dev);
+    assert(scale <= LIS2DH12_SCALE_16G);
+
+    LIS2DH12_CTRL_REG4_t reg4;
+
+    _acquire(dev);
+    reg4.reg = _read(dev, REG_CTRL_REG4);
+    reg4.bit.FS = scale;
     _write(dev, REG_CTRL_REG4, reg4.reg);
     _release(dev);
 
-    dev->comp = 4 - (scale >> 4);
-
     return LIS2DH12_OK;
 }
 
+lis2dh12_scale_t lis2dh12_get_scale(lis2dh12_t *dev)
+{
+    assert(dev);
+
+    LIS2DH12_CTRL_REG4_t reg4;
+
+    _acquire(dev);
+    reg4.reg = _read(dev, REG_CTRL_REG4);
+    _release(dev);
+
+    return reg4.bit.FS;
+}
+
 int lis2dh12_poweron(const lis2dh12_t *dev)
 {
     assert(dev);
 
     /* set default param values */
     lis2dh12_set_datarate(dev, dev->p->rate);
-    lis2dh12_set_powermode(dev, dev->p->powermode);
+    lis2dh12_set_resolution(dev, dev->p->resolution);
 
     return LIS2DH12_OK;
 }
@@ -551,5 +805,10 @@ int lis2dh12_poweroff(const lis2dh12_t *dev)
     /* set datarate to zero */
     lis2dh12_set_datarate(dev, 0);
 
+    /* disable temperature sensor */
+    _acquire(dev);
+    _write(dev, REG_TEMP_CFG_REG, LIS2DH12_TEMP_CFG_REG_DISABLE);
+    _release(dev);
+
     return LIS2DH12_OK;
 }
diff --git a/drivers/lis2dh12/lis2dh12_saul.c b/drivers/lis2dh12/lis2dh12_saul.c
index b3c878296b..25b87b2cf8 100644
--- a/drivers/lis2dh12/lis2dh12_saul.c
+++ b/drivers/lis2dh12/lis2dh12_saul.c
@@ -23,7 +23,7 @@
 
 static int read_accelerometer(const void *dev, phydat_t *res)
 {
-    if (lis2dh12_read((const lis2dh12_t *)dev, res->val) != LIS2DH12_OK) {
+    if (lis2dh12_read(dev, (lis2dh12_fifo_data_t*)res->val) != LIS2DH12_OK) {
         return 0;
     }
     res->unit = UNIT_G;
@@ -31,8 +31,25 @@ static int read_accelerometer(const void *dev, phydat_t *res)
     return 3;
 }
 
+static int read_temperature(const void *dev, phydat_t *res)
+{
+    if (lis2dh12_read_temperature(dev, &res->val[0])) {
+        return -ECANCELED;
+    }
+    res->unit = UNIT_TEMP_C;
+    res->scale = -2;
+
+    return 1;
+}
+
 const saul_driver_t lis2dh12_saul_driver = {
     .read = read_accelerometer,
     .write = saul_notsup,
-    .type = SAUL_SENSE_ACCEL
+    .type = SAUL_SENSE_ACCEL,
+};
+
+const saul_driver_t lis2dh12_saul_temp_driver = {
+    .read = read_temperature,
+    .write = saul_notsup,
+    .type = SAUL_SENSE_TEMP,
 };
diff --git a/drivers/netdev/ieee802154.c b/drivers/netdev/ieee802154.c
index 2296ffa19f..95fb902225 100644
--- a/drivers/netdev/ieee802154.c
+++ b/drivers/netdev/ieee802154.c
@@ -178,7 +178,7 @@ int netdev_ieee802154_get(netdev_ieee802154_t *dev, netopt_t opt, void *value,
             *((uint16_t *)value) = (_get_ieee802154_pdu(dev)
                                     - IEEE802154_MAX_HDR_LEN)
 #if IS_USED(MODULE_IEEE802154_SECURITY)
-                                    -IEEE802154_MAX_AUX_HDR_LEN
+                                    -IEEE802154_SEC_MAX_AUX_HDR_LEN
 #endif /* IS_USED(MODULE_IEEE802154_SECURITY) */
                                     - IEEE802154_FCS_LEN;
             res = sizeof(uint16_t);
diff --git a/drivers/nrf24l01p_ng/gnrc_netif_nrf24l01p_ng.c b/drivers/nrf24l01p_ng/gnrc_netif_nrf24l01p_ng.c
index f1cb2f91a4..98b118a4de 100644
--- a/drivers/nrf24l01p_ng/gnrc_netif_nrf24l01p_ng.c
+++ b/drivers/nrf24l01p_ng/gnrc_netif_nrf24l01p_ng.c
@@ -22,6 +22,7 @@
 #include "debug.h"
 
 #include "net/gnrc.h"
+#include "luid.h"
 #include "gnrc_netif_nrf24l01p_ng.h"
 #include "nrf24l01p_ng.h"
 
@@ -234,3 +235,13 @@ int gnrc_netif_nrf24l01p_ng_create(gnrc_netif_t *netif, char *stack,
     return gnrc_netif_create(netif, stack, stacksize, priority, name,
                              dev, &nrf24l01p_ng_netif_ops);
 }
+
+void __attribute__((weak)) nrf24l01p_ng_eui_get(const netdev_t *netdev, uint8_t *eui)
+{
+    (void)netdev;
+    do {
+        luid_get_lb(eui, NRF24L01P_NG_ADDR_WIDTH);
+    }
+    while (eui[NRF24L01P_NG_ADDR_WIDTH - 1] ==
+           ((uint8_t[])NRF24L01P_NG_BROADCAST_ADDR)[NRF24L01P_NG_ADDR_WIDTH - 1]);
+}
diff --git a/drivers/nrf24l01p_ng/nrf24l01p_ng_netdev.c b/drivers/nrf24l01p_ng/nrf24l01p_ng_netdev.c
index b202284aee..1388e88f9e 100644
--- a/drivers/nrf24l01p_ng/nrf24l01p_ng_netdev.c
+++ b/drivers/nrf24l01p_ng/nrf24l01p_ng_netdev.c
@@ -26,9 +26,6 @@
 #include "kernel_defines.h"
 #include "iolist.h"
 #include "irq.h"
-#include "luid.h"
-#include "mutex.h"
-#include "net/eui64.h"
 #include "net/netdev.h"
 #include "xtimer.h"
 
@@ -196,12 +193,10 @@ static int _init(netdev_t *netdev)
     /* assign to pipe 0 the broadcast address*/
     nrf24l01p_ng_write_reg(dev, NRF24L01P_NG_REG_RX_ADDR_P0,
                            NRF24L01P_NG_ADDR_P0(dev), aw);
-    luid_get_lb(NRF24L01P_NG_ADDR_P1(dev), aw);
-     /* "The LSByte must be unique for all six pipes" [datasheet p.38] */
-    if (NRF24L01P_NG_ADDR_P1(dev)[aw - 1] == bc[aw - 1]) {
-        luid_get_lb(NRF24L01P_NG_ADDR_P1(dev), aw);
-    }
-    /* assign to pipe 0 the "main" listening address */
+    /* "The LSByte must be unique for all six pipes" [datasheet p.38] */
+    nrf24l01p_ng_eui_get(&dev->netdev, NRF24L01P_NG_ADDR_P1(dev));
+    assert(NRF24L01P_NG_ADDR_P1(dev)[aw - 1] != NRF24L01P_NG_ADDR_P0(dev)[aw - 1]);
+    /* assign to pipe 1 the "main" listening address */
     nrf24l01p_ng_write_reg(dev, NRF24L01P_NG_REG_RX_ADDR_P1,
                            NRF24L01P_NG_ADDR_P1(dev), aw);
     /* set the address width */
diff --git a/drivers/pcd8544/pcd8544.c b/drivers/pcd8544/pcd8544.c
index b477a288cd..b5c5f96b49 100644
--- a/drivers/pcd8544/pcd8544.c
+++ b/drivers/pcd8544/pcd8544.c
@@ -320,11 +320,43 @@ void pcd8544_write_img(const pcd8544_t *dev, const uint8_t img[])
     done(dev);
 }
 
+void pcd8544_write_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data)
+{
+    /* check position */
+    if (x >= PCD8544_RES_X || y_line >= PCD8544_ROWS) {
+        return;
+    }
+    /* set position */
+    lock(dev);
+    _set_x(dev, x);
+    _set_y(dev, y_line);
+
+    /* write pixel */
+    _write(dev, MODE_DTA, data);
+    done(dev);
+}
+
+void pcd8544_clear_stackedpixel(const pcd8544_t *dev, uint8_t x, uint8_t y_line, uint8_t data)
+{
+    /* check position */
+    if (x >= PCD8544_RES_X || y_line >= PCD8544_ROWS) {
+        return;
+    }
+    /* set position */
+    lock(dev);
+    _set_x(dev, x);
+    _set_y(dev, y_line);
+
+    /* write pixel */
+    _write(dev, MODE_DTA, data);
+    done(dev);
+}
+
 void pcd8544_write_c(const pcd8544_t *dev, uint8_t x, uint8_t y, char c)
 {
     /* check position */
     if (x >= PCD8544_COLS || y >= PCD8544_ROWS) {
-        return ;
+        return;
     }
     /* set position */
     lock(dev);
@@ -345,6 +377,20 @@ void pcd8544_write_s(const pcd8544_t *dev, uint8_t x, uint8_t y, const char *s)
     }
 }
 
+void pcd8544_write_l(const pcd8544_t *dev, uint8_t y, const char *s)
+{
+    uint8_t x = 0;
+
+    /* write every char from string */
+    for (; (*s != '\0') && x < PCD8544_COLS; x++, s++) {
+        pcd8544_write_c(dev, x, y, *s);
+    }
+    /* fill rest with spaces */
+    for (; x < PCD8544_COLS; x++){
+        pcd8544_write_c(dev, x, y, *" ");
+    }
+}
+
 void pcd8544_clear(const pcd8544_t *dev)
 {
     lock(dev);
diff --git a/drivers/periph_common/flashpage.c b/drivers/periph_common/flashpage.c
index 8d0f4a4640..cb8e8b1967 100644
--- a/drivers/periph_common/flashpage.c
+++ b/drivers/periph_common/flashpage.c
@@ -24,16 +24,16 @@
 
 /* guard this file, must be done before including periph/flashpage.h
  * TODO: remove as soon as periph drivers can be build selectively */
-#if defined(FLASHPAGE_NUMOF) && defined(FLASHPAGE_SIZE)
-
+#if defined(FLASHPAGE_SIZE) || defined(PERIPH_FLASHPAGE_CUSTOM_PAGESIZES)
 #include "periph/flashpage.h"
+#endif
 
 #ifdef MODULE_PERIPH_FLASHPAGE_PAGEWISE
 void flashpage_read(unsigned page, void *data)
 {
     assert(page < FLASHPAGE_NUMOF);
 
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
     assert(page < (FLASH->SFR & FLASH_SFR_SFSA));
 #endif
 
@@ -44,7 +44,7 @@ int flashpage_verify(unsigned page, const void *data)
 {
     assert(page < (int)FLASHPAGE_NUMOF);
 
-#if defined(CPU_FAM_STM32WB)
+#if defined(CPU_FAM_STM32WB) || defined(CPU_FAM_STM32WL)
     assert(page < (int)(FLASH->SFR & FLASH_SFR_SFSA));
 #endif
 
@@ -76,7 +76,6 @@ void flashpage_write_page(unsigned page, const void *data)
 #endif /* MODULE_PERIPH_FLASHPAGE_PAGEWISE */
 
 #if defined(FLASHPAGE_RWWEE_NUMOF)
-
 void flashpage_rwwee_read(unsigned page, void *data)
 {
     assert(page < (int)FLASHPAGE_RWWEE_NUMOF);
@@ -101,7 +100,30 @@ int flashpage_rwwee_write_and_verify(unsigned page, const void *data)
     flashpage_rwwee_write_page(page, data);
     return flashpage_rwwee_verify(page, data);
 }
+#endif /* FLASHPAGE_RWWEE_NUMOF */
 
-#endif
+#ifdef PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_ADDR
+void *flashpage_addr(unsigned page)
+{
+    uintptr_t addr = CPU_FLASH_BASE;
 
-#endif
+    while (page) {
+        addr += flashpage_size(--page);
+    }
+
+    return (void*)addr;
+}
+#endif /* PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_ADDR */
+
+#ifdef PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_PAGE
+unsigned flashpage_page(void *addr)
+{
+    unsigned page = 0;
+
+    for (uintptr_t pos = CPU_FLASH_BASE; (uintptr_t)addr >= pos; ++page) {
+        pos += flashpage_size(page);
+    }
+
+    return page - 1;
+}
+#endif /* PERIPH_FLASHPAGE_NEEDS_FLASHPAGE_PAGE */
diff --git a/drivers/rtt_rtc/Makefile.features b/drivers/rtt_rtc/Makefile.features
new file mode 100644
index 0000000000..1ed82b05fe
--- /dev/null
+++ b/drivers/rtt_rtc/Makefile.features
@@ -0,0 +1,2 @@
+FEATURES_PROVIDED += periph_rtc
+FEATURES_PROVIDED += periph_rtc_ms
diff --git a/drivers/rtt_rtc/rtt_rtc.c b/drivers/rtt_rtc/rtt_rtc.c
index 878bc6ea94..2e16ac69c6 100644
--- a/drivers/rtt_rtc/rtt_rtc.c
+++ b/drivers/rtt_rtc/rtt_rtc.c
@@ -28,6 +28,7 @@
 
 #include "periph/rtc.h"
 #include "periph/rtt.h"
+#include "timex.h"
 
 #define ENABLE_DEBUG    0
 #include "debug.h"
@@ -40,6 +41,7 @@
 
 #define TICKS(x)        (    (x) * RTT_SECOND)
 #define SECONDS(x)      (_RTT(x) / RTT_SECOND)
+#define SUBSECONDS(x)   (_RTT(x) % RTT_SECOND)
 
 /* Place counter in .noinit section if no backup RAM is available.
    This means the date is undefined at cold boot, but will likely still
@@ -133,6 +135,22 @@ int rtc_set_time(struct tm *time)
     return 0;
 }
 
+int rtc_get_time_ms(struct tm *time, uint16_t *ms)
+{
+    uint32_t prev = rtc_now;
+
+    /* repeat calculation if an alarm triggered in between */
+    do {
+        uint32_t now = rtt_get_counter();
+        uint32_t tmp = _rtc_now(now);
+
+        rtc_localtime(tmp, time);
+        *ms = (SUBSECONDS(now) * MS_PER_SEC) / RTT_SECOND;
+    } while (prev != rtc_now);
+
+    return 0;
+}
+
 int rtc_get_time(struct tm *time)
 {
     uint32_t prev = rtc_now;
diff --git a/drivers/saul/init_devs/auto_init_lis2dh12.c b/drivers/saul/init_devs/auto_init_lis2dh12.c
index 4f89ee230c..05b9a1724e 100644
--- a/drivers/saul/init_devs/auto_init_lis2dh12.c
+++ b/drivers/saul/init_devs/auto_init_lis2dh12.c
@@ -30,7 +30,6 @@
  */
 #define LIS2DH12_NUM    ARRAY_SIZE(lis2dh12_params)
 
-
 /**
  * @brief   Number of defined SAUL registry info entries
  */
@@ -45,7 +44,7 @@ static lis2dh12_t lis2dh12_devs[LIS2DH12_NUM];
 /**
  * @brief   Memory for the SAUL registry entries
  */
-static saul_reg_t saul_entries[LIS2DH12_NUM];
+static saul_reg_t saul_entries[LIS2DH12_NUM * 2];
 
 void auto_init_lis2dh12(void)
 {
@@ -62,9 +61,14 @@ void auto_init_lis2dh12(void)
             continue;
         }
 
-        saul_entries[i].dev = &(lis2dh12_devs[i]);
-        saul_entries[i].name = lis2dh12_saul_info[i].name;
-        saul_entries[i].driver = &lis2dh12_saul_driver;
-        saul_reg_add(&(saul_entries[i]));
+        saul_entries[2 * i].dev = &lis2dh12_devs[i];
+        saul_entries[2 * i].name = lis2dh12_saul_info[i].name;
+        saul_entries[2 * i].driver = &lis2dh12_saul_driver;
+        saul_reg_add(&saul_entries[2 * i]);
+
+        saul_entries[2 * i + 1].dev = &lis2dh12_devs[i];
+        saul_entries[2 * i + 1].name = lis2dh12_saul_info[i].name;
+        saul_entries[2 * i + 1].driver = &lis2dh12_saul_temp_driver;
+        saul_reg_add(&saul_entries[2 * i + 1]);
     }
 }
diff --git a/drivers/saul/init_devs/auto_init_si70xx.c b/drivers/saul/init_devs/auto_init_si70xx.c
index 67d4c7cfc7..099eaccc96 100644
--- a/drivers/saul/init_devs/auto_init_si70xx.c
+++ b/drivers/saul/init_devs/auto_init_si70xx.c
@@ -29,6 +29,15 @@
  */
 #define SI70XX_NUM    ARRAY_SIZE(si70xx_params)
 
+/**
+ * @brief   Define the number of SAUL registry entries
+ */
+#if SI70XX_HAS_HUMIDITY_SENSOR
+#define SI70XX_SAUL_ENTRIES_NUM 2
+#else
+#define SI70XX_SAUL_ENTRIES_NUM 1
+#endif
+
 /**
  * @brief   Allocation of memory for device descriptors
  */
@@ -37,7 +46,7 @@ static si70xx_t si70xx_devs[SI70XX_NUM];
 /**
  * @brief   Memory for the SAUL registry entries
  */
-static saul_reg_t saul_entries[SI70XX_NUM * 2];
+static saul_reg_t saul_entries[SI70XX_NUM * SI70XX_SAUL_ENTRIES_NUM];
 
 /**
  * @brief   Define the number of saul info
@@ -56,6 +65,7 @@ void auto_init_si70xx(void)
 {
     assert(SI70XX_INFO_NUM == SI70XX_NUM);
 
+    unsigned entry = 0;
     for (unsigned i = 0; i < SI70XX_NUM; i++) {
         LOG_DEBUG("[auto_init_saul] initializing SI70xx #%u\n", i);
 
@@ -65,17 +75,17 @@ void auto_init_si70xx(void)
         }
 
         /* temperature */
-        saul_entries[i * 2].dev = &si70xx_devs[i];
-        saul_entries[i * 2].name = si70xx_saul_info[i].name;
-        saul_entries[i * 2].driver = &si70xx_temperature_saul_driver;
+        saul_entries[entry].dev = &si70xx_devs[i];
+        saul_entries[entry].name = si70xx_saul_info[i].name;
+        saul_entries[entry].driver = &si70xx_temperature_saul_driver;
+        saul_reg_add(&saul_entries[entry++]);
 
+#if SI70XX_HAS_HUMIDITY_SENSOR
         /* relative humidity */
-        saul_entries[(i * 2) + 1].dev = &si70xx_devs[i];
-        saul_entries[(i * 2) + 1].name = si70xx_saul_info[i].name;
-        saul_entries[(i * 2) + 1].driver = \
-                &si70xx_relative_humidity_saul_driver;
-
-        saul_reg_add(&saul_entries[i * 2]);
-        saul_reg_add(&saul_entries[(i * 2) + 1]);
+        saul_entries[entry].dev = &si70xx_devs[i];
+        saul_entries[entry].name = si70xx_saul_info[i].name;
+        saul_entries[entry].driver = &si70xx_relative_humidity_saul_driver;
+        saul_reg_add(&saul_entries[entry++]);
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR */
     }
 }
diff --git a/drivers/si70xx/include/si70xx_internals.h b/drivers/si70xx/include/si70xx_internals.h
index 621ae87fbb..beefcf868b 100644
--- a/drivers/si70xx/include/si70xx_internals.h
+++ b/drivers/si70xx/include/si70xx_internals.h
@@ -55,15 +55,25 @@ extern "C" {
  * @{
  */
 #if defined(MODULE_SI7006)
-#define SI70XX_ID                   (0x06)
+#define SI70XX_ID                   (6)
 #elif defined(MODULE_SI7013)
-#define SI70XX_ID                   (0x0D)
+#define SI70XX_ID                   (13)
 #elif defined(MODULE_SI7020)
-#define SI70XX_ID                   (0x14)
+#define SI70XX_ID                   (20)
 #elif defined(MODULE_SI7021)
-#define SI70XX_ID                   (0x15)
+#define SI70XX_ID                   (21)
+#elif defined(MODULE_SI7050)
+#define SI70XX_ID                   (50)
+#elif defined(MODULE_SI7051)
+#define SI70XX_ID                   (51)
+#elif defined(MODULE_SI7053)
+#define SI70XX_ID                   (53)
+#elif defined(MODULE_SI7054)
+#define SI70XX_ID                   (54)
+#elif defined(MODULE_SI7055)
+#define SI70XX_ID                   (55)
 #else
-#error "Please provide a valid Si70xx variant (Si7006/13/20/21)"
+#error "Please provide a valid Si70xx variant (Si7006/13/20/21/5X)"
 #endif
 
 #define SI70XX_REVISION_1           (0xFF)
diff --git a/drivers/si70xx/si70xx.c b/drivers/si70xx/si70xx.c
index bc74ca39f2..0dbd830b15 100644
--- a/drivers/si70xx/si70xx.c
+++ b/drivers/si70xx/si70xx.c
@@ -53,10 +53,7 @@ static uint16_t _do_measure(const si70xx_t *dev, uint8_t command)
     return ((uint16_t)result[0] << 8) + (result[1] & 0xfc);
 }
 
-/**
- * @brief   Internal helper function that reads the device serial number.
- */
-static uint64_t _get_serial(const si70xx_t *dev)
+uint64_t si70xx_get_serial(const si70xx_t *dev)
 {
     uint8_t out[2];
     uint8_t in_first[8] = { 0 };
@@ -95,18 +92,12 @@ static uint64_t _get_serial(const si70xx_t *dev)
     return (((uint64_t) id_first) << 32) + id_second;
 }
 
-/**
- * @brief   Internal helper function that reads the device identifier.
- */
-static uint8_t _get_id(const si70xx_t *dev)
+uint8_t si70xx_get_id(const si70xx_t *dev)
 {
-    return (_get_serial(dev) >> 24) & 0xff;
+    return (si70xx_get_serial(dev) >> 24) & 0xff;
 }
 
-/**
- * @brief   Internal helper function that reads the device serial revision.
- */
-static uint8_t _get_revision(const si70xx_t *dev)
+uint8_t si70xx_get_revision(const si70xx_t *dev)
 {
     uint8_t out[2];
     uint8_t in = 0;
@@ -128,17 +119,19 @@ static uint8_t _get_revision(const si70xx_t *dev)
 
 static int _test_device(const si70xx_t *dev)
 {
-    uint8_t revision = _get_revision(dev);
+    uint8_t revision = si70xx_get_revision(dev);
 
     if (revision != SI70XX_REVISION_1 && revision != SI70XX_REVISION_2) {
         DEBUG("[ERROR] Bad device revision (%d).\n", revision);
         return -SI70XX_ERR_NODEV;
     }
 
-    uint8_t id = _get_id(dev);
+    uint8_t id = si70xx_get_id(dev);
 
-    if (id != SI70XX_ID) {
-        DEBUG("[ERROR] Not a valid Si7006/13/20/21 device\n");
+    const bool valid_id = (id == SI70XX_ID);
+    if (!valid_id) {
+        DEBUG("[ERROR] Not a valid Si7006/13/20/21/5x device: %u\n",
+              (unsigned)id);
         return -SI70XX_ERR_NODEV;;
     }
 
diff --git a/drivers/si70xx/si70xx_saul.c b/drivers/si70xx/si70xx_saul.c
index 8ab680a4ce..8eafd93825 100644
--- a/drivers/si70xx/si70xx_saul.c
+++ b/drivers/si70xx/si70xx_saul.c
@@ -31,6 +31,7 @@ static int read_temperature(const void *dev, phydat_t *res)
     return 1;
 }
 
+#if SI70XX_HAS_HUMIDITY_SENSOR
 static int read_relative_humidity(const void *dev, phydat_t *res)
 {
     res->val[0] = (int32_t) si70xx_get_relative_humidity((const si70xx_t *)dev);
@@ -39,6 +40,7 @@ static int read_relative_humidity(const void *dev, phydat_t *res)
 
     return 1;
 }
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR */
 
 const saul_driver_t si70xx_temperature_saul_driver = {
     .read = read_temperature,
@@ -46,8 +48,10 @@ const saul_driver_t si70xx_temperature_saul_driver = {
     .type = SAUL_SENSE_TEMP
 };
 
+#if SI70XX_HAS_HUMIDITY_SENSOR
 const saul_driver_t si70xx_relative_humidity_saul_driver = {
     .read = read_relative_humidity,
     .write = saul_notsup,
     .type = SAUL_SENSE_HUM
 };
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR */
diff --git a/drivers/slipdev/Makefile.dep b/drivers/slipdev/Makefile.dep
index 58336f4aa9..0ec3dd39cf 100644
--- a/drivers/slipdev/Makefile.dep
+++ b/drivers/slipdev/Makefile.dep
@@ -1,4 +1,6 @@
 USEMODULE += tsrb
+USEMODULE += eui_provider
+USEMODULE += netdev_register
 FEATURES_REQUIRED += periph_uart
 
 ifneq (,$(filter slipdev_stdio,$(USEMODULE)))
diff --git a/drivers/slipdev/slipdev.c b/drivers/slipdev/slipdev.c
index e02648f395..f487735a8f 100644
--- a/drivers/slipdev/slipdev.c
+++ b/drivers/slipdev/slipdev.c
@@ -21,6 +21,7 @@
 #include "log.h"
 #include "slipdev.h"
 #include "slipdev_internal.h"
+#include "net/eui_provider.h"
 
 /* XXX: BE CAREFUL ABOUT USING OUTPUT WITH MODULE_SLIPDEV_STDIO IN SENDING
  * FUNCTIONALITY! MIGHT CAUSE DEADLOCK!!!1!! */
@@ -231,6 +232,12 @@ static int _get(netdev_t *netdev, netopt_t opt, void *value, size_t max_len)
             assert(max_len == sizeof(uint16_t));
             *((uint16_t *)value) = NETDEV_TYPE_SLIP;
             return sizeof(uint16_t);
+#if IS_USED(MODULE_SLIPDEV_L2ADDR)
+        case NETOPT_ADDRESS_LONG:
+            assert(max_len == sizeof(eui64_t));
+            netdev_eui64_get(netdev, value);
+            return sizeof(eui64_t);
+#endif
         default:
             return -ENOTSUP;
     }
@@ -245,12 +252,14 @@ static const netdev_driver_t slip_driver = {
     .set = netdev_set_notsup,
 };
 
-void slipdev_setup(slipdev_t *dev, const slipdev_params_t *params)
+void slipdev_setup(slipdev_t *dev, const slipdev_params_t *params, uint8_t index)
 {
     /* set device descriptor fields */
     dev->config = *params;
     dev->state = 0;
     dev->netdev.driver = &slip_driver;
+
+    netdev_register(&dev->netdev, NETDEV_SLIPDEV, index);
 }
 
 /** @} */
diff --git a/drivers/sm_pwm_01c/Kconfig b/drivers/sm_pwm_01c/Kconfig
index dc22036d6c..3fee1c6ad2 100644
--- a/drivers/sm_pwm_01c/Kconfig
+++ b/drivers/sm_pwm_01c/Kconfig
@@ -9,7 +9,6 @@ menuconfig MODULE_SM_PWM_01C
     depends on HAS_PERIPH_GPIO
     depends on HAS_PERIPH_GPIO_IRQ
     depends on TEST_KCONFIG
-    select MODULE_CHECKSUM
     select MODULE_PERIPH_GPIO
     select MODULE_PERIPH_GPIO_IRQ
     select MODULE_ZTIMER
diff --git a/drivers/soft_uart/include/soft_uart_params.h b/drivers/soft_uart/include/soft_uart_params.h
index 785e2a717f..2787933a5f 100644
--- a/drivers/soft_uart/include/soft_uart_params.h
+++ b/drivers/soft_uart/include/soft_uart_params.h
@@ -13,7 +13,7 @@
  * @file
  * @brief       Software UART configuration
  *
- * @author      Benjamin Valentin <benjjamin.valentin@ml-pa.com>
+ * @author      Benjamin Valentin <benjamin.valentin@ml-pa.com>
  */
 
 #ifndef SOFT_UART_PARAMS_H
diff --git a/drivers/soft_uart/soft_uart.c b/drivers/soft_uart/soft_uart.c
index 52fe01787a..5b9ae4b5ab 100644
--- a/drivers/soft_uart/soft_uart.c
+++ b/drivers/soft_uart/soft_uart.c
@@ -13,7 +13,7 @@
  * @file
  * @brief       Software UART implementation
  *
- * @author      Benjamin Valentin <benjjamin.valentin@ml-pa.com>
+ * @author      Benjamin Valentin <benjamin.valentin@ml-pa.com>
  */
 
 #include <stdio.h>
diff --git a/drivers/sx126x/sx126x_netdev.c b/drivers/sx126x/sx126x_netdev.c
index 0e93e75ef3..b539cd9c03 100644
--- a/drivers/sx126x/sx126x_netdev.c
+++ b/drivers/sx126x/sx126x_netdev.c
@@ -51,23 +51,24 @@ static int _send(netdev_t *netdev, const iolist_t *iolist)
         return -ENOTSUP;
     }
 
-    uint8_t size = iolist_size(iolist);
-
-    /* Ignore send if packet size is 0 */
-    if (!size) {
-        return 0;
-    }
-
-    DEBUG("[sx126x] netdev: sending packet now (size: %d).\n", size);
+    size_t pos = 0;
     /* Write payload buffer */
     for (const iolist_t *iol = iolist; iol; iol = iol->iol_next) {
         if (iol->iol_len > 0) {
-            sx126x_set_lora_payload_length(dev, iol->iol_len);
-            sx126x_write_buffer(dev, 0, iol->iol_base, iol->iol_len);
+            sx126x_write_buffer(dev, pos, iol->iol_base, iol->iol_len);
             DEBUG("[sx126x] netdev: send: wrote data to payload buffer.\n");
+            pos += iol->iol_len;
         }
     }
 
+    /* Ignore send if packet size is 0 */
+    if (!pos) {
+        return 0;
+    }
+
+    DEBUG("[sx126x] netdev: sending packet now (size: %d).\n", pos);
+    sx126x_set_lora_payload_length(dev, pos);
+
     state = NETOPT_STATE_TX;
     netdev->driver->set(netdev, NETOPT_STATE, &state, sizeof(uint8_t));
     DEBUG("[sx126x] netdev: send: transmission in progress.\n");
@@ -107,7 +108,7 @@ static int _recv(netdev_t *netdev, void *buf, size_t len, void *info)
 
     sx126x_read_buffer(dev, rx_buffer_status.buffer_start_pointer, buf, size);
 
-    return 0;
+    return size;
 }
 
 static int _init(netdev_t *netdev)
diff --git a/drivers/sx127x/Makefile.dep b/drivers/sx127x/Makefile.dep
index 4254f2eff7..2b79600317 100644
--- a/drivers/sx127x/Makefile.dep
+++ b/drivers/sx127x/Makefile.dep
@@ -6,12 +6,6 @@ USEMODULE += iolist
 USEMODULE += ztimer_usec
 USEMODULE += ztimer_msec
 
-# If RTT feature is available use the RTT backend of ztimer
-FEATURES_OPTIONAL += periph_rtt
-ifneq (,$(filter periph_rtt,$(FEATURES_USED)))
-  USEMODULE += ztimer_periph_rtt
-endif
-
 USEMODULE += lora
 
 ifneq (,$(filter gnrc,$(USEMODULE)))
diff --git a/drivers/sx127x/sx127x.c b/drivers/sx127x/sx127x.c
index 4ca4577cda..4b50f35127 100644
--- a/drivers/sx127x/sx127x.c
+++ b/drivers/sx127x/sx127x.c
@@ -75,7 +75,8 @@ static void sx127x_on_dio3_isr(void *arg);
 
 void sx127x_setup(sx127x_t *dev, const sx127x_params_t *params, uint8_t index)
 {
-    netdev_t *netdev = (netdev_t*) dev;
+    netdev_t *netdev = (netdev_t *)dev;
+
     netdev->driver = &sx127x_driver;
     dev->params = *params;
     netdev_register(&dev->netdev, NETDEV_SX127X, index);
@@ -148,7 +149,7 @@ int sx127x_init(sx127x_t *dev)
 
         /* wait till device signals end of POR cycle */
         while ((gpio_read(dev->params.reset_pin) > 0) ==
-               SX127X_POR_ACTIVE_LOGIC_LEVEL ) {};
+               SX127X_POR_ACTIVE_LOGIC_LEVEL) {}
     }
 
     /* wait for the device to become ready */
@@ -182,7 +183,7 @@ void sx127x_init_radio_settings(sx127x_t *dev)
     sx127x_set_freq_hop(dev, IS_ACTIVE(CONFIG_LORA_FREQUENCY_HOPPING_DEFAULT) ? true : false);
     sx127x_set_hop_period(dev, CONFIG_LORA_FREQUENCY_HOPPING_PERIOD_DEFAULT);
     sx127x_set_fixed_header_len_mode(dev, IS_ACTIVE(CONFIG_LORA_FIXED_HEADER_LEN_MODE_DEFAULT) ?
-                                                    true : false);
+                                     true : false);
     sx127x_set_iq_invert(dev, IS_ACTIVE(CONFIG_LORA_IQ_INVERTED_DEFAULT) ? true : false);
     sx127x_set_payload_length(dev, CONFIG_LORA_PAYLOAD_LENGTH_DEFAULT);
     sx127x_set_preamble_length(dev, CONFIG_LORA_PREAMBLE_LENGTH_DEFAULT);
@@ -214,7 +215,7 @@ uint32_t sx127x_random(sx127x_t *dev)
         ztimer_sleep(ZTIMER_MSEC, 1);   /* wait one millisecond */
 
         /* Non-filtered RSSI value reading. Only takes the LSB value */
-        rnd |= ((uint32_t) sx127x_reg_read(dev, SX127X_REG_LR_RSSIWIDEBAND) & 0x01) << i;
+        rnd |= ((uint32_t)sx127x_reg_read(dev, SX127X_REG_LR_RSSIWIDEBAND) & 0x01) << i;
     }
 
     sx127x_set_sleep(dev);
@@ -238,22 +239,22 @@ static void sx127x_on_dio_isr(sx127x_t *dev, sx127x_flags_t flag)
 
 static void sx127x_on_dio0_isr(void *arg)
 {
-    sx127x_on_dio_isr((sx127x_t*) arg, SX127X_IRQ_DIO0);
+    sx127x_on_dio_isr((sx127x_t *)arg, SX127X_IRQ_DIO0);
 }
 
 static void sx127x_on_dio1_isr(void *arg)
 {
-    sx127x_on_dio_isr((sx127x_t*) arg, SX127X_IRQ_DIO1);
+    sx127x_on_dio_isr((sx127x_t *)arg, SX127X_IRQ_DIO1);
 }
 
 static void sx127x_on_dio2_isr(void *arg)
 {
-    sx127x_on_dio_isr((sx127x_t*) arg, SX127X_IRQ_DIO2);
+    sx127x_on_dio_isr((sx127x_t *)arg, SX127X_IRQ_DIO2);
 }
 
 static void sx127x_on_dio3_isr(void *arg)
 {
-    sx127x_on_dio_isr((sx127x_t*) arg, SX127X_IRQ_DIO3);
+    sx127x_on_dio_isr((sx127x_t *)arg, SX127X_IRQ_DIO3);
 }
 
 /* Internal event handlers */
@@ -315,14 +316,14 @@ static int _init_gpios(sx127x_t *dev)
 
 static void _on_tx_timeout(void *arg)
 {
-    netdev_t *dev = (netdev_t *) arg;
+    netdev_t *dev = (netdev_t *)arg;
 
     dev->event_callback(dev, NETDEV_EVENT_TX_TIMEOUT);
 }
 
 static void _on_rx_timeout(void *arg)
 {
-    netdev_t *dev = (netdev_t *) arg;
+    netdev_t *dev = (netdev_t *)arg;
 
     dev->event_callback(dev, NETDEV_EVENT_RX_TIMEOUT);
 }
diff --git a/drivers/sx127x/sx127x_getset.c b/drivers/sx127x/sx127x_getset.c
index 371ce746be..9ec4bcd8c3 100644
--- a/drivers/sx127x/sx127x_getset.c
+++ b/drivers/sx127x/sx127x_getset.c
@@ -85,21 +85,21 @@ void sx127x_set_modem(sx127x_t *dev, uint8_t modem)
     dev->settings.modem = modem;
 
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            /* Todo */
-            break;
-        case SX127X_MODEM_LORA:
-            sx127x_set_op_mode(dev, SX127X_RF_OPMODE_SLEEP);
-            sx127x_reg_write(dev, SX127X_REG_OPMODE,
-                             (sx127x_reg_read(dev, SX127X_REG_OPMODE) &
-                              SX127X_RF_LORA_OPMODE_LONGRANGEMODE_MASK) |
-                             SX127X_RF_LORA_OPMODE_LONGRANGEMODE_ON);
-
-            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1, 0x00);
-            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING2, 0x00);
-            break;
-        default:
-            break;
+    case SX127X_MODEM_FSK:
+        /* Todo */
+        break;
+    case SX127X_MODEM_LORA:
+        sx127x_set_op_mode(dev, SX127X_RF_OPMODE_SLEEP);
+        sx127x_reg_write(dev, SX127X_REG_OPMODE,
+                         (sx127x_reg_read(dev, SX127X_REG_OPMODE) &
+                          SX127X_RF_LORA_OPMODE_LONGRANGEMODE_MASK) |
+                         SX127X_RF_LORA_OPMODE_LONGRANGEMODE_ON);
+
+        sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1, 0x00);
+        sx127x_reg_write(dev, SX127X_REG_DIOMAPPING2, 0x00);
+        break;
+    default:
+        break;
     }
 }
 
@@ -129,7 +129,7 @@ void sx127x_set_channel(sx127x_t *dev, uint32_t channel)
     /* Save current operating mode */
     dev->settings.channel = channel;
 
-    channel = (uint32_t)((double) channel / (double)LORA_FREQUENCY_RESOLUTION_DEFAULT);
+    channel = (uint32_t)((double)channel / (double)LORA_FREQUENCY_RESOLUTION_DEFAULT);
 
     /* Write frequency settings into chip */
     sx127x_reg_write(dev, SX127X_REG_FRFMSB, (uint8_t)((channel >> 16) & 0xFF));
@@ -142,56 +142,56 @@ uint32_t sx127x_get_time_on_air(const sx127x_t *dev, uint8_t pkt_len)
     uint32_t air_time = 0;
 
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            /* todo */
+    case SX127X_MODEM_FSK:
+        /* todo */
+        break;
+    case SX127X_MODEM_LORA:
+    {
+        double bw = 0.0;
+
+        /* Note: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported. */
+        switch (dev->settings.lora.bandwidth) {
+        case LORA_BW_125_KHZ:
+            bw = 125e3;
+            break;
+        case LORA_BW_250_KHZ:
+            bw = 250e3;
+            break;
+        case LORA_BW_500_KHZ:
+            bw = 500e3;
+            break;
+        default:
+            DEBUG("Invalid bandwidth: %d\n", dev->settings.lora.bandwidth);
             break;
-        case SX127X_MODEM_LORA:
-        {
-            double bw = 0.0;
-
-            /* Note: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported. */
-            switch (dev->settings.lora.bandwidth) {
-                case LORA_BW_125_KHZ:
-                    bw = 125e3;
-                    break;
-                case LORA_BW_250_KHZ:
-                    bw = 250e3;
-                    break;
-                case LORA_BW_500_KHZ:
-                    bw = 500e3;
-                    break;
-                default:
-                    DEBUG("Invalid bandwidth: %d\n", dev->settings.lora.bandwidth);
-                    break;
-            }
-
-            /* Symbol rate : time for one symbol [secs] */
-            double rs = bw / (1 << dev->settings.lora.datarate);
-            double ts = 1 / rs;
-
-            /* time of preamble */
-            double t_preamble = (dev->settings.lora.preamble_len + 4.25) * ts;
-
-            /* Symbol length of payload and time */
-            double tmp =
-                ceil(
-                    (8 * pkt_len - 4 * dev->settings.lora.datarate + 28
-                     + 16 * (dev->settings.lora.flags & SX127X_ENABLE_CRC_FLAG)
-                     - (!(dev->settings.lora.flags & SX127X_ENABLE_FIXED_HEADER_LENGTH_FLAG) ? 20 : 0))
-                    / (double) (4 * dev->settings.lora.datarate
-                                - (((dev->settings.lora.flags & SX127X_LOW_DATARATE_OPTIMIZE_FLAG)
-                                    > 0) ? 2 : 0)))
-                * (dev->settings.lora.coderate + 4);
-            double n_payload = 8 + ((tmp > 0) ? tmp : 0);
-            double t_payload = n_payload * ts;
-
-            /* Time on air */
-            double t_on_air = t_preamble + t_payload;
-
-            /* return milli seconds */
-            air_time = floor(t_on_air * 1e3 + 0.999);
         }
-        break;
+
+        /* Symbol rate : time for one symbol [secs] */
+        double rs = bw / (1 << dev->settings.lora.datarate);
+        double ts = 1 / rs;
+
+        /* time of preamble */
+        double t_preamble = (dev->settings.lora.preamble_len + 4.25) * ts;
+
+        /* Symbol length of payload and time */
+        double tmp =
+            ceil(
+                (8 * pkt_len - 4 * dev->settings.lora.datarate + 28
+                 + 16 * (dev->settings.lora.flags & SX127X_ENABLE_CRC_FLAG)
+                 - (!(dev->settings.lora.flags & SX127X_ENABLE_FIXED_HEADER_LENGTH_FLAG) ? 20 : 0))
+                / (double)(4 * dev->settings.lora.datarate
+                           - (((dev->settings.lora.flags & SX127X_LOW_DATARATE_OPTIMIZE_FLAG)
+                               > 0) ? 2 : 0)))
+            * (dev->settings.lora.coderate + 4);
+        double n_payload = 8 + ((tmp > 0) ? tmp : 0);
+        double t_payload = n_payload * ts;
+
+        /* Time on air */
+        double t_on_air = t_preamble + t_payload;
+
+        /* return milli seconds */
+        air_time = floor(t_on_air * 1e3 + 0.999);
+    }
+    break;
     }
 
     return air_time;
@@ -234,92 +234,97 @@ void sx127x_set_rx(sx127x_t *dev)
 #endif
 
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            /* todo */
-            break;
-        case SX127X_MODEM_LORA:
-        {
-            sx127x_reg_write(dev, SX127X_REG_LR_INVERTIQ,
-                             ((sx127x_reg_read(dev, SX127X_REG_LR_INVERTIQ) &
-                               SX127X_RF_LORA_INVERTIQ_TX_MASK &
-                               SX127X_RF_LORA_INVERTIQ_RX_MASK) |
-                              ((dev->settings.lora.flags & SX127X_IQ_INVERTED_FLAG) ? SX127X_RF_LORA_INVERTIQ_RX_ON :SX127X_RF_LORA_INVERTIQ_RX_OFF) |
-                              SX127X_RF_LORA_INVERTIQ_TX_OFF));
-            sx127x_reg_write(dev, SX127X_REG_LR_INVERTIQ2,
-                             ((dev->settings.lora.flags & SX127X_IQ_INVERTED_FLAG) ? SX127X_RF_LORA_INVERTIQ2_ON : SX127X_RF_LORA_INVERTIQ2_OFF));
+    case SX127X_MODEM_FSK:
+        /* todo */
+        break;
+    case SX127X_MODEM_LORA:
+    {
+        sx127x_reg_write(dev, SX127X_REG_LR_INVERTIQ,
+                         ((sx127x_reg_read(dev, SX127X_REG_LR_INVERTIQ) &
+                           SX127X_RF_LORA_INVERTIQ_TX_MASK &
+                           SX127X_RF_LORA_INVERTIQ_RX_MASK) |
+                          ((dev->settings.lora.flags &
+                            SX127X_IQ_INVERTED_FLAG) ? SX127X_RF_LORA_INVERTIQ_RX_ON :
+                           SX127X_RF_LORA_INVERTIQ_RX_OFF)
+                          |
+                          SX127X_RF_LORA_INVERTIQ_TX_OFF));
+        sx127x_reg_write(dev, SX127X_REG_LR_INVERTIQ2,
+                         ((dev->settings.lora.flags &
+                           SX127X_IQ_INVERTED_FLAG) ? SX127X_RF_LORA_INVERTIQ2_ON :
+                          SX127X_RF_LORA_INVERTIQ2_OFF));
 
 #if defined(MODULE_SX1276)
-            /* ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal */
-            if (dev->settings.lora.bandwidth < 9) {
-                sx127x_reg_write(dev, SX127X_REG_LR_DETECTOPTIMIZE,
-                                 sx127x_reg_read(dev, SX127X_REG_LR_DETECTOPTIMIZE) & 0x7F);
-                sx127x_reg_write(dev, SX127X_REG_LR_TEST30, 0x00);
-                switch (dev->settings.lora.bandwidth) {
-                    case LORA_BW_125_KHZ: /* 125 kHz */
-                        sx127x_reg_write(dev, SX127X_REG_LR_TEST2F, 0x40);
-                        break;
-                    case LORA_BW_250_KHZ: /* 250 kHz */
-                        sx127x_reg_write(dev, SX127X_REG_LR_TEST2F, 0x40);
-                        break;
-
-                    default:
-                        break;
-                }
-            }
-            else {
-                sx127x_reg_write(dev, SX127X_REG_LR_DETECTOPTIMIZE,
-                                 sx127x_reg_read(dev, SX127X_REG_LR_DETECTOPTIMIZE) | 0x80);
+        /* ERRATA 2.3 - Receiver Spurious Reception of a LoRa Signal */
+        if (dev->settings.lora.bandwidth < 9) {
+            sx127x_reg_write(dev, SX127X_REG_LR_DETECTOPTIMIZE,
+                             sx127x_reg_read(dev, SX127X_REG_LR_DETECTOPTIMIZE) & 0x7F);
+            sx127x_reg_write(dev, SX127X_REG_LR_TEST30, 0x00);
+            switch (dev->settings.lora.bandwidth) {
+            case LORA_BW_125_KHZ:         /* 125 kHz */
+                sx127x_reg_write(dev, SX127X_REG_LR_TEST2F, 0x40);
+                break;
+            case LORA_BW_250_KHZ:         /* 250 kHz */
+                sx127x_reg_write(dev, SX127X_REG_LR_TEST2F, 0x40);
+                break;
+
+            default:
+                break;
             }
+        }
+        else {
+            sx127x_reg_write(dev, SX127X_REG_LR_DETECTOPTIMIZE,
+                             sx127x_reg_read(dev, SX127X_REG_LR_DETECTOPTIMIZE) | 0x80);
+        }
 #endif
 
-            /* Setup interrupts */
-            if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
-                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
-                                 /* SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
-                                    SX127X_RF_LORA_IRQFLAGS_RXDONE |
-                                    SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
-                                    SX127X_RF_LORA_IRQFLAGS_VALIDHEADER | */
-                                 SX127X_RF_LORA_IRQFLAGS_TXDONE |
-                                 SX127X_RF_LORA_IRQFLAGS_CADDONE |
-                                 /* SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL | */
-                                 SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
-
-                /* DIO0=RxDone, DIO1=RxTimeout, DIO2=FhssChangeChannel, DIO3=ValidHeader */
-                sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
-                                 (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO2_MASK &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO3_MASK) |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO0_00 |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO1_00 |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO2_00 |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO3_01);
-            }
-            else {
-                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
-                                 /* SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
-                                    SX127X_RF_LORA_IRQFLAGS_RXDONE |
-                                    SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
-                                    SX127X_RF_LORA_IRQFLAGS_VALIDHEADER | */
-                                 SX127X_RF_LORA_IRQFLAGS_TXDONE |
-                                 SX127X_RF_LORA_IRQFLAGS_CADDONE |
-                                 SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL |
-                                 SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
-
-                /* DIO0=RxDone, DIO1=RxTimeout, DIO3=ValidHeader */
-                sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
-                                 (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO3_MASK) |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO0_00 |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO1_00 |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO3_01);
-            }
-
-            sx127x_reg_write(dev, SX127X_REG_LR_FIFORXBASEADDR, 0);
-            sx127x_reg_write(dev, SX127X_REG_LR_FIFOADDRPTR, 0);
+        /* Setup interrupts */
+        if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
+                             /* SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
+                                SX127X_RF_LORA_IRQFLAGS_RXDONE |
+                                SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
+                                SX127X_RF_LORA_IRQFLAGS_VALIDHEADER | */
+                             SX127X_RF_LORA_IRQFLAGS_TXDONE |
+                             SX127X_RF_LORA_IRQFLAGS_CADDONE |
+                             /* SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL | */
+                             SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
+
+            /* DIO0=RxDone, DIO1=RxTimeout, DIO2=FhssChangeChannel, DIO3=ValidHeader */
+            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
+                             (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO2_MASK &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO3_MASK) |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO0_00 |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO1_00 |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO2_00 |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO3_01);
         }
-        break;
+        else {
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
+                             /* SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
+                                SX127X_RF_LORA_IRQFLAGS_RXDONE |
+                                SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
+                                SX127X_RF_LORA_IRQFLAGS_VALIDHEADER | */
+                             SX127X_RF_LORA_IRQFLAGS_TXDONE |
+                             SX127X_RF_LORA_IRQFLAGS_CADDONE |
+                             SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL |
+                             SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
+
+            /* DIO0=RxDone, DIO1=RxTimeout, DIO3=ValidHeader */
+            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
+                             (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO3_MASK) |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO0_00 |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO1_00 |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO3_01);
+        }
+
+        sx127x_reg_write(dev, SX127X_REG_LR_FIFORXBASEADDR, 0);
+        sx127x_reg_write(dev, SX127X_REG_LR_FIFOADDRPTR, 0);
+    }
+    break;
     }
 
     sx127x_set_state(dev, SX127X_RF_RX_RUNNING);
@@ -345,52 +350,51 @@ void sx127x_set_tx(sx127x_t *dev)
     gpio_set(dev->params.tx_switch_pin);
 #endif
 
-     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            /* todo */
-            break;
-        case SX127X_MODEM_LORA:
-        {
-            if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
-                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
-                                 SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
-                                 SX127X_RF_LORA_IRQFLAGS_RXDONE |
-                                 SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
-                                 SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
-                                 /* SX127X_RF_LORA_IRQFLAGS_TXDONE | */
-                                 SX127X_RF_LORA_IRQFLAGS_CADDONE |
-                                 /* SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL | */
-                                 SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
-
-                /* DIO0=TxDone, DIO2=FhssChangeChannel */
-                sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
-                                 (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1 ) &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO2_MASK) |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO0_01 |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO2_00);
-            }
-            else
-            {
-                /* Enable TXDONE interrupt */
-                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
-                                 SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
-                                 SX127X_RF_LORA_IRQFLAGS_RXDONE |
-                                 SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
-                                 SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
-                                 /* SX127X_RF_LORA_IRQFLAGS_TXDONE | */
-                                 SX127X_RF_LORA_IRQFLAGS_CADDONE |
-                                 SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL |
-                                 SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
-
-                /* Set TXDONE interrupt to the DIO0 line */
-                sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
-                                 (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK) |
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO0_01);
-            }
-        }
+    switch (dev->settings.modem) {
+    case SX127X_MODEM_FSK:
+        /* todo */
         break;
+    case SX127X_MODEM_LORA:
+    {
+        if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
+                             SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
+                             SX127X_RF_LORA_IRQFLAGS_RXDONE |
+                             SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
+                             SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
+                                /* SX127X_RF_LORA_IRQFLAGS_TXDONE | */
+                             SX127X_RF_LORA_IRQFLAGS_CADDONE |
+                                /* SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL | */
+                             SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
+
+            /* DIO0=TxDone, DIO2=FhssChangeChannel */
+            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
+                             (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1 ) &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO2_MASK) |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO0_01 |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO2_00);
+        }
+        else {
+            /* Enable TXDONE interrupt */
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
+                             SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
+                             SX127X_RF_LORA_IRQFLAGS_RXDONE |
+                             SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
+                             SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
+                             /* SX127X_RF_LORA_IRQFLAGS_TXDONE | */
+                             SX127X_RF_LORA_IRQFLAGS_CADDONE |
+                             SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL |
+                             SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
+
+            /* Set TXDONE interrupt to the DIO0 line */
+            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
+                             (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK) |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO0_01);
+        }
+    }
+    break;
     }
 
     sx127x_set_state(dev, SX127X_RF_TX_RUNNING);
@@ -407,11 +411,11 @@ void sx127x_set_tx(sx127x_t *dev)
 uint8_t sx127x_get_max_payload_len(const sx127x_t *dev)
 {
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            return sx127x_reg_read(dev, SX127X_REG_PAYLOADLENGTH);
+    case SX127X_MODEM_FSK:
+        return sx127x_reg_read(dev, SX127X_REG_PAYLOADLENGTH);
 
-        case SX127X_MODEM_LORA:
-            return sx127x_reg_read(dev, SX127X_REG_LR_PAYLOADMAXLENGTH);
+    case SX127X_MODEM_LORA:
+        return sx127x_reg_read(dev, SX127X_REG_LR_PAYLOADMAXLENGTH);
     }
 
     /* should never be reached */
@@ -423,13 +427,13 @@ void sx127x_set_max_payload_len(const sx127x_t *dev, uint8_t maxlen)
     DEBUG("[sx127x] Set max payload len: %d\n", maxlen);
 
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            sx127x_reg_write(dev, SX127X_REG_PAYLOADLENGTH, maxlen);
-            break;
+    case SX127X_MODEM_FSK:
+        sx127x_reg_write(dev, SX127X_REG_PAYLOADLENGTH, maxlen);
+        break;
 
-        case SX127X_MODEM_LORA:
-            sx127x_reg_write(dev, SX127X_REG_LR_PAYLOADMAXLENGTH, maxlen);
-            break;
+    case SX127X_MODEM_LORA:
+        sx127x_reg_write(dev, SX127X_REG_LR_PAYLOADMAXLENGTH, maxlen);
+        break;
     }
 }
 
@@ -441,7 +445,7 @@ uint8_t sx127x_get_op_mode(const sx127x_t *dev)
 void sx127x_set_op_mode(const sx127x_t *dev, uint8_t op_mode)
 {
     if (IS_ACTIVE(ENABLE_DEBUG)) {
-        switch(op_mode) {
+        switch (op_mode) {
         case SX127X_RF_OPMODE_SLEEP:
             DEBUG("[sx127x] Set op mode: SLEEP\n");
             break;
@@ -475,13 +479,14 @@ uint8_t sx127x_get_bandwidth(const sx127x_t *dev)
 
 static void _low_datarate_optimize(sx127x_t *dev)
 {
-    if ( ((dev->settings.lora.bandwidth == LORA_BW_125_KHZ) &&
-          ((dev->settings.lora.datarate == LORA_SF11) ||
-           (dev->settings.lora.datarate == LORA_SF12))) ||
-         ((dev->settings.lora.bandwidth == LORA_BW_250_KHZ) &&
-          (dev->settings.lora.datarate == LORA_SF12))) {
+    if (((dev->settings.lora.bandwidth == LORA_BW_125_KHZ) &&
+         ((dev->settings.lora.datarate == LORA_SF11) ||
+          (dev->settings.lora.datarate == LORA_SF12))) ||
+        ((dev->settings.lora.bandwidth == LORA_BW_250_KHZ) &&
+         (dev->settings.lora.datarate == LORA_SF12))) {
         dev->settings.lora.flags |= SX127X_LOW_DATARATE_OPTIMIZE_FLAG;
-    } else {
+    }
+    else {
         dev->settings.lora.flags &= ~SX127X_LOW_DATARATE_OPTIMIZE_FLAG;
     }
 
@@ -501,6 +506,7 @@ static void _low_datarate_optimize(sx127x_t *dev)
 static void _update_bandwidth(const sx127x_t *dev)
 {
     uint8_t config1_reg = sx127x_reg_read(dev, SX127X_REG_LR_MODEMCONFIG1);
+
 #if defined(MODULE_SX1272)
     config1_reg &= SX1272_RF_LORA_MODEMCONFIG1_BW_MASK;
     switch (dev->settings.lora.bandwidth) {
@@ -587,13 +593,14 @@ void sx127x_set_spreading_factor(sx127x_t *dev, uint8_t datarate)
     dev->settings.lora.datarate = datarate;
 
     uint8_t config2_reg = sx127x_reg_read(dev, SX127X_REG_LR_MODEMCONFIG2);
+
     config2_reg &= SX127X_RF_LORA_MODEMCONFIG2_SF_MASK;
     config2_reg |= datarate << 4;
     sx127x_reg_write(dev, SX127X_REG_LR_MODEMCONFIG2, config2_reg);
 
     _low_datarate_optimize(dev);
 
-    switch(dev->settings.lora.datarate) {
+    switch (dev->settings.lora.datarate) {
     case LORA_SF6:
         sx127x_reg_write(dev, SX127X_REG_LR_DETECTOPTIMIZE,
                          SX127X_RF_LORA_DETECTIONOPTIMIZE_SF6);
@@ -694,6 +701,7 @@ void sx127x_set_hop_period(sx127x_t *dev, uint8_t hop_period)
     dev->settings.lora.freq_hop_period = hop_period;
 
     uint8_t tmp = sx127x_reg_read(dev, SX127X_REG_LR_PLLHOP);
+
     if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
         tmp |= SX127X_RF_LORA_PLLHOP_FASTHOP_ON;
         sx127x_reg_write(dev, SX127X_REG_LR_PLLHOP, tmp);
@@ -713,6 +721,7 @@ void sx127x_set_fixed_header_len_mode(sx127x_t *dev, bool fixed_len)
     _set_flag(dev, SX127X_ENABLE_FIXED_HEADER_LENGTH_FLAG, fixed_len);
 
     uint8_t config1_reg = sx127x_reg_read(dev, SX127X_REG_LR_MODEMCONFIG1);
+
 #if defined(MODULE_SX1272)
     config1_reg &= SX1272_RF_LORA_MODEMCONFIG1_IMPLICITHEADER_MASK;
     config1_reg |= fixed_len << 2;
@@ -725,7 +734,7 @@ void sx127x_set_fixed_header_len_mode(sx127x_t *dev, bool fixed_len)
 
 uint8_t sx127x_get_payload_length(const sx127x_t *dev)
 {
-    return sx127x_reg_read(dev, SX127X_REG_LR_PAYLOADLENGTH);;
+    return sx127x_reg_read(dev, SX127X_REG_LR_PAYLOADLENGTH);
 }
 
 void sx127x_set_payload_length(sx127x_t *dev, uint8_t len)
@@ -756,6 +765,7 @@ void sx127x_set_tx_power(sx127x_t *dev, int8_t power)
     dev->settings.lora.power = power;
 
     uint8_t pa_config = sx127x_reg_read(dev, SX127X_REG_PACONFIG);
+
 #if defined(MODULE_SX1272)
     uint8_t pa_dac = sx127x_reg_read(dev, SX1272_REG_PADAC);
 #else /* MODULE_SX1276 */
@@ -777,7 +787,8 @@ void sx127x_set_tx_power(sx127x_t *dev, int8_t power)
         if (power > 17) {
             pa_dac = ((pa_dac & SX127X_RF_PADAC_20DBM_MASK) |
                       SX127X_RF_PADAC_20DBM_ON);
-        } else {
+        }
+        else {
             pa_dac = ((pa_dac & SX127X_RF_PADAC_20DBM_MASK) |
                       SX127X_RF_PADAC_20DBM_OFF);
         }
@@ -791,7 +802,8 @@ void sx127x_set_tx_power(sx127x_t *dev, int8_t power)
 
             pa_config = ((pa_config & SX127X_RF_PACONFIG_OUTPUTPOWER_MASK) |
                          (uint8_t)((uint16_t)(power - 5) & 0x0F));
-        } else {
+        }
+        else {
             if (power < 2) {
                 power = 2;
             }
@@ -802,7 +814,8 @@ void sx127x_set_tx_power(sx127x_t *dev, int8_t power)
             pa_config = ((pa_config & SX127X_RF_PACONFIG_OUTPUTPOWER_MASK) |
                          (uint8_t)((uint16_t)(power - 2) & 0x0F));
         }
-    } else {
+    }
+    else {
         if (power < -1) {
             power = -1;
         }
@@ -858,6 +871,7 @@ void sx127x_set_symbol_timeout(sx127x_t *dev, uint16_t timeout)
     DEBUG("[sx127x] Set symbol timeout: %d\n", timeout);
 
     uint8_t config2_reg = sx127x_reg_read(dev, SX127X_REG_LR_MODEMCONFIG2);
+
     config2_reg &= SX127X_RF_LORA_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK;
     config2_reg |= (timeout >> 8) & ~SX127X_RF_LORA_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK;
     sx127x_reg_write(dev, SX127X_REG_LR_MODEMCONFIG2, config2_reg);
@@ -879,7 +893,7 @@ void sx127x_set_iq_invert(sx127x_t *dev, bool iq_invert)
                      (sx127x_reg_read(dev, SX127X_REG_LR_INVERTIQ) &
                       SX127X_RF_LORA_INVERTIQ_RX_MASK &
                       SX127X_RF_LORA_INVERTIQ_TX_MASK) |
-                      SX127X_RF_LORA_INVERTIQ_RX_OFF |
+                     SX127X_RF_LORA_INVERTIQ_RX_OFF |
                      (iq_invert ? SX127X_RF_LORA_INVERTIQ_TX_ON : SX127X_RF_LORA_INVERTIQ_TX_OFF));
 
     sx127x_reg_write(dev, SX127X_REG_LR_INVERTIQ2,
@@ -890,5 +904,5 @@ void sx127x_set_freq_hop(sx127x_t *dev, bool freq_hop_on)
 {
     DEBUG("[sx127x] Set freq hop: %d\n", freq_hop_on);
 
-     _set_flag(dev, SX127X_CHANNEL_HOPPING_FLAG, freq_hop_on);
+    _set_flag(dev, SX127X_CHANNEL_HOPPING_FLAG, freq_hop_on);
 }
diff --git a/drivers/sx127x/sx127x_internal.c b/drivers/sx127x/sx127x_internal.c
index c49b6ac9c0..8baed8810e 100644
--- a/drivers/sx127x/sx127x_internal.c
+++ b/drivers/sx127x/sx127x_internal.c
@@ -86,7 +86,7 @@ void sx127x_reg_write_burst(const sx127x_t *dev, uint8_t addr, uint8_t *buffer,
     spi_acquire(dev->params.spi, SPI_CS_UNDEF, SX127X_SPI_MODE, SX127X_SPI_SPEED);
 
     gpio_clear(dev->params.nss_pin);
-    spi_transfer_regs(dev->params.spi, SPI_CS_UNDEF, addr | 0x80, (char *) buffer, NULL, size);
+    spi_transfer_regs(dev->params.spi, SPI_CS_UNDEF, addr | 0x80, (char *)buffer, NULL, size);
     gpio_set(dev->params.nss_pin);
 
     spi_release(dev->params.spi);
@@ -98,7 +98,7 @@ void sx127x_reg_read_burst(const sx127x_t *dev, uint8_t addr, uint8_t *buffer,
     spi_acquire(dev->params.spi, SPI_CS_UNDEF, SX127X_SPI_MODE, SX127X_SPI_SPEED);
 
     gpio_clear(dev->params.nss_pin);
-    spi_transfer_regs(dev->params.spi, SPI_CS_UNDEF, addr & 0x7F, NULL, (char *) buffer, size);
+    spi_transfer_regs(dev->params.spi, SPI_CS_UNDEF, addr & 0x7F, NULL, (char *)buffer, size);
     gpio_set(dev->params.nss_pin);
 
     spi_release(dev->params.spi);
@@ -122,9 +122,11 @@ void sx1276_rx_chain_calibration(sx127x_t *dev)
 
     /* Save context */
     reg_pa_config_init_val = sx127x_reg_read(dev, SX127X_REG_PACONFIG);
-    initial_freq = (double) (((uint32_t) sx127x_reg_read(dev, SX127X_REG_FRFMSB) << 16)
-                             | ((uint32_t) sx127x_reg_read(dev, SX127X_REG_FRFMID) << 8)
-                             | ((uint32_t) sx127x_reg_read(dev, SX127X_REG_FRFLSB))) * (double)LORA_FREQUENCY_RESOLUTION_DEFAULT;
+    initial_freq = (double)(((uint32_t)sx127x_reg_read(dev, SX127X_REG_FRFMSB) << 16)
+                            | ((uint32_t)sx127x_reg_read(dev, SX127X_REG_FRFMID) << 8)
+                            | ((uint32_t)sx127x_reg_read(dev,
+                                                         SX127X_REG_FRFLSB))) *
+                   (double)LORA_FREQUENCY_RESOLUTION_DEFAULT;
 
     /* Cut the PA just in case, RFO output, power = -1 dBm */
     sx127x_reg_write(dev, SX127X_REG_PACONFIG, 0x00);
@@ -136,8 +138,7 @@ void sx1276_rx_chain_calibration(sx127x_t *dev)
                      | SX127X_RF_IMAGECAL_IMAGECAL_START);
 
     while ((sx127x_reg_read(dev, SX127X_REG_IMAGECAL) & SX127X_RF_IMAGECAL_IMAGECAL_RUNNING)
-           == SX127X_RF_IMAGECAL_IMAGECAL_RUNNING) {
-    }
+           == SX127X_RF_IMAGECAL_IMAGECAL_RUNNING) {}
 
     /* Set a frequency in HF band */
     sx127x_set_channel(dev, SX127X_HF_CHANNEL_DEFAULT);
@@ -148,8 +149,7 @@ void sx1276_rx_chain_calibration(sx127x_t *dev)
                      (sx127x_reg_read(dev, SX127X_REG_IMAGECAL) & SX127X_RF_IMAGECAL_IMAGECAL_MASK)
                      | SX127X_RF_IMAGECAL_IMAGECAL_START);
     while ((sx127x_reg_read(dev, SX127X_REG_IMAGECAL) & SX127X_RF_IMAGECAL_IMAGECAL_RUNNING)
-           == SX127X_RF_IMAGECAL_IMAGECAL_RUNNING) {
-    }
+           == SX127X_RF_IMAGECAL_IMAGECAL_RUNNING) {}
 
     /* Restore context */
     sx127x_reg_write(dev, SX127X_REG_PACONFIG, reg_pa_config_init_val);
@@ -162,24 +162,24 @@ int16_t sx127x_read_rssi(const sx127x_t *dev)
     int16_t rssi = 0;
 
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            rssi = -(sx127x_reg_read(dev, SX127X_REG_RSSIVALUE) >> 1);
-            break;
-        case SX127X_MODEM_LORA:
+    case SX127X_MODEM_FSK:
+        rssi = -(sx127x_reg_read(dev, SX127X_REG_RSSIVALUE) >> 1);
+        break;
+    case SX127X_MODEM_LORA:
 #if defined(MODULE_SX1272)
-            rssi = SX127X_RSSI_OFFSET + sx127x_reg_read(dev, SX127X_REG_LR_RSSIVALUE);
+        rssi = SX127X_RSSI_OFFSET + sx127x_reg_read(dev, SX127X_REG_LR_RSSIVALUE);
 #else /* MODULE_SX1276 */
-            if (dev->settings.channel > SX127X_RF_MID_BAND_THRESH) {
-                rssi = SX127X_RSSI_OFFSET_HF + sx127x_reg_read(dev, SX127X_REG_LR_RSSIVALUE);
-            }
-            else {
-                rssi = SX127X_RSSI_OFFSET_LF + sx127x_reg_read(dev, SX127X_REG_LR_RSSIVALUE);
-            }
+        if (dev->settings.channel > SX127X_RF_MID_BAND_THRESH) {
+            rssi = SX127X_RSSI_OFFSET_HF + sx127x_reg_read(dev, SX127X_REG_LR_RSSIVALUE);
+        }
+        else {
+            rssi = SX127X_RSSI_OFFSET_LF + sx127x_reg_read(dev, SX127X_REG_LR_RSSIVALUE);
+        }
 #endif
-            break;
-        default:
-            rssi = -1;
-            break;
+        break;
+    default:
+        rssi = -1;
+        break;
     }
 
     return rssi;
@@ -188,41 +188,41 @@ int16_t sx127x_read_rssi(const sx127x_t *dev)
 void sx127x_start_cad(sx127x_t *dev)
 {
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            break;
-        case SX127X_MODEM_LORA:
-            /* Disable all interrupts except CAD-related */
-            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
-                             SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
-                             SX127X_RF_LORA_IRQFLAGS_RXDONE |
-                             SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
-                             SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
-                             SX127X_RF_LORA_IRQFLAGS_TXDONE |
-                             /*SX127X_RF_LORA_IRQFLAGS_CADDONE |*/
-                             SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL
-                             /* | SX127X_RF_LORA_IRQFLAGS_CADDETECTED*/
-                             );
-
-            if (gpio_is_valid(dev->params.dio3_pin)) {
-                /* DIO3 = CADDone */
-                sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
-                                 (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO3_MASK) |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO3_00);
-            }
-            else {
-                /* DIO0 = CADDone */
-                sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
-                                 (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
-                                  SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK) |
-                                 SX127X_RF_LORA_DIOMAPPING1_DIO0_10);
-            }
-
-            sx127x_set_state(dev,  SX127X_RF_CAD);
-            sx127x_set_op_mode(dev, SX127X_RF_LORA_OPMODE_CAD);
-            break;
-        default:
-            break;
+    case SX127X_MODEM_FSK:
+        break;
+    case SX127X_MODEM_LORA:
+        /* Disable all interrupts except CAD-related */
+        sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGSMASK,
+                         SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT |
+                         SX127X_RF_LORA_IRQFLAGS_RXDONE |
+                         SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR |
+                         SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
+                         SX127X_RF_LORA_IRQFLAGS_TXDONE |
+                            /*SX127X_RF_LORA_IRQFLAGS_CADDONE |*/
+                         SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL
+                            /* | SX127X_RF_LORA_IRQFLAGS_CADDETECTED*/
+                         );
+
+        if (gpio_is_valid(dev->params.dio3_pin)) {
+            /* DIO3 = CADDone */
+            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
+                             (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO3_MASK) |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO3_00);
+        }
+        else {
+            /* DIO0 = CADDone */
+            sx127x_reg_write(dev, SX127X_REG_DIOMAPPING1,
+                             (sx127x_reg_read(dev, SX127X_REG_DIOMAPPING1) &
+                              SX127X_RF_LORA_DIOMAPPING1_DIO0_MASK) |
+                             SX127X_RF_LORA_DIOMAPPING1_DIO0_10);
+        }
+
+        sx127x_set_state(dev,  SX127X_RF_CAD);
+        sx127x_set_op_mode(dev, SX127X_RF_LORA_OPMODE_CAD);
+        break;
+    default:
+        break;
     }
 }
 
diff --git a/drivers/sx127x/sx127x_netdev.c b/drivers/sx127x/sx127x_netdev.c
index d6829b779a..d527d34da2 100644
--- a/drivers/sx127x/sx127x_netdev.c
+++ b/drivers/sx127x/sx127x_netdev.c
@@ -48,7 +48,7 @@ void _on_dio3_irq(void *arg);
 static int _send(netdev_t *netdev, const iolist_t *iolist)
 {
     DEBUG("[sx127x] Sending packet now.\n");
-    sx127x_t *dev = (sx127x_t*) netdev;
+    sx127x_t *dev = (sx127x_t *)netdev;
 
     if (sx127x_get_state(dev) == SX127X_RF_TX_RUNNING) {
         DEBUG("[sx127x] Cannot send packet: radio already in transmitting "
@@ -64,40 +64,40 @@ static int _send(netdev_t *netdev, const iolist_t *iolist)
     }
 
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            /* todo */
-            break;
-        case SX127X_MODEM_LORA:
-            /* Initializes the payload size */
-            if (!sx127x_get_fixed_header_len_mode(dev)) {
-                DEBUG("[sx127x] Modem option is LoRa.\n");
-                sx127x_set_payload_length(dev, size);
-            }
-
-            /* Full buffer used for Tx */
-            sx127x_reg_write(dev, SX127X_REG_LR_FIFOTXBASEADDR, 0x00);
-            sx127x_reg_write(dev, SX127X_REG_LR_FIFOADDRPTR, 0x00);
-
-            /* FIFO operations can not take place in Sleep mode
-             * So wake up the chip */
-            if (sx127x_get_op_mode(dev) == SX127X_RF_OPMODE_SLEEP) {
-                sx127x_set_standby(dev);
-                DEBUG("[sx127x] Waiting for chip to wake up.\n");
-                ztimer_sleep(ZTIMER_MSEC, SX127X_RADIO_WAKEUP_TIME); /* wait for chip wake up */
-            }
-
-            /* Write payload buffer */
-            for (const iolist_t *iol = iolist; iol; iol = iol->iol_next) {
-                if(iol->iol_len > 0) {
-                    sx127x_write_fifo(dev, iol->iol_base, iol->iol_len);
-                    DEBUG("[sx127x] Wrote to payload buffer.\n");
-                }
+    case SX127X_MODEM_FSK:
+        /* todo */
+        break;
+    case SX127X_MODEM_LORA:
+        /* Initializes the payload size */
+        if (!sx127x_get_fixed_header_len_mode(dev)) {
+            DEBUG("[sx127x] Modem option is LoRa.\n");
+            sx127x_set_payload_length(dev, size);
+        }
+
+        /* Full buffer used for Tx */
+        sx127x_reg_write(dev, SX127X_REG_LR_FIFOTXBASEADDR, 0x00);
+        sx127x_reg_write(dev, SX127X_REG_LR_FIFOADDRPTR, 0x00);
+
+        /* FIFO operations can not take place in Sleep mode
+         * So wake up the chip */
+        if (sx127x_get_op_mode(dev) == SX127X_RF_OPMODE_SLEEP) {
+            sx127x_set_standby(dev);
+            DEBUG("[sx127x] Waiting for chip to wake up.\n");
+            ztimer_sleep(ZTIMER_MSEC, SX127X_RADIO_WAKEUP_TIME);     /* wait for chip wake up */
+        }
+
+        /* Write payload buffer */
+        for (const iolist_t *iol = iolist; iol; iol = iol->iol_next) {
+            if (iol->iol_len > 0) {
+                sx127x_write_fifo(dev, iol->iol_base, iol->iol_len);
+                DEBUG("[sx127x] Wrote to payload buffer.\n");
             }
-            break;
-        default:
-            DEBUG("[sx127x] netdev: Unsupported modem (%d)\n",
-                  dev->settings.modem);
-            break;
+        }
+        break;
+    default:
+        DEBUG("[sx127x] netdev: Unsupported modem (%d)\n",
+              dev->settings.modem);
+        break;
     }
 
     sx127x_set_tx(dev);
@@ -107,94 +107,97 @@ static int _send(netdev_t *netdev, const iolist_t *iolist)
 
 static int _recv(netdev_t *netdev, void *buf, size_t len, void *info)
 {
-    sx127x_t *dev = (sx127x_t*) netdev;
+    sx127x_t *dev = (sx127x_t *)netdev;
     volatile uint8_t irq_flags = 0;
     uint8_t size = 0;
+
     switch (dev->settings.modem) {
-        case SX127X_MODEM_FSK:
-            /* todo */
-            break;
-        case SX127X_MODEM_LORA:
+    case SX127X_MODEM_FSK:
+        /* todo */
+        break;
+    case SX127X_MODEM_LORA:
+        /* Clear IRQ */
+        sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS, SX127X_RF_LORA_IRQFLAGS_RXDONE);
+
+        irq_flags = sx127x_reg_read(dev, SX127X_REG_LR_IRQFLAGS);
+        if ((irq_flags & SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR_MASK) ==
+            SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR) {
             /* Clear IRQ */
-            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS, SX127X_RF_LORA_IRQFLAGS_RXDONE);
-
-            irq_flags = sx127x_reg_read(dev, SX127X_REG_LR_IRQFLAGS);
-            if ( (irq_flags & SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR_MASK) ==
-                 SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR) {
-                /* Clear IRQ */
-                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
-                                 SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR);
-
-                if (!(dev->settings.lora.flags & SX127X_RX_CONTINUOUS_FLAG)) {
-                    sx127x_set_state(dev, SX127X_RF_IDLE);
-                }
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
+                             SX127X_RF_LORA_IRQFLAGS_PAYLOADCRCERROR);
 
-                ztimer_remove(ZTIMER_MSEC, &dev->_internal.rx_timeout_timer);
-                netdev->event_callback(netdev, NETDEV_EVENT_CRC_ERROR);
-                return -EBADMSG;
+            if (!(dev->settings.lora.flags & SX127X_RX_CONTINUOUS_FLAG)) {
+                sx127x_set_state(dev, SX127X_RF_IDLE);
             }
 
-            netdev_lora_rx_info_t *packet_info = info;
-            if (packet_info) {
-                uint8_t snr_value = sx127x_reg_read(dev, SX127X_REG_LR_PKTSNRVALUE);
-                if (snr_value & 0x80) { /* The SNR is negative */
-                    /* Invert and divide by 4 */
-                    packet_info->snr = -1 * ((~snr_value + 1) & 0xFF) >> 2;
-                }
-                else {
-                    /* Divide by 4 */
-                    packet_info->snr = (snr_value & 0xFF) >> 2;
-                }
+            ztimer_remove(ZTIMER_MSEC, &dev->_internal.rx_timeout_timer);
+            netdev->event_callback(netdev, NETDEV_EVENT_CRC_ERROR);
+            return -EBADMSG;
+        }
+
+        netdev_lora_rx_info_t *packet_info = info;
+        if (packet_info) {
+            uint8_t snr_value = sx127x_reg_read(dev, SX127X_REG_LR_PKTSNRVALUE);
+            if (snr_value & 0x80) {     /* The SNR is negative */
+                /* Invert and divide by 4 */
+                packet_info->snr = -1 * ((~snr_value + 1) & 0xFF) >> 2;
+            }
+            else {
+                /* Divide by 4 */
+                packet_info->snr = (snr_value & 0xFF) >> 2;
+            }
 
-                int16_t rssi = sx127x_reg_read(dev, SX127X_REG_LR_PKTRSSIVALUE);
+            int16_t rssi = sx127x_reg_read(dev, SX127X_REG_LR_PKTRSSIVALUE);
 
-                if (packet_info->snr < 0) {
+            if (packet_info->snr < 0) {
 #if defined(MODULE_SX1272)
-                    packet_info->rssi = SX127X_RSSI_OFFSET + rssi + (rssi >> 4) + packet_info->snr;
+                packet_info->rssi = SX127X_RSSI_OFFSET + rssi + (rssi >> 4) + packet_info->snr;
 #else /* MODULE_SX1276 */
-                    if (dev->settings.channel > SX127X_RF_MID_BAND_THRESH) {
-                        packet_info->rssi = SX127X_RSSI_OFFSET_HF + rssi + (rssi >> 4) + packet_info->snr;
-                    }
-                    else {
-                        packet_info->rssi = SX127X_RSSI_OFFSET_LF + rssi + (rssi >> 4) + packet_info->snr;
-                    }
-#endif
+                if (dev->settings.channel > SX127X_RF_MID_BAND_THRESH) {
+                    packet_info->rssi = SX127X_RSSI_OFFSET_HF + rssi + (rssi >> 4) +
+                                        packet_info->snr;
                 }
                 else {
+                    packet_info->rssi = SX127X_RSSI_OFFSET_LF + rssi + (rssi >> 4) +
+                                        packet_info->snr;
+                }
+#endif
+            }
+            else {
 #if defined(MODULE_SX1272)
-                    packet_info->rssi = SX127X_RSSI_OFFSET + rssi + (rssi >> 4);
+                packet_info->rssi = SX127X_RSSI_OFFSET + rssi + (rssi >> 4);
 #else /* MODULE_SX1276 */
-                    if (dev->settings.channel > SX127X_RF_MID_BAND_THRESH) {
-                        packet_info->rssi = SX127X_RSSI_OFFSET_HF + rssi + (rssi >> 4);
-                    }
-                    else {
-                        packet_info->rssi = SX127X_RSSI_OFFSET_LF + rssi + (rssi >> 4);
-                    }
-#endif
+                if (dev->settings.channel > SX127X_RF_MID_BAND_THRESH) {
+                    packet_info->rssi = SX127X_RSSI_OFFSET_HF + rssi + (rssi >> 4);
                 }
+                else {
+                    packet_info->rssi = SX127X_RSSI_OFFSET_LF + rssi + (rssi >> 4);
+                }
+#endif
             }
-
-            size = sx127x_reg_read(dev, SX127X_REG_LR_RXNBBYTES);
-            if (buf == NULL) {
-                return size;
-            }
-
-            if (size > len) {
-                return -ENOBUFS;
-            }
-
-            if (!(dev->settings.lora.flags & SX127X_RX_CONTINUOUS_FLAG)) {
-                sx127x_set_state(dev, SX127X_RF_IDLE);
-            }
-
-            ztimer_remove(ZTIMER_MSEC, &dev->_internal.rx_timeout_timer);
-            /* Read the last packet from FIFO */
-            uint8_t last_rx_addr = sx127x_reg_read(dev, SX127X_REG_LR_FIFORXCURRENTADDR);
-            sx127x_reg_write(dev, SX127X_REG_LR_FIFOADDRPTR, last_rx_addr);
-            sx127x_read_fifo(dev, (uint8_t*)buf, size);
-            break;
-        default:
-            break;
+        }
+
+        size = sx127x_reg_read(dev, SX127X_REG_LR_RXNBBYTES);
+        if (buf == NULL) {
+            return size;
+        }
+
+        if (size > len) {
+            return -ENOBUFS;
+        }
+
+        if (!(dev->settings.lora.flags & SX127X_RX_CONTINUOUS_FLAG)) {
+            sx127x_set_state(dev, SX127X_RF_IDLE);
+        }
+
+        ztimer_remove(ZTIMER_MSEC, &dev->_internal.rx_timeout_timer);
+        /* Read the last packet from FIFO */
+        uint8_t last_rx_addr = sx127x_reg_read(dev, SX127X_REG_LR_FIFORXCURRENTADDR);
+        sx127x_reg_write(dev, SX127X_REG_LR_FIFOADDRPTR, last_rx_addr);
+        sx127x_read_fifo(dev, (uint8_t *)buf, size);
+        break;
+    default:
+        break;
     }
 
     return size;
@@ -202,10 +205,11 @@ static int _recv(netdev_t *netdev, void *buf, size_t len, void *info)
 
 static int _init(netdev_t *netdev)
 {
-    sx127x_t *sx127x = (sx127x_t*) netdev;
+    sx127x_t *sx127x = (sx127x_t *)netdev;
 
     sx127x->irq = 0;
     sx127x_radio_settings_t settings;
+
     settings.channel = SX127X_CHANNEL_DEFAULT;
     settings.modem = SX127X_MODEM_DEFAULT;
     settings.state = SX127X_RF_IDLE;
@@ -256,95 +260,97 @@ static void _isr(netdev_t *netdev)
 
 static int _get(netdev_t *netdev, netopt_t opt, void *val, size_t max_len)
 {
-    (void) max_len;  /* unused when compiled without debug, assert empty */
-    sx127x_t *dev = (sx127x_t*) netdev;
+    (void)max_len;   /* unused when compiled without debug, assert empty */
+    sx127x_t *dev = (sx127x_t *)netdev;
 
     if (dev == NULL) {
         return -ENODEV;
     }
 
-    switch(opt) {
-        case NETOPT_STATE:
-            assert(max_len >= sizeof(netopt_state_t));
-            return _get_state(dev, val);
-
-        case NETOPT_DEVICE_TYPE:
-            assert(max_len >= sizeof(uint16_t));
-            *((uint16_t*) val) = NETDEV_TYPE_LORA;
-            return sizeof(uint16_t);
-
-        case NETOPT_CHANNEL_FREQUENCY:
-            assert(max_len >= sizeof(uint32_t));
-            *((uint32_t*) val) = sx127x_get_channel(dev);
-            return sizeof(uint32_t);
-
-        case NETOPT_BANDWIDTH:
-            assert(max_len >= sizeof(uint8_t));
-            *((uint8_t*) val) = sx127x_get_bandwidth(dev);
-            return sizeof(uint8_t);
-
-        case NETOPT_SPREADING_FACTOR:
-            assert(max_len >= sizeof(uint8_t));
-            *((uint8_t*) val) = sx127x_get_spreading_factor(dev);
-            return sizeof(uint8_t);
-
-        case NETOPT_CODING_RATE:
-            assert(max_len >= sizeof(uint8_t));
-            *((uint8_t*) val) = sx127x_get_coding_rate(dev);
-            return sizeof(uint8_t);
-
-        case NETOPT_MAX_PDU_SIZE:
-            assert(max_len >= sizeof(uint8_t));
-            *((uint8_t*) val) = sx127x_get_max_payload_len(dev);
-            return sizeof(uint8_t);
-
-        case NETOPT_INTEGRITY_CHECK:
-            assert(max_len >= sizeof(netopt_enable_t));
-            *((netopt_enable_t*) val) = sx127x_get_crc(dev) ? NETOPT_ENABLE : NETOPT_DISABLE;
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_CHANNEL_HOP:
-            assert(max_len >= sizeof(netopt_enable_t));
-            *((netopt_enable_t*) val) = (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) ? NETOPT_ENABLE : NETOPT_DISABLE;
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_CHANNEL_HOP_PERIOD:
-            assert(max_len >= sizeof(uint8_t));
-            *((uint8_t*) val) = sx127x_get_hop_period(dev);
-            return sizeof(uint8_t);
-
-        case NETOPT_SINGLE_RECEIVE:
-            assert(max_len >= sizeof(uint8_t));
-            *((netopt_enable_t*) val) = sx127x_get_rx_single(dev) ? NETOPT_ENABLE : NETOPT_DISABLE;
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_TX_POWER:
-            assert(max_len >= sizeof(int16_t));
-            *((int16_t*) val) = (int16_t)sx127x_get_tx_power(dev);
-            return sizeof(int16_t);
-
-        case NETOPT_SYNCWORD:
-            assert(max_len >= sizeof(uint8_t));
-            *((uint8_t*) val) = (uint8_t) sx127x_get_syncword(dev);
-            return sizeof(uint8_t);
-
-        case NETOPT_RANDOM:
-            assert(max_len >= sizeof(uint32_t));
-            *((uint32_t*) val) = (uint32_t) sx127x_random(dev);
-            return sizeof(uint32_t);
-
-        case NETOPT_IQ_INVERT:
-            assert(max_len >= sizeof(uint8_t));
-            *((netopt_enable_t*) val) = sx127x_get_iq_invert(dev) ? NETOPT_ENABLE : NETOPT_DISABLE;
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_RSSI:
-            assert(max_len >= sizeof(int8_t));
-            *((int8_t*) val) = sx127x_read_rssi(dev);
-            return sizeof(int8_t);
-
-        default:
-            break;
+    switch (opt) {
+    case NETOPT_STATE:
+        assert(max_len >= sizeof(netopt_state_t));
+        return _get_state(dev, val);
+
+    case NETOPT_DEVICE_TYPE:
+        assert(max_len >= sizeof(uint16_t));
+        *((uint16_t *)val) = NETDEV_TYPE_LORA;
+        return sizeof(uint16_t);
+
+    case NETOPT_CHANNEL_FREQUENCY:
+        assert(max_len >= sizeof(uint32_t));
+        *((uint32_t *)val) = sx127x_get_channel(dev);
+        return sizeof(uint32_t);
+
+    case NETOPT_BANDWIDTH:
+        assert(max_len >= sizeof(uint8_t));
+        *((uint8_t *)val) = sx127x_get_bandwidth(dev);
+        return sizeof(uint8_t);
+
+    case NETOPT_SPREADING_FACTOR:
+        assert(max_len >= sizeof(uint8_t));
+        *((uint8_t *)val) = sx127x_get_spreading_factor(dev);
+        return sizeof(uint8_t);
+
+    case NETOPT_CODING_RATE:
+        assert(max_len >= sizeof(uint8_t));
+        *((uint8_t *)val) = sx127x_get_coding_rate(dev);
+        return sizeof(uint8_t);
+
+    case NETOPT_MAX_PDU_SIZE:
+        assert(max_len >= sizeof(uint8_t));
+        *((uint8_t *)val) = sx127x_get_max_payload_len(dev);
+        return sizeof(uint8_t);
+
+    case NETOPT_INTEGRITY_CHECK:
+        assert(max_len >= sizeof(netopt_enable_t));
+        *((netopt_enable_t *)val) = sx127x_get_crc(dev) ? NETOPT_ENABLE : NETOPT_DISABLE;
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_CHANNEL_HOP:
+        assert(max_len >= sizeof(netopt_enable_t));
+        *((netopt_enable_t *)val) =
+            (dev->settings.lora.flags &
+             SX127X_CHANNEL_HOPPING_FLAG) ? NETOPT_ENABLE : NETOPT_DISABLE;
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_CHANNEL_HOP_PERIOD:
+        assert(max_len >= sizeof(uint8_t));
+        *((uint8_t *)val) = sx127x_get_hop_period(dev);
+        return sizeof(uint8_t);
+
+    case NETOPT_SINGLE_RECEIVE:
+        assert(max_len >= sizeof(uint8_t));
+        *((netopt_enable_t *)val) = sx127x_get_rx_single(dev) ? NETOPT_ENABLE : NETOPT_DISABLE;
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_TX_POWER:
+        assert(max_len >= sizeof(int16_t));
+        *((int16_t *)val) = (int16_t)sx127x_get_tx_power(dev);
+        return sizeof(int16_t);
+
+    case NETOPT_SYNCWORD:
+        assert(max_len >= sizeof(uint8_t));
+        *((uint8_t *)val) = (uint8_t)sx127x_get_syncword(dev);
+        return sizeof(uint8_t);
+
+    case NETOPT_RANDOM:
+        assert(max_len >= sizeof(uint32_t));
+        *((uint32_t *)val) = (uint32_t)sx127x_random(dev);
+        return sizeof(uint32_t);
+
+    case NETOPT_IQ_INVERT:
+        assert(max_len >= sizeof(uint8_t));
+        *((netopt_enable_t *)val) = sx127x_get_iq_invert(dev) ? NETOPT_ENABLE : NETOPT_DISABLE;
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_RSSI:
+        assert(max_len >= sizeof(int8_t));
+        *((int8_t *)val) = sx127x_read_rssi(dev);
+        return sizeof(int8_t);
+
+    default:
+        break;
     }
 
     return -ENOTSUP;
@@ -354,141 +360,141 @@ static int _set(netdev_t *netdev, netopt_t opt, const void *val, size_t len)
 {
     (void)len; /* unused when compiled without debug, assert empty */
 
-    sx127x_t *dev = (sx127x_t*) netdev;
+    sx127x_t *dev = (sx127x_t *)netdev;
     int res = -ENOTSUP;
 
     if (dev == NULL) {
         return -ENODEV;
     }
 
-    switch(opt) {
-        case NETOPT_STATE:
-            assert(len == sizeof(netopt_state_t));
-            return _set_state(dev, *((const netopt_state_t*) val));
-
-        case NETOPT_DEVICE_TYPE:
-            assert(len <= sizeof(uint16_t));
-            /* Only LoRa modem is supported for the moment */
-            if (*(const uint16_t*) val == NETDEV_TYPE_LORA) {
-                sx127x_set_modem(dev, SX127X_MODEM_LORA);
-                return sizeof(uint16_t);
-            }
-            else {
-                return -EINVAL;
-            }
-
-        case NETOPT_CHANNEL_FREQUENCY:
-            assert(len <= sizeof(uint32_t));
-            sx127x_set_channel(dev, *((const uint32_t*) val));
-            return sizeof(uint32_t);
-
-        case NETOPT_BANDWIDTH:
-            assert(len <= sizeof(uint8_t));
-            uint8_t bw = *((const uint8_t *)val);
-            if (bw > LORA_BW_500_KHZ) {
-                res = -EINVAL;
-                break;
-            }
-            sx127x_set_bandwidth(dev, bw);
-            return sizeof(uint8_t);
-
-        case NETOPT_SPREADING_FACTOR:
-            assert(len <= sizeof(uint8_t));
-            uint8_t sf = *((const uint8_t *)val);
-            if ((sf < LORA_SF6) || (sf > LORA_SF12)) {
-                res = -EINVAL;
-                break;
-            }
-            sx127x_set_spreading_factor(dev, sf);
-            return sizeof(uint8_t);
-
-        case NETOPT_CODING_RATE:
-            assert(len <= sizeof(uint8_t));
-            uint8_t cr = *((const uint8_t *)val);
-            if ((cr < LORA_CR_4_5) || (cr > LORA_CR_4_8)) {
-                res = -EINVAL;
-                break;
-            }
-            sx127x_set_coding_rate(dev, cr);
-            return sizeof(uint8_t);
-
-        case NETOPT_MAX_PDU_SIZE:
-            assert(len <= sizeof(uint8_t));
-            sx127x_set_max_payload_len(dev, *((const uint8_t*) val));
-            return sizeof(uint8_t);
-
-        case NETOPT_INTEGRITY_CHECK:
-            assert(len <= sizeof(netopt_enable_t));
-            sx127x_set_crc(dev, *((const netopt_enable_t*) val) ? true : false);
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_CHANNEL_HOP:
-            assert(len <= sizeof(netopt_enable_t));
-            sx127x_set_freq_hop(dev, *((const netopt_enable_t*) val) ? true : false);
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_CHANNEL_HOP_PERIOD:
-            assert(len <= sizeof(uint8_t));
-            sx127x_set_hop_period(dev, *((const uint8_t*) val));
-            return sizeof(uint8_t);
-
-        case NETOPT_SINGLE_RECEIVE:
-            assert(len <= sizeof(netopt_enable_t));
-            sx127x_set_rx_single(dev, *((const netopt_enable_t*) val) ? true : false);
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_RX_SYMBOL_TIMEOUT:
-            assert(len <= sizeof(uint16_t));
-            sx127x_set_symbol_timeout(dev, *((const uint16_t*) val));
-            return sizeof(uint16_t);
-
-        case NETOPT_RX_TIMEOUT:
-            assert(len <= sizeof(uint32_t));
-            sx127x_set_rx_timeout(dev, *((const uint32_t*) val));
-            return sizeof(uint32_t);
-
-        case NETOPT_TX_TIMEOUT:
-            assert(len <= sizeof(uint32_t));
-            sx127x_set_tx_timeout(dev, *((const uint32_t*) val));
-            return sizeof(uint32_t);
-
-        case NETOPT_TX_POWER:
-            assert(len <= sizeof(int16_t));
-            int16_t power = *((const int16_t *)val);
-            if ((power < INT8_MIN) || (power > INT8_MAX)) {
-                res = -EINVAL;
-                break;
-            }
-            sx127x_set_tx_power(dev, (int8_t)power);
-            return sizeof(int16_t);
-
-        case NETOPT_FIXED_HEADER:
-            assert(len <= sizeof(netopt_enable_t));
-            sx127x_set_fixed_header_len_mode(dev, *((const netopt_enable_t*) val) ? true : false);
-            return sizeof(netopt_enable_t);
-
-        case NETOPT_PDU_SIZE:
-            assert(len <= sizeof(uint16_t));
-            sx127x_set_payload_length(dev, *((const uint16_t*) val));
-            return sizeof(uint16_t);
+    switch (opt) {
+    case NETOPT_STATE:
+        assert(len == sizeof(netopt_state_t));
+        return _set_state(dev, *((const netopt_state_t *)val));
 
-        case NETOPT_PREAMBLE_LENGTH:
-            assert(len <= sizeof(uint16_t));
-            sx127x_set_preamble_length(dev, *((const uint16_t*) val));
+    case NETOPT_DEVICE_TYPE:
+        assert(len <= sizeof(uint16_t));
+        /* Only LoRa modem is supported for the moment */
+        if (*(const uint16_t *)val == NETDEV_TYPE_LORA) {
+            sx127x_set_modem(dev, SX127X_MODEM_LORA);
             return sizeof(uint16_t);
-
-        case NETOPT_SYNCWORD:
-            assert(len <= sizeof(uint8_t));
-            sx127x_set_syncword(dev, *((uint8_t*) val));
-            return sizeof(uint8_t);
-
-        case NETOPT_IQ_INVERT:
-            assert(len <= sizeof(netopt_enable_t));
-            sx127x_set_iq_invert(dev, *((const netopt_enable_t*) val) ? true : false);
-            return sizeof(bool);
-
-        default:
-            break;
+        }
+        else {
+            return -EINVAL;
+        }
+
+    case NETOPT_CHANNEL_FREQUENCY:
+        assert(len <= sizeof(uint32_t));
+        sx127x_set_channel(dev, *((const uint32_t *)val));
+        return sizeof(uint32_t);
+
+    case NETOPT_BANDWIDTH:
+        assert(len <= sizeof(uint8_t));
+        uint8_t bw = *((const uint8_t *)val);
+        if (bw > LORA_BW_500_KHZ) {
+            res = -EINVAL;
+            break;
+        }
+        sx127x_set_bandwidth(dev, bw);
+        return sizeof(uint8_t);
+
+    case NETOPT_SPREADING_FACTOR:
+        assert(len <= sizeof(uint8_t));
+        uint8_t sf = *((const uint8_t *)val);
+        if ((sf < LORA_SF6) || (sf > LORA_SF12)) {
+            res = -EINVAL;
+            break;
+        }
+        sx127x_set_spreading_factor(dev, sf);
+        return sizeof(uint8_t);
+
+    case NETOPT_CODING_RATE:
+        assert(len <= sizeof(uint8_t));
+        uint8_t cr = *((const uint8_t *)val);
+        if ((cr < LORA_CR_4_5) || (cr > LORA_CR_4_8)) {
+            res = -EINVAL;
+            break;
+        }
+        sx127x_set_coding_rate(dev, cr);
+        return sizeof(uint8_t);
+
+    case NETOPT_MAX_PDU_SIZE:
+        assert(len <= sizeof(uint8_t));
+        sx127x_set_max_payload_len(dev, *((const uint8_t *)val));
+        return sizeof(uint8_t);
+
+    case NETOPT_INTEGRITY_CHECK:
+        assert(len <= sizeof(netopt_enable_t));
+        sx127x_set_crc(dev, *((const netopt_enable_t *)val) ? true : false);
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_CHANNEL_HOP:
+        assert(len <= sizeof(netopt_enable_t));
+        sx127x_set_freq_hop(dev, *((const netopt_enable_t *)val) ? true : false);
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_CHANNEL_HOP_PERIOD:
+        assert(len <= sizeof(uint8_t));
+        sx127x_set_hop_period(dev, *((const uint8_t *)val));
+        return sizeof(uint8_t);
+
+    case NETOPT_SINGLE_RECEIVE:
+        assert(len <= sizeof(netopt_enable_t));
+        sx127x_set_rx_single(dev, *((const netopt_enable_t *)val) ? true : false);
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_RX_SYMBOL_TIMEOUT:
+        assert(len <= sizeof(uint16_t));
+        sx127x_set_symbol_timeout(dev, *((const uint16_t *)val));
+        return sizeof(uint16_t);
+
+    case NETOPT_RX_TIMEOUT:
+        assert(len <= sizeof(uint32_t));
+        sx127x_set_rx_timeout(dev, *((const uint32_t *)val));
+        return sizeof(uint32_t);
+
+    case NETOPT_TX_TIMEOUT:
+        assert(len <= sizeof(uint32_t));
+        sx127x_set_tx_timeout(dev, *((const uint32_t *)val));
+        return sizeof(uint32_t);
+
+    case NETOPT_TX_POWER:
+        assert(len <= sizeof(int16_t));
+        int16_t power = *((const int16_t *)val);
+        if ((power < INT8_MIN) || (power > INT8_MAX)) {
+            res = -EINVAL;
+            break;
+        }
+        sx127x_set_tx_power(dev, (int8_t)power);
+        return sizeof(int16_t);
+
+    case NETOPT_FIXED_HEADER:
+        assert(len <= sizeof(netopt_enable_t));
+        sx127x_set_fixed_header_len_mode(dev, *((const netopt_enable_t *)val) ? true : false);
+        return sizeof(netopt_enable_t);
+
+    case NETOPT_PDU_SIZE:
+        assert(len <= sizeof(uint16_t));
+        sx127x_set_payload_length(dev, *((const uint16_t *)val));
+        return sizeof(uint16_t);
+
+    case NETOPT_PREAMBLE_LENGTH:
+        assert(len <= sizeof(uint16_t));
+        sx127x_set_preamble_length(dev, *((const uint16_t *)val));
+        return sizeof(uint16_t);
+
+    case NETOPT_SYNCWORD:
+        assert(len <= sizeof(uint8_t));
+        sx127x_set_syncword(dev, *((uint8_t *)val));
+        return sizeof(uint8_t);
+
+    case NETOPT_IQ_INVERT:
+        assert(len <= sizeof(netopt_enable_t));
+        sx127x_set_iq_invert(dev, *((const netopt_enable_t *)val) ? true : false);
+        return sizeof(bool);
+
+    default:
+        break;
     }
 
     return res;
@@ -497,34 +503,34 @@ static int _set(netdev_t *netdev, netopt_t opt, const void *val, size_t len)
 static int _set_state(sx127x_t *dev, netopt_state_t state)
 {
     switch (state) {
-        case NETOPT_STATE_SLEEP:
-            sx127x_set_sleep(dev);
-            break;
+    case NETOPT_STATE_SLEEP:
+        sx127x_set_sleep(dev);
+        break;
 
-        case NETOPT_STATE_STANDBY:
-            sx127x_set_standby(dev);
-            break;
+    case NETOPT_STATE_STANDBY:
+        sx127x_set_standby(dev);
+        break;
 
-        case NETOPT_STATE_IDLE:
-            /* set permanent listening */
-            sx127x_set_rx_timeout(dev, 0);
-            sx127x_set_rx(dev);
-            break;
+    case NETOPT_STATE_IDLE:
+        /* set permanent listening */
+        sx127x_set_rx_timeout(dev, 0);
+        sx127x_set_rx(dev);
+        break;
 
-        case NETOPT_STATE_RX:
-            sx127x_set_rx(dev);
-            break;
+    case NETOPT_STATE_RX:
+        sx127x_set_rx(dev);
+        break;
 
-        case NETOPT_STATE_TX:
-            sx127x_set_tx(dev);
-            break;
+    case NETOPT_STATE_TX:
+        sx127x_set_tx(dev);
+        break;
 
-        case NETOPT_STATE_RESET:
-            sx127x_reset(dev);
-            break;
+    case NETOPT_STATE_RESET:
+        sx127x_reset(dev);
+        break;
 
-        default:
-            return -ENOTSUP;
+    default:
+        return -ENOTSUP;
     }
     return sizeof(netopt_state_t);
 }
@@ -532,36 +538,38 @@ static int _set_state(sx127x_t *dev, netopt_state_t state)
 static int _get_state(sx127x_t *dev, void *val)
 {
     uint8_t op_mode;
+
     op_mode = sx127x_get_op_mode(dev);
     netopt_state_t state = NETOPT_STATE_OFF;
-    switch(op_mode) {
-        case SX127X_RF_OPMODE_SLEEP:
-            state = NETOPT_STATE_SLEEP;
-            break;
-
-        case SX127X_RF_OPMODE_STANDBY:
-            state = NETOPT_STATE_STANDBY;
-            break;
 
-        case SX127X_RF_OPMODE_TRANSMITTER:
-            state = NETOPT_STATE_TX;
-            break;
-
-        case SX127X_RF_OPMODE_RECEIVER:
-        case SX127X_RF_LORA_OPMODE_RECEIVER_SINGLE:
-            /* Sx127x is in receive mode:
-             * -> need to check if the device is currently receiving a packet */
-            if (sx127x_reg_read(dev, SX127X_REG_LR_MODEMSTAT) &
-                SX127X_RF_LORA_MODEMSTAT_MODEM_STATUS_SIGNAL_DETECTED) {
-                state = NETOPT_STATE_RX;
-            }
-            else {
-                state = NETOPT_STATE_IDLE;
-            }
-            break;
-
-        default:
-            break;
+    switch (op_mode) {
+    case SX127X_RF_OPMODE_SLEEP:
+        state = NETOPT_STATE_SLEEP;
+        break;
+
+    case SX127X_RF_OPMODE_STANDBY:
+        state = NETOPT_STATE_STANDBY;
+        break;
+
+    case SX127X_RF_OPMODE_TRANSMITTER:
+        state = NETOPT_STATE_TX;
+        break;
+
+    case SX127X_RF_OPMODE_RECEIVER:
+    case SX127X_RF_LORA_OPMODE_RECEIVER_SINGLE:
+        /* Sx127x is in receive mode:
+         * -> need to check if the device is currently receiving a packet */
+        if (sx127x_reg_read(dev, SX127X_REG_LR_MODEMSTAT) &
+            SX127X_RF_LORA_MODEMSTAT_MODEM_STATUS_SIGNAL_DETECTED) {
+            state = NETOPT_STATE_RX;
+        }
+        else {
+            state = NETOPT_STATE_IDLE;
+        }
+        break;
+
+    default:
+        break;
     }
     memcpy(val, &state, sizeof(netopt_state_t));
     return sizeof(netopt_state_t);
@@ -569,181 +577,181 @@ static int _get_state(sx127x_t *dev, void *val)
 
 void _on_dio0_irq(void *arg)
 {
-    sx127x_t *dev = (sx127x_t *) arg;
-    netdev_t *netdev = (netdev_t*) &dev->netdev;
+    sx127x_t *dev = (sx127x_t *)arg;
+    netdev_t *netdev = (netdev_t *)&dev->netdev;
 
     switch (dev->settings.state) {
-        case SX127X_RF_RX_RUNNING:
-            netdev->event_callback(netdev, NETDEV_EVENT_RX_COMPLETE);
-            break;
-        case SX127X_RF_TX_RUNNING:
-            ztimer_remove(ZTIMER_MSEC, &dev->_internal.tx_timeout_timer);
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_LORA:
-                    /* Clear IRQ */
-                    sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
-                                     SX127X_RF_LORA_IRQFLAGS_TXDONE);
-                /* Intentional fall-through */
-                case SX127X_MODEM_FSK:
-                default:
-                    sx127x_set_state(dev, SX127X_RF_IDLE);
-                    netdev->event_callback(netdev, NETDEV_EVENT_TX_COMPLETE);
-                    break;
-            }
-            break;
-        case SX127X_RF_IDLE:
-            DEBUG("[sx127x] netdev: sx127x_on_dio0: IDLE state\n");
-            break;
+    case SX127X_RF_RX_RUNNING:
+        netdev->event_callback(netdev, NETDEV_EVENT_RX_COMPLETE);
+        break;
+    case SX127X_RF_TX_RUNNING:
+        ztimer_remove(ZTIMER_MSEC, &dev->_internal.tx_timeout_timer);
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_LORA:
+            /* Clear IRQ */
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
+                             SX127X_RF_LORA_IRQFLAGS_TXDONE);
+        /* Intentional fall-through */
+        case SX127X_MODEM_FSK:
         default:
-            DEBUG("[sx127x] netdev: sx127x_on_dio0: unknown state [%d]\n",
-                  dev->settings.state);
-            break;
+            sx127x_set_state(dev, SX127X_RF_IDLE);
+            netdev->event_callback(netdev, NETDEV_EVENT_TX_COMPLETE);
+            break;
+        }
+        break;
+    case SX127X_RF_IDLE:
+        DEBUG("[sx127x] netdev: sx127x_on_dio0: IDLE state\n");
+        break;
+    default:
+        DEBUG("[sx127x] netdev: sx127x_on_dio0: unknown state [%d]\n",
+              dev->settings.state);
+        break;
     }
 }
 
 void _on_dio1_irq(void *arg)
 {
     /* Get interrupt context */
-    sx127x_t *dev = (sx127x_t *) arg;
-    netdev_t *netdev = (netdev_t*) &dev->netdev;
+    sx127x_t *dev = (sx127x_t *)arg;
+    netdev_t *netdev = (netdev_t *)&dev->netdev;
 
     switch (dev->settings.state) {
-        case SX127X_RF_RX_RUNNING:
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_FSK:
-                    /* todo */
-                    break;
-                case SX127X_MODEM_LORA:
-                    ztimer_remove(ZTIMER_MSEC, &dev->_internal.rx_timeout_timer);
-                    /*  Clear Irq */
-                    sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS, SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT);
-                    sx127x_set_state(dev, SX127X_RF_IDLE);
-                    netdev->event_callback(netdev, NETDEV_EVENT_RX_TIMEOUT);
-                    break;
-                default:
-                    break;
-            }
+    case SX127X_RF_RX_RUNNING:
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_FSK:
+            /* todo */
             break;
-        case SX127X_RF_TX_RUNNING:
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_FSK:
-                    /* todo */
-                    break;
-                case SX127X_MODEM_LORA:
-                    break;
-                default:
-                    break;
-            }
+        case SX127X_MODEM_LORA:
+            ztimer_remove(ZTIMER_MSEC, &dev->_internal.rx_timeout_timer);
+            /*  Clear Irq */
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS, SX127X_RF_LORA_IRQFLAGS_RXTIMEOUT);
+            sx127x_set_state(dev, SX127X_RF_IDLE);
+            netdev->event_callback(netdev, NETDEV_EVENT_RX_TIMEOUT);
             break;
         default:
-            puts("[sx127x] netdev: sx127x_on_dio1: unknown state");
             break;
+        }
+        break;
+    case SX127X_RF_TX_RUNNING:
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_FSK:
+            /* todo */
+            break;
+        case SX127X_MODEM_LORA:
+            break;
+        default:
+            break;
+        }
+        break;
+    default:
+        puts("[sx127x] netdev: sx127x_on_dio1: unknown state");
+        break;
     }
 }
 
 void _on_dio2_irq(void *arg)
 {
     /* Get interrupt context */
-    sx127x_t *dev = (sx127x_t *) arg;
-    netdev_t *netdev = (netdev_t*) dev;
+    sx127x_t *dev = (sx127x_t *)arg;
+    netdev_t *netdev = (netdev_t *)dev;
 
     switch (dev->settings.state) {
-        case SX127X_RF_RX_RUNNING:
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_FSK:
-                    /* todo */
-                    break;
-                case SX127X_MODEM_LORA:
-                    if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
-                        /* Clear IRQ */
-                        sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
-                                         SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL);
-
-                        dev->_internal.last_channel = (sx127x_reg_read(dev, SX127X_REG_LR_HOPCHANNEL) &
-                                                       SX127X_RF_LORA_HOPCHANNEL_CHANNEL_MASK);
-                        netdev->event_callback(netdev, NETDEV_EVENT_FHSS_CHANGE_CHANNEL);
-                    }
-
-                    break;
-                default:
-                    break;
+    case SX127X_RF_RX_RUNNING:
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_FSK:
+            /* todo */
+            break;
+        case SX127X_MODEM_LORA:
+            if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
+                /* Clear IRQ */
+                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
+                                 SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL);
+
+                dev->_internal.last_channel = (sx127x_reg_read(dev, SX127X_REG_LR_HOPCHANNEL) &
+                                               SX127X_RF_LORA_HOPCHANNEL_CHANNEL_MASK);
+                netdev->event_callback(netdev, NETDEV_EVENT_FHSS_CHANGE_CHANNEL);
             }
+
+            break;
+        default:
+            break;
+        }
+        break;
+    case SX127X_RF_TX_RUNNING:
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_FSK:
             break;
-        case SX127X_RF_TX_RUNNING:
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_FSK:
-                    break;
-                case SX127X_MODEM_LORA:
-                    if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
-                        /* Clear IRQ */
-                        sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
-                                         SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL);
-
-                        dev->_internal.last_channel = (sx127x_reg_read(dev, SX127X_REG_LR_HOPCHANNEL) &
-                                                       SX127X_RF_LORA_HOPCHANNEL_CHANNEL_MASK);
-                        netdev->event_callback(netdev, NETDEV_EVENT_FHSS_CHANGE_CHANNEL);
-                    }
-                    break;
-                default:
-                    break;
+        case SX127X_MODEM_LORA:
+            if (dev->settings.lora.flags & SX127X_CHANNEL_HOPPING_FLAG) {
+                /* Clear IRQ */
+                sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
+                                 SX127X_RF_LORA_IRQFLAGS_FHSSCHANGEDCHANNEL);
+
+                dev->_internal.last_channel = (sx127x_reg_read(dev, SX127X_REG_LR_HOPCHANNEL) &
+                                               SX127X_RF_LORA_HOPCHANNEL_CHANNEL_MASK);
+                netdev->event_callback(netdev, NETDEV_EVENT_FHSS_CHANGE_CHANNEL);
             }
             break;
         default:
-            puts("[sx127x] netdev: sx127x_on_dio2: unknown state");
             break;
+        }
+        break;
+    default:
+        puts("[sx127x] netdev: sx127x_on_dio2: unknown state");
+        break;
     }
 }
 
 void _on_dio3_irq(void *arg)
 {
     /* Get interrupt context */
-    sx127x_t *dev = (sx127x_t *) arg;
-    netdev_t *netdev = (netdev_t *) dev;
+    sx127x_t *dev = (sx127x_t *)arg;
+    netdev_t *netdev = (netdev_t *)dev;
 
     switch (dev->settings.state) {
-        case SX127X_RF_CAD:
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_FSK:
-                    break;
-                case SX127X_MODEM_LORA:
-                    /* Clear IRQ */
-                    sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
-                                     SX127X_RF_LORA_IRQFLAGS_CADDETECTED |
-                                     SX127X_RF_LORA_IRQFLAGS_CADDONE);
-
-                    /* Send event message */
-                    dev->_internal.is_last_cad_success = ((sx127x_reg_read(dev, SX127X_REG_LR_IRQFLAGS) &
-                                                           SX127X_RF_LORA_IRQFLAGS_CADDETECTED) ==
-                                                          SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
-                    netdev->event_callback(netdev, NETDEV_EVENT_CAD_DONE);
-                    break;
-                default:
-                    puts("[sx127x] netdev: sx127x_on_dio3: unknown modem");
-                    break;
-            }
-            break;
-        case SX127X_RF_RX_RUNNING:
-            switch (dev->settings.modem) {
-                case SX127X_MODEM_FSK:
-                    break;
-                case SX127X_MODEM_LORA:
-                    /* Clear IRQ */
-                    sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS, SX127X_RF_LORA_IRQFLAGS_VALIDHEADER);
-
-                    netdev->event_callback(netdev, NETDEV_EVENT_RX_STARTED);
-                    break;
-                default:
-                    break;
-            }
+    case SX127X_RF_CAD:
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_FSK:
             break;
-        default:
-            DEBUG("[sx127x] netdev: sx127x_on_dio3: unknown state");
-            /* at least the related interrupts should be cleared in this case */
+        case SX127X_MODEM_LORA:
+            /* Clear IRQ */
             sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
-                             SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
                              SX127X_RF_LORA_IRQFLAGS_CADDETECTED |
                              SX127X_RF_LORA_IRQFLAGS_CADDONE);
+
+            /* Send event message */
+            dev->_internal.is_last_cad_success = ((sx127x_reg_read(dev, SX127X_REG_LR_IRQFLAGS) &
+                                                   SX127X_RF_LORA_IRQFLAGS_CADDETECTED) ==
+                                                  SX127X_RF_LORA_IRQFLAGS_CADDETECTED);
+            netdev->event_callback(netdev, NETDEV_EVENT_CAD_DONE);
+            break;
+        default:
+            puts("[sx127x] netdev: sx127x_on_dio3: unknown modem");
+            break;
+        }
+        break;
+    case SX127X_RF_RX_RUNNING:
+        switch (dev->settings.modem) {
+        case SX127X_MODEM_FSK:
+            break;
+        case SX127X_MODEM_LORA:
+            /* Clear IRQ */
+            sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS, SX127X_RF_LORA_IRQFLAGS_VALIDHEADER);
+
+            netdev->event_callback(netdev, NETDEV_EVENT_RX_STARTED);
+            break;
+        default:
             break;
+        }
+        break;
+    default:
+        DEBUG("[sx127x] netdev: sx127x_on_dio3: unknown state");
+        /* at least the related interrupts should be cleared in this case */
+        sx127x_reg_write(dev, SX127X_REG_LR_IRQFLAGS,
+                         SX127X_RF_LORA_IRQFLAGS_VALIDHEADER |
+                         SX127X_RF_LORA_IRQFLAGS_CADDETECTED |
+                         SX127X_RF_LORA_IRQFLAGS_CADDONE);
+        break;
     }
 }
 
diff --git a/drivers/touch_dev/Kconfig b/drivers/touch_dev/Kconfig
index b82955c3d3..68d2f80873 100644
--- a/drivers/touch_dev/Kconfig
+++ b/drivers/touch_dev/Kconfig
@@ -8,5 +8,6 @@
 config MODULE_TOUCH_DEV
     bool "Touch device generic API"
     depends on TEST_KCONFIG
+    imply MODULE_AUTO_INIT_SCREEN
     help
         This API is experimental and in an early state - expect changes!
diff --git a/drivers/touch_dev/Makefile.dep b/drivers/touch_dev/Makefile.dep
new file mode 100644
index 0000000000..3a3b8f47e4
--- /dev/null
+++ b/drivers/touch_dev/Makefile.dep
@@ -0,0 +1 @@
+DEFAULT_MODULE += auto_init_screen
diff --git a/examples/gcoap/Makefile b/examples/gcoap/Makefile
index 10595e1d86..52c4dcdc71 100644
--- a/examples/gcoap/Makefile
+++ b/examples/gcoap/Makefile
@@ -35,6 +35,21 @@ DEVELHELP ?= 1
 # Change this to 0 show compiler invocation lines by default:
 QUIET ?= 1
 
+# Instead of simulating an Ethernet connection, we can also simulate
+# an IEEE 802.15.4 radio using ZEP
+USE_ZEP ?= 0
+
+# set the ZEP port for native
+ZEP_PORT_BASE ?= 17754
+ifeq (1,$(USE_ZEP))
+  TERMFLAGS += -z [::1]:$(ZEP_PORT_BASE)
+  USEMODULE += socket_zep
+
+  ifneq (,$(ZEP_MAC))
+    TERMFLAGS += --eui64=$(ZEP_MAC)
+  endif
+endif
+
 include $(RIOTBASE)/Makefile.include
 
 # For now this goes after the inclusion of Makefile.include so Kconfig symbols
diff --git a/examples/gnrc_lorawan/Makefile b/examples/gnrc_lorawan/Makefile
index 16c25c0bdd..b3dd1762ba 100644
--- a/examples/gnrc_lorawan/Makefile
+++ b/examples/gnrc_lorawan/Makefile
@@ -1,24 +1,37 @@
 # name of your application
 APPLICATION = gnrc_lorawan
 
-USEMODULE += shell
-USEMODULE += shell_commands
+# Turn on developer helpers
+DEVELHELP ?= 1
+
+BOARD ?= b-l072z-lrwan1
+RIOTBASE ?= ../../
+
+# Include board's default network devices and auto-initialization of GNRC
+# interfaces
 USEMODULE += gnrc_netdev_default
 USEMODULE += auto_init_gnrc_netif
+
+# Add support for GNRC LoRaWAN
 USEMODULE += gnrc_lorawan
+
+# Use GNRC pktdump to print downlink messages
 USEMODULE += gnrc_pktdump
-USEMODULE += gnrc_neterr
 
-BOARD ?= b-l072z-lrwan1
-RIOTBASE ?= ../../
+# Include the shell and shell commands.
+USEMODULE += shell
+USEMODULE += shell_commands
 
-# Turn on developer helpers
-DEVELHELP ?= 1
+# Use GNRC Txtsnd to transmit LoRaWAN from the shell
+USEMODULE += gnrc_txtsnd
 
-# use SX1276 by default
-DRIVER ?= sx1276
+# Uncomment as needed if a board doesn't include a LoRa radio by default
+# USEMODULE += sx1272
+# USEMODULE += sx1276
 
-USEMODULE += $(DRIVER)
+# As there is an 'app.config' we want to explicitly disable Kconfig by setting
+# the variable to empty
+SHOULD_RUN_KCONFIG ?=
 
 include $(RIOTBASE)/Makefile.include
 
@@ -33,6 +46,14 @@ include $(RIOTBASE)/Makefile.include
 # Check if being configured via Kconfig
 ifndef CONFIG_KCONFIG_USEMODULE_LORAWAN
 
+  # Tell GNRC to encode LoRaWAN port in the GNRC netif header.
+  # This allows us to use `gnrc_txtsnd` to send data from the shell using the
+  # `txtsnd` command.
+  #
+  # Note: From Release 22.01 all GNRC LoRaWAN packets will include the netif
+  # header. Therefore this flag will be removed after that
+  CFLAGS += -DCONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR
+
   CFLAGS += -DCONFIG_LORAMAC_APP_KEY_DEFAULT=\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"
   CFLAGS += -DCONFIG_LORAMAC_APP_EUI_DEFAULT=\"BBBBBBBBBBBBBBBB\"
   CFLAGS += -DCONFIG_LORAMAC_DEV_EUI_DEFAULT=\"CCCCCCCCCCCCCCCC\"
diff --git a/examples/gnrc_lorawan/Makefile.ci b/examples/gnrc_lorawan/Makefile.ci
index 3797ffe80f..eb07191e2b 100644
--- a/examples/gnrc_lorawan/Makefile.ci
+++ b/examples/gnrc_lorawan/Makefile.ci
@@ -6,6 +6,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-uno \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
     msb-430 \
     msb-430h \
     nucleo-f031k6 \
diff --git a/examples/gnrc_lorawan/README.md b/examples/gnrc_lorawan/README.md
index bdc859e2ed..17414cc6cc 100644
--- a/examples/gnrc_lorawan/README.md
+++ b/examples/gnrc_lorawan/README.md
@@ -15,7 +15,6 @@ Usage
 
 It's necessary to join the LoRaWAN network either via OTAA or ABP.
 All keys, addresses and EUIs are in network endian (big endian).
-The application listens to downlinks on Port 2 by default.
 Region need to be set in the Makefile.
 
 ## OTAA
@@ -73,10 +72,15 @@ CFLAGS += -DCONFIG_LORAMAC_DEV_ADDR_DEFAULT=\"FFFFFFFF\"
 
 ## Send data
 
-After join, send data using `send` command. E.g to send "Hello RIOT!" to port 2:
+After join, send data using `txtsnd` command:
+```
+txtsnd <if> <hex_port> <data>
+```
+
+E.g to send "Hello RIOT!" to LoRaWAN port 123 (hex 0x7B) via interface 3:
 
 ```
-send 3 "Hello RIOT!" 2
+txtsnd 3 7B "Hello RIOT!"
 ```
 
 ## Changing datarate of transmission
@@ -100,7 +104,7 @@ Send some data. The result of the Link Check request can be seen with
 
 ```
 ifconfig 3 link_check
-send 3 "Join the RIOT!"
+txtsnd 3 01 "Join the RIOT!"
 ```
 
 Check demodulation margin and number of gateways using `ifconfig`
@@ -124,18 +128,43 @@ E.g send confirmable messages:
 
 ```
 ifconfig 3 ack_req
-send 3 "My confirmable message"
+txtsnd 3 01 "My confirmable message"
 ```
 
 And unconfirmable messages:
 
 ```
 ifconfig 3 -ack_req
-send 3 "My unconfirmable message"
+txtsnd 3 01 "My unconfirmable message"
+```
+
+## Receiving data
+
+Schedule a downlink for the LoRaWAN node in the Application Server. If using
+TTN, this can be done under `Applications > <APP> > Devices > <DEV> > Overview`
+and then check the `Downlink` section.
+
+After sending data, the LoRaWAN Network Server will reply with the downlink
+data. For simplicity, this application is configured to dump downlink data to
+[GNRC pktdump](https://doc.riot-os.org/pktdump_8h.html).
+
+E.g:
 ```
+PKTDUMP: data received:
+~~ SNIP  0 - size:   2 byte, type: NETTYPE_UNDEF (0)
+00000000  AA  AA
+~~ SNIP  1 - size:   9 byte, type: NETTYPE_NETIF (-1)
+if_pid: 3  rssi: -32768  lqi: 0
+flags: 0x0
+src_l2addr: (nil)
+dst_l2addr: 01
+~~ PKT    -  2 snips, total size:  11 byte
+```
+
+This downlink was sent to port 1 (check `dst_l2addr` field)
 
 Current state and future plans
-============
+==============================
 
 The current GNRC LoRaWAN stack is still in an experimental state. It's still
 not compliant with the LoRaWAN specification because some features like duty
diff --git a/examples/gnrc_lorawan/app.config b/examples/gnrc_lorawan/app.config
new file mode 100644
index 0000000000..293cd467ef
--- /dev/null
+++ b/examples/gnrc_lorawan/app.config
@@ -0,0 +1,2 @@
+CONFIG_KCONFIG_USEMODULE_GNRC_NETIF=y
+CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR=y
diff --git a/examples/gnrc_lorawan/main.c b/examples/gnrc_lorawan/main.c
index bd14363813..0308de4bda 100644
--- a/examples/gnrc_lorawan/main.c
+++ b/examples/gnrc_lorawan/main.c
@@ -22,7 +22,6 @@
 #include <string.h>
 
 #include "thread.h"
-#include "xtimer.h"
 #include "shell.h"
 #include "shell_commands.h"
 
@@ -32,81 +31,23 @@
 #include "net/gnrc/netif.h"
 
 #include "net/gnrc/pktbuf.h"
-#include "net/gnrc/pktdump.h"
 #include "net/gnrc/netreg.h"
+#include "net/gnrc/pktdump.h"
 #include "net/loramac.h"
 
-#define LORAWAN_QUEUE_SIZE (4U)
-
-static void _usage(void)
-{
-    puts("usage: send <if_pid> <payload> [port]");
-}
-
-int tx_cmd(int argc, char **argv)
-{
-    gnrc_pktsnip_t *pkt;
-    uint8_t port = CONFIG_LORAMAC_DEFAULT_TX_PORT; /* Default: 2 */
-    int interface;
-
-    if (argc < 3) {
-        _usage();
-        return 1;
-    }
-
-    interface = atoi(argv[1]);
-    /* handle optional parameters */
-    if (argc > 3) {
-        port = atoi(argv[3]);
-        if (port == 0 || port >= 224) {
-            printf("error: invalid port given '%d', "
-                   "port can only be between 1 and 223\n", port);
-            return 1;
-        }
-    }
-
-    pkt = gnrc_pktbuf_add(NULL, argv[2], strlen(argv[2]), GNRC_NETTYPE_UNDEF);
-
-    /* register for returned packet status */
-    if (gnrc_neterr_reg(pkt) != 0) {
-        puts("Can not register for error reporting");
-        return 0;
-    }
-
-    gnrc_netapi_set(interface, NETOPT_LORAWAN_TX_PORT, 0, &port, sizeof(port));
-    gnrc_netif_send(gnrc_netif_get_by_pid(interface), pkt);
-
-    /* wait for packet status and check */
-    msg_t msg;
-    msg_receive(&msg);
-    if ((msg.type != GNRC_NETERR_MSG_TYPE) ||
-        (msg.content.value != GNRC_NETERR_SUCCESS)) {
-        printf("Error sending packet: (status: %d\n)", (int) msg.content.value);
-    }
-    else {
-        puts("Successfully sent packet");
-    }
-
-    return 0;
-}
-
-static const shell_command_t shell_commands[] = {
-    { "send",       "Send LoRaWAN data",     tx_cmd },
-    { NULL, NULL, NULL }
-};
-
-
 int main(void)
 {
     /* start the shell */
     puts("Initialization successful - starting the shell now");
-    gnrc_netreg_entry_t dump = GNRC_NETREG_ENTRY_INIT_PID(CONFIG_LORAMAC_DEFAULT_TX_PORT,
+
+    /* Receive LoRaWAN packets in GNRC pktdump */
+    gnrc_netreg_entry_t dump = GNRC_NETREG_ENTRY_INIT_PID(GNRC_NETREG_DEMUX_CTX_ALL,
                                                           gnrc_pktdump_pid);
 
-    gnrc_netreg_register(GNRC_NETTYPE_LORAWAN, &dump);
-    char line_buf[SHELL_DEFAULT_BUFSIZE];
+    gnrc_netreg_register(GNRC_NETTYPE_UNDEF, &dump);
 
-    shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);
+    char line_buf[SHELL_DEFAULT_BUFSIZE];
+    shell_run(NULL, line_buf, SHELL_DEFAULT_BUFSIZE);
 
     return 0;
 }
diff --git a/examples/gnrc_networking/udp.c b/examples/gnrc_networking/udp.c
index 54f00afd7e..f7ae44df6d 100644
--- a/examples/gnrc_networking/udp.c
+++ b/examples/gnrc_networking/udp.c
@@ -30,11 +30,15 @@
 #include "net/gnrc/pktdump.h"
 #include "timex.h"
 #include "utlist.h"
+#if IS_USED(MODULE_ZTIMER_MSEC)
+#include "ztimer.h"
+#else
 #include "xtimer.h"
+#endif
 
-static gnrc_netreg_entry_t server = GNRC_NETREG_ENTRY_INIT_PID(GNRC_NETREG_DEMUX_CTX_ALL,
-                                                               KERNEL_PID_UNDEF);
-
+static gnrc_netreg_entry_t server =
+                        GNRC_NETREG_ENTRY_INIT_PID(GNRC_NETREG_DEMUX_CTX_ALL,
+                                                   KERNEL_PID_UNDEF);
 
 static void send(char *addr_str, char *port_str, char *data, unsigned int num,
                  unsigned int delay)
@@ -97,16 +101,22 @@ static void send(char *addr_str, char *port_str, char *data, unsigned int num,
             ip = gnrc_pkt_prepend(ip, netif_hdr);
         }
         /* send packet */
-        if (!gnrc_netapi_dispatch_send(GNRC_NETTYPE_UDP, GNRC_NETREG_DEMUX_CTX_ALL, ip)) {
+        if (!gnrc_netapi_dispatch_send(GNRC_NETTYPE_UDP,
+                                       GNRC_NETREG_DEMUX_CTX_ALL, ip)) {
             puts("Error: unable to locate UDP thread");
             gnrc_pktbuf_release(ip);
             return;
         }
-        /* access to `payload` was implicitly given up with the send operation above
+        /* access to `payload` was implicitly given up with the send operation
+         * above
          * => use temporary variable for output */
         printf("Success: sent %u byte(s) to [%s]:%u\n", payload_size, addr_str,
                port);
+#if IS_USED(MODULE_ZTIMER_MSEC)
+        ztimer_sleep(ZTIMER_MSEC, delay);
+#else
         xtimer_usleep(delay);
+#endif
     }
 }
 
@@ -157,8 +167,13 @@ int udp_cmd(int argc, char **argv)
         uint32_t num = 1;
         uint32_t delay = 1000000;
         if (argc < 5) {
-            printf("usage: %s send <addr> <port> <data> [<num> [<delay in us>]]\n",
-                   argv[0]);
+#if IS_USED(MODULE_ZTIMER_MSEC)
+            printf("usage: %s send "
+                   "<addr> <port> <data> [<num> [<delay in ms>]]\n", argv[0]);
+#else
+            printf("usage: %s send "
+                   "<addr> <port> <data> [<num> [<delay in us>]]\n", argv[0]);
+#endif
             return 1;
         }
         if (argc > 5) {
diff --git a/examples/lorawan/README.md b/examples/lorawan/README.md
index 578ce7eac5..66cf1c343e 100644
--- a/examples/lorawan/README.md
+++ b/examples/lorawan/README.md
@@ -75,7 +75,7 @@ for that device.
 
 2. flash device, set appropriate keys and test
 
-    $ DEVEUI=<device eui> APPEUI=<application eui> APPKEY=<application key> IOTLAB_NODE=auto-ssh make -C examples/lorawan/ flash test
+    $ DEVEUI=<device eui> APPEUI=<application eui> APPKEY=<application key> IOTLAB_NODE=auto make -C examples/lorawan/ flash test
 
 3. stop the iotlab experiment:
 
@@ -84,4 +84,4 @@ for that device.
 _note_: if you have multiple running experiments you will need to set `IOTLAB_EXP_ID`
         to the appropriate experiment, when using the `iotlab-exp` you will see a:
         `Waiting that experiment 175694 gets in state Running`. That number matches
-        the experiment id you started.
\ No newline at end of file
+        the experiment id you started.
diff --git a/examples/lorawan/main.c b/examples/lorawan/main.c
index a8078fcd38..9b6de7595e 100644
--- a/examples/lorawan/main.c
+++ b/examples/lorawan/main.c
@@ -52,7 +52,12 @@ static kernel_pid_t sender_pid;
 static char sender_stack[THREAD_STACKSIZE_MAIN / 2];
 
 static semtech_loramac_t loramac;
+#if IS_USED(MODULE_SX127X)
 static sx127x_t sx127x;
+#endif
+#if IS_USED(MODULE_SX126X)
+static sx126x_t sx126x;
+#endif
 
 static const char *message = "This is RIOT!";
 
diff --git a/examples/lua_REPL/Makefile.ci b/examples/lua_REPL/Makefile.ci
index 77ce5202be..7bde4f5a70 100644
--- a/examples/lua_REPL/Makefile.ci
+++ b/examples/lua_REPL/Makefile.ci
@@ -80,6 +80,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     samr30-xpro \
     samr34-xpro \
     seeeduino_arch-pro \
+    seeeduino_xiao \
     sensebox_samd21 \
     serpente \
     slstk3400a \
diff --git a/examples/nanocoap_server/coap_handler.c b/examples/nanocoap_server/coap_handler.c
index c1682cd127..6b5c3c6d02 100644
--- a/examples/nanocoap_server/coap_handler.c
+++ b/examples/nanocoap_server/coap_handler.c
@@ -96,7 +96,6 @@ static ssize_t _riot_value_handler(coap_pkt_t *pkt, uint8_t *buf, size_t len, vo
         break;
     case COAP_PUT:
     case COAP_POST:
-    {
         if (pkt->payload_len < 16) {
             /* convert the payload to an integer and update the internal value */
             char payload[16] = { 0 };
@@ -108,7 +107,6 @@ static ssize_t _riot_value_handler(coap_pkt_t *pkt, uint8_t *buf, size_t len, vo
             code = COAP_CODE_REQUEST_ENTITY_TOO_LARGE;
         }
     }
-    }
 
     return coap_reply_simple(pkt, code, buf, len,
             COAP_FORMAT_TEXT, (uint8_t*)rsp, p);
diff --git a/examples/openthread/main.c b/examples/openthread/main.c
index facd03fb61..a4bd1341fb 100644
--- a/examples/openthread/main.c
+++ b/examples/openthread/main.c
@@ -16,15 +16,37 @@
 #include <stdio.h>
 
 #include "ot.h"
+#include "openthread/thread.h"
+
+static void _panid_handler(event_t *event);
+
+static event_t event_panid = {
+    .handler = _panid_handler
+};
+
+static void _panid_handler(event_t *event)
+{
+    (void) event;
+
+    /* It's safe here to call any OpenThread specific API, since this code runs
+     * in the same thread as the OpenThread tasklet handler */
+
+    /* Get PanID from OpenThread API */
+    uint16_t panid = otLinkGetPanId(openthread_get_instance());
+    printf("Current panid: 0x%x\n", panid);
+}
 
 int main(void)
 {
-    puts("This a test for OpenThread");
     /* Example of how to call OpenThread stack functions */
-    puts("Get PANID ");
-    uint16_t panid = 0;
-    uint8_t res = ot_call_command("panid", NULL, (void*)&panid);
-    printf("Current panid: 0x%x (res:%x)\n", panid, res);
+    puts("This is an OpenThread example");
+
+    /** OpenThread needs to synchronize otApi calls
+     * with its tasklet scheduler. This
+     * synchronization is handled by RIOT using an
+     * event queue (accessible via openthread_get_evq())
+     */
+    event_post(openthread_get_evq(), &event_panid);
 
     return 0;
 }
diff --git a/firmwareExample/Makefile b/firmwareExample/Makefile
index e0edec6c4f..dc96c613eb 100644
--- a/firmwareExample/Makefile
+++ b/firmwareExample/Makefile
@@ -12,13 +12,25 @@ USEMODULE += shell_commands
 FEATURES_REQUIRED += periph_adc
 FEATURES_REQUIRED += periph_gpio_irq
 
+# acceleration sensor
+USEMODULE += lis2dh12_spi
+
 # gnrc_networking
 GNRC_NETIF_NUMOF := 1
 
+USEMODULE += gnrc_netdev_default
+USEMODULE += auto_init_gnrc_netif
+USEMODULE += gnrc_ipv6
+USEMODULE += gnrc_icmpv6_error
+USEMODULE += gnrc_udp
+USEMODULE += gnrc_icmpv6_echo
+
 USEMODULE += ps
 USEMODULE += netstats_l2
 USEMODULE += netstats_ipv6
 
+# PCD8544
+USEMODULE += pcd8544
 
 # This has to be the absolute path to the RIOT base directory:
 RIOTBASE ?= $(CURDIR)/..
diff --git a/firmwareExample/graphplot.c b/firmwareExample/graphplot.c
new file mode 100644
index 0000000000..f7f90c0cea
--- /dev/null
+++ b/firmwareExample/graphplot.c
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2021 Technische Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     firmwareExample
+ * @{
+ *
+ * @file
+ * @brief       Graph Plotting
+ *
+ * @author      Jan Mohr <jan.mohr@campus.tu-berlin.de>
+ *
+ * @}
+ */
+
+#include <stdio.h>
+#include "pcd8544.h"
+#include "graphplot.h"
+
+/* debug config */
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+static int16_t y_value_min = 0;
+static int16_t y_value_max = 0x7FFF;
+
+static uint8_t graph_mode = 0;
+
+static uint8_t pixel_save[PCD8544_RES_X][PCD8544_ROWS] = {{0x00}};
+
+static const uint8_t graph_img_0[] = {
+    0x84,0x82,0xFF,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x00,0x00,0x3F,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,
+    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,
+    0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
+    0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,
+    0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
+    0x20,0x20,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xA8,0x70,0x20,
+};
+
+static const uint8_t graph_img_1[] = {
+    0x84,0x82,0xFF,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x80,0x80,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
+    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xA0,0xC0,0x80,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,
+
+    0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+    0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+};
+
+void graphplot_clear(void) {
+    for (uint8_t x = 0; x < PCD8544_RES_X; x++) {
+        for (uint8_t y_line = 0; y_line < PCD8544_ROWS; y_line++){
+            pixel_save[x][y_line] = 0x00;
+        }
+    }
+}
+
+void graphplot_write_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y) {
+    /* check position */
+    if (x >= PCD8544_RES_X || y >= PCD8544_RES_Y) {
+        return;
+    }
+
+    /* calc y position */
+    uint8_t y_line = y / 8;
+
+    /* check pixel array */
+    pixel_save[x][y_line] = pixel_save[x][y_line] | (1 << (y % 8));
+
+    /* write stackedpixel */
+    pcd8544_write_stackedpixel(dev, x, y_line, pixel_save[x][y_line]);
+}
+
+void graphplot_clear_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y) {
+    /* check position */
+    if (x >= PCD8544_RES_X || y >= PCD8544_RES_Y) {
+        return;
+    }
+
+    /* calc y position */
+    uint8_t y_line = y / 8;
+
+    /* check pixel array */
+    pixel_save[x][y_line] = pixel_save[x][y_line] & ~(1 << (y % 8));
+
+    /* remove stackedpixel */
+    pcd8544_clear_stackedpixel(dev, x, y_line, pixel_save[x][y_line]);
+}
+
+void graphplot_diagram(const pcd8544_t *dev, uint8_t mode) {
+    uint8_t x, y_line;
+
+    /* store current mode of graph */
+    graph_mode = mode;
+
+    if (mode == 0) {
+        /* store graph_img in pixel_save */
+        for (unsigned i = 0; i < (PCD8544_RES_X * PCD8544_RES_Y / 8); i++) {
+            y_line = i / PCD8544_RES_X;
+            x = i - (PCD8544_RES_X * y_line);
+            pixel_save[x][y_line] = graph_img_0[i];
+        }
+        pcd8544_write_img(dev, graph_img_0);
+    }
+
+    else if (mode == 1) {
+        /* store graph_img in pixel_save */
+        for (unsigned i = 0; i < (PCD8544_RES_X * PCD8544_RES_Y / 8); i++) {
+            y_line = i / PCD8544_RES_X;
+            x = i - (PCD8544_RES_X * y_line);
+            pixel_save[x][y_line] = graph_img_1[i];
+        }
+
+        pcd8544_write_img(dev, graph_img_1);
+    }
+
+    else {
+        graph_mode = 0;
+        return;
+    }
+}
+
+void graphplot_set_min_max(int16_t min, int16_t max) {
+    /* check if value max is bigger than min and not equal */
+    if (graph_mode == 0) // mode with first quadrant
+        assert(max > min && max != -min);
+    if (graph_mode == 1) // mode with first and second quadrant
+        assert(max > min && max == -min);
+
+    y_value_min = min;
+    y_value_max = max;
+}
+
+void graphplot_write_coordinate(const pcd8544_t *dev, uint8_t x_coordinate, int16_t y_coordinate) {
+    /* check if in range */
+    if (y_coordinate >= y_value_max)
+        y_coordinate = y_value_max;
+    if (y_coordinate <= y_value_min)
+        y_coordinate = y_value_min;
+
+    /* save y_coordinate and sign of y_value */
+    bool neg_sign = false;
+    uint64_t y_value = 0;
+    y_value = y_coordinate;
+    if (y_coordinate < 0){
+        neg_sign = true;
+        y_value = y_coordinate * (-1);
+    }
+
+    /* y-axis parameter */
+    uint8_t axis_range = PCD8544_RES_Y - 1 - GRAPHPLOT_OFFSET_Y;
+    uint32_t value_range = (y_value_max - y_value_min);
+    uint32_t multiplier = 0x4000;
+
+    y_value = (y_value * axis_range * multiplier) / value_range;
+
+    /* restore y_value */
+    uint8_t y = y_value / multiplier;
+
+    if (graph_mode == 0)
+        y = (-1) * y + axis_range;
+    else if (graph_mode == 1) {
+        if (neg_sign)
+            y = y + axis_range / 2;
+        else
+            y = (-1) * y + axis_range / 2;
+    }
+    
+    /* check position */
+    if (x_coordinate >= PCD8544_RES_X || y >= PCD8544_RES_Y) {
+        return;
+    }
+
+    /* calc y position */
+    uint8_t y_line = y / 8;
+
+    /* check pixel array */
+    pixel_save[x_coordinate][y_line] = pixel_save[x_coordinate][y_line] | (1 << (y % 8));
+
+    /* write stackedpixel */
+    pcd8544_write_stackedpixel(dev, x_coordinate, y_line, pixel_save[x_coordinate][y_line]);
+}
diff --git a/firmwareExample/graphplot.h b/firmwareExample/graphplot.h
new file mode 100644
index 0000000000..843ed97d71
--- /dev/null
+++ b/firmwareExample/graphplot.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2021 Technische Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     firmwareExample
+ * @brief       Module to plot a graph on LCD display PCD8544
+ *
+ * @{
+ *
+ * @file
+ * @brief       Interface definition for plotting on the PCD8544 LCD
+ *
+ * @author      Jan Mohr <jan.mohr@campus.tu-berlin.de>
+ */
+
+#ifndef GRAPHPLOT_H
+#define GRAPHPLOT_H
+
+#include <stdint.h>
+
+#include "pcd8544.h"
+
+#define GRAPHPLOT_OFFSET_X 3
+#define GRAPHPLOT_OFFSET_Y 3
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+/**
+ * @brief   Sets a single pixel on the display
+ *
+ * The position of the pixel is specified in columns (x) and rows (y)
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] x         column_px absolute position to write pixel [0 - 83]
+ * @param[in] y         row_px absolute position to write pixel [0 - 47]
+ */
+void graphplot_write_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y);
+
+/**
+ * @brief   Removes a single pixel on the display
+ *
+ * The position of the pixel is specified in columns (x) and rows (y)
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] x         column_px absolute position to clear pixel [0 - 83]
+ * @param[in] y         row_px absolute position to clear pixel [0 - 47]
+ */
+void graphplot_clear_pixel(const pcd8544_t *dev, uint8_t x, uint8_t y);
+
+/**
+ * @brief   Write the diagram-image to memory of the given display
+ *
+ * The diagram-image is displayed after calling the function and the
+ * pixel array is updated.
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] mode      set the mode of the diagram [0 - 1]
+ */
+void graphplot_diagram(const pcd8544_t *dev, uint8_t mode);
+
+/**
+ * @brief   Set the min and max value for y-axis
+ *
+ * The min and max of the graph can be set,
+ * needs for graphplot_write_coordinate() function
+ *
+ * @param[in] dev       device descriptor of display to use
+ * @param[in] min       the minimum value for y-axis
+ * @param[in] max       the maximum value for y-axis
+ */
+void graphplot_set_min_max(int16_t min, int16_t max);
+
+/**
+ * @brief   Write coordinate to the graph
+ *
+ * The position of the pixel is calculated with min max value of the graph,
+ * function graphplot_set_min_max() needs to be called before 
+ *
+ * @param[in] dev           device descriptor of display to use
+ * @param[in] x_coordinate  time_tick value of the graph [0 - 83]
+ * @param[in] y_coordinate  value must be between min max, can be raw data value
+ */
+void graphplot_write_coordinate(const pcd8544_t *dev, uint8_t x_coordinate, int16_t y_coordinate);
+
+/**
+ * @brief   Clear the pixel array
+ *
+ * The pixel array is set to zero
+ *
+ */
+void graphplot_clear(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GRAPHPLOT_H */
+/** @} */
diff --git a/firmwareExample/main.c b/firmwareExample/main.c
index 8389ec7cb2..fc7a8ed988 100644
--- a/firmwareExample/main.c
+++ b/firmwareExample/main.c
@@ -7,7 +7,7 @@
  */
 
 /**
- * @ingroup     examples
+ * @ingroup     firmwareExample
  * @{
  *
  * @file
@@ -19,56 +19,491 @@
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 
 #include "shell.h"
 #include "msg.h"
-#include "periph/gpio.h"
-#include "periph/adc.h"
 #include "board.h"
+#include "xtimer.h"
+#include "thread.h"
+
+#include "periph/gpio.h"
+
+/* acceleration sensor config */
+#ifdef MODULE_LIS2DH12_SPI
+    #define LIS2DH12_PARAM_SPI  SPI_DEV(2)
+    #define LIS2DH12_PARAM_CS   GPIO_PIN(PB, 17)
+    #include "lis2dh12.h"
+    #include "lis2dh12_params.h"
+    #include "lis2dh12_registers.h"
+    static lis2dh12_t dev_lis;
+#elif MODULE_LIS3DH
+    #define LIS3DH_PARAM_SPI  (SPI_DEV(1))
+    #define LIS3DH_PARAM_CS   (GPIO_PIN(PA, 17))
+    #define LIS3DH_PARAM_INT1 (GPIO_PIN(PB, 11))
+    #define LIS3DH_PARAM_INT2 (GPIO_PIN(PB, 10))
+    #include "lis3dh.h"
+    #include "lis3dh_params.h"
+    static lis3dh_t dev_lis;
+#endif
 
-#define ADC_SAMPLE_LINE 0
+/* display PCD8544 */
+#include "pcd8544.h"
+static pcd8544_t dev_pcd;
+
+/* plotting graph */
+#include "graphplot.h"
+bool GRAPHPLOT_ENABLE = false;
+
+/* timings */
+#define SECOND          1000000
+#define MILLI_SECOND    1000
+/* values */
+#define INTERRUPT_WAIT      (350 * MILLI_SECOND)
+#define ADC_thread_delay    (300 * MILLI_SECOND)
+#define LIS_thread_delay    (200 * MILLI_SECOND)
+
+/* debug config */
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+/* ADC config */
+#include "periph/adc.h"
+#define ADC_SAMPLE_LINE 1   /* PB01 */
 
+/* message queue */
 #define MAIN_QUEUE_SIZE (8)
 static msg_t _main_msg_queue[MAIN_QUEUE_SIZE];
 
+/* ADC threading */
+char adc_thread_stack[THREAD_STACKSIZE_MAIN];
+kernel_pid_t ADC_thread_pid;
+bool ADC_thread_sleep = false;
+
+/* LIS threading */
+char lis_thread_stack[THREAD_STACKSIZE_MAIN];
+kernel_pid_t LIS_thread_pid;
+bool LIS_thread_sleep = false;
+
 /* toggles the user LED */
-static int toggle_LED(int argc, char **argv){
+static int led_toggle(int argc, char **argv) {
     (void)argc;
     (void)argv;
     LED0_TOGGLE;
     return 1;
 }
 
+/* clears full display and pixel array for graphplot */
+void __clear_display(void) {
+    graphplot_clear();
+    pcd8544_clear(&dev_pcd);
+}
+
 /* read ADC (differential mode) */
-static int read_ADC(int argc, char **argv){
+static int adc_read(int argc, char **argv) {
     (void)argc;
     (void)argv;
+
+    __clear_display();
+
+    ADC_thread_sleep = true;
+    GRAPHPLOT_ENABLE = false;
+    char buffer[PCD8544_COLS] = {0};
+
     int sample = adc_sample(ADC_LINE(ADC_SAMPLE_LINE), ADC_RES_10BIT);
-    printf("ADC value: %d\n", sample);
+    DEBUG("ADC value: %d\n", sample);
+
+    /* print to display */
+    sprintf(buffer, "ADC: %d", sample);
+    pcd8544_write_l(&dev_pcd, 0, buffer);
+
     return 1;
 }
 
+/* ADC periodic thread */
+void *adc_read_periodic(void *arg)
+{
+    (void) arg;
+    int sample = 0;
+    char buffer[PCD8544_COLS] = {0};
+    uint8_t time_ticks = GRAPHPLOT_OFFSET_X;
+
+    while (1) {
+        /* read ADC data */
+        sample = adc_sample(ADC_LINE(ADC_SAMPLE_LINE), ADC_RES_10BIT);
+
+        DEBUG("ADC value: %d\n", sample);
+
+        /* checking max time_ticks */
+        if (time_ticks >= PCD8544_RES_X - GRAPHPLOT_OFFSET_X) {
+            /* reset */
+            time_ticks = GRAPHPLOT_OFFSET_X;
+            if (GRAPHPLOT_ENABLE)
+                graphplot_diagram(&dev_pcd, 0);
+        }
+
+        if (!GRAPHPLOT_ENABLE) {
+            /* print to display */
+            sprintf(buffer, "ADC: %d", sample);
+            pcd8544_write_l(&dev_pcd, 0, buffer);
+        }
+        else {
+            /* print to graph */
+            graphplot_write_coordinate(&dev_pcd, time_ticks, sample);
+        }
+
+        xtimer_usleep(ADC_thread_delay);
+        time_ticks++;
+
+        if (ADC_thread_sleep)
+            thread_sleep();
+    }
+
+    return NULL;
+}
+
+/* ADC wake-up thread */
+static int adc_thread_wakeup (int argc, char **argv){
+    (void)argc;
+    (void)argv;
+
+    __clear_display();
+
+    ADC_thread_sleep = false;
+    GRAPHPLOT_ENABLE = false;
+    thread_wakeup(ADC_thread_pid);
+
+    return 0;
+}
+
 /* interrupt callback for user button */
-void button_int_cb(void* arg){
+void button_int_cb(void* arg) {
     (void)arg;
+
+    gpio_irq_disable(BTN0_PIN);
     puts("interrupt received.");
+    pcd8544_clear(&dev_pcd);
+    pcd8544_write_s(&dev_pcd, 1, 2, "Button_inter.");
+    xtimer_usleep(INTERRUPT_WAIT);
+    pcd8544_clear(&dev_pcd);
+    gpio_irq_enable(BTN0_PIN);
+}
+
+/* LIS init function */
+void lis_func_init(void) {
+
+#ifdef MODULE_LIS2DH12_SPI
+    if (lis2dh12_init(&dev_lis, &lis2dh12_params[0]) == 0) {
+        puts("lis2dh12 [Initialized]");
+    }
+    else {
+        puts("lis2dh12 [Failed]");
+    }
+
+    /* change LIS settings */
+    lis2dh12_set_resolution(&dev_lis, LIS2DH12_POWER_LOW);
+    lis2dh12_set_datarate(&dev_lis, LIS2DH12_RATE_100HZ);
+    lis2dh12_set_scale(&dev_lis, LIS2DH12_SCALE_2G);
+
+#elif MODULE_LIS3DH
+    if (lis3dh_init(&dev_lis, &lis3dh_params[0]) == 0) {
+        puts("lis3dh [Initialized]");
+    }
+    else {
+        puts("lis3dh [Failed]");
+    }
+
+    lis3dh_set_odr(&dev_lis, LIS3DH_ODR_100Hz);
+    lis3dh_set_scale(&dev_lis, 2);
+    lis3dh_set_axes(&dev_lis, LIS3DH_AXES_XYZ);
+#endif
+}
+
+/* read LIS values */
+static int lis_read(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    __clear_display();
+
+    LIS_thread_sleep = true;
+    GRAPHPLOT_ENABLE = false;
+    char buffer[PCD8544_COLS] = {0};
+
+#ifdef MODULE_LIS2DH12_SPI
+    lis2dh12_fifo_data_t data = {0};
+    lis2dh12_read(&dev_lis, &data);
+
+    DEBUG("X: %d  Y: %d  Z: %d\n", data.axis.x, data.axis.y, data.axis.z);
+
+    /* print to display */
+    sprintf(buffer, "X: %d", data.axis.x);
+    pcd8544_write_l(&dev_pcd, 1, buffer);
+
+    sprintf(buffer, "Y: %d", data.axis.y);
+    pcd8544_write_l(&dev_pcd, 2, buffer);
+
+    sprintf(buffer, "Z: %d", data.axis.z);
+    pcd8544_write_l(&dev_pcd, 3, buffer);
+
+#elif MODULE_LIS3DH
+    lis3dh_data_t data = {0};
+
+    lis3dh_read_xyz(&dev_lis, &data);
+    DEBUG("X: %d  Y: %d  Z: %d\n", data.acc_x, data.acc_y, data.acc_z);
+
+    /* print to display */
+    sprintf(buffer, "X: %d", data.acc_x);
+    pcd8544_write_l(&dev_pcd, 1, buffer);
+
+    sprintf(buffer, "Y: %d", data.acc_y);
+    pcd8544_write_l(&dev_pcd, 2, buffer);
+
+    sprintf(buffer, "Z: %d", data.acc_z);
+    pcd8544_write_l(&dev_pcd, 3, buffer);
+#endif
+
+    return 0;
+}
+
+/* LIS periodic thread */
+void *lis_read_periodic(void *arg)
+{
+    (void) arg;
+
+    int16_t value_x, value_y, value_z;
+    char buffer[PCD8544_COLS] = {0};
+    uint8_t time_ticks = GRAPHPLOT_OFFSET_X;
+
+    while (1) {
+        /* read LIS data */
+#ifdef MODULE_LIS2DH12_SPI
+        lis2dh12_fifo_data_t data = {0};
+
+        lis2dh12_read(&dev_lis, &data);
+        value_x = data.axis.x;
+        value_y = data.axis.y;
+        value_z = data.axis.z;
+
+#elif MODULE_LIS3DH
+        lis3dh_data_t data = {0};
+
+        lis3dh_read_xyz(&dev_lis, &data);
+        value_x = data.acc_x;
+        value_y = data.acc_y;
+        value_z = data.acc_z;
+#endif
+
+        DEBUG("X: %d  Y: %d  Z: %d\n", value_x, value_y, value_z);
+
+        /* checking max time_ticks */
+        if (time_ticks >= PCD8544_RES_X - GRAPHPLOT_OFFSET_X) {
+            /* reset */
+            time_ticks = GRAPHPLOT_OFFSET_X;
+            if (GRAPHPLOT_ENABLE)
+                graphplot_diagram(&dev_pcd, 1);
+        }
+
+        if (!GRAPHPLOT_ENABLE) {
+            /* print to display */
+            sprintf(buffer, "X: %d", value_x);
+            pcd8544_write_l(&dev_pcd, 1, buffer);
+
+            sprintf(buffer, "Y: %d", value_y);
+            pcd8544_write_l(&dev_pcd, 2, buffer);
+
+            sprintf(buffer, "Z: %d", value_z);
+            pcd8544_write_l(&dev_pcd, 3, buffer);
+        }
+        else {
+            /* print to graph */
+            graphplot_write_coordinate(&dev_pcd, time_ticks, value_x);
+            graphplot_write_coordinate(&dev_pcd, time_ticks, value_y);
+            graphplot_write_coordinate(&dev_pcd, time_ticks, value_z);
+        }
+
+        xtimer_usleep(LIS_thread_delay);
+        time_ticks++;
+
+        if (LIS_thread_sleep)
+            thread_sleep();
+    }
+
+    return NULL;
+}
+
+/* LIS wake-up thread */
+static int lis_thread_wakeup (int argc, char **argv){
+    (void)argc;
+    (void)argv;
+
+    __clear_display();
+
+    LIS_thread_sleep = false;
+    GRAPHPLOT_ENABLE = false;
+    thread_wakeup(LIS_thread_pid);
+
+    return 0;
+}
+
+/* turn on the display */
+static int display_on(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    pcd8544_poweron(&dev_pcd);
+    return 0;
+}
+
+/* turn off the display */
+static int display_off(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    pcd8544_poweroff(&dev_pcd);
+    return 0;
+}
+
+/* clear the display content */
+static int display_clear(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    __clear_display();
+    return 0;
+}
+
+/* display riot-logo */
+static int display_riot(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    pcd8544_riot(&dev_pcd);
+    return 0;
+}
+
+/* invert display content */
+static int display_invert(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    pcd8544_invert(&dev_pcd);
+    return 0;
+}
+
+/* write to specific line and column of display */
+static int display_write(int argc, char **argv) {
+    uint8_t line, column;
+
+    if (argc < 4) {
+        printf("usage: %s LINE COLUMN STRING\n", argv[0]);
+        return -1;
+    }
+
+    line = atoi(argv[1]);
+    column = atoi(argv[2]);
+
+    pcd8544_write_s(&dev_pcd, column, line, argv[3]);
+    return 0;
+}
+
+/* writes a specific pixel on display */
+static int display_pixel(int argc, char **argv) {
+    uint8_t x, y;
+
+    if (argc < 3) {
+        printf("usage: %s POSX POSY\n", argv[0]);
+        return -1;
+    }
+
+    x = atoi(argv[1]);
+    y = atoi(argv[2]);
+
+    graphplot_write_pixel(&dev_pcd, x, y);
+    return 0;
+}
+
+/* removes a specific pixel on display */
+static int display_pixel_clear(int argc, char **argv) {
+    uint8_t x, y;
+
+    if (argc < 3) {
+        printf("usage: %s POSX POSY\n", argv[0]);
+        return -1;
+    }
+
+    x = atoi(argv[1]);
+    y = atoi(argv[2]);
+
+    graphplot_clear_pixel(&dev_pcd, x, y);
+    return 0;
+}
+
+/* plot diagram on display */
+static int display_graph_adc(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    /* display the diagram */
+    graphplot_diagram(&dev_pcd, 0);
+    graphplot_set_min_max(0, 1200);
+
+    /* stops ADC and LIS threads */
+    LIS_thread_sleep = true;
+    ADC_thread_sleep = false;
+    GRAPHPLOT_ENABLE = true;
+    thread_wakeup(ADC_thread_pid);
+
+    return 0;
+}
+
+/* plot diagram on display */
+static int display_graph_lis(int argc, char **argv) {
+    (void)argc;
+    (void)argv;
+
+    /* display the diagram */
+    graphplot_diagram(&dev_pcd, 1);
+    graphplot_set_min_max(-1500, 1500);
+
+    /* stops ADC and LIS threads */
+    LIS_thread_sleep = false;
+    ADC_thread_sleep = true;
+    GRAPHPLOT_ENABLE = true;
+    thread_wakeup(LIS_thread_pid);
+
+    return 0;
 }
 
 /* shell commands */
 static const shell_command_t shell_commands[] = {
-    { "toggle_LED", "toggles the LED status of LED0", toggle_LED},
-    { "adc", "reads the ADC0", read_ADC},
+    { "disp_on", "Turn on the display", display_on },
+    { "disp_off", "Turn off the display", display_off },
+    { "disp_riot", "Displays RIOT logo", display_riot },
+    { "disp_invert", "Invert display", display_invert },
+    { "disp_write", "Write string to display", display_write},
+    { "disp_clear", "Clear display", display_clear },
+    { "pixel", "Writes a pixel at given position", display_pixel},
+    { "pixel_clear", "Removes a pixel at given position", display_pixel_clear},
+    { "graph_lis", "Plots the diagram image and displays the LIS data over time period", display_graph_lis},
+    { "graph_adc", "Plots the diagram image and displays the LIS data over time period", display_graph_adc},
+    { "lis_read", "Read acceleration data", lis_read },
+    { "lis_read_periodic", "Periodic read of acceleration data", lis_thread_wakeup },
+    { "adc_read", "Read ADC value, stops periodic read", adc_read},
+    { "adc_read_periodic", "Periodic read of ADC value", adc_thread_wakeup},
+    { "led_toggle", "Toggles the LED0 status", led_toggle},
     { NULL, NULL, NULL }
 };
 
-int main(void)
-{
+
+int main(void) {
+
     puts("Example Firmware");
 
     printf("You are running RIOT on a(n) %s board.\n", RIOT_BOARD);
     printf("This board features a(n) %s MCU.\n", RIOT_MCU);
 
-    /* powers off the LED */
+    /* power off the LED */
     LED0_OFF;
 
     /* setting up interrupt pin (user button) */
@@ -77,10 +512,40 @@ int main(void)
 
     /* setting up ADC */
     adc_init(ADC_LINE(ADC_SAMPLE_LINE));
+    /* starting sleeping ADC thread */
+    ADC_thread_pid = thread_create( adc_thread_stack, sizeof(adc_thread_stack),
+                        THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_SLEEPING,
+                        adc_read_periodic, NULL, "ADC_periodic");
 
     /* initializes the message queue */
     msg_init_queue(_main_msg_queue, MAIN_QUEUE_SIZE);
 
+    /* initializes acceleration sensor */
+    lis_func_init();
+    /* starting sleeping LIS thread */
+    LIS_thread_pid = thread_create( lis_thread_stack, sizeof(lis_thread_stack),
+                        THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_SLEEPING,
+                        lis_read_periodic, NULL, "LIS_periodic");
+
+    printf("Initializing PCD8544 LCD at SPI_%i...\n", SPI_DEV(0));
+    if (pcd8544_init(&dev_pcd, SPI_DEV(0), GPIO_PIN(PA,5),
+                     GPIO_PIN(PB,9), GPIO_PIN(PB,8)) != 0) {
+        puts("Failed to initialize PCD8544 display");
+        return 1;
+    }
+
+    /* display riot-logo for one second */
+    pcd8544_clear(&dev_pcd);
+    pcd8544_poweron(&dev_pcd);
+    pcd8544_riot(&dev_pcd);
+    xtimer_usleep(1 * SECOND);
+    pcd8544_clear(&dev_pcd);
+    pcd8544_write_s(&dev_pcd, 3, 1, "Running");
+    pcd8544_write_s(&dev_pcd, 3, 2, "Example");
+    pcd8544_write_s(&dev_pcd, 3, 3, "Firmware");
+    xtimer_usleep(2 * SECOND);
+    pcd8544_clear(&dev_pcd);
+
     /* start shell */
     puts("All up, running the shell now");
     char line_buf[SHELL_DEFAULT_BUFSIZE];
diff --git a/kconfigs/Kconfig.features b/kconfigs/Kconfig.features
index 99c394b361..43b800f18a 100644
--- a/kconfigs/Kconfig.features
+++ b/kconfigs/Kconfig.features
@@ -252,6 +252,11 @@ config HAS_PERIPH_RTC
     help
         Indicates that an RTC peripheral is present.
 
+config HAS_PERIPH_RTC_MS
+    bool
+    help
+        Indicates that the RTC peripheral can provide sub-second timestamps.
+
 config HAS_PERIPH_RTT
     bool
     help
@@ -262,6 +267,11 @@ config HAS_PERIPH_RTT_SET_COUNTER
     help
         Indicates that the RTT peripheral implements rtt_set_counter().
 
+config HAS_PERIPH_RTT_OVERFLOW
+    bool
+    help
+        Indicates that the RTT provides an overflow callback.
+
 config HAS_PERIPH_SPI
     bool
     help
diff --git a/makefiles/boot/riotboot.mk b/makefiles/boot/riotboot.mk
index 3288e2a7a6..1567d72e26 100644
--- a/makefiles/boot/riotboot.mk
+++ b/makefiles/boot/riotboot.mk
@@ -76,11 +76,15 @@ riotboot: $(SLOT_RIOT_BINS)
 
 # riotboot bootloader compile target
 riotboot/flash-bootloader: riotboot/bootloader/flash
-riotboot/bootloader/%: $(BUILDDEPS) pkg-prepare
+# IOTLAB_NODE is passed so that FLASHFILE is also set in the recursive make call
+# when PROGRAMMER=iotlab
+# avoid circular dependency against clean
+riotboot/bootloader/%: $$(if $$(filter riotboot/bootloader/clean,$$@),,$$(BUILDDEPS) pkg-prepare)
 	$(Q)/usr/bin/env -i \
 		QUIET=$(QUIET) PATH="$(PATH)"\
 		EXTERNAL_BOARD_DIRS="$(EXTERNAL_BOARD_DIRS)" BOARD=$(BOARD)\
 		DEBUG_ADAPTER_ID=$(DEBUG_ADAPTER_ID) \
+		IOTLAB_NODE=$(IOTLAB_NODE) \
 		PROGRAMMER=$(PROGRAMMER) PROGRAMMER_QUIET=$(PROGRAMMER_QUIET) \
 			$(MAKE) --no-print-directory -C $(RIOTBOOT_DIR) $*
 
@@ -95,6 +99,7 @@ $(BOOTLOADER_BIN)/riotboot.extended.bin: $(BOOTLOADER_BIN)/riotboot.bin
 
 # Only call sub make if not already in riotboot
 ifneq ($(BOOTLOADER_BIN)/riotboot.bin,$(BINFILE))
+  clean: riotboot/bootloader/clean
   $(BOOTLOADER_BIN)/riotboot.bin: riotboot/bootloader/binfile
 endif
 
diff --git a/makefiles/color.inc.mk b/makefiles/color.inc.mk
index 31f6bb6842..4e14ea3ea0 100644
--- a/makefiles/color.inc.mk
+++ b/makefiles/color.inc.mk
@@ -3,6 +3,7 @@
 
 COLOR_GREEN  :=
 COLOR_RED    :=
+COLOR_YELLOW :=
 COLOR_PURPLE :=
 COLOR_RESET  :=
 COLOR_ECHO   := /usr/bin/env echo
@@ -13,11 +14,11 @@ ifneq ($(CC_NOCOLOR),1)
   IS_TERMINAL = $(if $(MAKE_TERMOUT),$(MAKE_TERMERR),)
   # Check if terminal support colored output
   ifneq ($(IS_TERMINAL),)
-    COLOR_GREEN  := \033[1;32m
-    COLOR_RED    := \033[1;31m
-    COLOR_YELLOW := \033[1;33m
-    COLOR_PURPLE := \033[1;35m
-    COLOR_RESET  := \033[0m
+    COLOR_GREEN  := $(ANSI_GREEN)
+    COLOR_RED    := $(ANSI_RED)
+    COLOR_YELLOW := $(ANSI_YELLOW)
+    COLOR_PURPLE := $(ANSI_PURPLE)
+    COLOR_RESET  := $(ANSI_RESET)
     ifeq ($(OS),Darwin)
       COLOR_ECHO   := echo -e
       SHELL=bash
@@ -26,3 +27,11 @@ ifneq ($(CC_NOCOLOR),1)
     endif
   endif
 endif
+
+# Colorizer functions:
+#  These functions wrap a block of text in $(COLOR_X)...$(COLOR_RESET).
+#  Do not nest calls to this functions or the colors will be wrong.
+c_green = $(COLOR_GREEN)$(1)$(COLOR_RESET)
+c_red = $(COLOR_RED)$(1)$(COLOR_RESET)
+c_yellow = $(COLOR_YELLOW)$(1)$(COLOR_RESET)
+c_purple = $(COLOR_PURPLE)$(1)$(COLOR_RESET)
diff --git a/makefiles/dependency_resolution.inc.mk b/makefiles/dependency_resolution.inc.mk
index 7b15ea2ef1..a3a76223c2 100644
--- a/makefiles/dependency_resolution.inc.mk
+++ b/makefiles/dependency_resolution.inc.mk
@@ -2,6 +2,10 @@
 # until no new modules, pkgs, or features are pull in order to catch all
 # transient dependencies
 
+# Locate used modules in $(EXTERNAL_MODULE_DIRS).
+EXTERNAL_MODULE_PATHS := $(sort $(foreach dir,$(EXTERNAL_MODULE_DIRS),\
+  $(foreach mod,$(USEMODULE),$(dir $(wildcard $(dir)/$(mod)/Makefile)))))
+
 # Back up current state to detect changes
 OLD_STATE := $(USEMODULE) $(USEPKG) $(FEATURES_USED)
 
diff --git a/makefiles/info-global.inc.mk b/makefiles/info-global.inc.mk
index 6a49333dd0..8b8993c3c1 100644
--- a/makefiles/info-global.inc.mk
+++ b/makefiles/info-global.inc.mk
@@ -60,7 +60,7 @@ define board_unsatisfied_features
   else
     # add default modules
     include $(RIOTMAKE)/defaultmodules.inc.mk
-    USEMODULE += $(filter-out $(DISABLE_MODULE),$(DEFAULT_MODULE))
+    USEMODULE += $$(filter-out $$(DISABLE_MODULE),$$(DEFAULT_MODULE))
 
     include $(RIOTMAKE)/dependency_resolution.inc.mk
 
diff --git a/makefiles/kconfig.mk b/makefiles/kconfig.mk
index 2d91fbe18f..401b8a88e8 100644
--- a/makefiles/kconfig.mk
+++ b/makefiles/kconfig.mk
@@ -143,8 +143,8 @@ $(KCONFIG_GENERATED_DEPENDENCIES): FORCE | $(GENERATED_DIR)
 	      printf "config %s\n\tbool\n\tdefault y\n", toupper($$0)}' \
 	  | $(LAZYSPONGE) $(LAZYSPONGE_FLAGS) $@
 
-# All directories in EXTERNAL_MODULES_DIR which have a Kconfig file
-EXTERNAL_MODULE_KCONFIGS ?= $(sort $(foreach dir,$(EXTERNAL_MODULE_DIRS),\
+# All directories in EXTERNAL_MODULES_PATHS which have a Kconfig file
+EXTERNAL_MODULE_KCONFIGS ?= $(sort $(foreach dir,$(EXTERNAL_MODULE_PATHS),\
                               $(wildcard $(dir)/Kconfig)))
 # Build a Kconfig file that source all external modules configuration
 # files. Every EXTERNAL_MODULE_DIRS with a Kconfig file is written to
@@ -176,7 +176,7 @@ GENERATED_DIR_DEP := $(if $(CLEAN),,|) $(GENERATED_DIR)
 # Generates a .config file by merging multiple sources specified in
 # MERGE_SOURCES. This will also generate KCONFIG_OUT_DEP with the list of used
 # Kconfig files.
-$(KCONFIG_OUT_CONFIG): $(KCONFIG_EXTERNAL_CONFIGS)
+$(KCONFIG_OUT_CONFIG): $(KCONFIG_EXTERNAL_CONFIGS) | pkg-prepare
 $(KCONFIG_OUT_CONFIG): $(GENERATED_DEPENDENCIES_DEP) $(GENCONFIG) $(MERGE_SOURCES) $(GENERATED_DIR_DEP)
 	$(Q) $(GENCONFIG) \
 	  --config-out=$(KCONFIG_OUT_CONFIG) \
diff --git a/makefiles/pseudomodules.inc.mk b/makefiles/pseudomodules.inc.mk
index e2f3d8c248..7340f2b864 100644
--- a/makefiles/pseudomodules.inc.mk
+++ b/makefiles/pseudomodules.inc.mk
@@ -4,6 +4,7 @@ PSEUDOMODULES += at_urc_isr_low
 PSEUDOMODULES += at_urc_isr_medium
 PSEUDOMODULES += at_urc_isr_highest
 PSEUDOMODULES += at24c%
+PSEUDOMODULES += at86rf215_timestamp
 PSEUDOMODULES += atomic_utils
 PSEUDOMODULES += base64url
 PSEUDOMODULES += board_software_reset
@@ -19,13 +20,15 @@ PSEUDOMODULES += cord_ep_standalone
 PSEUDOMODULES += core_%
 PSEUDOMODULES += cortexm_fpu
 PSEUDOMODULES += cortexm_svc
+PSEUDOMODULES += cpp
 PSEUDOMODULES += cpu_check_address
-PSEUDOMODULES += crypto_%	# crypto_aes or crypto_3des
 PSEUDOMODULES += dbgpin
 PSEUDOMODULES += devfs_%
 PSEUDOMODULES += dhcpv6_%
+PSEUDOMODULES += dhcpv6_client_dns
 PSEUDOMODULES += ecc_%
 PSEUDOMODULES += event_%
+PSEUDOMODULES += event_timeout_ztimer
 PSEUDOMODULES += evtimer_mbox
 PSEUDOMODULES += evtimer_on_ztimer
 PSEUDOMODULES += fmt_%
@@ -73,6 +76,7 @@ PSEUDOMODULES += ieee802154_submac
 PSEUDOMODULES += ina3221_alerts
 PSEUDOMODULES += l2filter_blacklist
 PSEUDOMODULES += l2filter_whitelist
+PSEUDOMODULES += libstdcpp
 PSEUDOMODULES += lis2dh12_i2c
 PSEUDOMODULES += lis2dh12_int
 PSEUDOMODULES += lis2dh12_spi
@@ -127,6 +131,7 @@ PSEUDOMODULES += sched_cb
 PSEUDOMODULES += semtech_loramac_rx
 PSEUDOMODULES += shell_hooks
 PSEUDOMODULES += slipdev_stdio
+PSEUDOMODULES += slipdev_l2addr
 PSEUDOMODULES += sock
 PSEUDOMODULES += sock_async
 PSEUDOMODULES += sock_aux_local
@@ -262,6 +267,11 @@ PSEUDOMODULES += si7006
 PSEUDOMODULES += si7013
 PSEUDOMODULES += si7020
 PSEUDOMODULES += si7021
+PSEUDOMODULES += si7050
+PSEUDOMODULES += si7051
+PSEUDOMODULES += si7053
+PSEUDOMODULES += si7054
+PSEUDOMODULES += si7055
 
 #include variants of tmp00x drivers as pseudo modules
 PSEUDOMODULES += tmp006
@@ -301,6 +311,9 @@ PSEUDOMODULES += skald_eddystone
 # define optimized read function of DS18 driver as a pseudo module
 PSEUDOMODULES += ds18_optimized
 
+PSEUDOMODULES += crypto_aes_128
+PSEUDOMODULES += crypto_aes_192
+PSEUDOMODULES += crypto_aes_256
 # By using this pseudomodule, T tables will be precalculated.
 PSEUDOMODULES += crypto_aes_precalculated
 # This pseudomodule causes a loop in AES to be unrolled (more flash, less CPU)
diff --git a/makefiles/stdio.inc.mk b/makefiles/stdio.inc.mk
index 2599138eaa..d5d10bce68 100644
--- a/makefiles/stdio.inc.mk
+++ b/makefiles/stdio.inc.mk
@@ -41,7 +41,7 @@ ifneq (,$(filter stdio_uart_rx,$(USEMODULE)))
 endif
 
 ifneq (,$(filter stdio_uart,$(USEMODULE)))
-  FEATURES_REQUIRED += periph_uart
+  FEATURES_REQUIRED_ANY += periph_uart|periph_lpuart
 endif
 
 ifneq (,$(filter stdio_semihosting,$(USEMODULE)))
diff --git a/makefiles/tools/esptool.inc.mk b/makefiles/tools/esptool.inc.mk
index a863cb845f..566797fc4b 100644
--- a/makefiles/tools/esptool.inc.mk
+++ b/makefiles/tools/esptool.inc.mk
@@ -9,11 +9,18 @@ BOOTLOADER_BIN = bootloader$(BOOTLOADER_COLOR)$(BOOTLOADER_INFO).bin
 
 ESPTOOL ?= $(RIOTTOOLS)/esptool/esptool.py
 
-# The ELFFILE is the base one used for flashing
-FLASHFILE ?= $(ELFFILE)
+# The ELFFILE is defined by default in $(RIOTBASE)/Makefile.include but only
+# after the $(PROGRAMMER).inc.mk file is included, so we need ELFFILE defined
+# earlier. This is used to create new make rules in this file (based on
+# FLASHFILE) and can't be deferred.
+ELFFILE ?= $(BINDIR)/$(APPLICATION).elf
+FLASHFILE ?= $(ELFFILE).bin
 
-# Convert .elf to .bin before flashing
-FLASHDEPS += esp-image-convert
+# Convert .elf and .csv to .bin files at build time, but make them available for
+# tests at flash time. These can't be added to FLASHDEPS because they depend on
+# on ELFFILE and would trigger a rebuild with "flash-only".
+BUILD_FILES += $(FLASHFILE) $(BINDIR)/partitions.bin
+TEST_EXTRA_FILES += $(FLASHFILE) $(BINDIR)/partitions.bin
 
 # flasher configuration
 ifneq (,$(filter esp_qemu,$(USEMODULE)))
@@ -28,22 +35,30 @@ else
   FFLAGS += --flash_mode $(FLASH_MODE) --flash_freq $(FLASH_FREQ)
   FFLAGS += $(BOOTLOADER_POS) $(RIOTCPU)/$(CPU)/bin/$(BOOTLOADER_BIN)
   FFLAGS += 0x8000 $(BINDIR)/partitions.bin
-  FFLAGS += 0x10000 $(FLASHFILE).bin
+  FFLAGS += 0x10000 $(FLASHFILE)
 endif
 
-.PHONY: esp-image-convert esp-qemu
-# prepare image to flash: convert .elf to .bin
-esp-image-convert:
+# This is the binary that ends up programmed in the flash.
+$(ELFFILE).bin: $(ELFFILE)
 	$(Q)$(ESPTOOL) --chip $(FLASH_CHIP) elf2image --flash_mode $(FLASH_MODE) \
 		--flash_size $(FLASH_SIZE)MB --flash_freq $(FLASH_FREQ) $(FLASH_OPTS) \
-		-o $(FLASHFILE).bin $(FLASHFILE)
+		-o $@ $<
+
+# Default partition table with no OTA. Can be replaced with a custom partition
+# table setting PARTITION_TABLE_CSV.
+PARTITION_TABLE_CSV ?= $(BINDIR)/partitions.csv
+
+$(BINDIR)/partitions.csv: $(FLASHFILE)
 	$(Q)printf "\n" > $(BINDIR)/partitions.csv
-	$(Q)printf "nvs, data, nvs, 0x9000, 0x6000\n" >> $(BINDIR)/partitions.csv
-	$(Q)printf "phy_init, data, phy, 0xf000, 0x1000\n" >> $(BINDIR)/partitions.csv
-	$(Q)printf "factory, app, factory, 0x10000, " >> $(BINDIR)/partitions.csv
-	$(Q)ls -l $(FLASHFILE).bin | awk '{ print $$5 }' >> $(BINDIR)/partitions.csv
-	$(Q)python3 $(RIOTTOOLS)/esptool/gen_esp32part.py --verify \
-		$(BINDIR)/partitions.csv $(BINDIR)/partitions.bin
+	$(Q)printf "nvs, data, nvs, 0x9000, 0x6000\n" >> $@
+	$(Q)printf "phy_init, data, phy, 0xf000, 0x1000\n" >> $@
+	$(Q)printf "factory, app, factory, 0x10000, " >> $@
+	$(Q)ls -l $< | awk '{ print $$5 }' >> $@
+
+$(BINDIR)/partitions.bin: $(PARTITION_TABLE_CSV)
+	$(Q)python3 $(RIOTTOOLS)/esptool/gen_esp32part.py --verify $< $@
+
+.PHONY: esp-qemu
 
 esp-qemu:
 	$(Q)dd if=/dev/zero bs=1M count=$(FLASH_SIZE) | \
@@ -53,7 +68,7 @@ esp-qemu:
 		head -c $$((0x8000)) | \
 		cat - $(BINDIR)/partitions.bin tmp.bin | \
 		head -c $$((0x10000)) | \
-		cat - $(FLASHFILE).bin tmp.bin | \
+		cat - $(FLASHFILE) tmp.bin | \
 		head -c $(FLASH_SIZE)MB > $(BINDIR)/$(CPU)flash.bin && rm tmp.bin
 ifeq (esp32,$(CPU_FAM))
 	$(Q)cp $(RIOTCPU)/$(CPU)/bin/rom_0x3ff90000_0x00010000.bin $(BINDIR)/rom1.bin
diff --git a/makefiles/tools/programmer.inc.mk b/makefiles/tools/programmer.inc.mk
index b3e78613a8..a46a60ff2b 100644
--- a/makefiles/tools/programmer.inc.mk
+++ b/makefiles/tools/programmer.inc.mk
@@ -5,7 +5,7 @@ ifeq (0,$(PROGRAMMER_QUIET))
   PROGRAMMER_VERBOSE_OPT ?= --verbose
 endif
 
-# Don't use the programmer wrapper
+# Don't use the programmer wrapper by default
 USE_PROGRAMMER_WRAPPER_SCRIPT ?= 0
 
 ifeq (1,$(USE_PROGRAMMER_WRAPPER_SCRIPT))
diff --git a/makefiles/utils/ansi.mk b/makefiles/utils/ansi.mk
new file mode 100644
index 0000000000..53fabdb054
--- /dev/null
+++ b/makefiles/utils/ansi.mk
@@ -0,0 +1,11 @@
+# ANSI Terminal codes and other escape sequences.
+# The objective of this definitions is to be able to write special characters
+# without resorting to shell commands like echo.
+
+include $(RIOTMAKE)/utils/ansi_special.mk
+
+ANSI_GREEN  := $(ANSI_ESC)[1;32m
+ANSI_RED    := $(ANSI_ESC)[1;31m
+ANSI_YELLOW := $(ANSI_ESC)[1;33m
+ANSI_PURPLE := $(ANSI_ESC)[1;35m
+ANSI_RESET  := $(ANSI_ESC)[0m
diff --git a/makefiles/utils/ansi_special.mk b/makefiles/utils/ansi_special.mk
new file mode 100644
index 0000000000..a67d5367bb
--- /dev/null
+++ b/makefiles/utils/ansi_special.mk
@@ -0,0 +1,16 @@
+# Make does not recognize escaped characters (e.g. \t, \033, etc).
+# The following variables contain the characters themselves.
+# This file is inherently fragile (i.e. your editor could destroy the tab
+# without you realizing, to be careful when editing this.
+
+# To generate this: $ printf "ANSI_ESC := \033# comment"
+ANSI_ESC := # you may or may not be able to see that character in your editor
+
+# The third parameter to the subst is a tab - be careful not to replace it with
+# spaces!
+TAB := $(subst ,,	)
+
+define NEWLINE
+
+
+endef
diff --git a/makefiles/vars.inc.mk b/makefiles/vars.inc.mk
index 82e7b8e1df..d4cbbfa717 100644
--- a/makefiles/vars.inc.mk
+++ b/makefiles/vars.inc.mk
@@ -109,7 +109,7 @@ export HEXFILE               # The 'intel hex' stripped result of the compilatio
 # PROGRAMMERS_SUPPORTED      # The list of programmers supported by a board
 # PROGRAMMER_QUIET           # Change verbosity of programmer output (only used with flash and reset targets).
                              # Default is 1, not verbose. Use 0 to get normal programmer output.
-# USE_PROGRAMMER_WRAPPER_SCRIPT     # Use the programmer wrapper Python script. Default is 1 (0 if RIOT_CI_BUILD is set).
+# USE_PROGRAMMER_WRAPPER_SCRIPT     # Use the programmer wrapper Python script. Default is 0 (wrapper not used).
 
 
 export DLCACHE               # directory used to cache http downloads
diff --git a/pkg/Kconfig b/pkg/Kconfig
index 52fcc9a86c..04a9f49996 100644
--- a/pkg/Kconfig
+++ b/pkg/Kconfig
@@ -23,6 +23,7 @@ rsource "libcose/Kconfig"
 rsource "libfixmath/Kconfig"
 rsource "libhydrogen/Kconfig"
 rsource "lora-serialization/Kconfig"
+rsource "lvgl/Kconfig"
 rsource "micro-ecc/Kconfig"
 rsource "microcoap/Kconfig"
 rsource "minmea/Kconfig"
@@ -30,7 +31,8 @@ rsource "monocypher/Kconfig"
 rsource "nanocbor/Kconfig"
 rsource "nanopb/Kconfig"
 rsource "qcbor/Kconfig"
-rsource "qDSA/Kconfig"
+rsource "qdsa/Kconfig"
+rsource "qr-code-generator/Kconfig"
 rsource "relic/Kconfig"
 rsource "semtech-loramac/Kconfig"
 rsource "talking_leds/Kconfig"
diff --git a/pkg/doc.txt b/pkg/doc.txt
index db349171e3..9350f74c1a 100644
--- a/pkg/doc.txt
+++ b/pkg/doc.txt
@@ -2,6 +2,13 @@
  * @defgroup pkg   Packages
  * @{
  * @brief          External libraries and applications
+ * @details        What are packages?  RIOT packages:
+ *                 * pull a specific tested version most often from the (a) origin source
+ *                 * patch them to match the RIOT architecture
+ *                 * provide a specific tested configuration
+ *                   (such configuration may enable or disable features)
+ *                 * integrate the packages build process into the RIOT one
+ *                 * they have RIOT tests and/or examples to test/build them
  *
  * Using packages
  * ==============
diff --git a/pkg/edhoc-c/Makefile b/pkg/edhoc-c/Makefile
new file mode 100644
index 0000000000..3a7f4d7985
--- /dev/null
+++ b/pkg/edhoc-c/Makefile
@@ -0,0 +1,19 @@
+PKG_NAME = EDHOC-C
+PKG_URL = https://github.com/future-proof-iot/EDHOC-C.git
+PKG_VERSION = 1847c2c558d3ea97a070f6a9546a5913432ecf96
+PKG_LICENSE = BSD-3-Clause
+
+include $(RIOTBASE)/pkg/pkg.mk
+
+.PHONY: edhoc-c_%
+
+EDHOC_C_MODULES := $(filter edhoc-c_%,$(USEMODULE))
+
+all: $(EDHOC_C_MODULES)
+	"$(MAKE)" -C $(PKG_SOURCE_DIR)/src -f $(RIOTBASE)/Makefile.base MODULE=edhoc-c
+
+edhoc-c_crypto_%:
+	"$(MAKE)" -C $(PKG_SOURCE_DIR)/src/crypto -f $(RIOTBASE)/Makefile.base MODULE=$@ SRC=$*.c
+
+edhoc-c_cbor_%:
+	"$(MAKE)" -C $(PKG_SOURCE_DIR)/src/cbor -f $(RIOTBASE)/Makefile.base MODULE=$@ SRC=$*.c
diff --git a/pkg/edhoc-c/Makefile.dep b/pkg/edhoc-c/Makefile.dep
new file mode 100644
index 0000000000..ac7f4d4614
--- /dev/null
+++ b/pkg/edhoc-c/Makefile.dep
@@ -0,0 +1,22 @@
+ifneq (,$(filter edhoc-c_crypto_wolfssl,$(USEMODULE)))
+  USEPKG += wolfssl
+  USEMODULE += wolfcrypt
+  USEMODULE += wolfcrypt_aes
+  USEMODULE += wolfcrypt_ed25519
+  USEMODULE += wolfcrypt_curve25519
+  USEMODULE += wolfcrypt_hmac
+  USEMODULE += wolfcrypt_random
+  USEMODULE += wolfcrypt_sha256
+endif
+
+ifneq (,$(filter edhoc-c_crypto_tinycrypt,$(USEMODULE)))
+  USEPKG += tinycrypt
+  # Blacklist platforms using nimble, mynewt-nimble has an in-tree copy
+  # of tinycrypt that conflicts with the remote one
+  FEATURES_BLACKLIST += ble_nimble
+  USEPKG += c25519
+endif
+
+ifneq (,$(filter edhoc-c_cbor_nanocbor,$(USEMODULE)))
+  USEPKG += nanocbor
+endif
diff --git a/pkg/edhoc-c/Makefile.include b/pkg/edhoc-c/Makefile.include
new file mode 100644
index 0000000000..ebd90a09f1
--- /dev/null
+++ b/pkg/edhoc-c/Makefile.include
@@ -0,0 +1,23 @@
+INCLUDES += -I$(PKGDIRBASE)/EDHOC-C/include \
+            -I$(PKGDIRBASE)/EDHOC-C/src \
+            -I$(RIOTBASE)/pkg/edhoc-c/include \
+            #
+
+ifneq (,$(filter edhoc-c_crypto_wolfssl,$(USEMODULE)))
+  CFLAGS += -DHAVE_AESCCM
+  CFLAGS += -DHAVE_HKDF
+  CFLAGS += -DWOLFSSL
+endif
+
+ifneq (,$(filter edhoc-c_crypto_tinycrypt,$(USEMODULE)))
+  CFLAGS += -DTINYCRYPT
+endif
+
+ifneq (,$(filter edhoc-c_cbor_nanocbor,$(USEMODULE)))
+  CFLAGS += -DNANOCBOR
+endif
+
+# EDHOC-C configuration file for RIOT
+CFLAGS += -DEDHOC_CONFIG_FILE=\"edhoc_config.h\"
+# X509 backend in EDHOC-C is mbedtls currently not supported in RIOT
+CFLAGS += -DEMPTY_X509
diff --git a/pkg/edhoc-c/doc.txt b/pkg/edhoc-c/doc.txt
new file mode 100644
index 0000000000..e7fc1dc6e0
--- /dev/null
+++ b/pkg/edhoc-c/doc.txt
@@ -0,0 +1,48 @@
+/**
+ * @defgroup pkg_edhoc_c EDHOC-C
+ * @ingroup  pkg
+ * @brief    Support for Ephemeral Diffie-Hellman Over COSE (EDHOC)
+ * @see      https://github.com/openwsn-berkeley/EDHOC-C
+ *
+ * # EDHOC-C RIOT package
+ *
+ * ## Usage
+ *
+ * Just add it as a package in your application:
+ *
+ * ```makefile
+ * USEPKG += edhoc-c
+ * ```
+ *
+ * ### Backends
+ *
+ * EDHOC-C does not implement crypographic algorithms, instead it uses external
+ * libraries as a backend. Libraries that provide all requirements are
+ * currently @ref pkg_tinycrypt and @ref pkg_wolfssl. Pick one through the
+ * following module:
+ *
+ * ```makefile
+ * USEMODULE += edhoc-c_crypto_wolfssl
+ * USEMODULE += edhoc-c_crypto_tinycrypt
+ * ```
+ *
+ * EDHOC-C does not implement a CBOR library either, currently the only possible
+ * backend is @ref pkg_nanocbor. Select it through the following module:
+ *
+ * ```makefile
+ * USEMODULE += edhoc-c_cbor_nanocbor
+ * ```
+ *
+ * Don't forget to include the header for the EDHOC-C public API:
+ *
+ * ```c
+ * #include <edhoc/edhoc.h>
+ * ```
+ *
+ * ### Current Support
+ *
+ * - EDHOC-C supports @ref pkg_hacl as a crypto backend but it's using a different
+ *   version than the one supported currently in RIOT
+ * - x509 certificates require MBED-TLS, which is currently not supported in
+ *   RIOT so only RPK and CBOR certificates are supported.
+ */
diff --git a/pkg/edhoc-c/include/edhoc_config.h b/pkg/edhoc-c/include/edhoc_config.h
new file mode 100644
index 0000000000..7d37be2e9e
--- /dev/null
+++ b/pkg/edhoc-c/include/edhoc_config.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     pkg_edhoc_c
+ * @{
+ *
+ * @file
+ * @brief       EDHOC-C configuration file
+ *
+ * @author      Timothy Claeys <timothy.claeys@inria.fr>
+ *
+ * @}
+ */
+
+#ifndef EDHOC_CONFIG_H
+#define EDHOC_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief EDHOC_CIPHER_SUITE_X_ENABLED
+ *
+ * Enables support for a specific EDHOC cipher suite
+ *
+ */
+#define EDHOC_CIPHER_SUITE_0_ENABLED
+
+/**
+ * @brief EDHOC_AUTH_METHOD_X_ENABLED
+ * @{
+ *
+ * Enables support for a specific EDHOC authentication method
+ *
+ */
+#define EDHOC_AUTH_METHOD_0_ENABLED
+#define EDHOC_AUTH_METHOD_1_ENABLED
+#define EDHOC_AUTH_METHOD_2_ENABLED
+#define EDHOC_AUTH_METHOD_3_ENABLED
+/** @} */
+
+/**
+ * @brief EDHOC_ASYNC_API_ENABLED
+ *
+ * Exposes the individual EDHOC message functions for asynchronous usage.
+ *
+ */
+#define EDHOC_ASYNC_API_ENABLED
+
+/**
+ * @brief EDHOC_DEBUG_ENABLE
+ *
+ * Enables some extra methods that allow for easier testing and debugging
+ *
+ */
+#define EDHOC_DEBUG_ENABLED
+
+/**
+ * @brief EDHOC_AUTH_CERT_ENABLED
+ * @{
+ *
+ * Enables CBOR certificates as the EDHOC local credential
+ *
+ */
+#define EDHOC_AUTH_CERT_ENABLED
+#if defined(EDHOC_AUTH_CERT_ENABLED)
+#define EDHOC_AUTH_CBOR_CERT
+#endif
+/** @} */
+
+/**
+ * @brief EDHOC_AUTH_RPK_ENABLED
+ *
+ * Enables COSE raw public keys as the EDHOC local credential
+ *
+ */
+#define EDHOC_AUTH_RPK_ENABLED
+
+/**
+ * @brief EDHOC_COSE_HEADER_SIZE
+ *
+ * Sets the maximum number of COSE header elements
+ */
+#define EDHOC_COSE_HEADER_SIZE              (5)
+
+/**
+ * @brief EDHOC_CREDENTIAL_MAX_SIZE
+ *
+ * Sets the maximum buffer size for credentials (raw keys or certificates)
+ *
+ */
+#define EDHOC_CRED_SIZE                     (256)
+
+/**
+ * @brief EDHOC_CREDENTIAL_ID_MAX_SIZE
+ *
+ * Sets the maximum buffer size for credential identifiers
+ *
+ */
+#define EDHOC_CRED_ID_SIZE                  (256)
+
+/**
+ * @brief EDHOC_ADD_DATA_MAX_SIZE
+ *
+ * Maximum number of additional data bytes to piggy-back on the EDHOC exchange
+ *
+ */
+#define EDHOC_ADDITIONAL_DATA_SIZE          (64)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EDHOC_CONFIG_H */
diff --git a/pkg/libcose/Makefile b/pkg/libcose/Makefile
index d645544d40..99d1d063e0 100644
--- a/pkg/libcose/Makefile
+++ b/pkg/libcose/Makefile
@@ -1,6 +1,6 @@
 PKG_NAME=libcose
 PKG_URL=https://github.com/bergzand/libcose
-PKG_VERSION=8b5f651c3203682a2d98121cd3e5c844cb2b4c36
+PKG_VERSION=2929fdce7affbd5bb9db201370d95d8f7cf680f9
 PKG_LICENSE=LGPL
 
 include $(RIOTBASE)/pkg/pkg.mk
diff --git a/pkg/libcose/Makefile.dep b/pkg/libcose/Makefile.dep
index 2d5f718216..ffd4e2c6ca 100644
--- a/pkg/libcose/Makefile.dep
+++ b/pkg/libcose/Makefile.dep
@@ -10,3 +10,6 @@ endif
 ifneq (,$(filter libcose_crypt_c25519,$(USEMODULE)))
   USEPKG += c25519
 endif
+ifneq (,$(filter libcose_crypt_tinycrypt,$(USEMODULE)))
+  USEPKG += tinycrypt
+endif
diff --git a/pkg/libcose/Makefile.include b/pkg/libcose/Makefile.include
index 92328dc9b3..7342c0b07a 100644
--- a/pkg/libcose/Makefile.include
+++ b/pkg/libcose/Makefile.include
@@ -7,6 +7,9 @@ endif
 ifneq (,$(filter libcose_crypt_c25519,$(USEMODULE)))
   CFLAGS += -DCRYPTO_C25519
 endif
+ifneq (,$(filter libcose_crypt_tinycrypt,$(USEMODULE)))
+  CFLAGS += -DCRYPTO_TINYCRYPT
+endif
 
 # Declare pseudomodules here to be selfcontained
 PSEUDOMODULES += libcose_crypt_%
diff --git a/pkg/libcose/doc.txt b/pkg/libcose/doc.txt
index a9720cf982..8443bb9326 100644
--- a/pkg/libcose/doc.txt
+++ b/pkg/libcose/doc.txt
@@ -35,11 +35,15 @@
  * USEMODULE += libcose_crypt_hacl
  * USEMODULE += libcose_crypt_monocypher
  * USEMODULE += libcose_crypt_c25519
+ * USEMODULE += libcose_crypt_tinycrypt
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
  * The selection of pseudomodules determines the available algorithms:
  *
  * * @ref pkg_hacl "HACL" and @ref pkg_monocypher "Monocypher" both provide ChaCha20-Poly1305 and Ed25519.
  * * @ref pkg_c25519 "C25519" only provides the Ed25519 algorithm.
+ * * @ref pkg_tinycrypt "TINYCRYPT" provides AES-CCM-16-64-128, AES-CCM-16-128-128
+ *   ECDSA and ES256 as well as EC NIST P-256 curve support.
  *
+ * Some backend may conflict, others might be complementary.
  */
diff --git a/pkg/libcose/patches/0001-RIOT-Use-RIOT-random_bytes-function-instead-of-rando.patch b/pkg/libcose/patches/0001-RIOT-Use-RIOT-random_bytes-function-instead-of-rando.patch
index 66a174ab70..831e6e8af0 100644
Binary files a/pkg/libcose/patches/0001-RIOT-Use-RIOT-random_bytes-function-instead-of-rando.patch and b/pkg/libcose/patches/0001-RIOT-Use-RIOT-random_bytes-function-instead-of-rando.patch differ
diff --git a/pkg/lvgl/Kconfig b/pkg/lvgl/Kconfig
new file mode 100644
index 0000000000..47423ffaa4
--- /dev/null
+++ b/pkg/lvgl/Kconfig
@@ -0,0 +1,90 @@
+# Copyright (c) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+if TEST_KCONFIG
+
+menuconfig PACKAGE_LVGL
+    bool "LVGL package"
+    imply MODULE_AUTO_INIT_SCREEN
+    select MODULE_LVGL
+    select MODULE_LVGL_CORE
+    select MODULE_LVGL_DRAW
+    select MODULE_LVGL_FONT
+    select MODULE_LVGL_HAL
+    select MODULE_LVGL_MISC
+    select MODULE_LVGL_THEMES
+    select MODULE_LVGL_WIDGETS
+
+    # lvgl is not compatible with non 32bit platforms
+    # Building lv_misc triggers the error:
+    # "left shift count >= width of type [-Werror=shift-count-overflow]"
+    depends on !HAS_ARCH_8BIT
+    depends on !HAS_ARCH_16BIT
+
+if PACKAGE_LVGL
+
+config MODULE_LVGL_CONTRIB
+    bool "Contrib"
+    select MODULE_DISP_DEV
+    select MODULE_CORE_THREAD_FLAGS
+    select MODULE_XTIMER
+
+config MODULE_LVGL_CONTRIB_TOUCH
+    bool "Touch support"
+    select MODULE_TOUCH_DEV
+
+endif # PACKAGE_LVGL
+
+config MODULE_LVGL
+    bool
+
+config MODULE_LVGL_CORE
+    bool
+
+config MODULE_LVGL_DRAW
+    bool
+
+config MODULE_LVGL_FONT
+    bool
+
+config MODULE_LVGL_HAL
+    bool
+
+config MODULE_LVGL_MISC
+    bool
+
+config MODULE_LVGL_THEMES
+    bool
+
+config MODULE_LVGL_WIDGETS
+    bool
+
+endif # TEST_KCONFIG
+
+menuconfig KCONFIG_USEPKG_LVGL
+    bool "Configure LVGL"
+    depends on USEPKG_LVGL
+    help
+        Configure LVGL package via Kconfig.
+
+if KCONFIG_USEPKG_LVGL
+
+menu "LVGL RIOT configuration"
+
+    config LVGL_INACTIVITY_PERIOD_MS
+        int "Inactivity period before blocking the LVGL thread (in ms)"
+        default 5000
+
+    config LVGL_TASK_HANDLER_DELAY_US
+        int "Delay between calls to the lvgl task handler (in us)"
+        default 5000
+
+endmenu
+
+osource "$(RIOTBASE)/build/pkg/lvgl/Kconfig"
+
+endif
diff --git a/pkg/lvgl/Makefile b/pkg/lvgl/Makefile
index 31df453d5c..0ab1aed6a3 100644
--- a/pkg/lvgl/Makefile
+++ b/pkg/lvgl/Makefile
@@ -1,6 +1,6 @@
 PKG_NAME=lvgl
 PKG_URL=https://github.com/littlevgl/lvgl
-PKG_VERSION=5035c0c7809d288d5b5d141a22b0bf9bf932cf1b # v7.7.1
+PKG_VERSION=ec9de515b36641be565d7bace5863ab631ce3b69 # v7.11.0
 PKG_LICENSE=MIT
 
 include $(RIOTBASE)/pkg/pkg.mk
diff --git a/pkg/lvgl/Makefile.dep b/pkg/lvgl/Makefile.dep
index 7aa99187c1..f9de871957 100644
--- a/pkg/lvgl/Makefile.dep
+++ b/pkg/lvgl/Makefile.dep
@@ -17,8 +17,6 @@ ifneq (,$(filter lvgl_contrib_touch,$(USEMODULE)))
   USEMODULE += touch_dev
 endif
 
-DEFAULT_MODULE += auto_init_screen
-
 # lvgl is not compatible with non 32bit platforms
 # Building lv_misc triggers the error:
 # "left shift count >= width of type [-Werror=shift-count-overflow]"
diff --git a/pkg/lvgl/Makefile.include b/pkg/lvgl/Makefile.include
index 86d3a5807e..22d027aab3 100644
--- a/pkg/lvgl/Makefile.include
+++ b/pkg/lvgl/Makefile.include
@@ -8,26 +8,8 @@ ifneq (,$(filter lvgl_contrib,$(USEMODULE)))
   DIRS += $(RIOTBASE)/pkg/lvgl/contrib
 endif
 
-# Configuration options
-# Graphical settings
-LVGL_COLOR_DEPTH        ?= 16
-LVGL_COLOR_16_SWAP      ?= 1
-
-# Memory settings
-LVGL_MEM_SIZE           ?= 5U*1024U
-
-# Engine settings
-LVGL_INACTIVITY_PERIOD_MS   ?= 5*MS_PER_SEC   # 5s
-LVGL_TASK_HANDLER_DELAY_US  ?= 5*US_PER_MS    # 5ms
-LVGL_TASK_THREAD_PRIO       ?= THREAD_PRIORITY_MAIN+1
-
-# Set the CFLAGS variable accordingly
-CFLAGS += -DLV_COLOR_DEPTH=$(LVGL_COLOR_DEPTH)
-CFLAGS += -DLV_COLOR_16_SWAP=$(LVGL_COLOR_16_SWAP)
-CFLAGS += -DLV_MEM_SIZE=$(LVGL_MEM_SIZE)
-CFLAGS += -DLVGL_INACTIVITY_PERIOD_MS=$(LVGL_INACTIVITY_PERIOD_MS)
-CFLAGS += -DLVGL_TASK_HANDLER_DELAY_US=$(LVGL_TASK_HANDLER_DELAY_US)
-CFLAGS += -DLVGL_TASK_THREAD_PRIO=$(LVGL_TASK_THREAD_PRIO)
+# Configure the lvgl_riot_conf.h header for lvgl kconfig management
+CFLAGS += -DLV_CONF_KCONFIG_EXTERNAL_INCLUDE=\""lvgl_riot_conf.h"\"
 
 # lvgl module is not a concrete module, so declare it as a pseudomodule
 PSEUDOMODULES += lvgl
diff --git a/pkg/lvgl/contrib/lvgl.c b/pkg/lvgl/contrib/lvgl.c
index 94546e72c0..90e1a2f454 100644
--- a/pkg/lvgl/contrib/lvgl.c
+++ b/pkg/lvgl/contrib/lvgl.c
@@ -26,32 +26,26 @@
 #include "log.h"
 
 #include "lvgl/lvgl.h"
-#include "lv_conf.h"
 #include "lvgl_riot.h"
 
 #include "screen_dev.h"
 
-#ifndef LVGL_TASK_THREAD_PRIO
-#define LVGL_TASK_THREAD_PRIO       (THREAD_PRIORITY_MAIN + 1)
-#endif
-
 #ifndef LVGL_COLOR_BUF_SIZE
 #define LVGL_COLOR_BUF_SIZE         (LV_HOR_RES_MAX * 5)
 #endif
 
-#ifndef LVGL_INACTIVITY_PERIOD_MS
-#define LVGL_INACTIVITY_PERIOD_MS   (1 * MS_PER_SEC)    /* 1s */
+#ifndef CONFIG_LVGL_INACTIVITY_PERIOD_MS
+#define CONFIG_LVGL_INACTIVITY_PERIOD_MS   (5 * MS_PER_SEC)    /* 5s */
 #endif
 
-#ifndef LVGL_TASK_HANDLER_DELAY_US
-#define LVGL_TASK_HANDLER_DELAY_US  (5 * US_PER_MS)     /* 5ms */
+#ifndef CONFIG_LVGL_TASK_HANDLER_DELAY_US
+#define CONFIG_LVGL_TASK_HANDLER_DELAY_US  (5 * US_PER_MS)     /* 5ms */
 #endif
 
 #ifndef LVGL_THREAD_FLAG
 #define LVGL_THREAD_FLAG            (1 << 7)
 #endif
 
-static char _task_thread_stack[THREAD_STACKSIZE_LARGE];
 static kernel_pid_t _task_thread_pid;
 
 static lv_disp_buf_t disp_buf;
@@ -60,30 +54,6 @@ static lv_color_t buf[LVGL_COLOR_BUF_SIZE];
 static screen_dev_t *_screen_dev = NULL;
 
 
-static void *_task_thread(void *arg)
-{
-    (void)arg;
-
-    while (1) {
-        /* Normal operation (no sleep) in < LVGL_INACTIVITY_PERIOD_MS msec
-           inactivity */
-        if (lv_disp_get_inactive_time(NULL) < LVGL_INACTIVITY_PERIOD_MS) {
-            lv_task_handler();
-        }
-        else {
-            /* Block after LVGL_ACTIVITY_PERIOD msec inactivity */
-            thread_flags_wait_one(LVGL_THREAD_FLAG);
-
-            /* trigger an activity so the task handler is called on the next loop */
-            lv_disp_trig_activity(NULL);
-        }
-
-        xtimer_usleep(LVGL_TASK_HANDLER_DELAY_US);
-    }
-
-    return NULL;
-}
-
 static void _disp_map(lv_disp_drv_t *drv, const lv_area_t *area, lv_color_t *color_p)
 {
     if (!_screen_dev->display) {
@@ -155,15 +125,30 @@ void lvgl_init(screen_dev_t *screen_dev)
         lv_indev_drv_register(&indev_drv);
     }
 #endif
-
-    lv_task_handler();
 }
 
-void lvgl_start(void)
+void lvgl_run(void)
 {
-    _task_thread_pid = thread_create(_task_thread_stack, sizeof(_task_thread_stack),
-                                     LVGL_TASK_THREAD_PRIO, THREAD_CREATE_STACKTEST,
-                                     _task_thread, NULL, "_task_thread");
+    _task_thread_pid = thread_getpid();
+
+    lv_task_handler();
+
+    while (1) {
+        /* Normal operation (no sleep) in < CONFIG_LVGL_INACTIVITY_PERIOD_MS msec
+           inactivity */
+        if (lv_disp_get_inactive_time(NULL) < CONFIG_LVGL_INACTIVITY_PERIOD_MS) {
+            lv_task_handler();
+        }
+        else {
+            /* Block after LVGL_ACTIVITY_PERIOD msec inactivity */
+            thread_flags_wait_one(LVGL_THREAD_FLAG);
+
+            /* trigger an activity so the task handler is called on the next loop */
+            lv_disp_trig_activity(NULL);
+        }
+
+        xtimer_usleep(CONFIG_LVGL_TASK_HANDLER_DELAY_US);
+    }
 }
 
 void lvgl_wakeup(void)
diff --git a/pkg/lvgl/doc.txt b/pkg/lvgl/doc.txt
index 1ecfe38607..feaebc7445 100644
--- a/pkg/lvgl/doc.txt
+++ b/pkg/lvgl/doc.txt
@@ -8,26 +8,14 @@
 ## Configuration options
 
 The package can be configured with using several variables. These variables can
-either be passed directly to build command line or set in the application
-Makefile.
-
-### Graphical settings
-
-- `LVGL_COLOR_DEPTH`: configure the color depth in bit of the screen (default: 16)
-- `LVGL_COLOR_16_SWAP`: enable byte swap when communicating with the screen
-  driver (default: 1, enabled)
-
-### Memory settings
-
-`LVGL_MEM_SIZE`: configure the maximum memory size used by lvgl. This depends
-on the number of lvgl widgets and objects used by the interface (default:
-5U*1024U, 5KiB). Must be greater than 2KiB.
+either be configured using CFLAGS or using Kconfig (via `make menuconfig`).
+LVGL_TASK_THREAD_PRIO cannot be configured via Kconfig.
 
 ### Engine settings
 
-- `LVGL_INACTIVITY_PERIOD_MS`: maximum inactivity period before going to sleep in ms.
-  (default: 1s)
-- `LVGL_TASK_HANDLER_DELAY_US`: delay between lvgl task handle call in ms.
+- `CONFIG_LVGL_INACTIVITY_PERIOD_MS`: maximum inactivity period before going to sleep in ms.
+  (default: 5s)
+- `CONFIG_LVGL_TASK_HANDLER_DELAY_US`: delay between lvgl task handle call in us.
   (default: 5ms)
 - `LVGL_TASK_THREAD_PRIO`: lvgl task handler thread priority.
   (default: THREAD_PRIORITY_MAIN - 1)
@@ -35,7 +23,7 @@ on the number of lvgl widgets and objects used by the interface (default:
 Example of command line for changing the max activity period to 5s:
 
 ```
-LVGL_ACTIVITY_PERIOD=5000 make -C tests/pkg_lvgl
+CFLAGS=-DCONFIG_LVGL_ACTIVITY_PERIOD=5000 make -C tests/pkg_lvgl
 ```
 
  */
diff --git a/pkg/lvgl/include/lv_conf.h b/pkg/lvgl/include/lv_conf.h
index 54141430f6..1feedb8482 100644
--- a/pkg/lvgl/include/lv_conf.h
+++ b/pkg/lvgl/include/lv_conf.h
@@ -22,6 +22,7 @@ extern "C" {
 #endif
 
 #include <stdint.h>
+#include "lvgl_riot_conf.h"
 
 /*====================
    Graphical settings
@@ -83,9 +84,6 @@ extern "C" {
 #define LV_DISP_MEDIUM_LIMIT 50
 #define LV_DISP_LARGE_LIMIT  70
 
-/* Type of coordinates. Should be `int16_t` (or `int32_t` for extreme cases) */
-typedef int16_t lv_coord_t;
-
 /*=========================
    Memory manager settings
  *=========================*/
@@ -298,14 +296,6 @@ typedef void * lv_img_decoder_user_data_t;
  *  HAL settings
  *==================*/
 
-/* 1: use a custom tick source.
- * It removes the need to manually update the tick with `lv_tick_inc`) */
-#define LV_TICK_CUSTOM     1
-#if LV_TICK_CUSTOM == 1
-#define LV_TICK_CUSTOM_INCLUDE  "xtimer.h"       /*Header for the sys time function*/
-#define LV_TICK_CUSTOM_SYS_TIME_EXPR (xtimer_now_usec() / US_PER_MS)     /*Expression evaluating to current systime in ms*/
-#endif   /*LV_TICK_CUSTOM*/
-
 typedef void * lv_disp_drv_user_data_t;             /*Type of user data in the display driver*/
 typedef void * lv_indev_drv_user_data_t;            /*Type of user data in the input device driver*/
 
@@ -382,8 +372,8 @@ typedef void * lv_indev_drv_user_data_t;            /*Type of user data in the i
 
 /* Montserrat fonts with bpp = 4
  * https://fonts.google.com/specimen/Montserrat  */
-#define LV_FONT_MONTSERRAT_12    0
-#define LV_FONT_MONTSERRAT_14    1
+#define LV_FONT_MONTSERRAT_12    1
+#define LV_FONT_MONTSERRAT_14    0
 #define LV_FONT_MONTSERRAT_16    0
 #define LV_FONT_MONTSERRAT_18    0
 #define LV_FONT_MONTSERRAT_20    0
@@ -477,10 +467,10 @@ typedef void * lv_font_user_data_t;
 #define LV_THEME_DEFAULT_COLOR_PRIMARY      lv_color_hex(0x01a2b1)
 #define LV_THEME_DEFAULT_COLOR_SECONDARY    lv_color_hex(0x44d1b6)
 #define LV_THEME_DEFAULT_FLAG               LV_THEME_MATERIAL_FLAG_DARK
-#define LV_THEME_DEFAULT_FONT_SMALL         &lv_font_montserrat_14
-#define LV_THEME_DEFAULT_FONT_NORMAL        &lv_font_montserrat_14
-#define LV_THEME_DEFAULT_FONT_SUBTITLE      &lv_font_montserrat_14
-#define LV_THEME_DEFAULT_FONT_TITLE         &lv_font_montserrat_14
+#define LV_THEME_DEFAULT_FONT_SMALL         &lv_font_montserrat_12
+#define LV_THEME_DEFAULT_FONT_NORMAL        &lv_font_montserrat_12
+#define LV_THEME_DEFAULT_FONT_SUBTITLE      &lv_font_montserrat_12
+#define LV_THEME_DEFAULT_FONT_TITLE         &lv_font_montserrat_12
 
 /*=================
  *  Text settings
diff --git a/pkg/lvgl/include/lvgl_riot.h b/pkg/lvgl/include/lvgl_riot.h
index 7c16cb7879..595e3d3982 100644
--- a/pkg/lvgl/include/lvgl_riot.h
+++ b/pkg/lvgl/include/lvgl_riot.h
@@ -33,9 +33,15 @@ extern "C" {
 void lvgl_init(screen_dev_t *screen_dev);
 
 /**
- * Start the lvgl task handler background thread
-*/
-void lvgl_start(void);
+ * @brief   Run the lvgl task handler
+ *
+ * In order to run the lvgl internal task handler in an endless loop, this
+ * function must be called manually either from the main thread or from a
+ * custom thread.
+ * In case of CONFIG_LVGL_INACTIVITY_PERIOD_MS ms of inactivity, the loop stops
+ * the thread running the lvgl task handler until @ref lvgl_wakeup is called.
+ */
+void lvgl_run(void);
 
 /**
  * @brief   Wakeup lvgl when inactive
diff --git a/pkg/lvgl/include/lvgl_riot_conf.h b/pkg/lvgl/include/lvgl_riot_conf.h
new file mode 100644
index 0000000000..5b9b4aefc3
--- /dev/null
+++ b/pkg/lvgl/include/lvgl_riot_conf.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     pkg_lvgl
+ * @{
+ *
+ * @file
+ * @brief       Definitions specific to RIOT for the LittlevGL engine
+ *
+ * @author      Alexandre Abadie <alexandre.abadie@inria.fr>
+ */
+
+#ifndef LVGL_RIOT_CONF_H
+#define LVGL_RIOT_CONF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Type of coordinates. Should be `int16_t` (or `int32_t` for extreme cases) */
+typedef int16_t lv_coord_t;
+
+#define LV_TICK_CUSTOM     1
+#if LV_TICK_CUSTOM == 1
+#define LV_TICK_CUSTOM_INCLUDE  "xtimer.h"       /*Header for the sys time function*/
+#define LV_TICK_CUSTOM_SYS_TIME_EXPR (xtimer_now_usec() / US_PER_MS)     /*Expression evaluating to current systime in ms*/
+#endif   /*LV_TICK_CUSTOM*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LVGL_RIOT_CONF_H */
diff --git a/pkg/nanocbor/Makefile b/pkg/nanocbor/Makefile
index 22224b87a0..d5de73bd75 100644
--- a/pkg/nanocbor/Makefile
+++ b/pkg/nanocbor/Makefile
@@ -1,6 +1,6 @@
 PKG_NAME    = nanocbor
 PKG_URL     = https://github.com/bergzand/nanocbor
-PKG_VERSION = e47950bb6cafd944f4a6ecf49cf9276363b4592e
+PKG_VERSION = 7728af0633a8d9d119c9b36a5c5a441e11e75ff1
 PKG_LICENSE = CC-0
 
 include $(RIOTBASE)/pkg/pkg.mk
diff --git a/pkg/nanocbor/patches/0001-Revert-decoder-Fix-return-codes-in-documentation-and.patch b/pkg/nanocbor/patches/0001-Revert-decoder-Fix-return-codes-in-documentation-and.patch
deleted file mode 100644
index 03db1686c0..0000000000
Binary files a/pkg/nanocbor/patches/0001-Revert-decoder-Fix-return-codes-in-documentation-and.patch and /dev/null differ
diff --git a/pkg/nanopb/Makefile.gensrc b/pkg/nanopb/Makefile.gensrc
index c0803df6c5..1c86af590c 100644
--- a/pkg/nanopb/Makefile.gensrc
+++ b/pkg/nanopb/Makefile.gensrc
@@ -16,7 +16,7 @@ PROTO_INCLUDES += -I.
 PROTO_INCLUDES += -I$(PKGDIRBASE)/nanopb/generator/proto
 PROTO_INCLUDES += -I$(PROTOBUF_PATH)
 
-$(SRC): $(GENSRC)
+$(SRC) $(SRCXX): $(GENSRC)
 
 $(GENSRC): $(PROTOBUF_FILES)
 	$(Q)D=$(BINDIR)/$(MODULE) && \
diff --git a/pkg/nimble/Makefile.dep b/pkg/nimble/Makefile.dep
index 110476872a..7a34d5942a 100644
--- a/pkg/nimble/Makefile.dep
+++ b/pkg/nimble/Makefile.dep
@@ -2,10 +2,6 @@
 USEMODULE += sema
 USEMODULE += event_callback
 USEMODULE += ztimer_msec
-# all nRF CPUs support hardware RTT, so we use it
-ifneq (,$(filter nrf5%,$(CPU_FAM)))
-  USEMODULE += ztimer_periph_rtt
-endif
 
 # Requires nimble feature
 FEATURES_REQUIRED += ble_nimble
@@ -72,6 +68,7 @@ endif
 
 ifneq (,$(filter nimble_netif,$(USEMODULE)))
   FEATURES_REQUIRED += ble_nimble_netif
+  USEMODULE += random
   USEMODULE += l2util
   USEMODULE += bluetil_addr
   ifneq (,$(filter gnrc_ipv6_%,$(USEMODULE)))
diff --git a/pkg/nimble/Makefile.include b/pkg/nimble/Makefile.include
index fa3191052d..b28dad166e 100644
--- a/pkg/nimble/Makefile.include
+++ b/pkg/nimble/Makefile.include
@@ -93,15 +93,27 @@ ifneq (,$(filter nimble_netif,$(USEMODULE)))
 
   # configure NimBLE's internals
   NIMBLE_MAX_CONN ?= 3
-  CFLAGS += -DMYNEWT_VAL_MSYS_1_BLOCK_SIZE=264
   CFLAGS += -DMYNEWT_VAL_BLE_L2CAP_COC_MAX_NUM=$(NIMBLE_MAX_CONN)
   CFLAGS += -DMYNEWT_VAL_BLE_MAX_CONNECTIONS=$(NIMBLE_MAX_CONN)
-  # NimBLEs internal buffer need to hold one IPv6 MTU per connection
-  # for the internal MTU of 256 byte, we need 10 mbufs per connection...
+
+  # the maximum fragment size that we can receive. For maximum efficiency this
+  # should be equal to the maximum configured link layer packet size.
+  # WARNING: this value MUST never be larger than MYNEWT_VAL_BLE_LL_MAX_PKT_SIZE
+  CFLAGS += -DMYNEWT_VAL_BLE_L2CAP_COC_MPS=251
+
+  # in order to fit a 251 byte COC data segment into a single mbuf buffer, the
+  # used block size must be at least 297 byte (251 data + 48 overhead)
+  CFLAGS += -DMYNEWT_VAL_MSYS_1_BLOCK_SIZE="(MYNEWT_VAL_BLE_L2CAP_COC_MPS + 48)"
+
+  # in the worst case, NimBLEs internal buffer needs to hold two full IPv6 MTUs
+  # per connection (1 TX and 1 RX). But in practice this would be highly over-
+  # provisioned. Allocating 10 memory blocks per connection plus another 5
+  # for internal buffering has proven to be a generous default value.
   CFLAGS += -DMYNEWT_VAL_MSYS_1_BLOCK_COUNT=35
 
   # optimize the NimBLE controller for IP traffic
   ifneq (,$(filter nimble_controller,$(USEMODULE)))
+    CFLAGS += -DMYNEWT_VAL_BLE_LL_MAX_PKT_SIZE=251
     CFLAGS += -DMYNEWT_VAL_BLE_LL_CFG_FEAT_DATA_LEN_EXT=1
   endif
 endif
diff --git a/pkg/nimble/autoconn/include/nimble_autoconn.h b/pkg/nimble/autoconn/include/nimble_autoconn.h
index 0730657f2d..d9e23bfb4f 100644
--- a/pkg/nimble/autoconn/include/nimble_autoconn.h
+++ b/pkg/nimble/autoconn/include/nimble_autoconn.h
@@ -145,8 +145,11 @@ typedef struct {
     uint32_t scan_win;
     /** opening a new connection is aborted after this time [in ms] */
     uint32_t conn_timeout;
-    /** connection interval used when opening a new connection [in ms] */
-    uint32_t conn_itvl;
+    /** connection interval used when opening a new connection, lower bound.
+     *  [in ms] */
+    uint32_t conn_itvl_min;
+    /** connection interval, upper bound [in ms] */
+    uint32_t conn_itvl_max;
     /** slave latency used for new connections [in ms] */
     uint16_t conn_latency;
     /** supervision timeout used for new connections [in ms] */
diff --git a/pkg/nimble/autoconn/include/nimble_autoconn_params.h b/pkg/nimble/autoconn/include/nimble_autoconn_params.h
index 9c259fdbf5..67532286f9 100644
--- a/pkg/nimble/autoconn/include/nimble_autoconn_params.h
+++ b/pkg/nimble/autoconn/include/nimble_autoconn_params.h
@@ -51,8 +51,11 @@ extern "C" {
 #ifndef NIMBLE_AUTOCONN_CONN_TIMEOUT_MS
 #define NIMBLE_AUTOCONN_CONN_TIMEOUT_MS     (3 * NIMBLE_AUTOCONN_SCAN_WIN_MS)
 #endif
-#ifndef NIMBLE_AUTOCONN_CONN_ITVL_MS
-#define NIMBLE_AUTOCONN_CONN_ITVL_MS        (75U)           /* 75ms */
+#ifndef NIMBLE_AUTOCONN_CONN_ITVL_MIN_MS
+#define NIMBLE_AUTOCONN_CONN_ITVL_MIN_MS    75U             /* 75ms */
+#endif
+#ifndef NIMBLE_AUTOCONN_CONN_ITVL_MAX_MS
+#define NIMBLE_AUTOCONN_CONN_ITVL_MAX_MS    75U             /* 75ms */
 #endif
 #ifndef NIMBLE_AUTOCONN_CONN_LATENCY
 #define NIMBLE_AUTOCONN_CONN_LATENCY        (0)
@@ -74,7 +77,8 @@ extern "C" {
       .scan_itvl     = NIMBLE_AUTOCONN_SCAN_ITVL_MS,     \
       .scan_win      = NIMBLE_AUTOCONN_SCAN_WIN_MS,      \
       .conn_timeout  = NIMBLE_AUTOCONN_CONN_TIMEOUT_MS,  \
-      .conn_itvl     = NIMBLE_AUTOCONN_CONN_ITVL_MS,     \
+      .conn_itvl_min = NIMBLE_AUTOCONN_CONN_ITVL_MIN_MS, \
+      .conn_itvl_max = NIMBLE_AUTOCONN_CONN_ITVL_MAX_MS, \
       .conn_latency  = NIMBLE_AUTOCONN_CONN_LATENCY,     \
       .conn_super_to = NIMBLE_AUTOCONN_CONN_SVTO_MS,     \
       .node_id       = NIMBLE_AUTOCONN_NODE_ID, }
diff --git a/pkg/nimble/autoconn/nimble_autoconn.c b/pkg/nimble/autoconn/nimble_autoconn.c
index b75469b474..10f85d7b69 100644
--- a/pkg/nimble/autoconn/nimble_autoconn.c
+++ b/pkg/nimble/autoconn/nimble_autoconn.c
@@ -277,8 +277,8 @@ int nimble_autoconn_update(const nimble_autoconn_params_t *params,
     /* populate the connection parameters */
     _conn_params.scan_itvl = BLE_GAP_SCAN_ITVL_MS(params->scan_win);
     _conn_params.scan_window = _conn_params.scan_itvl;
-    _conn_params.itvl_min = BLE_GAP_CONN_ITVL_MS(params->conn_itvl);
-    _conn_params.itvl_max = _conn_params.itvl_min;
+    _conn_params.itvl_min = BLE_GAP_CONN_ITVL_MS(params->conn_itvl_min);
+    _conn_params.itvl_max = BLE_GAP_CONN_ITVL_MS(params->conn_itvl_max);
     _conn_params.latency = 0;
     _conn_params.supervision_timeout = BLE_GAP_SUPERVISION_TIMEOUT_MS(
                                                          params->conn_super_to);
diff --git a/pkg/nimble/netif/include/nimble_netif.h b/pkg/nimble/netif/include/nimble_netif.h
index bb033e500c..fd4b7927fd 100644
--- a/pkg/nimble/netif/include/nimble_netif.h
+++ b/pkg/nimble/netif/include/nimble_netif.h
@@ -102,6 +102,37 @@ extern "C" {
 #define NIMBLE_NETIF_MTU            (1280U)
 #endif
 
+/**
+ * @brief   Set to > 0 to enforce different connection intervals for each of the
+ *          nodes BLE connections
+ *
+ * Enabling this option will enforce that every BLE connection a node maintains,
+ * independent of the nodes role, uses a different connection interval. The
+ * value of NIMBLE_NETIF_CONN_ITVL_SPACING specifies the minimum spacing between
+ * connection intervals as multiple of 1,25ms. E.g. a value of 2 will force each
+ * connection to use a connection interval that is at least 2.5ms different from
+ * all other used connection intervals.
+ *
+ * If a node is the coordinator of a connection, it will generate a connection
+ * interval for each new connection based on a random value by adhering to the
+ * spacing constraint.
+ *
+ * If a node is the subordinate of a new connection, it will check if the given
+ * connection interval is fulfilling the spacing constraint with respect to
+ * already existing connections of that node. If the connection interval of the
+ * new connection is not properly spaced, the node will drop the connection
+ * right away, giving the coordinator node the possibly to reconnect with a
+ * different connection interval.
+ */
+#ifndef NIMBLE_NETIF_CONN_ITVL_SPACING
+#define NIMBLE_NETIF_CONN_ITVL_SPACING          0
+#endif
+
+/**
+ * @brief   Minimum spacing of connection interval when using randomized
+ *          intervals, in multiples of 1.25ms
+ */
+
 /**
  * @brief   Return codes used by the NimBLE netif module
  */
@@ -183,16 +214,18 @@ void nimble_netif_eventcb(nimble_netif_eventcb_t cb);
  *
  * @param[in] addr          address of the advertising BLE slave, in the NimBLE
  *                          addr format (little endian)
- * @param[in] conn_params   connection (timing) parameters
+ * @param[in] conn_params   connection (timing) parameters, set to NULL to use
+ *                          NimBLEs default parameters
  * @param[in] timeout       connect timeout [in ms]
  *
  * @return  the used connection handle on success
  * @return  NIMBLE_NETIF_BUSY if already connected to the given address or if
  *          a connection setup procedure is in progress
  * @return  NIMBLE_NETIF_NOMEM if no connection context memory is available
+ * @return  NIMBLE_NETIF_NOTFOUND if unable to find valid connection interval
  */
 int nimble_netif_connect(const ble_addr_t *addr,
-                         const struct ble_gap_conn_params *conn_params,
+                         struct ble_gap_conn_params *conn_params,
                          uint32_t timeout);
 
 /**
diff --git a/pkg/nimble/netif/include/nimble_netif_conn.h b/pkg/nimble/netif/include/nimble_netif_conn.h
index d1cd7f4432..02ad46d42f 100644
--- a/pkg/nimble/netif/include/nimble_netif_conn.h
+++ b/pkg/nimble/netif/include/nimble_netif_conn.h
@@ -23,6 +23,7 @@
 #define NIMBLE_NETIF_CONN_H
 
 #include <stdint.h>
+#include <stdbool.h>
 
 #include "nimble_netif.h"
 
@@ -41,6 +42,7 @@ extern "C" {
 typedef struct {
     struct ble_l2cap_chan *coc;     /**< l2cap context as exposed by NimBLE */
     uint16_t gaphandle;             /**< GAP handle exposed by NimBLE */
+    uint16_t itvl;                  /**< currently used connection interval */
     uint16_t state;                 /**< the current state of the context */
     uint8_t addr[BLE_ADDR_LEN];     /**< BLE address of connected peer
                                          (in network byte order) */
@@ -175,6 +177,46 @@ int nimble_netif_conn_start_adv(void);
  */
 void nimble_netif_conn_free(int handle, uint8_t *addr);
 
+/**
+ * @brief   Get the used connection interval for the given connection handle
+ *
+ * @param[in] handle        connection handle
+ *
+ * @return  used connection interval in milliseconds on success
+ * @return  0 if unable to get connection interval
+ */
+uint16_t nimble_netif_conn_get_itvl_ms(int handle);
+
+/**
+ * @brief   Check if the given connection interval is used, taking the minimal
+ *          spacing as defined by NIMBLE_NETIF_CONN_ITVL_SPACING into account
+ *
+ * @param[in] itvl          connection interval to check, multiples of 1.25ms
+ * @param[in] skip_handle   do not compare against connection interval for this
+ *                          handle, set to NIMBLE_NETIF_CONN_INVALID to check
+ *                          all
+ *
+ * @return  true if given interval is used
+ * @return  false if given interval is not used
+ */
+bool nimble_netif_conn_itvl_used(uint16_t itvl, int skip_handle);
+
+/**
+ * @brief   Generate a pseudorandom connection interval from the given range
+ *
+ * If the NIMBLE_NETIF_CONN_ITVL_SPACING option is enabled, this function
+ * ensures that the generated connection interval is spaced at least
+ * NIMBLE_NETIF_CONN_ITVL_SPACING from the connection interval of each open
+ * BLE connection.
+ *
+ * @param[in] min           minimum connection interval
+ * @param[in] max           maximum connection interval
+ *
+ * @return  generated connection interval on success, multiples of 1.25ms
+ * @return  0 if no valid connection interval could be generated
+ */
+uint16_t nimble_netif_conn_gen_itvl(uint16_t min, uint16_t max);
+
 /**
  * @brief   Find the connection context with a given GAP handle and return a
  *          pointer to it
diff --git a/pkg/nimble/netif/nimble_netif.c b/pkg/nimble/netif/nimble_netif.c
index e2ad84f251..0a2b70a82a 100644
--- a/pkg/nimble/netif/nimble_netif.c
+++ b/pkg/nimble/netif/nimble_netif.c
@@ -364,20 +364,32 @@ static int _on_l2cap_server_evt(struct ble_l2cap_event *event, void *arg)
             conn = nimble_netif_conn_get(handle);
             assert(conn);
 
+            /* in the unlikely event the L2CAP connection establishment fails,
+             * we close the GAP connection */
             if (event->connect.status != 0) {
-                /* in the unlikely event the L2CAP connection establishment
-                 * fails, we close the GAP connection */
                 ble_gap_terminate(conn->gaphandle, BLE_ERR_REM_USER_CONN_TERM);
                 break;
             }
+
+            /* we need to update the state to keep everything in sync */
             conn->coc = event->connect.chan;
             conn->state |= NIMBLE_NETIF_L2CAP_SERVER;
             conn->state &= ~(NIMBLE_NETIF_ADV | NIMBLE_NETIF_CONNECTING);
+
+            /* in case conn itvl spacing is enabled, make sure that the conn
+             * itvl of the new connection is sufficiently spaced */
+            if ((NIMBLE_NETIF_CONN_ITVL_SPACING > 0) &&
+                nimble_netif_conn_itvl_used(conn->itvl, handle)) {
+                ble_gap_terminate(conn->gaphandle, BLE_ERR_REM_USER_CONN_TERM);
+                break;
+            }
+
             _notify(handle, NIMBLE_NETIF_CONNECTED_SLAVE, conn->addr);
             break;
         case BLE_L2CAP_EVENT_COC_DISCONNECTED:
             conn = nimble_netif_conn_from_gaphandle(event->disconnect.conn_handle);
             assert(conn && (conn->state & NIMBLE_NETIF_L2CAP_SERVER));
+            conn->coc = NULL;
             conn->state &= ~NIMBLE_NETIF_L2CAP_CONNECTED;
             break;
         case BLE_L2CAP_EVENT_COC_ACCEPT: {
@@ -411,9 +423,21 @@ static void _on_gap_connected(nimble_netif_conn_t *conn, uint16_t conn_handle)
     (void)res;
 
     conn->gaphandle = conn_handle;
+    conn->itvl = desc.conn_itvl;
     bluetil_addr_swapped_cp(desc.peer_id_addr.val, conn->addr);
 }
 
+static void _on_gap_param_update(int handle, nimble_netif_conn_t *conn)
+{
+    struct ble_gap_conn_desc desc;
+    int res = ble_gap_conn_find(conn->gaphandle, &desc);
+    assert(res == 0) ;
+    (void)res;
+
+    conn->itvl = desc.conn_itvl;
+    _notify(handle, NIMBLE_NETIF_CONN_UPDATED, conn->addr);
+}
+
 static int _on_gap_master_evt(struct ble_gap_event *event, void *arg)
 {
     int res = 0;
@@ -458,7 +482,7 @@ static int _on_gap_master_evt(struct ble_gap_event *event, void *arg)
             break;
         }
         case BLE_GAP_EVENT_CONN_UPDATE:
-            _notify(handle, NIMBLE_NETIF_CONN_UPDATED, conn->addr);
+            _on_gap_param_update(handle, conn);
             break;
         case BLE_GAP_EVENT_CONN_UPDATE_REQ:
         case BLE_GAP_EVENT_MTU:
@@ -502,7 +526,7 @@ static int _on_gap_slave_evt(struct ble_gap_event *event, void *arg)
             break;
         }
         case BLE_GAP_EVENT_CONN_UPDATE:
-            _notify(handle, NIMBLE_NETIF_CONN_UPDATED, conn->addr);
+            _on_gap_param_update(handle, conn);
             break;
         case BLE_GAP_EVENT_CONN_UPDATE_REQ:
             /* nothing to do here */
@@ -537,12 +561,15 @@ void nimble_netif_eventcb(nimble_netif_eventcb_t cb)
 }
 
 int nimble_netif_connect(const ble_addr_t *addr,
-                         const struct ble_gap_conn_params *conn_params,
+                         struct ble_gap_conn_params *conn_params,
                          uint32_t timeout)
 {
     assert(addr);
     assert(_eventcb);
 
+    uint16_t itvl_min = 0;
+    uint16_t itvl_max = 0;
+
     /* the netif_conn module expects addresses in network byte order */
     uint8_t addrn[BLE_ADDR_LEN];
     bluetil_addr_swapped_cp(addr->val, addrn);
@@ -559,11 +586,31 @@ int nimble_netif_connect(const ble_addr_t *addr,
         return NIMBLE_NETIF_NOMEM;
     }
 
+    if ((conn_params != NULL)
+        && (conn_params->itvl_min != conn_params->itvl_max)) {
+        /* we need to save the min/max intervals in order to restore them
+         * later on */
+        itvl_min = conn_params->itvl_min;
+        itvl_max = conn_params->itvl_max;
+
+        uint16_t itvl = nimble_netif_conn_gen_itvl(itvl_min, itvl_max);
+        if (itvl == 0) {
+            return NIMBLE_NETIF_NOTFOUND;
+        }
+        conn_params->itvl_min = itvl;
+        conn_params->itvl_max = itvl;
+    }
+
     int res = ble_gap_connect(nimble_riot_own_addr_type, addr, timeout,
                               conn_params, _on_gap_master_evt, (void *)handle);
     assert(res == 0);
     (void)res;
 
+    if (itvl_min != itvl_max) {
+        conn_params->itvl_min = itvl_min;
+        conn_params->itvl_max = itvl_max;
+    }
+
     _notify(handle, NIMBLE_NETIF_INIT_MASTER, addrn);
 
     return handle;
diff --git a/pkg/nimble/netif/nimble_netif_conn.c b/pkg/nimble/netif/nimble_netif_conn.c
index 8f907dab6a..25f27acb61 100644
--- a/pkg/nimble/netif/nimble_netif_conn.c
+++ b/pkg/nimble/netif/nimble_netif_conn.c
@@ -21,6 +21,7 @@
 #include <assert.h>
 
 #include "nimble_netif_conn.h"
+#include "random.h"
 
 #define ENABLE_DEBUG            0
 #include "debug.h"
@@ -220,3 +221,55 @@ unsigned nimble_netif_conn_count(uint16_t filter)
 
     return cnt;
 }
+
+uint16_t nimble_netif_conn_get_itvl_ms(int handle)
+{
+    if ((handle == 0) || (handle >= CONN_CNT)) {
+        return 0;
+    }
+
+    return ((_conn[handle].itvl * BLE_HCI_CONN_ITVL) / 1000);
+}
+
+bool nimble_netif_conn_itvl_used(uint16_t itvl, int skip_handle)
+{
+    for (int handle = 0; handle < CONN_CNT; handle++) {
+        if ((handle != skip_handle) && (_conn[handle].itvl != 0)) {
+            uint16_t diff = (_conn[handle].itvl < itvl)
+                                                    ? itvl - _conn[handle].itvl
+                                                    : _conn[handle].itvl - itvl;
+            if (diff < NIMBLE_NETIF_CONN_ITVL_SPACING) {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+uint16_t nimble_netif_conn_gen_itvl(uint16_t min, uint16_t max)
+{
+    assert(min <= max);
+
+    uint16_t start = random_uint32_range(min, max);
+
+    if (NIMBLE_NETIF_CONN_ITVL_SPACING == 0) {
+        return start;
+    }
+
+    for (uint16_t itvl = start;
+         itvl <= max;
+         itvl += NIMBLE_NETIF_CONN_ITVL_SPACING) {
+        if (!nimble_netif_conn_itvl_used(itvl, NIMBLE_NETIF_CONN_INVALID)) {
+            return itvl;
+        }
+    }
+    for (uint16_t itvl = start - NIMBLE_NETIF_CONN_ITVL_SPACING;
+         itvl >= min;
+         itvl -= NIMBLE_NETIF_CONN_ITVL_SPACING) {
+        if (!nimble_netif_conn_itvl_used(itvl, NIMBLE_NETIF_CONN_INVALID)) {
+            return itvl;
+        }
+    }
+    return 0;
+}
diff --git a/pkg/nimble/statconn/nimble_statconn.c b/pkg/nimble/statconn/nimble_statconn.c
index ebbcdbbfa3..e57fe0f6b9 100644
--- a/pkg/nimble/statconn/nimble_statconn.c
+++ b/pkg/nimble/statconn/nimble_statconn.c
@@ -27,14 +27,10 @@
 
 #include "host/ble_hs.h"
 
-#if NIMBLE_STATCONN_CONN_ITVL_MIN_MS != NIMBLE_STATCONN_CONN_ITVL_MAX_MS
-#include "random.h"
-
 /* sanity check on the conn interval range to catch configuration errors */
 #if NIMBLE_STATCONN_CONN_ITVL_MIN_MS > NIMBLE_STATCONN_CONN_ITVL_MAX_MS
 #error "nimble_statconn: CONN_ITVL_MIN_MS must be <= CONN_ITVL_MAX_MS"
 #endif
-#endif
 
 #define ENABLE_DEBUG    0
 #include "debug.h"
@@ -91,16 +87,6 @@ static void _activate(uint8_t role)
         ble_addr_t peer;
         peer.type = BLE_ADDR_RANDOM;
         bluetil_addr_swapped_cp(slot->addr, peer.val);
-        /* compute a random new random connection interval if configured */
-#if NIMBLE_STATCONN_CONN_ITVL_MIN_MS != NIMBLE_STATCONN_CONN_ITVL_MAX_MS
-        uint32_t itvl = random_uint32_range(NIMBLE_STATCONN_CONN_ITVL_MIN_MS,
-                                            NIMBLE_STATCONN_CONN_ITVL_MAX_MS);
-        _conn_params.itvl_min = BLE_GAP_CONN_ITVL_MS(itvl);
-#else
-        _conn_params.itvl_min = BLE_GAP_CONN_ITVL_MS(
-                                            NIMBLE_STATCONN_CONN_ITVL_MIN_MS);
-#endif
-        _conn_params.itvl_max = _conn_params.itvl_min;
         /* try to (re)open the connection */
         nimble_netif_connect(&peer, &_conn_params, _conn_timeout);
     }
@@ -208,6 +194,10 @@ void nimble_statconn_init(void)
     _conn_params.latency = NIMBLE_STATCONN_CONN_LATENCY;
     _conn_params.supervision_timeout = BLE_GAP_SUPERVISION_TIMEOUT_MS(
                                                NIMBLE_STATCONN_CONN_SUPERTO_MS);
+    _conn_params.itvl_min = BLE_GAP_CONN_ITVL_MS(
+                                            NIMBLE_STATCONN_CONN_ITVL_MIN_MS);
+    _conn_params.itvl_max = BLE_GAP_CONN_ITVL_MS(
+                                            NIMBLE_STATCONN_CONN_ITVL_MAX_MS);
     _conn_params.min_ce_len = 0;
     _conn_params.max_ce_len = 0;
     _conn_timeout = NIMBLE_STATCONN_CONN_TIMEOUT_MS;
diff --git a/pkg/openthread/include/ot.h b/pkg/openthread/include/ot.h
index c554599766..1fe08deff8 100644
--- a/pkg/openthread/include/ot.h
+++ b/pkg/openthread/include/ot.h
@@ -13,6 +13,35 @@
  * @see         https://github.com/openthread/openthread
  *
  * Thread is a mesh oriented network stack running for IEEE802.15.4 networks.
+ *
+ * The RIOT port allows to directly call OpenThread API functions using
+ * @ref sys_event. For example:
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ {.c}
+ * #include "ot.h"
+ * #include "openthread/thread.h"
+ *
+ * static void _panid_handler(event_t *event);
+ * static event_t event_panid = {
+ *     .handler = _panid_handler
+ * };
+ *
+ * static void _panid_handler(event_t *event)
+ * {
+ *     (void) event;
+ *     uint16_t panid = otLinkGetPanId(openthread_get_instance());
+ *     do_something_with_panid(panid);
+ * }
+ *
+ * int main(void)
+ * {
+ *     event_post(openthread_get_evq(), &event_panid);
+ *     return 0;
+ * }
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * @see https://openthread.io/releases/thread-reference-20180619
+ *
  * @{
  *
  * @file
@@ -73,6 +102,10 @@ typedef struct {
 
 /**
  * @brief   Struct containing an OpenThread job
+ *
+ * @deprecated   This structure is not needed anymore since it's possible to
+ *               run OpenThread code via @ref sys_event (see @ref openthread_get_evq).
+ *               Therefore it will be removed after the 2022.01 release.
  */
 typedef struct {
     event_t ev;                             /**< Event associated to the OpenThread job */
@@ -142,13 +175,6 @@ void openthread_radio_init(netdev_t *dev, uint8_t *tb, uint8_t *rb);
  */
 int openthread_netdev_init(char *stack, int stacksize, char priority, const char *name, netdev_t *netdev);
 
-/**
- * @brief   get PID of OpenThread thread.
- *
- * @return  PID of OpenThread thread
- */
-kernel_pid_t openthread_get_pid(void);
-
 /**
  * @brief   Init OpenThread random
  */
@@ -157,6 +183,10 @@ void ot_random_init(void);
 /**
  * @brief   Execute OpenThread command. Call this function only in OpenThread thread
  *
+ * @deprecated   This function is not needed anymore since it's possible to
+ *               run OpenThread code via @ref sys_event (see @ref openthread_get_evq).
+ *               Therefore it will be removed after the 2022.01 release.
+ *
  * @param[in]   ot_instance     OpenThread instance
  * @param[in]   command         OpenThread command name
  * @param[in]   arg             arg for the command
@@ -172,6 +202,10 @@ uint8_t ot_exec_command(otInstance *ot_instance, const char* command, void *arg,
  * @note    An OpenThread command allows direct calls to OpenThread API (otXXX functions) without worrying about concurrency
  * issues. All API calls should be made in OT_JOB type functions.
  *
+ * @deprecated   This function is not needed anymore since it's possible to
+ *               run OpenThread code via @ref sys_event (see @ref openthread_get_evq).
+ *               Therefore it will be removed after the 2022.01 release.
+ *
  * @param[in]   command         name of the command to call
  * @param[in]   arg             arg for the command
  * @param[out]  answer          answer for the command
diff --git a/pkg/openwsn/Makefile.dep b/pkg/openwsn/Makefile.dep
index 12f55e540e..d52055b452 100644
--- a/pkg/openwsn/Makefile.dep
+++ b/pkg/openwsn/Makefile.dep
@@ -44,7 +44,6 @@ ifneq (,$(filter openwsn_coap,$(USEMODULE)))
 endif
 
 ifneq (,$(filter openwsn_crypto,$(USEMODULE)))
-  USEMODULE += crypto_3des
   USEMODULE += cipher_modes
 endif
 
@@ -75,10 +74,6 @@ endif
 ifneq (,$(filter openwsn_sctimer_ztimer,$(USEMODULE)))
   USEMODULE += ztimer_usec
   USEMODULE += ztimer_msec
-  FEATURES_OPTIONAL += periph_rtt
-  ifneq (,$(filter periph_rtt,$(FEATURES_USED)))
-    USEMODULE += ztimer_periph_rtt
-  endif
 endif
 
 ifneq (,$(filter openwsn_sctimer_rtt,$(USEMODULE)))
diff --git a/pkg/openwsn/Makefile.include b/pkg/openwsn/Makefile.include
index 5b70c175cd..1ed97f0cc9 100644
--- a/pkg/openwsn/Makefile.include
+++ b/pkg/openwsn/Makefile.include
@@ -72,12 +72,9 @@ ifneq (,$(filter at86rf2xx,$(USEMODULE)))
   CFLAGS += -DAT86RF2XX_BASIC_MODE
 endif
 
-# We want the highest possible frequency set for periph_rtt, but not all
-# platforms can configure this value. use highest possible RTT_FREQUENCY
-# for platforms that allow it
-ifneq (,$(filter stm32 nrf52 sam%,$(CPU)))
-  RTT_FREQUENCY ?= RTT_MAX_FREQUENCY
-  CFLAGS += -DRTT_FREQUENCY=$(RTT_FREQUENCY)
+# Auto ACK should be disabled in order to run OpenWSN
+ifndef CONFIG_KCONFIG_USEMODULE_IEEE802154
+  CFLAGS += -DCONFIG_IEEE802154_AUTO_ACK_DISABLE
 endif
 
 # LLVM ARM shows issues with missing definitions for stdatomic
diff --git a/pkg/openwsn/contrib/cryptoengine.c b/pkg/openwsn/contrib/cryptoengine.c
index 1ef8ffc6bf..996f6a2e21 100644
--- a/pkg/openwsn/contrib/cryptoengine.c
+++ b/pkg/openwsn/contrib/cryptoengine.c
@@ -38,7 +38,7 @@ owerror_t cryptoengine_aes_ccms_enc(uint8_t *a, uint8_t len_a, uint8_t *m,
     int ret, len;
     uint8_t tmp_buff[MAX_MESSAGE_LEN + CCM_MAC_MAX_LEN];
 
-    ret = cipher_init(&cipher, CIPHER_AES_128, key, CCM_BLOCK_SIZE);
+    ret = cipher_init(&cipher, CIPHER_AES, key, CCM_BLOCK_SIZE);
 
     if (ret != 1) {
         return E_FAIL;
@@ -64,7 +64,7 @@ owerror_t cryptoengine_aes_ccms_dec(uint8_t *a, uint8_t len_a, uint8_t *m,
     int ret, len;
     uint8_t tmp_buff[MAX_MESSAGE_LEN];
 
-    ret = cipher_init(&cipher, CIPHER_AES_128, key, CCM_BLOCK_SIZE);
+    ret = cipher_init(&cipher, CIPHER_AES, key, CCM_BLOCK_SIZE);
 
     if (ret != 1) {
         return E_FAIL;
@@ -88,7 +88,7 @@ owerror_t cryptoengine_aes_ecb_enc(uint8_t *buffer, uint8_t *key)
     cipher_t cipher;
     int ret, len;
 
-    ret = cipher_init(&cipher, CIPHER_AES_128, key, CCM_BLOCK_SIZE);
+    ret = cipher_init(&cipher, CIPHER_AES, key, CCM_BLOCK_SIZE);
 
     if (ret != 1) {
         return E_FAIL;
diff --git a/pkg/openwsn/contrib/radio_hal.c b/pkg/openwsn/contrib/radio_hal.c
index ae35306740..b69aeddc38 100644
--- a/pkg/openwsn/contrib/radio_hal.c
+++ b/pkg/openwsn/contrib/radio_hal.c
@@ -71,9 +71,12 @@ void _idmanager_addr_override(void)
 
     /* Set all IEEE addresses */
     uint16_t panid = OPENWSN_PANID;
-    ieee802154_radio_set_hw_addr_filter(openwsn_radio.dev, &short_addr,
-                                        &eui64, &panid);
-
+    ieee802154_radio_config_addr_filter(openwsn_radio.dev, IEEE802154_AF_SHORT_ADDR,
+                                        &short_addr);
+    ieee802154_radio_config_addr_filter(openwsn_radio.dev, IEEE802154_AF_EXT_ADDR,
+                                        &eui64);
+    ieee802154_radio_config_addr_filter(openwsn_radio.dev, IEEE802154_AF_PANID,
+                                        &panid);
 }
 
 static void _hal_radio_cb(ieee802154_dev_t *dev, ieee802154_trx_ev_t status)
@@ -137,8 +140,8 @@ int openwsn_radio_init(void *radio_dev)
     /* If the radio is still not in TRX_OFF state, spin */
     while (ieee802154_radio_confirm_on(dev) == -EAGAIN) {}
 
-    /* Enable basic mode, no AUTOACK. no CSMA */
-    ieee802154_radio_set_rx_mode(dev, IEEE802154_RX_AACK_DISABLED);
+    /* Enable basic mode (no AUTOACK. no CSMA-CA).
+     * Auto ACK is disabled via CONFIG_IEEE802154_AUTO_ACK_DISABLE. */
     /* MAC layer retransmissions are disabled by _set_csma_params() */
     ieee802154_radio_set_csma_params(dev, NULL, -1);
 
@@ -147,7 +150,7 @@ int openwsn_radio_init(void *radio_dev)
         where the destination-address mode is 0 (no destination address).
         per rfc8180 4.5.1 the destination address must be set, which means
         the destination-address mode can't be 0 */
-        ieee802154_radio_set_rx_mode(dev, IEEE802154_RX_PROMISC);
+        ieee802154_radio_set_frame_filter_mode(dev, IEEE802154_FILTER_PROMISC);
     }
 
     /* Configure PHY settings (channel, TX power) */
diff --git a/pkg/pkg.mk b/pkg/pkg.mk
index da306c76ce..66ddf8bddc 100644
--- a/pkg/pkg.mk
+++ b/pkg/pkg.mk
@@ -113,7 +113,10 @@ $(PKG_PATCHED): $(PKG_PATCHED_PREREQUISITES)
 
 $(PKG_DOWNLOADED): $(MAKEFILE_LIST) | $(PKG_SOURCE_DIR)/.git
 	$(info [INFO] updating $(PKG_NAME) $(PKG_DOWNLOADED))
-	$(Q)$(GIT_IN_PKG) fetch $(GIT_QUIET) $(PKG_URL) $(PKG_VERSION)
+	$(Q)if ! $(GIT_IN_PKG) cat-file -e $(PKG_VERSION); then \
+		printf "[INFO] fetching new $(PKG_NAME) version "$(PKG_VERSION)"\n"; \
+		$(GIT_IN_PKG) fetch $(GIT_QUIET) "$(PKG_URL)" "$(PKG_VERSION)"; \
+	fi
 	echo $(PKG_VERSION) > $@
 
 $(PKG_SOURCE_DIR)/.git: | $(PKG_CUSTOM_PREPARED)
diff --git a/pkg/qDSA/Makefile b/pkg/qDSA/Makefile
deleted file mode 100644
index 94485f34e2..0000000000
--- a/pkg/qDSA/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-PKG_NAME=qDSA
-PKG_URL=https://github.com/RIOT-OS/qDSA.git
-PKG_VERSION=dd2392b0c81ce4187fd3e1e2d3e0a4767f75782e
-PKG_LICENSE=PD
-
-include $(RIOTBASE)/pkg/pkg.mk
-
-all:
-	$(QQ)"$(MAKE)" -C $(PKG_SOURCE_DIR)/$(QDSA_IMPL)
diff --git a/pkg/qDSA/Kconfig b/pkg/qdsa/Kconfig
similarity index 100%
rename from pkg/qDSA/Kconfig
rename to pkg/qdsa/Kconfig
diff --git a/pkg/qdsa/Makefile b/pkg/qdsa/Makefile
new file mode 100644
index 0000000000..6c4035c4ca
--- /dev/null
+++ b/pkg/qdsa/Makefile
@@ -0,0 +1,9 @@
+PKG_NAME=qdsa
+PKG_URL=https://github.com/RIOT-OS/qdsa.git
+PKG_VERSION=4cb3f1a140f25e18ed288fd484defe3d45bdf166
+PKG_LICENSE=PD
+
+include $(RIOTBASE)/pkg/pkg.mk
+
+all:
+	$(QQ)"$(MAKE)" -C $(PKG_SOURCE_DIR)/$(QDSA_IMPL)
diff --git a/pkg/qDSA/Makefile.dep b/pkg/qdsa/Makefile.dep
similarity index 78%
rename from pkg/qDSA/Makefile.dep
rename to pkg/qdsa/Makefile.dep
index 2cedd9b6cc..dbf3943b42 100644
--- a/pkg/qDSA/Makefile.dep
+++ b/pkg/qdsa/Makefile.dep
@@ -1,9 +1,9 @@
 ifneq (,$(filter cortex-m23 cortex-m0%,$(CPU_CORE)))
-  USEMODULE += qDSA_asm
+  USEMODULE += qdsa_asm
 endif
 
 ifneq (,$(filter arch_avr8,$(FEATURES_USED)))
-  USEMODULE += qDSA_asm
+  USEMODULE += qdsa_asm
 endif
 
 # qDsa is not 16 bit compatible
diff --git a/pkg/qDSA/Makefile.include b/pkg/qdsa/Makefile.include
similarity index 89%
rename from pkg/qDSA/Makefile.include
rename to pkg/qdsa/Makefile.include
index 1c113f8d3b..245e84adc3 100644
--- a/pkg/qDSA/Makefile.include
+++ b/pkg/qdsa/Makefile.include
@@ -10,7 +10,7 @@ endif
 
 export QDSA_IMPL
 
-INCLUDES += -I$(PKGDIRBASE)/qDSA/$(QDSA_IMPL)
+INCLUDES += -I$(PKGDIRBASE)/qdsa/$(QDSA_IMPL)
 
 ifeq (cortex-m0plus,$(CPU_CORE))
   # There are problems with the LLVM assembler and the Cortex-M0+ instruction
diff --git a/pkg/qDSA/doc.txt b/pkg/qdsa/doc.txt
similarity index 89%
rename from pkg/qDSA/doc.txt
rename to pkg/qdsa/doc.txt
index 80aa3e63d6..9d99cc8d42 100644
--- a/pkg/qDSA/doc.txt
+++ b/pkg/qdsa/doc.txt
@@ -1,5 +1,5 @@
 /**
- * @defgroup pkg_qDSA   qDSA
+ * @defgroup pkg_qdsa   qdsa
  * @ingroup  pkg
  * @ingroup  sys
  * @brief    Small and Secure Digital Signatures with Curve-based Diffie-Hellman Key Pairs
diff --git a/pkg/qr-code-generator/Kconfig b/pkg/qr-code-generator/Kconfig
new file mode 100644
index 0000000000..d0b3f13503
--- /dev/null
+++ b/pkg/qr-code-generator/Kconfig
@@ -0,0 +1,9 @@
+# Copyright (c) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+config PACKAGE_QR-CODE-GENERATOR
+    bool "QR Code generator"
+    depends on TEST_KCONFIG
diff --git a/pkg/qr-code-generator/Makefile b/pkg/qr-code-generator/Makefile
new file mode 100644
index 0000000000..4b98f0c475
--- /dev/null
+++ b/pkg/qr-code-generator/Makefile
@@ -0,0 +1,11 @@
+PKG_NAME=qr-code-generator
+PKG_URL=https://github.com/nayuki/QR-Code-generator
+PKG_VERSION=71c75cfeb0f06788ebc43a39b704c39fcf5eba7c  # v1.6.0
+PKG_LICENSE=MIT
+
+include $(RIOTBASE)/pkg/pkg.mk
+
+CFLAGS += -Wno-type-limits
+
+all:
+	$(QQ)"$(MAKE)" -C $(PKG_SOURCE_DIR)/c -f $(CURDIR)/$(PKG_NAME).mk
diff --git a/pkg/qr-code-generator/Makefile.include b/pkg/qr-code-generator/Makefile.include
new file mode 100644
index 0000000000..ab90976c68
--- /dev/null
+++ b/pkg/qr-code-generator/Makefile.include
@@ -0,0 +1 @@
+INCLUDES += -I$(PKGDIRBASE)/qr-code-generator/c
diff --git a/pkg/qr-code-generator/doc.txt b/pkg/qr-code-generator/doc.txt
new file mode 100644
index 0000000000..0365fb36e9
--- /dev/null
+++ b/pkg/qr-code-generator/doc.txt
@@ -0,0 +1,11 @@
+/**
+ * @defgroup pkg_qr-code-generator   QR Code generator
+ * @ingroup  pkg
+ * @brief    QR Code generator library
+ *
+ * # License
+ *
+ * Licensed under MIT.
+ *
+ * @see      https://github.com/nayuki/QR-Code-generator
+ */
diff --git a/pkg/qr-code-generator/qr-code-generator.mk b/pkg/qr-code-generator/qr-code-generator.mk
new file mode 100644
index 0000000000..6b0a0c8af5
--- /dev/null
+++ b/pkg/qr-code-generator/qr-code-generator.mk
@@ -0,0 +1,5 @@
+MODULE = qr-code-generator
+
+SRC := qrcodegen.c
+
+include $(RIOTBASE)/Makefile.base
diff --git a/pkg/semtech-loramac/Makefile.dep b/pkg/semtech-loramac/Makefile.dep
index 16eb716643..7bc149afcf 100644
--- a/pkg/semtech-loramac/Makefile.dep
+++ b/pkg/semtech-loramac/Makefile.dep
@@ -1,6 +1,6 @@
 USEMODULE += random
 USEMODULE += hashes
-USEMODULE += crypto_aes
+USEMODULE += crypto_aes_128
 
 USEMODULE += semtech_loramac_contrib
 USEMODULE += semtech_loramac_mac
@@ -9,7 +9,6 @@ USEMODULE += semtech_loramac_crypto
 USEMODULE += semtech_loramac_arch
 
 USEMODULE += ztimer_msec
-USEMODULE += ztimer_periph_rtt
 
 # The build fails on MSP430 because the toolchain doesn't provide
 # EXIT_SUCCESS/EXIT_FAILURE macros
diff --git a/pkg/tinycrypt/Makefile b/pkg/tinycrypt/Makefile
index 4889b1e382..a85b1d2e40 100644
--- a/pkg/tinycrypt/Makefile
+++ b/pkg/tinycrypt/Makefile
@@ -5,5 +5,5 @@ PKG_LICENSE=BSD-3-Clause
 
 include $(RIOTBASE)/pkg/pkg.mk
 
-all:
-	$(QQ)"$(MAKE)" -C $(PKG_SOURCE_DIR)/lib/source/ -f $(RIOTBASE)/Makefile.base MODULE=$(PKG_NAME)
+all: Makefile.tinycrypt
+	$(QQ)"$(MAKE)" -C $(PKG_SOURCE_DIR)/lib/source/ -f $(CURDIR)/Makefile.tinycrypt -f $(RIOTBASE)/Makefile.base MODULE=$(PKG_NAME)
diff --git a/pkg/tinycrypt/Makefile.tinycrypt b/pkg/tinycrypt/Makefile.tinycrypt
new file mode 100644
index 0000000000..ded7429150
--- /dev/null
+++ b/pkg/tinycrypt/Makefile.tinycrypt
@@ -0,0 +1 @@
+SRC = $(filter-out ecc_platform_specific.c,$(wildcard *.c))
diff --git a/pkg/tinycrypt/patches/0001-Add-a-HKDF-implementation.patch b/pkg/tinycrypt/patches/0001-Add-a-HKDF-implementation.patch
new file mode 100644
index 0000000000..0f20a6f3e3
Binary files /dev/null and b/pkg/tinycrypt/patches/0001-Add-a-HKDF-implementation.patch differ
diff --git a/pkg/wakaama/contrib/lwm2m_client.c b/pkg/wakaama/contrib/lwm2m_client.c
index 372f24b879..f0863e10e7 100644
--- a/pkg/wakaama/contrib/lwm2m_client.c
+++ b/pkg/wakaama/contrib/lwm2m_client.c
@@ -169,8 +169,11 @@ static void *_lwm2m_client_run(void *arg)
                 break;
         }
 
-        DEBUG("Waiting for UDP packet on port: %d\n", _client_data->sock.local.port);
-        rcv_len = sock_udp_recv(&_client_data->sock, &rcv_buf, sizeof(rcv_buf),
+        sock_udp_ep_t local;
+        int res = sock_udp_get_local(&_client_data->sock, &local);
+        assert(res >= 0);
+        DEBUG("Waiting for UDP packet on port: %d\n", local.port);
+        rcv_len = sock_udp_recv(&_client_data->sock, rcv_buf, sizeof(rcv_buf),
                                 tv * US_PER_SEC, &remote);
         DEBUG("sock_udp_recv()\n");
         if (rcv_len > 0) {
diff --git a/pkg/wakaama/contrib/lwm2m_client_connection.c b/pkg/wakaama/contrib/lwm2m_client_connection.c
index 12bc8395a2..8ce27d67a8 100644
--- a/pkg/wakaama/contrib/lwm2m_client_connection.c
+++ b/pkg/wakaama/contrib/lwm2m_client_connection.c
@@ -124,14 +124,6 @@ static void _parse_host_and_port(char **host, char **port, char *default_port);
  */
 static netif_t *_get_interface(char *host);
 
-/**
- * @brief Sets a given interface to a given UDP endpoint
- *
- * @param[out] ep           UDP endpoint
- * @param[in]  netif        Network interface to assign
- */
-static void _set_interface(sock_udp_ep_t *ep, const netif_t *netif);
-
 void *lwm2m_connect_server(uint16_t sec_obj_inst_id, void *user_data)
 {
     lwm2m_client_data_t *client_data = (lwm2m_client_data_t *)user_data;
@@ -313,20 +305,6 @@ static void _parse_host_and_port(char **host, char **port, char *default_port)
     *port = _port;
 }
 
-static void _set_interface(sock_udp_ep_t *ep, const netif_t *netif)
-{
-    if (netif == NULL || ep == NULL) {
-        return;
-    }
-
-    /* currently there is no way to assign a network interface to a sock
-     * endpoint by means of a generic API, so we need to check */
-    if (IS_USED(MODULE_GNRC_NETIF)) {
-        const gnrc_netif_t *gnrc_netif = (gnrc_netif_t *)netif;
-        ep->netif = (uint16_t)gnrc_netif->pid;
-    }
-}
-
 static netif_t *_get_interface(char *host)
 {
     netif_t *netif = NULL;
@@ -411,7 +389,11 @@ static lwm2m_client_connection_t *_connection_create(int instance_id,
             goto free_out;
         }
         else {
-            _set_interface(&conn->remote, netif);
+            int16_t netif_id = netif_get_id(netif);
+            if (netif_id < 0) {
+                goto free_out;
+            }
+            conn->remote.netif = netif_id;
         }
     }
 
diff --git a/release-notes.txt b/release-notes.txt
index 8bbe764d62..67e01de885 100644
--- a/release-notes.txt
+++ b/release-notes.txt
@@ -1,3 +1,566 @@
+RIOT-2021.07 - Release Notes
+============================
+RIOT is a multi-threading operating system which enables soft real-time
+capabilities and comes with support for a range of devices that are typically
+found in the Internet of Things: 8-bit and 16-bit microcontrollers as well as
+light-weight 32-bit processors.
+
+RIOT is based on the following design principles: energy-efficiency, soft
+real-time capabilities, small memory footprint, modularity, and uniform API
+access, independent of the underlying hardware (with partial POSIX compliance).
+
+RIOT is developed by an international open-source community which is
+independent of specific vendors (e.g. similarly to the Linux community) and is
+licensed with a non-viral copyleft license (LGPLv2.1), which allows indirect
+business models around the free open-source software platform provided by RIOT.
+
+
+About this release
+==================
+
+The 2021.07 release includes:
+
+- Many improvements to ztimer usage
+- Added nucleo-wl55jc and Seeeduino XIAO boards
+- stm32f1 kconfig support
+- Fixed multiplication overflow in calloc, a.k.a. BadAlloc, for all supported
+  platforms
+
+
+169 pull requests, composed of 339 commits, have been merged since the
+last release, and 16 issues have been solved. 37 people contributed with
+code in 69 days. 685 files have been touched with 23625 (+) insertions and
+7000 deletions (-).
+
+
+Notations used below
+====================
+
+    + means new feature/item
+    * means modified feature/item
+    - means removed feature/item
+
+
+New features and changes
+========================
+
+
+System Libraries (21)
+---------------------
+
++ congure_mock: add capability to provide actual methods (#16133)
++ dhcpv6_client: add DNS recursive name server option handling (#16585)
++ drivers/ethos: enable multiple instances (#16544)
++ drivers/slipdev: report NETOPT_ADDRESS to simulate l2 address (#16531)
++ gnrc_lorawan: add support for RTT (ztimer) (#14558)
++ sys/byteorder: add little endian to/from buf functions (#16363)
++ sys/crypto: Enable support for AES-192, AES-256 (#16183)
++ sys/event/timeout: add option to use ztimer as backend (#16505)
++ sys/event: add periodic timeout event (#16507)
++ sys/ps: enable runtime_usec output for the ps command (#16470)
+* gnrc_dhcpv6_client_6lbr: choose downstream if as !upstream (#16530)
+* net/emcute: Allow RETAIN flag to be set on incoming PUBLISHs (#16326)
+* net/gnrc/rpl: use ztimer_msec if available (#16339)
+* net/grnc/sixlowpan/ctx: use ztimer_msec if available (#16340)
+* sys/arduino: replace xtimer by ztimer as high-level background timer (#15317)
+* sys/auto_init: move sock_dtls after network stack initialization (#16528)
+* sys/Makefile.dep: Some cleanup (#16268)
+* sys/net/gnrc/netif: Make aac_mode a flag field (#16596)
+* sys/trickle: migrate from xtimer to ZTIMER_MSEC (#16322)
+* sys/ztimer: use highest frequency for nrf51 as well (#16572)
+* ztimer: pull ztimer_periph_rtt for ZTIMER_MSEC if available (#16553)
+* sys/shell/sc_gnrc_rpl: Err out early if RPL not even started (#16358)
+
+Networking (4)
+--------------
+
++ drivers/nrf24l01p_ng: add hook nrf24l01p_ng_eui_get() (#16296)
+* pkg/nimble/netif: allow to apply and enforce random and unique
+  connection intervals (#16372)
+* pkg/semtech-loramac: don't force ztimer rtt backend (#16566)
+
+Packages (8)
+------------
+
++ pkg/nanopb: add dependency for C++ source files (#16504)
++ pkg/edhoc-c: initial commit (#16295)
++ pkg: add QR Code generator package (#16462)
+* pkg/libcose: Update to latest master (#16464)
+* pkg/lvgl: remove internal thread (#16486)
+* pkg/nanocbor: bump version (#16362)
+* pkg/pkg.mk: avoid git fetch if commit is already there (#16514)
+* pkg/wakaama: remove gnrc dependency (#16563)
+
+Boards (10)
+-----------
+
++ board/feather-nrf52840: add uf2 boot loader (#16276)
++ boards/atmega: add USEC_ADJUST values (#16554)
++ boards/esp32-wrover-kit: add dependency to ILI9341 (#16488)
++ boards/nucleo-wl55jc: Initial support (#16255)
++ boards/z1: add CONFIG_ZTIMER_USEC_ADJUST_% values (#16555)
++ boards: Adding board support for the Seeeduino XIAO (#16469)
+* board/nrf52840dongle: fix and enhance pin mapping for I2C and SPI (#16401)
+* Configuration extension for arduino-nano-33-iot (#16301)
+* cpu/kinetis: use LPTMR as rtt backend (#16546)
+* makefiles/stdio.inc.mk: stdio_uart require uart or lpuart (#16331)
+
+CPU (12)
+--------
+
++ cpu/atxmega/periph: Add spi driver (#16290)
++ cpu/efm32: add RTT_FREQUENCY support to efm32 (#16344)
++ cpu/esp*: add CLOCK_CORECLOCK (#16361)
++ cpu/lpc23xx: implement periph/flashpage (#16409)
++ SAML21 CPU: support 4MHz, 8MHz, 12MHz CORE_CORECLOCK choices (#16433)
+* CPU SAML21: fix timers frequency when using slow clocks (#16446)
+* cpu/avr8_common: fix errno (#16565)
+* cpu/native: make thread stacksize defines overridable (#16457)
+* cpu/sam0_common: UART: Revert "implement inverted RX & TX" (#15205)
+* cpu/stm32/periph/rtt_all: RTT peripheral support for CPU_FAM_STM32L5 (#16545)
+* cpu/stm32: Generate the irqs in a reproducible manner (#16511)
+* ieee802154/hal: adapt frame filter and source address matching
+  changes (#15468)
+
+Device Drivers (13)
+-------------------
+
++ cpu/atxmega/periph: Add i2c driver (#16306)
++ cpu/esp_common: Support disabling I2C clock stretching in ESP8266 (#16386)
++ cpu: add periph_rtt_overflow feature (#16420)
++ drivers/at86rf215: add RX timestamps (#16365)
++ drivers/periph: flashpage: add common helper functions (#15908)
++ drivers/rtt_rtc: implement rtc_get_time_ms() (#16347)
++ drivers/si70xx: Add support for Si705x sensors (#15684)
++ drivers/{disp_dev,touch_dev}: add auto_init_screen as default module
+  when used (#16485)
++ esp8266: Support UART1 and other UART0 pins. (#16387)
+* cpu/sam0_common: only include RTC/RTT symbols if module is used (#16421)
+* driver/bmx280: remove unused xtimer dependency (#16400)
+* drivers/cc2420: register with netdev (#15012)
+* drivers/ccs811: fix default config for ccs811_full (#16454)
+
+Documentation (5)
+-----------------
+
++ doc: README: Add documentation on downloads and release cycle (#16345)
+* doc/pkg: provide a longer short description (#16352)
+* docs: Remove references to Freenode from the documentation (#16571)
+* Documentation: Remove mentions of the users@ and devel@ mailing
+  lists. (#16428)
+* README: Update url of documentation (#16436)
+
+Build System / Tooling (11)
+---------------------------
+
++ make: introduce QUIETER (#16513)
++ riotctrl_ctrl: A reset helper class for `native` (#15978)
++ TAKEOVER: makefiles/color: Add color functions, new attempt (#16434)
++ tools/dhcpv6-pd_ia: add Linux Mint to installer (#16410)
++ tools/iotlab-testbed: add support for remote debugger (#16510)
+* esptool: Allow to pass the partition table CSV (#16307)
+* makefiles/boot/riotboot.mk: pass IOTLAB_NODE (#16562)
+* makefiles/boot/riotboot: clean bootloader when cleaning application (#16197)
+* makefiles/info-global.inc.mk: fix DEFAULT_MODULE inclusion (#16435)
+* makefiles/vars.inc.mk: update USE_PROGRAMMER_WRAPPER_SCRIPT comment (#16404)
+* tools/iotlab-tested: several improvements in single board support (#16501)
+
+Kconfig (3)
+-----------
+
++ cpu/stm32f1: Add Kconfig dependency modeling (#16483)
++ Kconfig: expose IEEE 802.15.4 Security to Kconfig (#16515)
+* pkg/lvgl: bump to latest version + model configuration in Kconfig (#16346)
+
+Examples (2)
+------------
+
++ examples/lorawan: add missing sx126x descriptor (#16592)
+* examples/gnrc_networking: use ztimer_msec if available (#16343)
+
+Testing (15)
+------------
+
++ .github: add automatic PR labeler action (#16476)
++ gh-actions: release-tests: add filter input (#16432)
++ tests/pkg_qr-code-generator: add disp-dev for esp32-wrover-kit (#16492)
++ tests/riotboot/flashwrite: add automatic test (#15559)
+* gh-actions/release-tests: export QUIETER to docker (#16581)
+* Simplify kconfig murdock testing (#16487)
+* tests/congure-turo: reset before opening terminal (#16564)
+* tests/disp_dev: improve genericity of application + optimize screen
+  refresh (#16479)
+* tests/gnrc_dhcpv6_client_6lbr: Update test for DHCPv6 MUD option (#16593)
+* tests/malloc: refactor test (#16427)
+* tests/periph_rtt_min: adapt for slower RTTs (#16329)
+* tests/pkg_qr-code-generator: improve display speed in test
+  application (#16466)
+* tests/pkg_tensorflow-lite/Makefile.ci: explicit list (#16354)
+* tests/touch_dev: improve genericity by using auto_init_screen module (#16480)
+* tests/ztimer_periodic: iterate over clocks (#16254)
+
+API Changes (3)
+---------------
+
+* build system: Rework EXTERNAL_MODULE_DIRS (#16104)
+* ieee802154: migrate `netdev_ieee802154_dst_filter` to a common
+  ieee802154 (#16576)
+* net/gcoap: change return type from gcoap_req_send() to ssize_t (#16526)
+
+And 22 minor changes.
+
+Deprecations
+============
+
+Deprecations (3)
+----------------
+
+* gnrc_lorawan: encode LoRaWAN port in netif header (#16080)
+* tools/testbed: use IOTLAB_NODE=auto instead of auto-ssh (#16491)
+* pkg/openthread: deprecate ot_command related functions (#15664)
+
+Removals (1)
+------------
+
+- core/lifo: Remove lifo [after 2021.04] (#16098)
+
+Bug fixes (34)
+==============
+
+* .github/labeler: quote rules (#16519)
+* core/msg.c: fixed msg_queue_print() (#15168)
+* cpu/atmega_common: RTC: fix off-by-one second normalization &
+  simplify rtc_get_time() (#16442)
+* cpu/esp8266: Fix typo in esp_gdbstub config. (#16304)
+* cpu/sam0/i2c: Handle read with I2C_NOSTOP flag (#16605)
+* cpu/sam0_common: ethernet: fix RX detection (#16383)
+* cpu/stm32/gpio_all: fix IRQ handler for G0/L5/MP1 families (#16319)
+* cpu/stm32/gpio_f1: fix IRQ handler (#16478)
+* cpu/stm32/periph/spi: fix wrong parameter order (#16418)
+* dist/Kconfiglib: fix autoconf header (#16561)
+* doc: fix URLs to the new website (#16445)
+* drivers/lis2dh12: clean up API (#16328)
+* drivers/sx126x: fix netdev send and recv function (#16570)
+* Fix Cortex-M hard faults when building with -O3 or -Ofast (#16414)
+* gnrc_ipv6_nib: consider all local interfaces when looking for address (#16569)
+* gnrc_ipv6_nib: consider all prefixes when deciding on-link next hop (#16532)
+* gnrc_ipv6_nib: get node from proper interface (#16548)
+* gnrc_lorawan: fix undefined state when PSDU is NULL (#16586)
+* gnrc_netif/lorawan: drop netif header on send (#16584)
+* gnrc_sock: imply end-point netif only if unset (#16643)
+* NanoCBOR: Bump version (#16580)
+* net/ieee802154_security: small bugfix and stricter names (#16106)
+* pkg/nanocbor: bump version (#16538)
+* pkg/nimble/netif: fix and optimize NimBLE buffer sizes (#16503)
+* pkg/nimble/netif: fix randomized conn intervals (#16601)
+* pkg/nimble: temporary fix to NimBLE PRNG seed issue (#16338)
+* pkg/qdsa: force qdsa to lowercase (#16552)
+* release-test: fetch host key for lille site (#16575)
+* shell/sc_nimble_netif: fix _connect_name scan dur (#16337)
+* sys/malloc_thread_safety: fix potential overflow in multiplication (#16443)
+* sys/net/gnrc/netif: make gnrc_netif_create() blocking to avoid race
+  condition (#16527)
+* sys/ztimer: convert clock do not require pm (#16573)
+* tests/msg_queue_print: fix test on hw (#16525)
+* tests: small fixes (#16426)
+
+
+Known issues
+============
+
+Network related issues (51)
+---------------------------
+
+* 6lo gnrc fragmentation expects driver to block on TX (#7474)
+* 6lo: RIOT does not receive packets from Linux when short_addr is set (#11033)
+* Address registration handling inappropriate (#15867)
+* app/netdev: application stops working after receiving frames with
+  assertion or completely without error (#8271)
+* at86rf2xx: Dead lock when sending while receiving (#8242)
+* at86rf2xx: lost interrupts (#5486)
+* border_router: significant packet loss when sending out packets using
+  USB cdc-ecm on nrf52 (#16411)
+* CC2538 RF overlapping PIN usage (#8779)
+* core: "Invalid read of size 4" (#7199)
+* cpu/esp8266: Tracking open problems of esp_wifi netdev driver (#10861)
+* dist/tools/sliptty/start_network.sh: IPv6 connectivity is broken on
+  PC (#14689)
+* driver/mrf24j40: blocks shell input with auto_init_gnrc_netif (#12943)
+* drivers/at86rf215: Incorrect channel number set for subGHz (#15906)
+* DTLS examples cannot send message to localhost (#14315)
+* Emcute cannot create a double-byte name (#12642)
+* ethernet: Missing multicast addr assignment (#13493)
+* ethos: fails to respond to first message. (#11988)
+* ethos: Unable to choose global source address. (#13745)
+* ethos: Unable to handle fragmented IPv6 packets from Linux kernel (#12264)
+* examples/cord_ep: Dead lock when (re-)registering in callback
+  function (#12884)
+* examples/gnrc_border_router: esp_wifi crashes on disconnect (#14679)
+* Forwarding a packet back to its link layer source should not be
+  allowed (#5051)
+* gcoap example request on tap I/F fails with NIB issue (#8199)
+* gcoap: Suspected crosstalk between requests (possible NULL call) (#14390)
+* General 802.15.4/CC2538 RF driver dislikes fast ACKs (#7304)
+* gnrc ipv6: multicast packets are not dispatched to the upper layers (#5230)
+* gnrc_border_router stops routing after a while (#16398)
+* gnrc_icmpv6_echo: flood-pinging another node leads to leaks in own
+  packet buffer (#12565)
+* gnrc_ipv6: Multicast is not forwarded if routing node listens to the
+  address (#4527)
+* gnrc_rpl: missing bounds checks in _parse_options (#16085)
+* gnrc_sock_udp: Possible Race condition on copy in application buffer (#10389)
+* gomach: Resetting netif with cli doesn't return (#10370)
+* LoRaWan node ISR stack overflowed (#14962)
+* lwip_sock_tcp / sock_async: received events before calling
+  sock_accept() are lost due to race condition. (#16303)
+* Missing drop implementations in netdev_driver_t::recv (#10410)
+* net: netdev_driver_t::send() doc unclear (#10969)
+* netdev_ieee802154: Mismatch between radio ll address and in memory
+  address (#10380)
+* nrf52: Not able to add global or ULA address to interface (#13280)
+* nrfmin: communication not possible after multicast ping with no
+  interval (#11405)
+* openthread: does not build on current Arch (#10809)
+* ping6 is failing when testing with cc2538dk (#13997)
+* pkg/tinydtls: auxiliary data API does not work for async sockets (#16054)
+* pkg: libcoap is partially broken and outdated (#7737)
+* Possible memory leak in RIOT/build/pkg/ndn-riot/app.c (#15638)
+* Riot-os freezes with lwip + enc28j60 + stm32L4 (#13088)
+* samr30 xpro doesn't seem to use its radio ok (#12761)
+* scan-build errors found during 2019.07 testing (#11852)
+* send data with UDP at 10HZ, the program die (#11860)
+* stale border router does not get replaced (#12210)
+* Unclear how Router Solicitations are (or should be) handled (#15926)
+* xbee: setting PAN ID sometimes fails (#10338)
+
+Timer related issues (15)
+-------------------------
+
+* cpu/native: timer interrupt issue (#6442)
+* misc issues with tests/trickle (#9052)
+* MSP430: periph_timer clock config wrong (#8251)
+* periph/timer: `timer_set()` underflow safety check (tracking issue) (#13072)
+* periph_timer: systematic proportional error in timer_set (#10545)
+* saml21 system time vs rtc (#10523)
+* Sleep mode for Arduino (#13321)
+* stm32_common/periph/rtc: current implementation broken/poor accuracy (#8746)
+* sys/newlib: gettimeofday() returns time since boot, not current wall
+  time. (#9187)
+* tests: xtimer_drift gets stuck on native (#6052)
+* xtimer mis-scaling with long sleep times (#9049)
+* xtimer: add's items to the wrong list if the timer overflows between
+  _xtimer_now()  and irq_disable() (#7114)
+* xtimer_set_msg: crash when using same message for 2 timers (#10510)
+* xtimer_usleep stuck for small values (#7347)
+* xtimer_usleep wrong delay time (#10073)
+
+Drivers related issues (19)
+---------------------------
+
+* (almost solved) SPI SD-Card driver: SPI initialisation freeze until
+  timeout (#14439)
+* adc is not a ADC-Driver but a analog pin abstraction (#14424)
+* at86rf2xx: Simultaneous use of different transceiver types is not
+  supported (#4876)
+* cpu/msp430: GPIO driver doesn't work properly (#9419)
+* driver/hts221: Temperature and Humidity readings incorrect (#12445)
+* ESP32 + DHT + SAUL reading two endpoints causes freeze. (#12057)
+* examples/dtls-wolfssl not working on pba-d-01-kw2x (#13527)
+* fail to send data to can bus (#12371)
+* floats and doubles being used all over the place. (#12045)
+* mdt_erase success, but vfs_format resets board (esp32-heltec-
+  lora32-v2) (#14506)
+* periph/spi: Switching between CPOL=0,1 problems on Kinetis with
+  software CS (#6567)
+* periph: GPIO drivers are not thread safe (#4866)
+* Potential security and safety race conditions on attached devices (#13444)
+* PWM: Single-phase initialization creates flicker (#15121)
+* sam0_eth: extremely long time to RX (frames stuck in buffer?) (#16451)
+* STM32: SPI clock not returning to idle state and generating
+  additional clock cycles (#11104)
+* TCP client  cannot  send read only data (#16541)
+* Two bugs may lead to NULL dereference. (#15006)
+* w5100 driver's improvement (#16417)
+
+Native related issues (6)
+-------------------------
+
+* examples/ccn-lite: floating point exception while testing on native (#15878)
+* examples/micropython: floating point exception while testing on
+  native (#15870)
+* native not float safe (#495)
+* native: tlsf: early malloc will lead to a crash (#5796)
+* SDL2 does not work due to missing getpid (#13501)
+* SIGFPE on native architecture when printing double floats on Ubuntu
+  21.04 (#16282)
+
+Other platforms related issues (24)
+-----------------------------------
+
+* Failing tests on FE310 (Hifive1b) (#13086)
+* arm7: printf() with float/double not working (#11885)
+* boards/hifive1: flashing issue (#13104)
+* Cannot use LLVM with Cortex-M boards (#13390)
+* cpu/cortexm_common: irq_enable returns the current state of
+  interrupts (not previous) (#10076)
+* cpu/sam0: flashpage write / read cycle produces different results
+  depending on code layout in flash (#14929)
+* cpu/stm32f1: CPU hangs after wake-up from STOP power mode (#13918)
+* esp32-wroom-32: tests/netstats_l2 failing sometimes (#14237)
+* esp32: can't use newer C++ standard than c++11 (#15685)
+* esp8266 precompiled bootloaders don't support partitions past 1MB (#16402)
+* esp8266: Hangs when erasing spi sector on mtd0 if using esp_wifi (#16281)
+* gcoap/esp8266: Stack overflow with gcoap example (#13606)
+* I found stm32 DMA periph driver bugs!  when I tested stm32l431rc
+  board. (#16242)
+* Incorrect default $PORT building for esp32-wroom-32 on macOS (#10258)
+* MIPS: toolchain objcopy doesn't work and no .bin can be generated (#14410)
+* MPU doesn't work on cortex-m0+ (#14822)
+* periph_timer: Test coverage & broken on STM32F767ZI (#15072)
+* riscv: ISR stack is too small for ENABLE_DEBUG in core files (#16395)
+* stm32152re: hardfault when DBGMCU_CR_DBG* bits are set and branch
+  after __WFI() (#14015)
+* stm32f7: Large performance difference between stm32f746 and stm32f767 (#14728)
+* sys/riotboot/flashwrite: unaligned write when skipping
+  `RIOTBOOT_MAGIC` on stm32wb (#15917)
+* tests/mpu_noexec_ram: fails on  i-nucleo-lrwan1 (#14572)
+* XFA support on AVR and MSP430 broken with binutils 2.36.1 (#16251)
+
+Build system related issues (15)
+--------------------------------
+
+* `buildtest` uses wrong build directory (#9742)
+* `make -j flash` fails due to missing make dependencies or `make
+  flash-only` rebuilds the .elf (#16385)
+* Build dependencies - processing order issues (#9913)
+* build: info-build doesn't work with boards without port set (#15185)
+* BUILD_IN_DOCKER ignores USEMODULE (#14504)
+* Different build behavior between `murdock` and
+  `riot/riotbuild:latest` image (#9645)
+* dist/tools/cppcheck/cppchck.sh: errors when running with Cppcheck
+  1.89 (#12771)
+* doxygen: riot.css modified by 'make doc' (#8122)
+* LTO broken (binaries too large) (#16202)
+* macros: RIOT_FILE_RELATIVE printing wrong file name for headers (#4053)
+* make: ccache leads to differing binaries (#14264)
+* make: Setting constants on compile time doesn't really set them
+  everywhere (#3256)
+* make: use of immediate value of variables before they have their
+  final value (#8913)
+* Tracking: remove harmful use of `export` in make and immediate
+  evaluation (#10850)
+* Windows AVR Mega development makefile Error (#6120)
+
+Other issues (41)
+-----------------
+
+* [TRACKING] sys/shell refactoring. (#12105)
+* _NVIC_SystemReset stuck in infinite loop when calling pm_reboot
+  through shell after flashing with J-Link (#13044)
+* `make term` no longer works with JLinkExe v6.94 (#16022)
+* `make term` output is inconsistent between boards, `ethos` and
+  `native` (#12108)
+* assert: c99 static_assert macro doesn't function for multiple
+  static_asserts in the same scope (#9371)
+* Basic test for periph/rtt introduced in #15431 is incorrect (#15940)
+* boards/esp32-wroom-32: tests/mtd_raw flakey (#16130)
+* Bug: openocd 0.10.0-6  Ubuntu dies while debugging with -rtos auto (#13285)
+* C++11 extensions in header files (#5561)
+* Can't build relic with benchmarks or tests (#12897)
+* CC2538DK board docs: broken links (#12889)
+* edbg: long lines flooded over serial become garbled (#14548)
+* examples / tests: LoRa tests fail on platforms that don't support
+  LoRa (#14520)
+* File systems report names with leading slashes (#14635)
+* flashing issue on frdm-k64f (#15903)
+* Gcoap drops long packages instead of gracefully erring out (#14167)
+* I2C not working under RIOT with U8G2 pkg (#16381)
+* Making the newlib thread-safe (#4488)
+* nanocoap: incomplete response to /.well-known/core request (#10731)
+* Order of auto_init functions (#13541)
+* pkg/tinydtls: Multiple issues (#16108)
+* Possible memset optimized out in crypto code (#10751)
+* Potential race condition in compile_and_test_for_board.py (#12621)
+* pyterm on stdio_cdc_acm stops working after a few seconds (#16077)
+* RIOT cannot compile with the latest version of macOS (10.14) and
+  Xcode 10 (#10121)
+* RIOT is saw-toothing in energy consumption (even when idling) (#5009)
+* riotboot/nrf52840dk: flashing slot1 with JLINK fails (#14576)
+* scheduler: priority inversion problem (#7365)
+* sys/fmt: Missing tests for fmt_float, fmt_lpad (#7220)
+* sys/riotboot: documentation issues (#11243)
+* sys/stdio_uart: dropped data when received at once (#10639)
+* tests/cpp11_*: failing on i-nucleo-lrwan1 (#14578)
+* tests/lwip target board for python test is hardcoded to native (#6533)
+* tests/pkg_libhydrogen: test fails on master for the samr21-xpro with
+  LLVM (#15066)
+* tests/pkg_tensorflow-lite: tests randomly failing on nrf52dk and
+  esp32-wroom-32 (#13133)
+* tests/test_tools: test fails while testing on samr21-xpro/iotlab-m3 (#15888)
+* tests: broken with stdio_rtt if auto_init is disabled (#13120)
+* tests: some tests don't work with `newlib` lock functions. (#12732)
+* Tracker: Reduce scope on unintended COMMON variables (#2346)
+* usb-serial/list-ttys.sh: Broken when a debugger offers multiple
+  serial ports (#15814)
+* Use of multiple CAN bus on compatible boards (#14801)
+
+There are 171 known issues in this release
+
+Fixed Issues since the last release (2021.04)
+=============================================
+
+- All but first ping to downstream interface fails (#16547)
+- pkg/lvgl: LoadProhibitedCause exception on BOARD=esp32-wrover-kit (#16471)
+- SX127x Join procedure failed (The Things Network) (#16419)
+- riotctrl: shell interaction seems timing sensitive (#16415)
+- at86rf231 initialization loses race against auto_init_gnrc_rpl (#16359)
+- cpu/sam0_common: Ethernet driver stops working after a while (#16298)
+- Conflict between nimble and uwb-core packages (#15528)
+- pkg/ccn-lite: unable to `make -j -C examples/ccn-lite-relay` (#14288)
+- make -j flash broken on esp* (will always flash the previous binary) (#13492)
+- sys/xtimer: segmentation fault: in function
+  xtimer_msg_received_timeout (#13345)
+- drivers/srf04: incorrect values on ATmega based platforms (#13079)
+- Indeterministic hard fault in _mutex_lock(), with nRF52 SoftDevice (#10122)
+- mrf24j40: does not link for examples/default (#8752)
+- nRF52: gnrc_6lowpan_ble: memory leak with nordic_softdevice_ble (#6018)
+- OSX +  SAMR21-xpro: shell cannot handle command inputs larger than 64
+  chars (#5863)
+
+16 fixed issues since last release (2021.04)
+
+
+Acknowledgements
+================
+We would like to thank all companies that provided us with hardware for porting
+and testing RIOT-OS. Further thanks go to companies and institutions that
+directly sponsored development time. And finally, big thanks to all of you
+contributing in so many different ways to make RIOT worthwhile!
+
+
+More information
+================
+http://www.riot-os.org
+
+
+Matrix and Forum
+================
+* Join the RIOT Matrix room at: #riot-os:matrix.org
+* Join the RIOT Forum at: forum.riot-os.org
+
+*Note: [IRC was removed](https://forum.riot-os.org/t/riot-irc-and-even-more-freenode-turmoil/3262)*
+
+
+License
+=======
+* The code developed by the RIOT community is licensed under the GNU Lesser
+  General Public License (LGPL) version 2.1 as published by the Free Software
+  Foundation.
+* Some external sources and packages are published under a separate license.
+
+All code files contain licensing information.
+
+
 RIOT-2021.04 - Release Notes
 ============================
 RIOT is a multi-threading operating system which enables soft real-time
diff --git a/sys/Kconfig b/sys/Kconfig
index 3c768062d6..94626af3b9 100644
--- a/sys/Kconfig
+++ b/sys/Kconfig
@@ -58,6 +58,18 @@ rsource "usb/Kconfig"
 rsource "xtimer/Kconfig"
 rsource "ztimer/Kconfig"
 
+config MODULE_CPP
+    bool "Use CPP compiler"
+    depends on TEST_KCONFIG
+    depends on HAS_CPP
+
+config MODULE_LIBSTDCPP
+    bool "Use the CPP standard library"
+    depends on TEST_KCONFIG
+    depends on HAS_LIBSTDCPP
+    depends on HAS_CPP
+    select MODULE_CPP
+
 config MODULE_SYS
     bool
     default y
diff --git a/sys/Makefile.dep b/sys/Makefile.dep
index fc7ca0f3ab..a3e96ab080 100644
--- a/sys/Makefile.dep
+++ b/sys/Makefile.dep
@@ -6,16 +6,21 @@ ifneq (,$(filter arduino,$(USEMODULE)))
   FEATURES_REQUIRED += cpp
   FEATURES_REQUIRED += periph_gpio
   FEATURES_REQUIRED += periph_uart
-  SKETCH_MODULE ?= arduino_sketches
-  USEMODULE += $(SKETCH_MODULE)
+  USEMODULE += arduino_sketches
   USEMODULE += fmt
-  USEMODULE += xtimer
+  USEMODULE += ztimer_usec
+  USEMODULE += ztimer_msec
 endif
 
 ifneq (,$(filter arduino_pwm,$(FEATURES_USED)))
   FEATURES_REQUIRED += periph_pwm
 endif
 
+# cannot be moved to GNRC's Makefile.dep, as module name neither starts or ends with gnrc
+ifneq (,$(filter auto_init_gnrc_netif,$(USEMODULE)))
+  USEMODULE += gnrc_netif_init_devs
+endif
+
 ifneq (,$(filter congure_%,$(USEMODULE)))
   USEMODULE += congure
 endif
@@ -37,17 +42,21 @@ ifneq (,$(filter i2c_scan,$(USEMODULE)))
 endif
 
 ifneq (,$(filter prng_fortuna,$(USEMODULE)))
-  USEMODULE += crypto_aes
+  USEMODULE += crypto_aes_128
 endif
 
-ifneq (,$(filter crypto_aes_%,$(USEMODULE)))
-  USEMODULE += crypto_aes
+ifneq (,$(filter crypto_%,$(USEMODULE)))
+  USEMODULE += crypto
 endif
 
-ifneq (,$(filter crypto_%,$(USEMODULE)))
+ifneq (,$(filter cipher_modes,$(USEMODULE)))
   USEMODULE += crypto
 endif
 
+ifneq (,$(filter crypto,$(USEMODULE)))
+  DEFAULT_MODULE += crypto_aes_128
+endif
+
 ifneq (,$(filter sys_bus_%,$(USEMODULE)))
   USEMODULE += sys_bus
   USEMODULE += core_msg_bus
@@ -55,7 +64,7 @@ endif
 
 ifneq (,$(filter ieee802154_security,$(USEMODULE)))
   USEMODULE += crypto
-  USEMODULE += crypto_aes
+  USEMODULE += crypto_aes_128
   USEMODULE += cipher_modes
 endif
 
@@ -75,10 +84,6 @@ ifneq (,$(filter base64url,$(USEMODULE)))
   USEMODULE += base64
 endif
 
-ifneq (,$(filter auto_init_gnrc_netif,$(USEMODULE)))
-  USEMODULE += gnrc_netif_init_devs
-endif
-
 ifneq (,$(filter auto_init_saul,$(USEMODULE)))
   USEMODULE += saul_init_devs
 endif
@@ -96,33 +101,20 @@ ifneq (,$(filter dhcpv6_client,$(USEMODULE)))
   USEMODULE += event
   USEMODULE += random
   USEMODULE += xtimer
-endif
-
-ifneq (,$(filter gnrc_mac,$(USEMODULE)))
-  USEMODULE += gnrc_priority_pktqueue
-  USEMODULE += csma_sender
-  USEMODULE += evtimer
-  ifneq (,$(filter gnrc_netif,$(USEMODULE)))
-    USEMODULE += gnrc_netif_mac
+  ifneq (,$(filter sock_dns,$(USEMODULE)))
+    USEMODULE += dhcpv6_client_dns
   endif
 endif
 
-ifneq (,$(filter gnrc_gomach,$(USEMODULE)))
+ifneq (,$(filter fuzzing,$(USEMODULE)))
+  USEMODULE += netdev_test
   USEMODULE += gnrc_netif
-  USEMODULE += gnrc_nettype_gomach
-  USEMODULE += random
-  USEMODULE += xtimer
-  USEMODULE += gnrc_mac
-  FEATURES_REQUIRED += periph_rtt
+  USEMODULE += gnrc_pktbuf_malloc
 endif
 
-ifneq (,$(filter gnrc_lorawan,$(USEMODULE)))
-  USEMODULE += xtimer
-  USEMODULE += random
-  USEMODULE += hashes
-  USEMODULE += crypto_aes
-  USEMODULE += netdev_layer
-  USEMODULE += gnrc_nettype_lorawan
+# include GNRC dependencies
+ifneq (,$(filter gnrc% %gnrc,$(USEMODULE)))
+  include $(RIOTBASE)/sys/net/gnrc/Makefile.dep
 endif
 
 ifneq (,$(filter sntp,$(USEMODULE)))
@@ -130,13 +122,6 @@ ifneq (,$(filter sntp,$(USEMODULE)))
   USEMODULE += xtimer
 endif
 
-ifneq (,$(filter gnrc_netdev_default,$(USEMODULE)))
-  # enable default network devices on the platform
-  USEMODULE += netdev_default
-  USEMODULE += netdev
-  USEMODULE += gnrc_netif
-endif
-
 ifneq (,$(filter netdev_ieee802154,$(USEMODULE)))
   USEMODULE += ieee802154
   USEMODULE += random
@@ -148,309 +133,33 @@ ifneq (,$(filter netdev_ieee802154_submac,$(USEMODULE)))
   USEMODULE += ieee802154_submac
 endif
 
-ifneq (,$(filter gnrc_dhcpv6_%, $(USEMODULE)))
-  USEMODULE += gnrc_dhcpv6
-endif
-
-ifneq (,$(filter gnrc_dhcpv6_client,$(USEMODULE)))
-  USEMODULE += dhcpv6_client
-  USEMODULE += gnrc_ipv6_nib
-  USEMODULE += gnrc_netif
-  USEMODULE += gnrc_sock_udp
-endif
-
-ifneq (,$(filter gnrc_dhcpv6_client_6lbr,$(USEMODULE)))
-  USEMODULE += gnrc_dhcpv6_client
-endif
-
-ifneq (,$(filter gnrc_uhcpc,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_uhcpc
-  USEMODULE += uhcpc
-  USEMODULE += gnrc_sock_udp
-  USEMODULE += fmt
-endif
-
 ifneq (,$(filter uhcpc,$(USEMODULE)))
   USEMODULE += posix_inet
 endif
 
-ifneq (,$(filter gnrc_%,$(filter-out gnrc_netapi gnrc_netreg gnrc_netif% gnrc_pkt%,$(USEMODULE))))
-  USEMODULE += gnrc
-endif
-
-ifneq (,$(filter gnrc_sock_%,$(USEMODULE)))
-  USEMODULE += gnrc_sock
-  ifneq (,$(filter sock_aux_timestamp,$(USEMODULE)))
-    USEMODULE += gnrc_netif_timestamp
-  endif
-endif
-
-ifneq (,$(filter gnrc_sock_async,$(USEMODULE)))
-  USEMODULE += gnrc_netapi_callbacks
-endif
-
-ifneq (,$(filter gnrc_sock_udp,$(USEMODULE)))
-  USEMODULE += gnrc_udp
-  USEMODULE += random     # to generate random ports
-endif
-
-ifneq (,$(filter gnrc_sock,$(USEMODULE)))
-  USEMODULE += gnrc_netapi_mbox
-  USEMODULE += sock
-endif
-
-ifneq (,$(filter gnrc_netapi_mbox,$(USEMODULE)))
-  USEMODULE += core_mbox
-endif
-
 ifneq (,$(filter netdev_tap,$(USEMODULE)))
   USEMODULE += netif
   USEMODULE += netdev_eth
   USEMODULE += iolist
 endif
 
-ifneq (,$(filter gnrc_rpl_p2p,$(USEMODULE)))
-  USEMODULE += gnrc_rpl
-endif
-
-ifneq (,$(filter gnrc_rpl,$(USEMODULE)))
-  USEMODULE += gnrc_icmpv6
-  USEMODULE += gnrc_ipv6_nib
-  USEMODULE += trickle
-  USEMODULE += xtimer
-  USEMODULE += evtimer
-endif
-
 ifneq (,$(filter trickle,$(USEMODULE)))
   USEMODULE += random
-  USEMODULE += xtimer
+  ifeq (,$(filter ztimer_msec,$(USEMODULE)))
+    USEMODULE += xtimer
+  endif
 endif
 
 ifneq (,$(filter eui_provider,$(USEMODULE)))
   USEMODULE += luid
 endif
 
-ifneq (,$(filter gnrc_netif,$(USEMODULE)))
-  USEMODULE += netif
-  USEMODULE += l2util
-  USEMODULE += fmt
-  ifneq (,$(filter netdev_ieee802154_submac,$(USEMODULE)))
-    USEMODULE += gnrc_netif_pktq
-  endif
-  ifneq (,$(filter netdev_ieee802154,$(USEMODULE)))
-    USEMODULE += gnrc_netif_ieee802154
-  endif
-  ifneq (,$(filter netdev_eth,$(USEMODULE)))
-    USEMODULE += gnrc_netif_ethernet
-  endif
-  ifneq (,$(filter gnrc_lorawan,$(USEMODULE)))
-    USEMODULE += gnrc_netif_lorawan
-  endif
-endif
-
-ifneq (,$(filter gnrc_netif_bus,$(USEMODULE)))
-  USEMODULE += core_msg_bus
-endif
-
-ifneq (,$(filter gnrc_netif_events,$(USEMODULE)))
-  USEMODULE += core_thread_flags
-  USEMODULE += event
-endif
-
-ifneq (,$(filter ieee802154 nrfmin esp_now cc110x gnrc_sixloenc,$(USEMODULE)))
-  ifneq (,$(filter gnrc_ipv6, $(USEMODULE)))
-    USEMODULE += gnrc_sixlowpan
-  endif
-  ifneq (,$(filter gnrc_ipv6_default, $(USEMODULE)))
-    USEMODULE += gnrc_sixlowpan_default
-  endif
-  ifneq (,$(filter gnrc_ipv6_router_default, $(USEMODULE)))
-    USEMODULE += gnrc_sixlowpan_router_default
-  endif
+ifneq (,$(filter ieee802154 nrfmin esp_now cc110x,$(USEMODULE)))
   ifneq (,$(filter lwip%, $(USEMODULE)))
     USEMODULE += lwip_sixlowpan
   endif
 endif
 
-ifneq (,$(filter gnrc_sixlowpan_default,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib_6ln
-  USEMODULE += gnrc_sixlowpan
-  ifeq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
-    USEMODULE += gnrc_sixlowpan_frag
-  endif
-  USEMODULE += gnrc_sixlowpan_iphc
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_router_default,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib_6lr
-  ifeq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
-    USEMODULE += gnrc_sixlowpan_frag
-  endif
-  USEMODULE += gnrc_sixlowpan_iphc
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_border_router_default,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib_6lbr
-  USEMODULE += gnrc_ipv6_router_default
-  ifeq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
-    USEMODULE += gnrc_sixlowpan_frag
-  endif
-  USEMODULE += gnrc_sixlowpan_iphc
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag,$(USEMODULE)))
-  USEMODULE += gnrc_sixlowpan
-  USEMODULE += gnrc_sixlowpan_frag_fb
-  USEMODULE += gnrc_sixlowpan_frag_rb
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag_fb,$(USEMODULE)))
-  USEMODULE += core_msg
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag_minfwd,$(USEMODULE)))
-  USEMODULE += gnrc_netif_pktq
-  USEMODULE += gnrc_sixlowpan_frag
-  USEMODULE += gnrc_sixlowpan_frag_hint
-  USEMODULE += gnrc_sixlowpan_frag_vrb
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag_rb,$(USEMODULE)))
-  USEMODULE += xtimer
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
-  USEMODULE += gnrc_sixlowpan
-  USEMODULE += gnrc_sixlowpan_frag_fb
-  USEMODULE += gnrc_sixlowpan_frag_vrb
-  USEMODULE += gnrc_sixlowpan_frag_rb
-  USEMODULE += evtimer
-  USEMODULE += xtimer
-  ifneq (,$(filter gnrc_tx_sync,$(USEMODULE)))
-    # TODO: Implement gnrc_tx_sync for gnrc_sixlowpand_frag_sfr
-    $(error module gnrc_tx_sync conflicts with gnrc_sixlowpand_frag_sfr)
-  endif
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag_sfr_stats,$(USEMODULE)))
-  USEMODULE += gnrc_sixlowpan_frag_sfr
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_frag_vrb,$(USEMODULE)))
-  USEMODULE += xtimer
-  USEMODULE += gnrc_sixlowpan_frag_fb
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_iphc,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6
-  USEMODULE += gnrc_sixlowpan
-  USEMODULE += gnrc_sixlowpan_ctx
-  USEMODULE += gnrc_sixlowpan_iphc_nhc
-endif
-
-ifneq (,$(filter gnrc_sixlowpan,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_sixlowpan
-  USEMODULE += gnrc_nettype_sixlowpan
-  USEMODULE += sixlowpan
-  ifneq (,$(filter gnrc_netif,$(USEMODULE)))
-    USEMODULE += gnrc_netif_6lo
-  endif
-endif
-
-ifneq (,$(filter gnrc_sixlowpan_ctx,$(USEMODULE)))
-  USEMODULE += ipv6_addr
-  ifeq (,$(filter ztimer_msec,$(USEMODULE)))
-    USEMODULE += xtimer
-  endif
-endif
-
-ifneq (,$(filter gnrc_ipv6_default,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6
-  USEMODULE += gnrc_icmpv6
-endif
-
-ifneq (,$(filter gnrc_ipv6_router_default,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_router
-  USEMODULE += gnrc_icmpv6
-endif
-
-ifneq (,$(filter gnrc_ndp,$(USEMODULE)))
-  USEMODULE += gnrc_icmpv6
-  USEMODULE += gnrc_ipv6_hdr
-  USEMODULE += gnrc_netif
-endif
-
-ifneq (,$(filter gnrc_icmpv6_echo,$(USEMODULE)))
-  USEMODULE += gnrc_icmpv6
-  USEMODULE += gnrc_ipv6_hdr
-  USEMODULE += gnrc_netif_hdr
-endif
-
-ifneq (,$(filter gnrc_icmpv6_error,$(USEMODULE)))
-  USEMODULE += gnrc_icmpv6
-  USEMODULE += gnrc_ipv6_hdr
-  USEMODULE += gnrc_netif_hdr
-endif
-
-ifneq (,$(filter gnrc_icmpv6,$(USEMODULE)))
-  USEMODULE += inet_csum
-  USEMODULE += ipv6_hdr
-  USEMODULE += gnrc_nettype_icmpv6
-  USEMODULE += gnrc_nettype_ipv6
-  USEMODULE += icmpv6
-endif
-
-ifneq (,$(filter gnrc_rpl_srh,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_ext_rh
-endif
-
-ifneq (,$(filter gnrc_ipv6_ext_frag,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_ext
-  USEMODULE += xtimer
-endif
-
-ifneq (,$(filter gnrc_ipv6_ext_opt,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_ext
-endif
-
-ifneq (,$(filter gnrc_ipv6_ext_rh,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_ext
-endif
-
-ifneq (,$(filter gnrc_ipv6_ext,$(USEMODULE)))
-  USEMODULE += gnrc_nettype_ipv6
-  USEMODULE += gnrc_nettype_ipv6_ext
-endif
-
-ifneq (,$(filter gnrc_ipv6_whitelist,$(USEMODULE)))
-  USEMODULE += ipv6_addr
-endif
-
-ifneq (,$(filter gnrc_ipv6_blacklist,$(USEMODULE)))
-  USEMODULE += ipv6_addr
-endif
-
-ifneq (,$(filter gnrc_ipv6_router,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6
-  USEMODULE += gnrc_ipv6_nib_router
-endif
-
-ifneq (,$(filter gnrc_ipv6,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_ipv6
-  USEMODULE += inet_csum
-  USEMODULE += ipv6_addr
-  USEMODULE += gnrc_ipv6_hdr
-  USEMODULE += gnrc_ipv6_nib
-  USEMODULE += gnrc_netif
-  USEMODULE += gnrc_netif_ipv6
-  USEMODULE += gnrc_nettype_ipv6
-endif
-
-ifneq (,$(filter gnrc_ipv6_hdr,$(USEMODULE)))
-  USEMODULE += ipv6_hdr
-  USEMODULE += gnrc_pktbuf
-endif
-
 ifneq (,$(filter sixlowpan,$(USEMODULE)))
   USEMODULE += ipv6_hdr
 endif
@@ -460,60 +169,6 @@ ifneq (,$(filter ipv6_hdr,$(USEMODULE)))
   USEMODULE += ipv6_addr
 endif
 
-ifneq (,$(filter gnrc_ipv6_nib_6lbr,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib_6lr
-endif
-
-ifneq (,$(filter gnrc_ipv6_nib_6lr,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib_6ln
-  USEMODULE += gnrc_ipv6_nib_router
-endif
-
-ifneq (,$(filter gnrc_ipv6_nib_6ln,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib
-  USEMODULE += gnrc_sixlowpan_nd
-endif
-
-ifneq (,$(filter gnrc_ipv6_nib_dns,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib
-endif
-
-ifneq (,$(filter gnrc_ipv6_nib_router,$(USEMODULE)))
-  USEMODULE += gnrc_ipv6_nib
-endif
-
-ifneq (,$(filter gnrc_ipv6_nib,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_ipv6_nib
-  USEMODULE += evtimer
-  USEMODULE += gnrc_ndp
-  USEMODULE += gnrc_netif
-  USEMODULE += gnrc_netif_ipv6
-  USEMODULE += ipv6_addr
-  USEMODULE += random
-endif
-
-ifneq (,$(filter gnrc_udp,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_udp
-  USEMODULE += gnrc_nettype_udp
-  USEMODULE += inet_csum
-  USEMODULE += udp
-endif
-
-ifneq (,$(filter gnrc_tcp,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_tcp
-  USEMODULE += gnrc_nettype_tcp
-  USEMODULE += inet_csum
-  USEMODULE += random
-  USEMODULE += tcp
-  USEMODULE += evtimer_mbox
-endif
-
-ifneq (,$(filter gnrc_pktdump,$(USEMODULE)))
-  DEFAULT_MODULE += auto_init_gnrc_pktdump
-  USEMODULE += gnrc_pktbuf
-  USEMODULE += od
-endif
-
 ifneq (,$(filter ieee802154_submac,$(USEMODULE)))
   USEMODULE += xtimer
 endif
@@ -617,9 +272,6 @@ endif
 
 ifneq (,$(filter posix_sleep,$(USEMODULE)))
   USEMODULE += ztimer_msec
-  ifneq (,$(filter periph_rtt,$(USEMODULE)))
-    USEMODULE += ztimer_periph_rtt
-  endif
   USEMODULE += ztimer_usec
   USEMODULE += posix_headers
 endif
@@ -654,52 +306,6 @@ ifneq (,$(filter cpp11-compat,$(USEMODULE)))
   FEATURES_REQUIRED += libstdcpp
 endif
 
-ifneq (,$(filter fuzzing,$(USEMODULE)))
-  USEMODULE += netdev_test
-  USEMODULE += gnrc_netif
-  USEMODULE += gnrc_pktbuf_malloc
-endif
-
-ifneq (,$(filter gnrc,$(USEMODULE)))
-  USEMODULE += gnrc_netapi
-  USEMODULE += gnrc_netreg
-  USEMODULE += gnrc_netif
-  USEMODULE += gnrc_netif_hdr
-  USEMODULE += gnrc_pktbuf
-  ifneq (,$(filter sock_async, $(USEMODULE)))
-    USEMODULE += gnrc_sock_async
-  endif
-  ifneq (,$(filter sock_ip, $(USEMODULE)))
-    USEMODULE += gnrc_sock_ip
-  endif
-  ifneq (,$(filter sock_udp, $(USEMODULE)))
-    USEMODULE += gnrc_sock_udp
-  endif
-endif
-
-ifneq (,$(filter gnrc_pktbuf, $(USEMODULE)))
-  ifeq (,$(filter gnrc_pktbuf_%, $(USEMODULE)))
-    USEMODULE += gnrc_pktbuf_static
-  endif
-  ifeq (gnrc_pktbuf_cmd,$(filter gnrc_pktbuf_%, $(USEMODULE)))
-    USEMODULE += gnrc_pktbuf_static
-  endif
-  DEFAULT_MODULE += auto_init_gnrc_pktbuf
-  USEMODULE += gnrc_pkt
-endif
-
-ifneq (,$(filter gnrc_pktbuf_%, $(USEMODULE)))
-  USEMODULE += gnrc_pktbuf # make MODULE_GNRC_PKTBUF macro available for all implementations
-endif
-
-ifneq (,$(filter gnrc_netif_%,$(USEMODULE)))
-  USEMODULE += gnrc_netif
-endif
-
-ifneq (,$(filter gnrc_netif_pktq,$(USEMODULE)))
-  USEMODULE += xtimer
-endif
-
 ifneq (,$(filter netstats_%, $(USEMODULE)))
   USEMODULE += netstats
 endif
@@ -709,13 +315,6 @@ ifneq (,$(filter netstats_neighbor_%, $(USEMODULE)))
   USEMODULE += xtimer
 endif
 
-ifneq (,$(filter gnrc_lwmac,$(USEMODULE)))
-  USEMODULE += gnrc_netif
-  USEMODULE += gnrc_nettype_lwmac
-  USEMODULE += gnrc_mac
-  FEATURES_REQUIRED += periph_rtt
-endif
-
 ifneq (,$(filter pthread,$(USEMODULE)))
   USEMODULE += xtimer
   USEMODULE += timex
@@ -853,9 +452,6 @@ ifneq (,$(filter sock_async_event,$(USEMODULE)))
 endif
 
 ifneq (,$(filter sock_async,$(USEMODULE)))
-  ifneq (,$(filter gnrc%,$(USEMODULE)))
-    USEMODULE += gnrc_sock_async
-  endif
   ifneq (,$(filter openwsn%,$(USEMODULE)))
     USEMODULE += openwsn_sock_async
   endif
@@ -880,8 +476,21 @@ ifneq (,$(filter event_thread_%,$(USEMODULE)))
   USEMODULE += event_thread
 endif
 
+ifneq (,$(filter event_timeout_ztimer,$(USEMODULE)))
+  USEMODULE += event_timeout
+endif
+
+ifneq (,$(filter event_periodic_timeout,$(USEMODULE)))
+  USEMODULE += event_timeout
+  USEMODULE += ztimer_periodic
+endif
+
 ifneq (,$(filter event_timeout,$(USEMODULE)))
-  USEMODULE += xtimer
+  ifneq (,$(filter event_timeout_ztimer,$(USEMODULE)))
+    USEMODULE += ztimer_usec
+  else
+    USEMODULE += xtimer
+  endif
 endif
 
 ifneq (,$(filter event,$(USEMODULE)))
@@ -899,12 +508,9 @@ ifneq (,$(filter gcoap,$(USEMODULE)))
   USEMODULE += sock_util
   USEMODULE += event_callback
   USEMODULE += event_timeout
-ifneq (,$(filter gnrc%,$(USEMODULE)))
-  USEMODULE += gnrc_sock_async
-endif
-ifneq (,$(filter openwsn%,$(USEMODULE)))
-  USEMODULE += openwsn_sock_udp
-endif
+  ifneq (,$(filter openwsn%,$(USEMODULE)))
+    USEMODULE += openwsn_sock_udp
+  endif
 endif
 
 ifneq (,$(filter luid,$(USEMODULE)))
@@ -933,9 +539,6 @@ ifneq (,$(filter skald,$(USEMODULE)))
   USEMODULE += nrfble
   USEMODULE += random
   USEMODULE += ztimer_msec
-   ifneq (,$(filter periph_rtt,$(USEMODULE)))
-    USEMODULE += ztimer_periph_rtt
-  endif
 endif
 
 ifneq (,$(filter bluetil_addr,$(USEMODULE)))
diff --git a/sys/Makefile.include b/sys/Makefile.include
index 69207bfc82..2ca8bdce07 100644
--- a/sys/Makefile.include
+++ b/sys/Makefile.include
@@ -133,10 +133,8 @@ ifneq (,$(filter test_utils_result_output,$(USEMODULE)))
   include $(RIOTBASE)/sys/test_utils/result_output/Makefile.include
 endif
 
-# Convert xtimer into a pseudo module if its API is already implemented by
-# ztimer's compatibility wrapper
-ifneq (,$(filter ztimer_xtimer_compat,$(USEMODULE)))
-  PSEUDOMODULES += xtimer
+ifneq (,$(filter ztimer,$(USEMODULE)))
+  include $(RIOTBASE)/sys/ztimer/Makefile.include
 endif
 
 ifneq (,$(filter prng,$(USEMODULE)))
diff --git a/sys/arduino/Kconfig b/sys/arduino/Kconfig
index e14b23759b..876b852313 100644
--- a/sys/arduino/Kconfig
+++ b/sys/arduino/Kconfig
@@ -5,14 +5,26 @@
 # directory for more details.
 #
 
+config MODULE_ARDUINO_SKETCHES
+    bool
+
 menuconfig MODULE_ARDUINO
     bool "Arduino support"
     imply MODULE_ARDUINO_PWM
     imply MODULE_PERIPH_ADC
+    imply MODULE_PERIPH_I2C
+    imply MODULE_PERIPH_SPI
     depends on HAS_ARDUINO
     depends on HAS_PERIPH_GPIO
+    depends on HAS_CPP
     depends on TEST_KCONFIG
     select MODULE_PERIPH_GPIO
+    select MODULE_CPP
+    select MODULE_ARDUINO_SKETCHES
+    select MODULE_FMT
+    select MODULE_ZTIMER
+    select MODULE_ZTIMER_MSEC
+    select MODULE_ZTIMER_USEC
 
 config MODULE_ARDUINO_PWM
     bool "PWM support for Arduino"
diff --git a/sys/arduino/Makefile.include b/sys/arduino/Makefile.include
index 16e404ff14..fba73396d7 100644
--- a/sys/arduino/Makefile.include
+++ b/sys/arduino/Makefile.include
@@ -1,6 +1,7 @@
 # Add Arduino sketches to the application as a module
 
 SKETCHES = $(wildcard $(APPDIR)/*.sketch)
+SKETCH_MODULE = arduino_sketches
 
 ifneq (,$(SKETCHES))
   # Define application sketches module, it will be generated into $(BINDIR)
diff --git a/sys/arduino/base.cpp b/sys/arduino/base.cpp
index b1d58e7d41..51e90cc966 100644
--- a/sys/arduino/base.cpp
+++ b/sys/arduino/base.cpp
@@ -19,7 +19,8 @@
  */
 
 extern "C" {
-#include "xtimer.h"
+#include "assert.h"
+#include "ztimer.h"
 #include "periph/gpio.h"
 #include "periph/adc.h"
 #include "periph/pwm.h"
@@ -60,22 +61,22 @@ int digitalRead(int pin)
 
 void delay(unsigned long msec)
 {
-    xtimer_usleep(msec * US_PER_MS);
+    ztimer_sleep(ZTIMER_MSEC, msec);
 }
 
 void delayMicroseconds(unsigned long usec)
 {
-    xtimer_usleep(usec);
+    ztimer_sleep(ZTIMER_USEC, usec);
 }
 
 unsigned long micros()
 {
-    return xtimer_now_usec();
+    return ztimer_now(ZTIMER_USEC);
 }
 
 unsigned long millis()
 {
-    return xtimer_now_usec64() / US_PER_MS;
+    return ztimer_now(ZTIMER_MSEC);
 }
 
 #if MODULE_PERIPH_ADC
diff --git a/sys/auto_init/Kconfig b/sys/auto_init/Kconfig
index 3208d8da7e..7c7dcc09dc 100644
--- a/sys/auto_init/Kconfig
+++ b/sys/auto_init/Kconfig
@@ -5,7 +5,7 @@
 # directory for more details.
 #
 
-config MODULE_AUTO_INIT
+menuconfig MODULE_AUTO_INIT
     bool "Auto-initialization system"
     default y
     depends on TEST_KCONFIG
@@ -14,4 +14,9 @@ config MODULE_AUTO_INIT
         drivers, or network interfaces) on start-up automatically. Disable if a
         more custom initialization is required. If unsure, say Y.
 
+if MODULE_AUTO_INIT
+
+rsource "screen/Kconfig"
 rsource "multimedia/Kconfig"
+
+endif # MODULE_AUTO_INIT
diff --git a/sys/auto_init/auto_init.c b/sys/auto_init/auto_init.c
index bad383816f..553fad2945 100644
--- a/sys/auto_init/auto_init.c
+++ b/sys/auto_init/auto_init.c
@@ -108,6 +108,11 @@ void auto_init(void)
         extern void lwip_bootstrap(void);
         lwip_bootstrap();
     }
+    if (IS_USED(MODULE_SOCK_DTLS)) {
+        LOG_DEBUG("Auto init sock_dtls.\n");
+        extern void sock_dtls_init(void);
+        sock_dtls_init();
+    }
     if (IS_USED(MODULE_OPENTHREAD)) {
         LOG_DEBUG("Bootstrapping openthread.\n");
         extern void openthread_bootstrap(void);
@@ -169,11 +174,6 @@ void auto_init(void)
         extern void auto_init_loramac(void);
         auto_init_loramac();
     }
-    if (IS_USED(MODULE_SOCK_DTLS)) {
-        LOG_DEBUG("Auto init sock_dtls.\n");
-        extern void sock_dtls_init(void);
-        sock_dtls_init();
-    }
 
     /* initialize USB devices */
     if (IS_USED(MODULE_AUTO_INIT_USBUS)) {
@@ -257,10 +257,10 @@ void auto_init(void)
         dhcpv6_client_auto_init();
     }
 
-    if (IS_USED(MODULE_GNRC_DHCPV6_CLIENT_6LBR)) {
-        LOG_DEBUG("Auto init 6LoWPAN border router DHCPv6 client\n");
-        extern void gnrc_dhcpv6_client_6lbr_init(void);
-        gnrc_dhcpv6_client_6lbr_init();
+    if (IS_USED(MODULE_GNRC_DHCPV6_CLIENT_SIMPLE_PD)) {
+        LOG_DEBUG("Auto init DHCPv6 client for simple prefix delegation\n");
+        extern void gnrc_dhcpv6_client_simple_pd_init(void);
+        gnrc_dhcpv6_client_simple_pd_init();
     }
 
     if (IS_USED(MODULE_AUTO_INIT_MULTIMEDIA)) {
diff --git a/sys/auto_init/screen/Kconfig b/sys/auto_init/screen/Kconfig
new file mode 100644
index 0000000000..e822c22620
--- /dev/null
+++ b/sys/auto_init/screen/Kconfig
@@ -0,0 +1,9 @@
+# Copyright (c) 2021 HAW Hamburg
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+#
+
+config MODULE_AUTO_INIT_SCREEN
+    bool "Auto-initialize screens"
diff --git a/sys/congure/mock/congure_mock.c b/sys/congure/mock/congure_mock.c
index 840e3b734b..378c653937 100644
--- a/sys/congure/mock/congure_mock.c
+++ b/sys/congure/mock/congure_mock.c
@@ -37,9 +37,11 @@ static const congure_snd_driver_t _driver = {
     .report_ecn_ce = _snd_report_ecn_ce,
 };
 
-void congure_mock_snd_setup(congure_mock_snd_t *c)
+void congure_mock_snd_setup(congure_mock_snd_t *c,
+                            const congure_snd_driver_t *methods)
 {
     c->super.driver = &_driver;
+    c->methods = methods;
 }
 
 static void _snd_init(congure_snd_t *cong, void *ctx)
@@ -49,6 +51,9 @@ static void _snd_init(congure_snd_t *cong, void *ctx)
     c->init_calls++;
     c->init_args.c = &c->super;
     c->init_args.ctx = ctx;
+    if (c->methods && c->methods->init) {
+        c->methods->init(cong, ctx);
+    }
 }
 
 static int32_t _snd_inter_msg_interval(congure_snd_t *cong, unsigned msg_size)
@@ -58,6 +63,9 @@ static int32_t _snd_inter_msg_interval(congure_snd_t *cong, unsigned msg_size)
     c->inter_msg_interval_calls++;
     c->inter_msg_interval_args.c = &c->super;
     c->inter_msg_interval_args.msg_size = msg_size;
+    if (c->methods && c->methods->inter_msg_interval) {
+        return c->methods->inter_msg_interval(cong, msg_size);
+    }
     return -1;
 }
 
@@ -68,6 +76,9 @@ static void _snd_report_msg_sent(congure_snd_t *cong, unsigned msg_size)
     c->report_msg_sent_calls++;
     c->report_msg_sent_args.c = &c->super;
     c->report_msg_sent_args.msg_size = msg_size;
+    if (c->methods && c->methods->report_msg_sent) {
+        c->methods->report_msg_sent(cong, msg_size);
+    }
 }
 
 static void _snd_report_msg_discarded(congure_snd_t *cong, unsigned msg_size)
@@ -77,6 +88,9 @@ static void _snd_report_msg_discarded(congure_snd_t *cong, unsigned msg_size)
     c->report_msg_discarded_calls++;
     c->report_msg_discarded_args.c = &c->super;
     c->report_msg_discarded_args.msg_size = msg_size;
+    if (c->methods && c->methods->report_msg_discarded) {
+        c->methods->report_msg_discarded(cong, msg_size);
+    }
 }
 
 static void _snd_report_msgs_lost(congure_snd_t *cong, congure_snd_msg_t *msgs)
@@ -86,6 +100,9 @@ static void _snd_report_msgs_lost(congure_snd_t *cong, congure_snd_msg_t *msgs)
     c->report_msgs_lost_calls++;
     c->report_msgs_lost_args.c = &c->super;
     c->report_msgs_lost_args.msgs = msgs;
+    if (c->methods && c->methods->report_msgs_lost) {
+        c->methods->report_msgs_lost(cong, msgs);
+    }
 }
 
 static void _snd_report_msgs_timeout(congure_snd_t *cong,
@@ -96,6 +113,9 @@ static void _snd_report_msgs_timeout(congure_snd_t *cong,
     c->report_msgs_timeout_calls++;
     c->report_msgs_timeout_args.c = &c->super;
     c->report_msgs_timeout_args.msgs = msgs;
+    if (c->methods && c->methods->report_msgs_timeout) {
+        c->methods->report_msgs_timeout(cong, msgs);
+    }
 }
 
 static void _snd_report_msg_acked(congure_snd_t *cong, congure_snd_msg_t *msg,
@@ -107,6 +127,9 @@ static void _snd_report_msg_acked(congure_snd_t *cong, congure_snd_msg_t *msg,
     c->report_msg_acked_args.c = &c->super;
     c->report_msg_acked_args.msg = msg;
     c->report_msg_acked_args.ack = ack;
+    if (c->methods && c->methods->report_msg_acked) {
+        c->methods->report_msg_acked(cong, msg, ack);
+    }
 }
 
 static void _snd_report_ecn_ce(congure_snd_t *cong, ztimer_now_t time)
@@ -116,6 +139,9 @@ static void _snd_report_ecn_ce(congure_snd_t *cong, ztimer_now_t time)
     c->report_ecn_ce_calls++;
     c->report_ecn_ce_args.c = &c->super;
     c->report_ecn_ce_args.time = time;
+    if (c->methods && c->methods->report_ecn_ce) {
+        c->methods->report_ecn_ce(cong, time);
+    }
 }
 
 /** @} */
diff --git a/sys/crypto/Kconfig b/sys/crypto/Kconfig
index fa070b10c1..9311436a8a 100644
--- a/sys/crypto/Kconfig
+++ b/sys/crypto/Kconfig
@@ -5,32 +5,23 @@
 # directory for more details.
 #
 
-menu "Crypto"
-
-config MODULE_CRYPTO
-    bool "Common cryptographic functionalities"
+menuconfig MODULE_CRYPTO
+    bool "Crypto"
     depends on TEST_KCONFIG
 
-choice
-    bool "Crypto block ciphers API implementation"
-    optional
-    depends on TEST_KCONFIG
-    help
-        The common Crypto block ciphers API has multiple implementations. Choose
-        one of the following.
+if MODULE_CRYPTO
 
-config MODULE_CRYPTO_AES
-    bool "AES"
-    select MODULE_CRYPTO
+menu "Crypto AES options"
 
-config MODULE_CRYPTO_3DES
-    bool "3DES (deprecated)"
-    select MODULE_CRYPTO
+config MODULE_CRYPTO_AES_128
+    bool "AES-128"
+    default y
 
-endchoice
+config MODULE_CRYPTO_AES_192
+    bool "AES-192"
 
-menu "Crypto AES options"
-depends on MODULE_CRYPTO_AES
+config MODULE_CRYPTO_AES_256
+    bool "AES-256"
 
 config MODULE_CRYPTO_AES_PRECALCULATED
     bool "Pre-calculate T tables"
@@ -44,4 +35,4 @@ endmenu # Crypto AES options
 
 rsource "modes/Kconfig"
 
-endmenu # Crypto
+endif # Crypto
diff --git a/sys/crypto/aes.c b/sys/crypto/aes.c
index a6a229df83..776b6cc192 100644
--- a/sys/crypto/aes.c
+++ b/sys/crypto/aes.c
@@ -39,6 +39,28 @@
 #include <stdint.h>
 #include "crypto/aes.h"
 #include "crypto/ciphers.h"
+#include "kernel_defines.h"
+
+#if !IS_USED(MODULE_CRYPTO_AES_128) && !IS_USED(MODULE_CRYPTO_AES_192) && \
+    !IS_USED(MODULE_CRYPTO_AES_256)
+    #error "sys/crypto/aes: No aes module used."
+#endif
+
+/**
+ * @brief AES key size used
+ */
+#if IS_USED(MODULE_CRYPTO_AES_128) && !IS_USED(MODULE_CRYPTO_AES_192) && \
+    !IS_USED(MODULE_CRYPTO_AES_256)
+#  define AES_KEY_SIZE(ctx) AES_KEY_SIZE_128
+#elif !IS_USED(MODULE_CRYPTO_AES_128) && IS_USED(MODULE_CRYPTO_AES_192) && \
+    !IS_USED(MODULE_CRYPTO_AES_256)
+#  define AES_KEY_SIZE(ctx) AES_KEY_SIZE_192
+#elif !IS_USED(MODULE_CRYPTO_AES_128) && !IS_USED(MODULE_CRYPTO_AES_192) && \
+    IS_USED(MODULE_CRYPTO_AES_256)
+#  define AES_KEY_SIZE(ctx) AES_KEY_SIZE_256
+#else
+#  define AES_KEY_SIZE(ctx) ctx->key_size
+#endif
 
 /**
  * Interface to the aes cipher
@@ -49,7 +71,9 @@ static const cipher_interface_t aes_interface = {
     aes_encrypt,
     aes_decrypt
 };
+
 const cipher_id_t CIPHER_AES_128 = &aes_interface;
+const cipher_id_t CIPHER_AES = &aes_interface;
 
 static const u32 Te0[256] = {
     0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
@@ -794,19 +818,26 @@ static const u32 rcon[] = {
     0x1B000000, 0x36000000,
 };
 
-
 int aes_init(cipher_context_t *context, const uint8_t *key, uint8_t keySize)
 {
     uint8_t i;
 
-    /* This implementation only supports a single key size (defined in AES_KEY_SIZE) */
-    if (keySize != AES_KEY_SIZE) {
+    if (keySize != AES_KEY_SIZE_128 && keySize != AES_KEY_SIZE_192 &&
+        keySize != AES_KEY_SIZE_256) {
+        return CIPHER_ERR_INVALID_KEY_SIZE;
+    }
+
+    if ((keySize == AES_KEY_SIZE_128 && !IS_USED(MODULE_CRYPTO_AES_128)) ||
+        (keySize == AES_KEY_SIZE_192 && !IS_USED(MODULE_CRYPTO_AES_192)) ||
+        (keySize == AES_KEY_SIZE_256 && !IS_USED(MODULE_CRYPTO_AES_256))) {
         return CIPHER_ERR_INVALID_KEY_SIZE;
     }
 
+    context->key_size = keySize;
+
     /* Make sure that context is large enough. If this is not the case,
        you should build with -DAES */
-    if (CIPHER_MAX_CONTEXT_SIZE < AES_KEY_SIZE) {
+    if (CIPHER_MAX_CONTEXT_SIZE < keySize) {
         return CIPHER_ERR_BAD_CONTEXT_SIZE;
     }
 
@@ -1036,13 +1067,14 @@ int aes_encrypt(const cipher_context_t *context, const uint8_t *plainBlock,
     const AES_KEY *key = &aeskey;
 
     res = aes_set_encrypt_key((unsigned char *)context->context,
-                              AES_KEY_SIZE * 8, &aeskey);
+                              AES_KEY_SIZE(context) * 8, &aeskey);
     if (res < 0) {
         return res;
     }
 
     const u32 *rk;
     u32 s0, s1, s2, s3, t0, t1, t2, t3;
+
 #ifndef MODULE_CRYPTO_AES_UNROLL
     int r;
 #endif /* ?MODULE_CRYPTO_AES_UNROLL */
@@ -1304,7 +1336,7 @@ int aes_decrypt(const cipher_context_t *context, const uint8_t *cipherBlock,
     const AES_KEY *key = &aeskey;
 
     res = aes_set_decrypt_key((unsigned char *)context->context,
-                              AES_KEY_SIZE * 8, &aeskey);
+                              AES_KEY_SIZE(context) * 8, &aeskey);
 
     if (res < 0) {
         return res;
@@ -1312,6 +1344,7 @@ int aes_decrypt(const cipher_context_t *context, const uint8_t *cipherBlock,
 
     const u32 *rk;
     u32 s0, s1, s2, s3, t0, t1, t2, t3;
+
 #ifndef MODULE_CRYPTO_AES_UNROLL
     int r;
 #endif /* ?MODULE_CRYPTO_AES_UNROLL */
diff --git a/sys/crypto/doc.txt b/sys/crypto/doc.txt
index 959de84633..e6e861ce80 100644
--- a/sys/crypto/doc.txt
+++ b/sys/crypto/doc.txt
@@ -16,12 +16,11 @@
  * @section ciphers Ciphers
  *
  * RIOT supports the following block ciphers:
- *  * AES-128
- *  * 3DES (deprecated)
+ *  * AES-128, AES-192, AES-256
  *  * NULL
  *
- * You can use them directly by adding `crypto_aes` or `crypto_3des` to your
- * USEMODULE-List.
+ * You can use them directly by adding `crypto_aes_128`, `crypto_aes_192` or
+ * `crypto_aes_256` to your USEMODULE-List.
  * While you can use the ciphers functions directly, you should resort to
  * the generic API for block ciphers whenever possible.
  *
@@ -37,7 +36,7 @@
  *          plain_text[AES_BLOCK_SIZE] = {0},
  *          cipher_text[AES_BLOCK_SIZE] = {0};
  *
- *  if (cipher_init(&cipher, CIPHER_AES_128, key, AES_KEY_SIZE) < 0)
+ *  if (cipher_init(&cipher, CIPHER_AES, key, AES_KEY_SIZE) < 0)
  *      printf("Cipher init failed!\n");
  *
  *  if (cipher_encrypt(&cipher, plain_text, cipher_text) < 0)
diff --git a/sys/event/periodic.c b/sys/event/periodic.c
new file mode 100644
index 0000000000..e493b0ee33
--- /dev/null
+++ b/sys/event/periodic.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     sys_event
+ * @{
+ *
+ * @file
+ * @brief       Periodic Event Implementation
+ *
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ *
+ * @}
+ */
+#include "kernel_defines.h"
+#include "ztimer.h"
+#include "ztimer/periodic.h"
+#include "event/periodic.h"
+
+static int _event_periodic_callback(void *arg)
+{
+    event_periodic_t *event_periodic = (event_periodic_t *)arg;
+
+    event_post(event_periodic->queue, event_periodic->event);
+
+    return 0;
+}
+
+void event_periodic_init(event_periodic_t *event_periodic,
+                         ztimer_clock_t *clock,
+                         event_queue_t *queue, event_t *event)
+{
+    ztimer_periodic_init(clock, &event_periodic->timer, _event_periodic_callback,
+                         event_periodic, 0);
+    event_periodic->queue = queue;
+    event_periodic->event = event;
+}
diff --git a/sys/event/timeout.c b/sys/event/timeout.c
index fb18c273bd..fc45f5354f 100644
--- a/sys/event/timeout.c
+++ b/sys/event/timeout.c
@@ -8,6 +8,12 @@
  * directory for more details.
  */
 
+#include "kernel_defines.h"
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+#include "ztimer.h"
+#else
+#include "xtimer.h"
+#endif
 #include "event/timeout.h"
 
 static void _event_timeout_callback(void *arg)
@@ -16,7 +22,7 @@ static void _event_timeout_callback(void *arg)
     event_post(event_timeout->queue, event_timeout->event);
 }
 
-void event_timeout_init(event_timeout_t *event_timeout, event_queue_t *queue, event_t *event)
+static void _event_timeout_init(event_timeout_t *event_timeout, event_queue_t *queue, event_t *event)
 {
     event_timeout->timer.callback = _event_timeout_callback;
     event_timeout->timer.arg = event_timeout;
@@ -24,12 +30,38 @@ void event_timeout_init(event_timeout_t *event_timeout, event_queue_t *queue, ev
     event_timeout->event = event;
 }
 
+void event_timeout_init(event_timeout_t *event_timeout, event_queue_t *queue, event_t *event)
+{
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+    event_timeout_ztimer_init(event_timeout, ZTIMER_USEC, queue, event);
+#else
+    _event_timeout_init(event_timeout, queue, event);
+#endif
+}
+
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+void event_timeout_ztimer_init(event_timeout_t *event_timeout, ztimer_clock_t* clock,
+                               event_queue_t *queue, event_t *event)
+{
+    event_timeout->clock = clock;
+    _event_timeout_init(event_timeout, queue, event);
+}
+#endif
+
 void event_timeout_set(event_timeout_t *event_timeout, uint32_t timeout)
 {
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+    ztimer_set(event_timeout->clock, &event_timeout->timer, timeout);
+#else
     xtimer_set(&event_timeout->timer, timeout);
+#endif
 }
 
 void event_timeout_clear(event_timeout_t *event_timeout)
 {
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+    ztimer_remove(event_timeout->clock, &event_timeout->timer);
+#else
     xtimer_remove(&event_timeout->timer);
+#endif
 }
diff --git a/sys/hashes/cmac.c b/sys/hashes/cmac.c
index 698d0925d7..27cc57975c 100644
--- a/sys/hashes/cmac.c
+++ b/sys/hashes/cmac.c
@@ -49,7 +49,7 @@ int cmac_init(cmac_context_t *ctx, const uint8_t *key, uint8_t key_size)
     }
 
     memset(ctx, 0, sizeof(cmac_context_t));
-    return cipher_init(&(ctx->aes_ctx), CIPHER_AES_128, key, key_size);
+    return cipher_init(&(ctx->aes_ctx), CIPHER_AES, key, key_size);
 }
 
 void cmac_update(cmac_context_t *ctx, const void *data, size_t len)
diff --git a/sys/include/bit.h b/sys/include/bit.h
index a0cb78dd4f..2879bf9201 100644
--- a/sys/include/bit.h
+++ b/sys/include/bit.h
@@ -197,6 +197,57 @@ static inline void bit_clear8(volatile uint8_t *ptr, uint8_t bit)
     *((volatile uint8_t *)bitband_addr(ptr, bit)) = 0;
 }
 
+/**
+ * @brief Checks if a single bit in the 32 bit word pointed to by @p ptr is set
+ *
+ * The effect is the same as for the following snippet:
+ *
+ * @code{c}
+ *   *ptr & (1 << bit);
+ * @endcode
+ *
+ * @param[in]  ptr pointer to target word
+ * @param[in]  bit bit number within the word
+ */
+static inline bool bit_check32(volatile uint32_t *ptr, uint8_t bit)
+{
+    return *((volatile uint32_t *)bitband_addr(ptr, bit));
+}
+
+/**
+ * @brief Checks if a single bit in the 16 bit word pointed to by @p ptr is set
+ *
+ * The effect is the same as for the following snippet:
+ *
+ * @code{c}
+ *   *ptr & (1 << bit);
+ * @endcode
+ *
+ * @param[in]  ptr pointer to target word
+ * @param[in]  bit bit number within the word
+ */
+static inline bool bit_check16(volatile uint16_t *ptr, uint8_t bit)
+{
+    return *((volatile uint16_t *)bitband_addr(ptr, bit));
+}
+
+/**
+ * @brief Checks if a single bit in the 8 bit byte pointed to by @p ptr is set
+ *
+ * The effect is the same as for the following snippet:
+ *
+ * @code{c}
+ *   *ptr & (1 << bit);
+ * @endcode
+ *
+ * @param[in]  ptr pointer to target byte
+ * @param[in]  bit bit number within the byte
+ */
+static inline bool bit_check8(volatile uint8_t *ptr, uint8_t bit)
+{
+    return *((volatile uint8_t *)bitband_addr(ptr, bit));
+}
+
 /** @} */
 
 #else /* CPU_HAS_BITBAND */
@@ -231,6 +282,21 @@ static inline void bit_clear8(volatile uint8_t *ptr, uint8_t bit)
     *ptr &= ~(1 << (bit));
 }
 
+static inline bool bit_check32(volatile uint32_t *ptr, uint8_t bit)
+{
+    return *ptr & (1 << bit);
+}
+
+static inline bool bit_check16(volatile uint16_t *ptr, uint8_t bit)
+{
+    return *ptr & (1 << bit);
+}
+
+static inline bool bit_check8(volatile uint8_t *ptr, uint8_t bit)
+{
+    return *ptr & (1 << bit);
+}
+
 #endif /* CPU_HAS_BITBAND */
 
 #endif /* !BITBAND_FUNCTIONS_PROVIDED */
diff --git a/sys/include/byteorder.h b/sys/include/byteorder.h
index 600eb87308..bafc20b624 100644
--- a/sys/include/byteorder.h
+++ b/sys/include/byteorder.h
@@ -19,6 +19,7 @@
 #ifndef BYTEORDER_H
 #define BYTEORDER_H
 
+#include <string.h>
 #include <stdint.h>
 #include "unaligned.h"
 
@@ -682,6 +683,93 @@ static inline void byteorder_htobebufll(uint8_t *buf, uint64_t val)
 #endif
 }
 
+static inline uint16_t byteorder_lebuftohs(const uint8_t *buf)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    /* little endian to little endian conversion is easy, but buffer might be
+     * unaligned */
+    return unaligned_get_u16(buf);
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    return (uint16_t)((buf[0] << 8) | (buf[1] << 0));
+#endif
+}
+
+static inline uint32_t byteorder_lebuftohl(const uint8_t *buf)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    /* little endian to little endian conversion is easy, but buffer might be
+     * unaligned */
+    return unaligned_get_u32(buf);
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    return (((uint32_t) buf[0] << 24)
+          | ((uint32_t) buf[1] << 16)
+          | ((uint32_t) buf[2] << 8)
+          | ((uint32_t) buf[3] << 0));
+#endif
+}
+
+static inline uint64_t byteorder_lebuftohll(const uint8_t *buf)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    /* little endian to little endian conversion is easy, but buffer might be
+     * unaligned */
+    return unaligned_get_u64(buf);
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    return (((uint64_t) buf[0] << 56)
+          | ((uint64_t) buf[1] << 48)
+          | ((uint64_t) buf[2] << 40)
+          | ((uint64_t) buf[3] << 32)
+          | ((uint64_t) buf[4] << 24)
+          | ((uint64_t) buf[5] << 16)
+          | ((uint64_t) buf[6] <<  8)
+          | ((uint64_t) buf[7] <<  0));
+#endif
+}
+
+static inline void byteorder_htolebufs(uint8_t *buf, uint16_t val)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    /* little endian to little endian conversion is easy, but buffer might be
+     * unaligned */
+    memcpy(buf, &val, sizeof(val));
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    buf[0] = (uint8_t)(val >> 8);
+    buf[1] = (uint8_t)(val >> 0);
+#endif
+}
+
+static inline void byteorder_htolebufl(uint8_t *buf, uint32_t val)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    /* little endian to little endian conversion is easy, but buffer might be
+     * unaligned */
+    memcpy(buf, &val, sizeof(val));
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    buf[0] = (uint8_t)(val >> 24);
+    buf[1] = (uint8_t)(val >> 16);
+    buf[2] = (uint8_t)(val >> 8);
+    buf[3] = (uint8_t)(val >> 0);
+#endif
+}
+
+static inline void byteorder_htolebufll(uint8_t *buf, uint64_t val)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+    /* little endian to little endian conversion is easy, but buffer might be
+     * unaligned */
+    memcpy(buf, &val, sizeof(val));
+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    buf[0] = (uint8_t)(val >> 56);
+    buf[1] = (uint8_t)(val >> 48);
+    buf[2] = (uint8_t)(val >> 40);
+    buf[3] = (uint8_t)(val >> 32);
+    buf[4] = (uint8_t)(val >> 24);
+    buf[5] = (uint8_t)(val >> 16);
+    buf[6] = (uint8_t)(val >> 8);
+    buf[7] = (uint8_t)(val >> 0);
+#endif
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sys/include/congure/mock.h b/sys/include/congure/mock.h
index d93ea49a1a..429bf92bfb 100644
--- a/sys/include/congure/mock.h
+++ b/sys/include/congure/mock.h
@@ -33,7 +33,12 @@ extern "C" {
  * @extends congure_snd_t
  */
 typedef struct {
-    congure_snd_t super;        /**< see @ref congure_snd_t */
+    congure_snd_t super;            /**< see @ref congure_snd_t */
+    /**
+     * @brief   Optional methods called in addition to the tracking functions
+     *          of the mock driver
+     */
+    const congure_snd_driver_t *methods;
     /**
      * @brief   How often was the congure_snd_driver_t::init() method called?
      */
@@ -152,9 +157,12 @@ typedef struct {
 /**
  * @brief   Sets up the driver for CongURE mock object
  *
- * @param[in] c A CongURE mock object
+ * @param[in] c         A CongURE mock object
+ * @param[in] methods   Methods to call in addition to the tracking of the mock
+ *                      driver. May be NULL.
  */
-void congure_mock_snd_setup(congure_mock_snd_t *c);
+void congure_mock_snd_setup(congure_mock_snd_t *c,
+                            const congure_snd_driver_t *methods);
 
 #ifdef __cplusplus
 }
diff --git a/sys/include/crypto/aes.h b/sys/include/crypto/aes.h
index 5a57d33f75..2055dbb76a 100644
--- a/sys/include/crypto/aes.h
+++ b/sys/include/crypto/aes.h
@@ -13,6 +13,14 @@
  * @file
  * @brief       Headers for the implementation of the AES cipher-algorithm
  *
+ * The default key size is 128 bits. To use a different key size add
+ * USEMODULE += crypto_aes_192 and/or USEMODULE += crypto_aes_256 to
+ * your Makefile.
+ *
+ * If only one key size is needed and that key size is not 128 bits, the 128 bit
+ * key size can be disabled with DISABLE_MODULE += crypto_aes_128 as an
+ * optimization.
+ *
  * @author      Freie Universitaet Berlin, Computer Systems & Telematics
  * @author      Nicolai Schmittberger <nicolai.schmittberger@fu-berlin.de>
  * @author      Fabrice Bellard
@@ -46,20 +54,26 @@ typedef uint8_t u8;
 
 #define AES_MAXNR         14
 #define AES_BLOCK_SIZE    16
-#define AES_KEY_SIZE      16
+
+/**
+ * @name AES key sizes
+ * @{
+ */
+#define AES_KEY_SIZE_128    16
+#define AES_KEY_SIZE_192    24
+#define AES_KEY_SIZE_256    32
+/** @} */
 
 /**
  * @brief AES key
  * @see cipher_context_t
  */
-struct aes_key_st {
+typedef struct aes_key_st {
     /** @cond INTERNAL */
     uint32_t rd_key[4 * (AES_MAXNR + 1)];
     int rounds;
     /** @endcond */
-};
-
-typedef struct aes_key_st AES_KEY;
+} AES_KEY;
 
 /**
  * @brief the cipher_context_t-struct adapted for AES
diff --git a/sys/include/crypto/ciphers.h b/sys/include/crypto/ciphers.h
index d66e7a54e4..152dc2b662 100644
--- a/sys/include/crypto/ciphers.h
+++ b/sys/include/crypto/ciphers.h
@@ -23,6 +23,7 @@
 #define CRYPTO_CIPHERS_H
 
 #include <stdint.h>
+#include "kernel_defines.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -30,20 +31,29 @@ extern "C" {
 
 /* Shared header file for all cipher algorithms */
 
-/** @brief the length of keys in bytes */
-#define CIPHERS_MAX_KEY_SIZE 20
+/** @brief the length of keys in bytes
+ *
+ * As of now AES is the only cipher which supports different key sizes.
+ * Here we optimize the CIPHERS_MAX_KEY_SIZE to always have the smallest possible
+ * value based on which AES key sizes are used.
+ */
+#if IS_USED(MODULE_CRYPTO_AES_256)
+    #define CIPHERS_MAX_KEY_SIZE 32
+#elif IS_USED(MODULE_CRYPTO_AES_192)
+    #define CIPHERS_MAX_KEY_SIZE 24
+#else
+    #define CIPHERS_MAX_KEY_SIZE 16
+#endif
 #define CIPHER_MAX_BLOCK_SIZE 16
 
 /**
  * Context sizes needed for the different ciphers.
  * Always order by number of bytes descending!!! <br><br>
  *
- * threedes     needs 24  bytes                           <br>
  * aes          needs CIPHERS_MAX_KEY_SIZE bytes          <br>
  */
-#if defined(MODULE_CRYPTO_3DES)
-    #define CIPHER_MAX_CONTEXT_SIZE 24
-#elif defined(MODULE_CRYPTO_AES)
+#if IS_USED(MODULE_CRYPTO_AES_256) || IS_USED(MODULE_CRYPTO_AES_192) || \
+    IS_USED(MODULE_CRYPTO_AES_128)
     #define CIPHER_MAX_CONTEXT_SIZE CIPHERS_MAX_KEY_SIZE
 #else
 /* 0 is not a possibility because 0-sized arrays are not allowed in ISO C */
@@ -56,7 +66,8 @@ extern "C" {
 #define CIPHER_ERR_INVALID_LENGTH     -4
 #define CIPHER_ERR_ENC_FAILED         -5
 #define CIPHER_ERR_DEC_FAILED         -6
-/** Is returned by the cipher_init functions, if the corresponding alogirithm has not been included in the build */
+/** Is returned by the cipher_init functions, if the corresponding algorithm
+ * has not been included in the build */
 #define CIPHER_ERR_BAD_CONTEXT_SIZE    0
 /**  Returned by cipher_init upon successful initialization of a cipher. */
 #define CIPHER_INIT_SUCCESS            1
@@ -65,7 +76,8 @@ extern "C" {
  * @brief   the context for cipher-operations
  */
 typedef struct {
-    uint8_t context[CIPHER_MAX_CONTEXT_SIZE];  /**< buffer for cipher operations */
+    uint8_t key_size;                           /**< key size used */
+    uint8_t context[CIPHER_MAX_CONTEXT_SIZE];   /**< buffer for cipher operations */
 } cipher_context_t;
 
 
@@ -96,8 +108,18 @@ typedef struct cipher_interface_st {
 
 typedef const cipher_interface_t *cipher_id_t;
 
+/**
+ * @brief AES_128 cipher id
+ *
+ * @deprecated Use @ref CIPHER_AES instead. Will be removed after 2021.07
+ * release.
+ */
 extern const cipher_id_t CIPHER_AES_128;
 
+/**
+ * @brief AES cipher id
+ */
+extern const cipher_id_t CIPHER_AES;
 
 /**
  * @brief basic struct for using block ciphers
diff --git a/sys/include/event/periodic.h b/sys/include/event/periodic.h
new file mode 100644
index 0000000000..408e8f0eef
--- /dev/null
+++ b/sys/include/event/periodic.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     sys_event
+ * @brief       Provides functionality to trigger periodic events
+ *
+ * event_periodic intentionally doesn't extend event structures in order to
+ * support events that are integrated in larger structs intrusively.
+ *
+ * Example:
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~ {.c}
+ * event_periodic_t event_periodic;
+ *
+ * printf("posting timed callback every 1sec\n");
+ * event_periodic_init(&event_periodic, ZTIMER_USEC, &queue, (event_t*)&event);
+ * event_periodic_start(&event_periodic, 1000000);
+ * [...]
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * @{
+ *
+ * @file
+ * @brief       Event Periodic API
+ *
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ *
+ */
+
+#ifndef EVENT_PERIODIC_H
+#define EVENT_PERIODIC_H
+
+#include "event.h"
+#include "ztimer/periodic.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief   Timeout Event structure
+ */
+typedef struct {
+    ztimer_periodic_t timer;    /**< ztimer object used for timeout */
+    event_queue_t *queue;       /**< event queue to post event to */
+    event_t *event;             /**< event to post after timeout */
+} event_periodic_t;
+
+/**
+ * @brief    Initialize a periodic event timeout
+ *
+ * @param[in]       event_periodic  event_periodic object to initialize
+ * @param[in]       clock           the clock to configure this timer on
+ * @param[in]       queue           queue that the timed-out event will be
+ *                                  added to
+ * @param[in]       event           event to add to queue after timeout
+ */
+void event_periodic_init(event_periodic_t *event_periodic, ztimer_clock_t *clock,
+                         event_queue_t *queue, event_t *event);
+
+/**
+ * @brief   Starts a periodic timeout
+ *
+ * This will make the event as configured in @p event_periodic be triggered
+ * at every interval ticks (based on event_periodic->clock).
+ *
+ * @note: the used event_periodic struct must stay valid until after the timeout
+ *        event has been processed!
+ *
+ * @param[in]   event_periodic   event_timout context object to use
+ * @param[in]   interval         period length for the event
+ */
+static inline void event_periodic_start(event_periodic_t *event_periodic,
+                                        uint32_t interval)
+{
+    event_periodic->timer.interval = interval;
+    ztimer_periodic_start(&event_periodic->timer);
+}
+
+/**
+ * @brief   Stop a periodic timeout event
+ *
+ * Calling this function will cancel the timeout by removing its underlying
+ * timer. If the timer has already fired before calling this function, the
+ * connected event will be put already into the given event queue and this
+ * function does not have any effect.
+ *
+ * @param[in]   event_periodic  event_periodic_timeout context object to use
+ */
+static inline void event_periodic_stop(event_periodic_t *event_periodic)
+{
+    ztimer_periodic_stop(&event_periodic->timer);
+}
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* EVENT_PERIODIC_H */
+/** @} */
diff --git a/sys/include/event/timeout.h b/sys/include/event/timeout.h
index 774e22f905..6b2522facc 100644
--- a/sys/include/event/timeout.h
+++ b/sys/include/event/timeout.h
@@ -38,7 +38,11 @@
 #define EVENT_TIMEOUT_H
 
 #include "event.h"
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+#include "ztimer.h"
+#else
 #include "xtimer.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -48,14 +52,34 @@ extern "C" {
  * @brief   Timeout Event structure
  */
 typedef struct {
-    xtimer_t timer;         /**< xtimer object used for timeout */
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER)
+    ztimer_t timer;         /**< ztimer object used for timeout */
+    ztimer_clock_t *clock;  /**< ztimer clock to use */
+#else
+    xtimer_t timer;         /**< ztimer object used for timeout */
+#endif
     event_queue_t *queue;   /**< event queue to post event to   */
     event_t *event;         /**< event to post after timeout    */
 } event_timeout_t;
 
+#if IS_USED(MODULE_EVENT_TIMEOUT_ZTIMER) || DOXYGEN
+/**
+ * @brief   Initialize timeout event object
+ *
+ * @param[in]   event_timeout   event_timeout object to initialize
+ * @param[in]   clock           the clock backend, eg: ZTIMER_USEC, ZTIMER_MSEC
+ * @param[in]   queue           queue that the timed-out event will be added to
+ * @param[in]   event           event to add to queue after timeout
+ */
+void event_timeout_ztimer_init(event_timeout_t *event_timeout, ztimer_clock_t *clock,
+                               event_queue_t *queue, event_t *event);
+#endif
+
 /**
  * @brief   Initialize timeout event object
  *
+ * @note    If ztimer is used the default time clock backend is ZTIMER_USEC
+ *
  * @param[in]   event_timeout   event_timeout object to initialize
  * @param[in]   queue           queue that the timed-out event will be added to
  * @param[in]   event           event to add to queue after timeout
@@ -67,13 +91,15 @@ void event_timeout_init(event_timeout_t *event_timeout, event_queue_t *queue,
  * @brief   Set a timeout
  *
  * This will make the event as configured in @p event_timeout be triggered
- * after @p timeout microseconds.
+ * after @p timeout microseconds (if using @ref xtimer) or the the @ref
+ * ztimer_clock_t ticks.
  *
  * @note: the used event_timeout struct must stay valid until after the timeout
  *        event has been processed!
  *
  * @param[in]   event_timeout   event_timout context object to use
- * @param[in]   timeout         timeout in microseconds
+ * @param[in]   timeout         timeout in microseconds ot the ztimer_clock_t
+ *                              ticks units
  */
 void event_timeout_set(event_timeout_t *event_timeout, uint32_t timeout);
 
diff --git a/sys/include/net/dhcpv6.h b/sys/include/net/dhcpv6.h
index 817d9d96e5..47497cf642 100644
--- a/sys/include/net/dhcpv6.h
+++ b/sys/include/net/dhcpv6.h
@@ -65,6 +65,7 @@ extern "C" {
 #define DHCPV6_OPT_PREF             (7U)    /**< preference option */
 #define DHCPV6_OPT_ELAPSED_TIME     (8U)    /**< elapsed time option */
 #define DHCPV6_OPT_STATUS           (13U)   /**< status code option */
+#define DHCPV6_OPT_DNS_RNS          (23U)   /**< DNS recursive name server option */
 #define DHCPV6_OPT_IA_PD            (25U)   /**< identity association for prefix
                                              *   delegation (IA_PD) option */
 #define DHCPV6_OPT_IAPFX            (26U)   /**< IA prefix option */
diff --git a/sys/include/net/eui_provider.h b/sys/include/net/eui_provider.h
index 44f46a2d9d..a856406815 100644
--- a/sys/include/net/eui_provider.h
+++ b/sys/include/net/eui_provider.h
@@ -75,10 +75,13 @@
  * Recommendations
  * ===============
  *
- * While it is possible to match EUIs with any netdev in a first come, first serve
- * fashion (`NETDEV_ANY`, `NETDEV_INDEX_ANY`) it is recommended to fix the EUI
- * providers to a device and interface to avoid them being used for 'virtual'
- * interfaces.
+ * Do not use `NETDEV_ANY` as EUI device type. Otherwise if you have two
+ * interfaces both will match the same EUI.
+ *
+ * It is however possible to use `NETDEV_INDEX_ANY` if you have multiple
+ * interfaces of the same type and your EUI provider function takes the index
+ * into account (or returns error if the index is out of bounds with the
+ * available ids).
  *
  * Fixed addresses are only guaranteed if the network devices are also fixed.
  * E.g. if you usually have two netdevs and disable the first one at compile-time
@@ -132,7 +135,7 @@ typedef int (*netdev_get_eui64_cb_t)(uint8_t index, eui64_t *addr);
  */
 typedef struct {
     netdev_get_eui48_cb_t provider; /**< function to provide an EUI-48                  */
-    netdev_type_t type;             /**< device type to match or `NETDEV_ANY`           */
+    netdev_type_t type;             /**< device type to match                           */
     uint8_t index;                  /**< device index to match or `NETDEV_INDEX_ANY`    */
 } eui48_conf_t;
 
@@ -141,7 +144,7 @@ typedef struct {
  */
 typedef struct {
     netdev_get_eui64_cb_t provider; /**< function to provide an EUI-64                  */
-    netdev_type_t type;             /**< device type to match or `NETDEV_ANY`           */
+    netdev_type_t type;             /**< device type to match                           */
     uint8_t index;                  /**< device index to match or `NETDEV_INDEX_ANY`    */
 } eui64_conf_t;
 
diff --git a/sys/include/net/gcoap.h b/sys/include/net/gcoap.h
index 433dc8a283..dfd2ed7636 100644
--- a/sys/include/net/gcoap.h
+++ b/sys/include/net/gcoap.h
@@ -800,9 +800,9 @@ static inline ssize_t gcoap_request(coap_pkt_t *pdu, uint8_t *buf, size_t len,
  * @return  length of the packet
  * @return  0 if cannot send
  */
-size_t gcoap_req_send(const uint8_t *buf, size_t len,
-                      const sock_udp_ep_t *remote,
-                      gcoap_resp_handler_t resp_handler, void *context);
+ssize_t gcoap_req_send(const uint8_t *buf, size_t len,
+                       const sock_udp_ep_t *remote,
+                       gcoap_resp_handler_t resp_handler, void *context);
 
 /**
  * @brief   Initializes a CoAP response packet on a buffer
diff --git a/sys/include/net/gnrc/dhcpv6/client/6lbr.h b/sys/include/net/gnrc/dhcpv6/client/simple_pd.h
similarity index 79%
rename from sys/include/net/gnrc/dhcpv6/client/6lbr.h
rename to sys/include/net/gnrc/dhcpv6/client/simple_pd.h
index c35cfd484c..c20697a474 100644
--- a/sys/include/net/gnrc/dhcpv6/client/6lbr.h
+++ b/sys/include/net/gnrc/dhcpv6/client/simple_pd.h
@@ -7,9 +7,10 @@
  */
 
 /**
- * @defgroup    net_dhcpv6_client_6lbr  DHCPv6 client for 6LoWPAN border routers
+ * @defgroup    net_dhcpv6_client_6lbr  DHCPv6 client for simple prefix
+ *              delegation
  * @ingroup     net_dhcpv6_client
- * @brief       DHCPv6 client bootstrapping for 6LoWPAN border routers
+ * @brief       DHCPv6 client bootstrapping for routers & 6LoWPAN border routers
  * @{
  *
  * @file
@@ -17,8 +18,8 @@
  *
  * @author  Martine S. Lenders <m.lenders@fu-berlin.de>
  */
-#ifndef NET_GNRC_DHCPV6_CLIENT_6LBR_H
-#define NET_GNRC_DHCPV6_CLIENT_6LBR_H
+#ifndef NET_GNRC_DHCPV6_CLIENT_SIMPLE_PD_H
+#define NET_GNRC_DHCPV6_CLIENT_SIMPLE_PD_H
 
 #ifdef __cplusplus
 extern "C" {
@@ -60,15 +61,15 @@ extern "C" {
 #endif
 
 /**
- * @brief   Initializes the DHCPv6 client for 6LoWPAN border router
+ * @brief   Initializes the DHCPv6 client for simple prefix delegation
  *
  * @note    Called by `auto_init` when included
  */
-void gnrc_dhcpv6_client_6lbr_init(void);
+void gnrc_dhcpv6_client_simple_pd_init(void);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* NET_GNRC_DHCPV6_CLIENT_6LBR_H */
+#endif /* NET_GNRC_DHCPV6_CLIENT_SIMPLE_PD_H */
 /** @} */
diff --git a/sys/include/net/gnrc/lorawan.h b/sys/include/net/gnrc/lorawan.h
index 0518fd9b16..1571b3153c 100644
--- a/sys/include/net/gnrc/lorawan.h
+++ b/sys/include/net/gnrc/lorawan.h
@@ -34,18 +34,6 @@ extern "C" {
  * @ingroup net_gnrc_conf
  * @{
  */
-/**
- * @brief maximum timer drift in per mille
- *
- * @note this is only a workaround to compensate inaccurate timers.
- *
- * E.g a value of 1 means there's a positive drift of 0.1% (set timeout to
- * 1000 ms => triggers after 1001 ms)
- */
-#ifndef CONFIG_GNRC_LORAWAN_TIMER_DRIFT
-#define CONFIG_GNRC_LORAWAN_TIMER_DRIFT 10
-#endif
-
 /**
  * @brief the minimum symbols to detect a LoRa preamble
  */
@@ -188,6 +176,24 @@ void gnrc_lorawan_radio_rx_timeout_cb(gnrc_lorawan_t *mac);
  */
 void gnrc_lorawan_radio_tx_done_cb(gnrc_lorawan_t *mac);
 
+/**
+ * @brief Indicate the MAC layer reception of a frame went wrong.
+ *
+ * @param[in] mac pointer to the MAC descriptor
+ */
+static inline void gnrc_lorawan_radio_rx_error_cb(gnrc_lorawan_t *mac)
+{
+    /* The failed reception is seen by the MAC layer as an RX timeout */
+    gnrc_lorawan_radio_rx_timeout_cb(mac);
+}
+
+/**
+ * @brief Indicate the MAC layer that the timer was fired
+ *
+ * @param[in] mac pointer to the MAC descriptor
+ */
+void gnrc_lorawan_timeout_cb(gnrc_lorawan_t *mac);
+
 /**
  * @brief Init GNRC LoRaWAN
  *
@@ -231,8 +237,9 @@ void gnrc_lorawan_mcps_request(gnrc_lorawan_t *mac,
  *        To be called on radio RX done event.
  *
  * @param[in] mac pointer to the MAC descriptor
- * @param[in] data pointer to the psdu. Pass NULL if the packet was wrong (or
- * allocation failed)
+ * @param[in] data pointer to the psdu. Must not be NULL. Use
+ *            @ref gnrc_lorawan_radio_rx_error_cb instead if the reception was
+ *            not successful.
  * @param[in] size size of the PSDU
  */
 void gnrc_lorawan_radio_rx_done_cb(gnrc_lorawan_t *mac, uint8_t *data,
@@ -296,6 +303,23 @@ netdev_t *gnrc_lorawan_get_netdev(gnrc_lorawan_t *mac);
  */
 int gnrc_lorawan_phy_set_channel_mask(gnrc_lorawan_t *mac, uint16_t channel_mask);
 
+/**
+ * @brief Set a timer with the given time
+ * @note Supposed to be implemented by the user of GNRC LoRaWAN
+ *
+ * @param[in] mac pointer to the MAC descriptor
+ * @param us timeout microseconds
+ */
+void gnrc_lorawan_set_timer(gnrc_lorawan_t *mac, uint32_t us);
+
+/**
+ * @brief Remove the current timer
+ * @note Supposed to be implemented by the user of GNRC LoRaWAN
+ *
+ * @param[in] mac pointer to the MAC descriptor
+ */
+void gnrc_lorawan_remove_timer(gnrc_lorawan_t *mac);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sys/include/net/gnrc/netif/conf.h b/sys/include/net/gnrc/netif/conf.h
index 1ade168799..dc5556c77e 100644
--- a/sys/include/net/gnrc/netif/conf.h
+++ b/sys/include/net/gnrc/netif/conf.h
@@ -143,7 +143,7 @@ extern "C" {
  *       address types are included
  */
 #ifndef GNRC_NETIF_L2ADDR_MAXLEN
-#if defined(MODULE_NETDEV_IEEE802154) || defined(MODULE_XBEE)
+#if defined(MODULE_NETDEV_IEEE802154) || defined(MODULE_XBEE) || defined(MODULE_SLIPDEV_L2ADDR)
 #define GNRC_NETIF_L2ADDR_MAXLEN   (IEEE802154_LONG_ADDRESS_LEN)
 #elif   MODULE_NETDEV_ETH
 #define GNRC_NETIF_L2ADDR_MAXLEN   (ETHERNET_ADDR_LEN)
diff --git a/sys/include/net/gnrc/netif/flags.h b/sys/include/net/gnrc/netif/flags.h
index d269fdda70..2d02e80cc3 100644
--- a/sys/include/net/gnrc/netif/flags.h
+++ b/sys/include/net/gnrc/netif/flags.h
@@ -27,9 +27,9 @@ extern "C" {
  * @anchor  net_gnrc_netif_aac
  */
 enum {
-    GNRC_NETIF_AAC_NONE = 0,    /**< no configuration */
-    GNRC_NETIF_AAC_AUTO,        /**< Use some automatic bootstrapping (e.g. SLAAC with IPv6) */
-    GNRC_NETIF_AAC_DHCP,        /**< Use DHCP(v6) */
+    GNRC_NETIF_AAC_NONE = 0x00, /**< no configuration */
+    GNRC_NETIF_AAC_AUTO = 0x01, /**< Use some automatic bootstrapping (e.g. SLAAC with IPv6) */
+    GNRC_NETIF_AAC_DHCP = 0x02, /**< Use DHCP(v6) */
     /* extend if needed */
 };
 
@@ -82,7 +82,7 @@ enum {
 #define GNRC_NETIF_FLAGS_IPV6_ADV_RETRANS_TIMER    (0x00000040U)
 
 /**
- * @brief   If gnrc_netif_t::ipv6::aac_mode == GNRC_NETIF_AAC_DHCP then this
+ * @brief   If gnrc_netif_t::ipv6::aac_mode & GNRC_NETIF_AAC_DHCP then this
  *          flag indicates that other configuration information is available via
  *          DHCPv6 (e.g. DNS-related information)
  *
diff --git a/sys/include/net/gnrc/netif/ipv6.h b/sys/include/net/gnrc/netif/ipv6.h
index 5fb6acbada..8bd2ec0ca2 100644
--- a/sys/include/net/gnrc/netif/ipv6.h
+++ b/sys/include/net/gnrc/netif/ipv6.h
@@ -243,7 +243,7 @@ typedef struct {
 #endif /* MODULE_GNRC_IPV6_NIB */
 
     /**
-     * @brief   IPv6 auto-address configuration mode
+     * @brief   IPv6 auto-address configuration mode flags
      *
      * @note    Only available with module @ref net_gnrc_ipv6 "gnrc_ipv6"
      */
diff --git a/sys/include/net/gnrc/netif/lorawan.h b/sys/include/net/gnrc/netif/lorawan.h
index ed7647cf6f..d544ed1da7 100644
--- a/sys/include/net/gnrc/netif/lorawan.h
+++ b/sys/include/net/gnrc/netif/lorawan.h
@@ -20,6 +20,8 @@
 
 #include "net/gnrc/lorawan.h"
 
+#include "ztimer.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -29,6 +31,21 @@ extern "C" {
  */
 #define GNRC_NETIF_LORAWAN_FLAGS_LINK_CHECK                (0x1U)
 
+/**
+ * @brief Encode LoRaWAN port in GNRC netif header.
+ *
+ * When set, GNRC netif will interpret the destination address of the
+ * GNRC netif header as the LoRaWAN port. For downlinks, a GNRC netif header
+ * with the received port in destination field will be included in the
+ * first snip.
+ *
+ * @deprecated From Release 2021.10 all GNRC LoRaWAN packets will include
+ * the GNRC Netif header. Therefore this parameter will be removed
+ */
+#if defined(DOXYGEN)
+#define CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR
+#endif
+
 /**
  * @brief   GNRC LoRaWAN interface descriptor
  */
@@ -39,6 +56,8 @@ typedef struct {
     uint8_t deveui[LORAMAC_DEVEUI_LEN];     /**< Device EUI buffer */
     uint8_t appeui[LORAMAC_APPEUI_LEN];     /**< App EUI buffer */
     gnrc_lorawan_t mac;                     /**< gnrc lorawan mac descriptor */
+    ztimer_t timer;                         /**< General purpose timer */
+    ztimer_t backoff_timer;                 /**< Backoff timer */
     uint8_t flags;                          /**< flags for the LoRaWAN interface */
     uint8_t demod_margin;                   /**< value of last demodulation margin */
     uint8_t num_gateways;                   /**< number of gateways of last link check */
diff --git a/sys/include/net/gnrc/rpl.h b/sys/include/net/gnrc/rpl.h
index 9b4d6b6036..90a477da79 100644
--- a/sys/include/net/gnrc/rpl.h
+++ b/sys/include/net/gnrc/rpl.h
@@ -152,7 +152,6 @@
 #include "net/gnrc/rpl/dodag.h"
 #include "net/gnrc/rpl/of_manager.h"
 #include "net/fib.h"
-#include "xtimer.h"
 #include "trickle.h"
 
 #ifdef MODULE_NETSTATS_RPL
diff --git a/sys/include/net/gnrc/tx_sync.h b/sys/include/net/gnrc/tx_sync.h
index 107697b522..5b8c2159f5 100644
--- a/sys/include/net/gnrc/tx_sync.h
+++ b/sys/include/net/gnrc/tx_sync.h
@@ -108,7 +108,7 @@ gnrc_pktsnip_t * gnrc_tx_sync_split(gnrc_pktsnip_t *pkt);
 static inline void gnrc_tx_complete(gnrc_pktsnip_t *pkt)
 {
     assert(IS_USED(MODULE_GNRC_TX_SYNC) && (pkt->type == GNRC_NETTYPE_TX_SYNC));
-    gnrc_tx_sync_t *sync = pkt->data;
+    gnrc_tx_sync_t *sync = (gnrc_tx_sync_t*)pkt->data;
     mutex_unlock(&sync->signal);
 }
 
diff --git a/sys/include/net/ieee802154.h b/sys/include/net/ieee802154.h
index 17769ea4c7..7994e839bd 100644
--- a/sys/include/net/ieee802154.h
+++ b/sys/include/net/ieee802154.h
@@ -301,6 +301,13 @@ extern const uint8_t ieee802154_addr_bcast[IEEE802154_ADDR_BCAST_LEN];
 #define CONFIG_IEEE802154_CCA_THRESH_DEFAULT       (-70)
 #endif
 
+/**
+ * @brief Disable Auto ACK support
+ */
+#ifdef DOXYGEN
+#define CONFIG_IEEE802154_AUTO_ACK_DISABLE 0
+#endif
+
 /**
  * @brief   Initializes an IEEE 802.15.4 MAC frame header in @p buf.
  *
@@ -389,6 +396,25 @@ int ieee802154_get_src(const uint8_t *mhr, uint8_t *src, le_uint16_t *src_pan);
  */
 int ieee802154_get_dst(const uint8_t *mhr, uint8_t *dst, le_uint16_t *dst_pan);
 
+/**
+ * @brief  Check whether a frame pass the IEEE 802.15.4 frame filter.
+ *
+ * A frame passes the frame filter only if:
+ * - The PAN ID matches the PAN ID of the frame filter or the broadcast PAN ID
+ * - Either the Short or Extended Address matches the frame filter OR the
+ *   Short Address is the broadcast address.
+ *
+ * @param[in] mhr           MAC header (PSDU)
+ * @param[in] pan           PAN ID of the frame filter.
+ * @param[in] short_addr    Short Address of the frame filter.
+ * @param[in] ext_addr      Extended Address of the frame filter.
+ *
+ * @return 0            if frame passes the frame filter.
+ * @return 1            if frame doesn't pass the frame filter.
+ */
+int ieee802154_dst_filter(const uint8_t *mhr, uint16_t pan,
+                          network_uint16_t short_addr, const eui64_t *ext_addr);
+
 /**
  * @brief   Gets sequence number from MAC header.
  *
diff --git a/sys/include/net/ieee802154/radio.h b/sys/include/net/ieee802154/radio.h
index aa2ef4b6a6..cb42d7abad 100644
--- a/sys/include/net/ieee802154/radio.h
+++ b/sys/include/net/ieee802154/radio.h
@@ -148,6 +148,15 @@ typedef enum {
      * @brief Multi-Rate Frequency Shift Keying PHY mode
      */
     IEEE802154_CAP_PHY_MR_FSK           = BIT17,
+    /**
+     * @brief the device supports source address match table.
+     *
+     * A Source Address Match table contains source addresses with pending
+     * data. When a coordinator device receives an IEEE 802.15.4 Data
+     * Request command from a child node, the Frame Pending bit of the ACK is
+     * set if the source address matches one from the table.
+     */
+    IEEE802154_CAP_SRC_ADDR_MATCH       = BIT18,
 } ieee802154_rf_caps_t;
 
 /**
@@ -288,6 +297,87 @@ typedef enum {
     IEEE802154_RADIO_CONFIRM_CCA,
 } ieee802154_trx_ev_t;
 
+/**
+ * @brief Source Address Match commands.
+ */
+typedef enum {
+    /**
+     * @brief Enable or disable source address match.
+     *
+     * Enabling it sets the frame pending to all ACK frames in
+     * response to a Data Request command (if the radio doesn't
+     * support Source Address Matching) or to a specific address
+     * in the Source Address Matching table
+     */
+    IEEE802154_SRC_MATCH_EN,
+    /**
+     * @brief Add a short address to entry.
+     *
+     * This command should only be implemented if @ref IEEE802154_CAP_SRC_ADDR_MATCH
+     * is available.
+     */
+    IEEE802154_SRC_MATCH_SHORT_ADD,
+    /**
+     * @brief Clear short address from entry.
+     * This command should only be implemented if @ref IEEE802154_CAP_SRC_ADDR_MATCH
+     * is available.
+     */
+    IEEE802154_SRC_MATCH_SHORT_CLEAR,
+    /**
+     * @brief Add a extended address to entry.
+     * This command should only be implemented if @ref IEEE802154_CAP_SRC_ADDR_MATCH
+     * is available.
+     */
+    IEEE802154_SRC_MATCH_EXT_ADD,
+    /**
+     * @brief Clear extended address from entry.
+     *
+     * This command should only be implemented if @ref IEEE802154_CAP_SRC_ADDR_MATCH
+     * is available.
+     */
+    IEEE802154_SRC_MATCH_EXT_CLEAR,
+} ieee802154_src_match_t;
+
+/**
+ * @brief Address filter command
+ */
+typedef enum {
+    IEEE802154_AF_SHORT_ADDR, /**< Set short IEEE 802.15.4 address (network_uint16_t) */
+    IEEE802154_AF_EXT_ADDR,   /**< Set extended IEEE 802.15.4 address (eui64_t) */
+    IEEE802154_AF_PANID,      /**< Set PAN ID (uint16_t) */
+    IEEE802154_AF_PAN_COORD,  /**< Set device as PAN coordinator (bool) */
+} ieee802154_af_cmd_t;
+
+/**
+ * @brief Frame Filter mode
+ */
+typedef enum {
+    /**
+     * @brief accept all valid frames that match address filter configuration
+     */
+    IEEE802154_FILTER_ACCEPT,
+    /**
+     * @brief accept only ACK frames
+     *
+     * @note This mode should only be implemented if the transceiver doesn't
+     * handle ACK frame reception (when @ref IEEE802154_CAP_FRAME_RETRANS and
+     * @ref IEEE802154_CAP_IRQ_ACK_TIMEOUT are not present).
+     */
+    IEEE802154_FILTER_ACK_ONLY,
+    /**
+     * @brief accept all valid frames
+     *
+     * @note This mode is optional
+     */
+    IEEE802154_FILTER_PROMISC,
+    /**
+     * @brief accept all frames, regardless of FCS
+     *
+     * @note This mode is optional
+     */
+    IEEE802154_FILTER_SNIFFER,
+} ieee802154_filter_mode_t;
+
 /**
  * @brief CSMA-CA exponential backoff parameters.
  */
@@ -372,40 +462,6 @@ typedef enum {
     IEEE802154_CCA_MODE_ED_THRESH_OR_CS,
 } ieee802154_cca_mode_t;
 
-/**
- * @brief RX mode configuration
- */
-typedef enum {
-    /**
-     * @brief Auto ACK is disabled
-     */
-    IEEE802154_RX_AACK_DISABLED,
-    /**
-     * @brief Auto ACK is enabled
-     */
-    IEEE802154_RX_AACK_ENABLED,
-    /**
-     * @brief Auto ACK is enabled and frame pending bit set in the next ACK frame
-     */
-    IEEE802154_RX_AACK_FRAME_PENDING,
-    /**
-     * @brief Radio is in promiscuous mode
-     */
-    IEEE802154_RX_PROMISC,
-    /**
-     * @brief Radio is ready to receive ACK frames
-     *
-     * This mode is optional. If a radio decides to implement it, the radio
-     * should allow ACK frames (and block ACK frames in all other RX modes).
-     * Note that this mode cannot guarantee that only ACK frames will be
-     * received.
-     *
-     * Expected to be implemented when either @ref IEEE802154_CAP_FRAME_RETRANS
-     * or @ref IEEE802154_CAP_IRQ_ACK_TIMEOUT is not there.
-     */
-    IEEE802154_RX_WAIT_FOR_ACK,
-} ieee802154_rx_mode_t;
-
 /**
  * @brief Holder of the PHY configuration
  */
@@ -565,9 +621,10 @@ struct ieee802154_radio_ops {
      * - @ref set_cca_threshold
      * - @ref set_cca_mode
      * - @ref config_phy
+     * - @ref config_addr_filter
      * - @ref set_csma_params
-     * - @ref set_rx_mode
-     * - @ref set_hw_addr_filter
+     * - @ref set_frame_filter_mode
+     * - @ref config_src_addr_match
      * - @ref set_frame_retrans (if available)
      *
      * @param[in] dev IEEE802.15.4 device descriptor
@@ -698,26 +755,6 @@ struct ieee802154_radio_ops {
      */
     int (*config_phy)(ieee802154_dev_t *dev, const ieee802154_phy_conf_t *conf);
 
-    /**
-     * @brief Set IEEE802.15.4 addresses in hardware address filter
-     *
-     * @pre the device is on
-     *
-     * @param[in] dev IEEE802.15.4 device descriptor
-     * @param[in] short_addr the IEEE802.15.4 short address. If NULL, the short
-     *            address is not altered..
-     * @param[in] ext_addr the IEEE802.15.4 extended address (Network Byte Order).
-     *            If NULL, the extended address is not altered.
-     * @param[in] pan_id the IEEE802.15.4 PAN ID. If NULL, the PAN ID is not altered.
-     *
-     * @return 0 on success
-     * @return negative errno on error
-     */
-    int (*set_hw_addr_filter)(ieee802154_dev_t *dev,
-                              const network_uint16_t *short_addr,
-                              const eui64_t *ext_addr,
-                              const uint16_t *pan_id);
-
     /**
      * @brief Set number of frame retransmissions
      *
@@ -756,15 +793,55 @@ struct ieee802154_radio_ops {
                            int8_t retries);
 
     /**
-     * @brief Set the RX mode.
+     * @brief Set the frame filter moder.
+     *
+     * @pre the device is on
+     *
+     * @param[in] dev IEEE802.15.4 device descriptor
+     * @param[in] mode address filter mode
+     *
+     * @return 0 on success
+     * @return negative errno on error
+     */
+    int (*set_frame_filter_mode)(ieee802154_dev_t *dev, ieee802154_filter_mode_t mode);
+
+    /**
+     * @brief Configure the address filter.
+     *
+     * This functions is used for configuring the address filter parameters
+     * required by the IEEE 802.15.4 standard.
+     *
+     * @pre the device is on
+     *
+     * @param[in] dev IEEE802.15.4 device descriptor
+     * @param[in] cmd command for the address filter
+     * @param[in] value value for @p cmd.
+     *
+     * @return 0 on success
+     * @return negative errno on error
+     */
+    int (*config_addr_filter)(ieee802154_dev_t *dev, ieee802154_af_cmd_t cmd, const void *value);
+
+    /**
+     * @brief Set the source address match configuration.
+     *
+     * This function configures the source address match filter in order to set
+     * the Frame Pending bit in ACK frames accordingly.
+     * In case the radio doesn't support @ref IEEE802154_CAP_SRC_ADDR_MATCH,
+     * this functions is used to activate the Frame Pending bit for all ACK
+     * frames (in order to be compliant with the IEEE 802.15.4 standard).
+     *
+     * @pre the device is on
      *
      * @param[in] dev IEEE802.15.4 device descriptor
-     * @param[in] mode RX mode
+     * @param[in] cmd command for the source address match configuration
+     * @param[in] value value associated to @p cmd.
      *
      * @return 0 on success
      * @return negative errno on error
      */
-    int (*set_rx_mode)(ieee802154_dev_t *dev, ieee802154_rx_mode_t mode);
+    int (*config_src_addr_match)(ieee802154_dev_t *dev, ieee802154_src_match_t cmd,
+                                 const void *value);
 };
 
 /**
@@ -881,6 +958,24 @@ static inline int ieee802154_radio_config_phy(ieee802154_dev_t *dev,
     return dev->driver->config_phy(dev, conf);
 }
 
+/**
+ * @brief Shortcut to @ref ieee802154_radio_ops::config_src_addr_match
+ *
+ * @pre the device is on
+ *
+ * @param[in] dev IEEE802.15.4 device descriptor
+ * @param[in] cmd command for the source address match configuration
+ * @param[in] value value associated to @p cmd.
+ *
+ * @return  result of @ref ieee802154_radio_ops::config_src_addr_match
+ */
+static inline int ieee802154_radio_config_src_address_match(ieee802154_dev_t *dev,
+                                                            ieee802154_src_match_t cmd,
+                                                            const void *value)
+{
+    return dev->driver->config_src_addr_match(dev, cmd, value);
+}
+
 /**
  * @brief Shortcut to @ref ieee802154_radio_ops::off
  *
@@ -896,25 +991,37 @@ static inline int ieee802154_radio_off(ieee802154_dev_t *dev)
 }
 
 /**
- * @brief Shortcut to @ref ieee802154_radio_ops::set_hw_addr_filter
+ * @brief Shortcut to @ref ieee802154_radio_ops::config_addr_filter
  *
  * @pre the device is on
  *
  * @param[in] dev IEEE802.15.4 device descriptor
- * @param[in] short_addr the IEEE802.15.4 short address. If NULL, the short
- *            address is not altered..
- * @param[in] ext_addr the IEEE802.15.4 extended address (Network Byte Order).
- *            If NULL, the extended address is not altered.
- * @param[in] pan_id the IEEE802.15.4 PAN ID. If NULL, the PAN ID is not altered.
+ * @param[in] cmd command for the address filter
+ * @param[in] value value for @p cmd.
  *
- * @return result of @ref ieee802154_radio_ops::set_hw_addr_filter
+ * @return result of @ref ieee802154_radio_ops::config_addr_filter
  */
-static inline int ieee802154_radio_set_hw_addr_filter(ieee802154_dev_t *dev,
-                                                      const network_uint16_t *short_addr,
-                                                      const eui64_t *ext_addr,
-                                                      const uint16_t *pan_id)
+static inline int ieee802154_radio_config_addr_filter(ieee802154_dev_t *dev,
+                                                  ieee802154_af_cmd_t cmd,
+                                                  const void* value)
 {
-    return dev->driver->set_hw_addr_filter(dev, short_addr, ext_addr, pan_id);
+    return dev->driver->config_addr_filter(dev, cmd, value);
+}
+
+/**
+ * @brief Shortcut to @ref ieee802154_radio_ops::set_frame_filter_mode
+ *
+ * @pre the device is on
+ *
+ * @param[in] dev IEEE802.15.4 device descriptor
+ * @param[in] mode frame filter mode
+ *
+ * @return result of @ref ieee802154_radio_ops::set_frame_filter_mode
+ */
+static inline int ieee802154_radio_set_frame_filter_mode(ieee802154_dev_t *dev,
+                                                    ieee802154_filter_mode_t mode)
+{
+    return dev->driver->set_frame_filter_mode(dev, mode);
 }
 
 /**
@@ -1303,20 +1410,6 @@ static inline uint32_t ieee802154_radio_get_phy_modes(ieee802154_dev_t *dev)
     return (dev->driver->caps & IEEE802154_RF_CAPS_PHY_MASK);
 }
 
-/**
- * @brief Shortcut to @ref ieee802154_radio_ops::set_rx_mode
- *
- * @param[in] dev IEEE802.15.4 device descriptor
- * @param[in] mode RX mode
- *
- * @return result of @ref ieee802154_radio_ops::set_rx_mode
- */
-static inline int ieee802154_radio_set_rx_mode(ieee802154_dev_t *dev,
-                                               ieee802154_rx_mode_t mode)
-{
-    return dev->driver->set_rx_mode(dev, mode);
-}
-
 /**
  * @brief Convert a @ref ieee802154_phy_mode_t to a @ref ieee802154_rf_caps_t
  * value.
diff --git a/sys/include/net/ieee802154/submac.h b/sys/include/net/ieee802154/submac.h
index 9ec703b231..7f3913c277 100644
--- a/sys/include/net/ieee802154/submac.h
+++ b/sys/include/net/ieee802154/submac.h
@@ -173,8 +173,8 @@ int ieee802154_send(ieee802154_submac_t *submac, const iolist_t *iolist);
 static inline int ieee802154_set_short_addr(ieee802154_submac_t *submac,
                                             const network_uint16_t *short_addr)
 {
-    int res = ieee802154_radio_set_hw_addr_filter(submac->dev, short_addr, NULL,
-                                                  NULL);
+
+    int res = ieee802154_radio_config_addr_filter(submac->dev, IEEE802154_AF_SHORT_ADDR, short_addr);
 
     if (res >= 0) {
         memcpy(&submac->short_addr, short_addr, IEEE802154_SHORT_ADDRESS_LEN);
@@ -195,8 +195,7 @@ static inline int ieee802154_set_short_addr(ieee802154_submac_t *submac,
 static inline int ieee802154_set_ext_addr(ieee802154_submac_t *submac,
                                           const eui64_t *ext_addr)
 {
-    int res = ieee802154_radio_set_hw_addr_filter(submac->dev, NULL, ext_addr,
-                                                  NULL);
+    int res = ieee802154_radio_config_addr_filter(submac->dev, IEEE802154_AF_EXT_ADDR, ext_addr);
 
     if (res >= 0) {
         memcpy(&submac->ext_addr, ext_addr, IEEE802154_LONG_ADDRESS_LEN);
@@ -216,8 +215,7 @@ static inline int ieee802154_set_ext_addr(ieee802154_submac_t *submac,
 static inline int ieee802154_set_panid(ieee802154_submac_t *submac,
                                        const uint16_t *panid)
 {
-    int res = ieee802154_radio_set_hw_addr_filter(submac->dev, NULL, NULL,
-                                                  panid);
+    int res = ieee802154_radio_config_addr_filter(submac->dev, IEEE802154_AF_PANID, panid);
 
     if (res >= 0) {
         submac->panid = *panid;
diff --git a/sys/include/net/ieee802154_security.h b/sys/include/net/ieee802154_security.h
index 58ca1327c3..04cef87df0 100644
--- a/sys/include/net/ieee802154_security.h
+++ b/sys/include/net/ieee802154_security.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 Otto-von-Gericke-Universität Magdeburg
+ * Copyright (C) 2020 Otto-von-Guericke-Universität Magdeburg
  *
  * This file is subject to the terms and conditions of the GNU Lesser
  * General Public License v2.1. See the file LICENSE in the top level
@@ -34,7 +34,7 @@ extern "C" {
 #endif
 
 /**
- * @brief   Forward declaration of an IEEE802.15.4 abstract security device
+ * @brief   Forward declaration of an IEEE 802.15.4 abstract security device
  */
 typedef struct ieee802154_sec_dev ieee802154_sec_dev_t;
 
@@ -88,7 +88,7 @@ typedef struct ieee802154_radio_cipher_ops {
 } ieee802154_radio_cipher_ops_t;
 
 /**
- * @brief IEEE802.15.4 security device descriptor
+ * @brief IEEE 802.15.4 security device descriptor
  */
 struct ieee802154_sec_dev {
     /**
@@ -101,17 +101,14 @@ struct ieee802154_sec_dev {
     void *ctx;
 };
 
-#if !defined(IEEE802154_DEFAULT_KEY) || defined(DOXYGEN)
+#if !defined(CONFIG_IEEE802154_SEC_DEFAULT_KEY) || defined(DOXYGEN)
 /**
- * @brief   AES key that is used in the test vectors from the specification
+ * @brief   AES default key
  *
  * @note    Predefine it yourself,
  *          if you want another key to be set up on initialization
  */
-#define IEEE802154_DEFAULT_KEY                  { 0xc0, 0xc1, 0xc2, 0xc3,   \
-                                                  0xc4, 0xc5, 0xc6, 0xc7,   \
-                                                  0xc8, 0xc9, 0xca, 0xcb,   \
-                                                  0xcc, 0xcd, 0xce, 0xcf }
+#define CONFIG_IEEE802154_SEC_DEFAULT_KEY       "pizza_margherita"
 #endif
 
 /**
@@ -127,68 +124,68 @@ struct ieee802154_sec_dev {
 /**
  * @brief   Maximum length of the security auxiliary header in bytes
  */
-#define IEEE802154_MAX_AUX_HDR_LEN              (14U)
+#define IEEE802154_SEC_MAX_AUX_HDR_LEN          (14U)
 
 /**
  * @brief   Maximum Size of IEEE 802.15.4 MAC
  */
-#define IEEE802154_MAC_SIZE                     (16U)
+#define IEEE802154_SEC_MAX_MAC_SIZE             (16U)
 
 /**
  * @brief   Mask to get security level bits
  */
-#define IEEE802154_SCF_SECLEVEL_MASK            (0x07)
+#define IEEE802154_SEC_SCF_SECLEVEL_MASK        (0x07)
 
 /**
  * @brief   Number of shifts to set/get security level bits
  */
-#define IEEE802154_SCF_SECLEVEL_SHIFT           (0)
+#define IEEE802154_SEC_SCF_SECLEVEL_SHIFT       (0)
 
 /**
  * @brief   Mask to get key mode bits
  */
-#define IEEE802154_SCF_KEYMODE_MASK             (0x18)
+#define IEEE802154_SEC_SCF_KEYMODE_MASK         (0x18)
 
 /**
  * @brief   Number of shifts to set/get key mode bits
  */
-#define IEEE802154_SCF_KEYMODE_SHIFT            (3)
+#define IEEE802154_SEC_SCF_KEYMODE_SHIFT        (3)
 
 /**
  * @brief    Security levels
  *
- * <em>IEEE802154_SCF_SECLEVEL_MIC*</em>:
+ * <em>IEEE802154_SEC_SCF_SECLEVEL_MIC*</em>:
  * A message integrity code (MIC), also known as MAC,
  * is used to prove authentication. The MIC covers the whole frame
  * i.e. header, auxiliary header, and frame payload.
  * The MIC is always encrypted, thus it must be decrypted by the receiver,
  * to be checked.
  *
- * <em>IEEE802154_SCF_SECLEVEL_ENC*</em>:
+ * <em>IEEE802154_SEC_SCF_SECLEVEL_ENC*</em>:
  * AES-128 in ECB mode is used to encrypt the payload of a frame to provide
  * confidentiality.
  *
- * <em>IEEE802154_SCF_SECLEVEL_ENC_MIC*</em>:
+ * <em>IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC*</em>:
  * A combination of the two modes above is used to ensure
  * authentication and confidentiality.
  */
 typedef enum {
-    IEEE802154_SCF_SECLEVEL_NONE                = 0x00, /**< no security */
-    IEEE802154_SCF_SECLEVEL_MIC32               = 0x01, /**< 32 bit MIC */
-    IEEE802154_SCF_SECLEVEL_MIC64               = 0x02, /**< 64 bit MIC */
-    IEEE802154_SCF_SECLEVEL_MIC128              = 0x03, /**< 128 bit MIC */
-    IEEE802154_SCF_SECLEVEL_ENC                 = 0x04, /**< encryption */
-    IEEE802154_SCF_SECLEVEL_ENC_MIC32           = 0x05, /**< enc. + 32 bit MIC */
-    IEEE802154_SCF_SECLEVEL_ENC_MIC64           = 0x06, /**< enc. + 64 bit MIC (mandatory) */
-    IEEE802154_SCF_SECLEVEL_ENC_MIC128          = 0x07  /**< enc. + 128 bit MIC */
-} ieee802154_scf_seclevel_t;
+    IEEE802154_SEC_SCF_SECLEVEL_NONE            = 0x00, /**< no security */
+    IEEE802154_SEC_SCF_SECLEVEL_MIC32           = 0x01, /**< 32 bit MIC */
+    IEEE802154_SEC_SCF_SECLEVEL_MIC64           = 0x02, /**< 64 bit MIC */
+    IEEE802154_SEC_SCF_SECLEVEL_MIC128          = 0x03, /**< 128 bit MIC */
+    IEEE802154_SEC_SCF_SECLEVEL_ENC             = 0x04, /**< encryption */
+    IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC32       = 0x05, /**< enc. + 32 bit MIC */
+    IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC64       = 0x06, /**< enc. + 64 bit MIC (mandatory) */
+    IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC128      = 0x07  /**< enc. + 128 bit MIC */
+} ieee802154_sec_scf_seclevel_t;
 
 /**
  * @brief   Key identifier modes
  *
  * The key identifier field in the auxiliary header
  * consists of the key source and the key index fields and is only present
- * if the key identifier mode is not IEEE802154_SCF_KEYMODE_IMPLICIT.
+ * if the key identifier mode is not IEEE802154_SEC_SCF_KEYMODE_IMPLICIT.
  * (see 9.4.3 in the spec.)
  *
  * +----------------+-------------+------------------+------------------------------------+
@@ -206,18 +203,18 @@ typedef enum {
  * |                |             |                  | short source address               |
  * |                |             |                  | of the originator of the frame.    |
  * +----------------+-------------+------------------+------------------------------------+
- * | HX_INDEX       | 8 bytes     | 1 byte           | The key can be determined          |
+ * | HW_INDEX       | 8 bytes     | 1 byte           | The key can be determined          |
  * |                |             |                  | from the key index and             |
  * |                |             |                  | the long address of the originator |
  * |                |             |                  | of the frame.                      |
  * +----------------+-------------+------------------+------------------------------------+
  */
 typedef enum {
-    IEEE802154_SCF_KEYMODE_IMPLICIT             = 0x00, /**< Key is determined implicitly */
-    IEEE802154_SCF_KEYMODE_INDEX                = 0x01, /**< Key is determined from key index */
-    IEEE802154_SCF_KEYMODE_SHORT_INDEX          = 0x02, /**< Key is determined from 4 byte key source and key index */
-    IEEE802154_SCF_KEYMODE_HW_INDEX             = 0x03  /**< Key is determined from 8 byte key source and key index */
-} ieee802154_scr_keymode_t;
+    IEEE802154_SEC_SCF_KEYMODE_IMPLICIT         = 0x00, /**< Key is determined implicitly */
+    IEEE802154_SEC_SCF_KEYMODE_INDEX            = 0x01, /**< Key is determined from key index */
+    IEEE802154_SEC_SCF_KEYMODE_SHORT_INDEX      = 0x02, /**< Key is determined from 4 byte key source and key index */
+    IEEE802154_SEC_SCF_KEYMODE_HW_INDEX         = 0x03  /**< Key is determined from 8 byte key source and key index */
+} ieee802154_sec_scf_keymode_t;
 
 /**
  * @brief   IEEE 802.15.4 security error codes
@@ -239,11 +236,11 @@ typedef struct ieee802154_sec_context {
      */
     cipher_t cipher;
     /**
-     * @brief   Security level IEEE802154_SCF_SECLEVEL_*
+     * @brief   Security level IEEE802154_SEC_SCF_SECLEVEL_*
      */
     uint8_t security_level;
     /**
-     * @brief   Key mode IEEE802154_SCF_KEYMODE_*
+     * @brief   Key mode IEEE802154_SEC_SCF_KEYMODE_*
      */
     uint8_t key_id_mode;
     /**
@@ -279,9 +276,9 @@ typedef struct __attribute__((packed)) {
      *  +--------+--------+--------+--------+--------+--------+--------+--------+
      *
      * security level:
-     * one of IEEE802154_SCF_SECLEVEL_*
+     * one of IEEE802154_SEC_SCF_SECLEVEL_*
      * key identifier mode:
-     * one of IEEE802154_SCF_KEY_*
+     * one of IEEE802154_SEC_SCF_KEY_*
      * frame counter suppression:
      * basically always zero because we do not support TSCH right now
      * ASN:
@@ -296,20 +293,20 @@ typedef struct __attribute__((packed)) {
      * @brief   key identifier (0 - 9 bytes) according to key id. mode
      */
     uint8_t key_id[];
-} ieee802154_aux_sec_t;
+} ieee802154_sec_aux_t;
 
 /**
- * @brief   Content of key_source if key mode is IEEE802154_SCF_KEYMODE_INDEX
+ * @brief   Content of key_source if key mode is IEEE802154_SEC_SCF_KEYMODE_INDEX
  */
 typedef struct __attribute__((packed)) {
     /**
      * @brief   Key index of key from originator, defined by key source
      */
     uint8_t key_index;
-} ieee802154_aux_sec_key_identifier_1_t;
+} ieee802154_sec_aux_key_identifier_1_t;
 
 /**
- * @brief   Content of key_source if key mode is IEEE802154_SCF_KEYMODE_SHORT_INDEX
+ * @brief   Content of key_source if key mode is IEEE802154_SEC_SCF_KEYMODE_SHORT_INDEX
  */
 typedef struct __attribute__((packed)) {
     /**
@@ -320,10 +317,10 @@ typedef struct __attribute__((packed)) {
      * @brief   Key index of key from originator, defined by key source
      */
     uint8_t key_index;
-} ieee802154_aux_sec_key_identifier_5_t;
+} ieee802154_sec_aux_key_identifier_5_t;
 
 /**
- * @brief   Content of key_source if key mode is IEEE802154_SCF_KEYMODE_HW_INDEX
+ * @brief   Content of key_source if key mode is IEEE802154_SEC_SCF_KEYMODE_HW_INDEX
  */
 typedef struct __attribute__((packed)) {
     /**
@@ -334,7 +331,7 @@ typedef struct __attribute__((packed)) {
      * @brief   Key index of key from originator, defined by key source
      */
     uint8_t key_index;
-} ieee802154_aux_sec_key_identifier_9_t;
+} ieee802154_sec_aux_key_identifier_9_t;
 
 /**
  * @brief   Format of 13 byte nonce
@@ -349,10 +346,10 @@ typedef struct __attribute__((packed)) {
      */
     uint32_t frame_counter;
     /**
-     * @brief   One of IEEE802154_SCF_SECLEVEL_*
+     * @brief   One of IEEE802154_SEC_SCF_SECLEVEL_*
      */
     uint8_t security_level;
-} ieee802154_ccm_nonce_t;
+} ieee802154_sec_ccm_nonce_t;
 
 /**
  * @brief   Format of 16 byte input block of CCM
@@ -365,18 +362,18 @@ typedef struct __attribute__((packed)) {
     /**
      * @brief   Nonce (Number that is only used once)
      */
-    ieee802154_ccm_nonce_t nonce;
+    ieee802154_sec_ccm_nonce_t nonce;
     /**
      * @brief   Either the length of the actual message (for CBC-MAC) or
      *          a block counter (for CTR)
      */
     uint16_t counter;
-} ieee802154_ccm_block_t;
+} ieee802154_sec_ccm_block_t;
 
 /**
  * @brief   Initialize IEEE 802.15.4 security context with default values
  *
- * @param[out]      ctx                     security context
+ * @param[out]      ctx                     IEEE 802.15.4 security context
  */
 void ieee802154_sec_init(ieee802154_sec_context_t *ctx);
 
diff --git a/sys/include/net/netopt.h b/sys/include/net/netopt.h
index 0a87aeaf9d..da1fa1e5f4 100644
--- a/sys/include/net/netopt.h
+++ b/sys/include/net/netopt.h
@@ -640,6 +640,20 @@ typedef enum {
     /**
      * @brief   (uint8_t) LoRaWAN TX application port
      * - LoRaWAN: between 1 and 223 (included)
+     *
+     * @deprecated  This option is deprecated and will be removed in the
+     *              2022.01 Release.
+     *              The port is encoded now as a one byte
+     *              destination address in a @ref net_gnrc_netif_hdr snip
+     *              prepended in the packet.
+     *              The user must take care of prepending the required snip
+     *              during transmission. On reception, the
+     *              snip is prepended automatically by the stack and shall be
+     *              consumed by the user.
+     *              During the deprecation period it is required to
+     *              compile with @ref
+     *              CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR
+     *
      */
     NETOPT_LORAWAN_TX_PORT,
 
@@ -734,7 +748,7 @@ typedef enum {
     NETOPT_RANDOM,
 
     /**
-     * @brief (uint8_t) Get or set the number of PHY symbols before assuming there's no data
+     * @brief (uint16_t) Get or set the number of PHY symbols before assuming there's no data
      */
     NETOPT_RX_SYMBOL_TIMEOUT,
 
diff --git a/sys/include/trickle.h b/sys/include/trickle.h
index 76210789eb..994af9d73c 100644
--- a/sys/include/trickle.h
+++ b/sys/include/trickle.h
@@ -32,8 +32,13 @@
  extern "C" {
 #endif
 
-#include "xtimer.h"
 #include "thread.h"
+#if IS_USED(MODULE_ZTIMER_MSEC)
+#include "ztimer.h"
+#else
+#include "xtimer.h"
+#endif
+
 
 /**
  * @brief Trickle callback function with arguments
@@ -59,8 +64,13 @@ typedef struct {
     trickle_callback_t callback;    /**< callback function and parameter that
                                          trickle calls after each interval */
     msg_t msg;                      /**< the msg_t to use for intervals */
+#if IS_USED(MODULE_ZTIMER_MSEC)
+    ztimer_t msg_timer;             /**< timer to send a msg_t to the target
+                                         thread for a new interval */
+#else
     xtimer_t msg_timer;             /**< xtimer to send a msg_t to the target
                                          thread for a new interval */
+#endif
 } trickle_t;
 
 /**
diff --git a/sys/malloc_thread_safe/malloc_wrappers.c b/sys/malloc_thread_safe/malloc_wrappers.c
index 138dae65a2..2fc390e1dc 100644
--- a/sys/malloc_thread_safe/malloc_wrappers.c
+++ b/sys/malloc_thread_safe/malloc_wrappers.c
@@ -14,13 +14,14 @@
  * @author  Gunar Schorcht <gunar@schorcht.net>
  */
 
+#include <string.h>
+
 #include "assert.h"
 #include "irq.h"
 #include "mutex.h"
 
 extern void *__real_malloc(size_t size);
 extern void __real_free(void *ptr);
-extern void *__real_calloc(size_t nmemb, size_t size);
 extern void *__real_realloc(void *ptr, size_t size);
 
 static mutex_t _lock;
@@ -44,11 +45,20 @@ void __wrap_free(void *ptr)
 
 void *__wrap_calloc(size_t nmemb, size_t size)
 {
-    assert(!irq_is_in());
-    mutex_lock(&_lock);
-    void *ptr = __real_calloc(nmemb, size);
-    mutex_unlock(&_lock);
-    return ptr;
+    /* some c libs don't perform proper overflow check (e.g. newlib < 4.0.0). Hence, we
+     * just implement calloc on top of malloc ourselves. In addition to ensuring proper
+     * overflow checks, this likely saves a bit of ROM */
+    size_t total_size;
+    if (__builtin_mul_overflow(nmemb, size, &total_size)) {
+        return NULL;
+    }
+
+    void *res = __wrap_malloc(total_size);
+    if (res) {
+        memset(res, 0, total_size);
+    }
+
+    return res;
 }
 
 void *__wrap_realloc(void *ptr, size_t size)
diff --git a/sys/net/application_layer/dhcpv6/_dhcpv6.h b/sys/net/application_layer/dhcpv6/_dhcpv6.h
index 1aff58561f..8fc8bebe36 100644
--- a/sys/net/application_layer/dhcpv6/_dhcpv6.h
+++ b/sys/net/application_layer/dhcpv6/_dhcpv6.h
@@ -172,6 +172,19 @@ typedef struct __attribute__((packed)) {
     char msg[];                     /**< UTF-8 encoded text string (not 0-terminated!) */
 } dhcpv6_opt_status_t;
 
+/**
+ * @brief   DHCPv6 DNS recursive name server option
+ * @see [RFC 3646, section 3]
+ *      (https://datatracker.ietf.org/doc/html/rfc3646#section-3)
+ * @note    Only parsed with `dhcpv6_client_dns` module compiled in.
+ */
+typedef struct __attribute__((packed)) {
+    network_uint16_t type;          /**< @ref DHCPV6_OPT_DNS_RNS */
+    network_uint16_t len;           /**< length of dhcpv6_opt_status_t::dns_rns in byte */
+    ipv6_addr_t dns_rns[];          /**< addresses of DNS recursive name servers
+                                     *   in order of preference */
+} dhcpv6_opt_dns_rns_t;
+
 /**
  * @brief   DHCPv6 identity association for prefix delegation option (IA_PD)
  *          format
@@ -224,6 +237,17 @@ typedef struct __attribute__((packed)) {
     char mud_string[];       /**< MUD URL using the "https" scheme */
 } dhcpv6_opt_mud_url_t;
 
+/**
+ * @brief   Configures a DNS recursive name server provided by the server.
+ *
+ * @note    Only available with module `dhcpv6_client_dns`.
+ *
+ * @param[in] opt       A legal DNS recursive name option.
+ * @param[in] netif     Network interface the message carrying @p opt came in.
+ */
+void dhcpv6_client_dns_rns_conf(const dhcpv6_opt_dns_rns_t *opt,
+                                uint16_t netif);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sys/net/application_layer/dhcpv6/client.c b/sys/net/application_layer/dhcpv6/client.c
index 2fc8461feb..bab8b14e71 100644
--- a/sys/net/application_layer/dhcpv6/client.c
+++ b/sys/net/application_layer/dhcpv6/client.c
@@ -636,6 +636,12 @@ static bool _parse_reply(uint8_t *rep, size_t len)
     for (dhcpv6_opt_t *opt = (dhcpv6_opt_t *)(&rep[sizeof(dhcpv6_msg_t)]);
          len > 0; len -= _opt_len(opt), opt = _opt_next(opt)) {
         switch (byteorder_ntohs(opt->type)) {
+#if IS_USED(MODULE_DHCPV6_CLIENT_DNS)
+            case DHCPV6_OPT_DNS_RNS:
+                dhcpv6_client_dns_rns_conf((dhcpv6_opt_dns_rns_t *)opt,
+                                           remote.netif);
+                break;
+#endif  /* IS_USED(MODULE_DHCPV6_CLIENT_DNS) */
             case DHCPV6_OPT_IA_PD:
                 for (unsigned i = 0; i < CONFIG_DHCPV6_CLIENT_PFX_LEASE_MAX; i++) {
                     dhcpv6_opt_iapfx_t *iapfx = NULL;
diff --git a/sys/net/application_layer/dhcpv6/client_dns.c b/sys/net/application_layer/dhcpv6/client_dns.c
new file mode 100644
index 0000000000..7c37b1e9a8
--- /dev/null
+++ b/sys/net/application_layer/dhcpv6/client_dns.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @{
+ *
+ * @file
+ * @author  Martine Lenders <m.lenders@fu-berlin.de>
+ */
+
+#include "net/dhcpv6/client.h"
+#if IS_USED(MODULE_SOCK_DNS)
+#include "net/sock/dns.h"
+#endif
+
+#include "_dhcpv6.h"
+
+#define ENABLE_DEBUG 0
+#include "debug.h"
+
+static char addr_str[IPV6_ADDR_MAX_STR_LEN];
+
+void dhcpv6_client_dns_rns_conf(const dhcpv6_opt_dns_rns_t *opt, uint16_t netif)
+{
+    if (byteorder_ntohs(opt->len) < sizeof(ipv6_addr_t)) {
+        DEBUG("dhcpv6_client_dns: no DNS recursive name server provided.\n");
+        return;
+    }
+#if IS_USED(MODULE_SOCK_DNS) && IS_ACTIVE(SOCK_HAS_IPV6)
+    DEBUG("Overriding sock_dns_server with %s\n",
+          ipv6_addr_to_str(addr_str, opt->dns_rns, sizeof(addr_str)));
+    sock_dns_server.port = SOCK_DNS_PORT;
+    sock_dns_server.family = AF_INET6;
+    sock_dns_server.netif = netif;
+    memcpy(sock_dns_server.addr.ipv6, opt->dns_rns,
+           sizeof(sock_dns_server.addr.ipv6));
+    return;
+#endif
+}
+
+/** @} */
diff --git a/sys/net/application_layer/emcute/emcute.c b/sys/net/application_layer/emcute/emcute.c
index 9326d9e996..2999e73415 100644
--- a/sys/net/application_layer/emcute/emcute.c
+++ b/sys/net/application_layer/emcute/emcute.c
@@ -167,7 +167,7 @@ static void on_publish(size_t len, size_t pos)
 
     /* return error code in case we don't support/understand active flags. So
      * far we only understand QoS 1... */
-    if (rbuf[pos + 1] & ~(EMCUTE_QOS_1 | EMCUTE_TIT_SHORT)) {
+    if (rbuf[pos + 1] & ~(EMCUTE_QOS_1 | EMCUTE_TIT_SHORT | EMCUTE_RETAIN)) {
         buf[6] = REJ_NOTSUP;
         sock_udp_send(&sock, &buf, 7, &gateway);
         return;
diff --git a/sys/net/application_layer/gcoap/gcoap.c b/sys/net/application_layer/gcoap/gcoap.c
index 7355b4b8f0..6fe449ecea 100644
--- a/sys/net/application_layer/gcoap/gcoap.c
+++ b/sys/net/application_layer/gcoap/gcoap.c
@@ -812,9 +812,9 @@ int gcoap_req_init(coap_pkt_t *pdu, uint8_t *buf, size_t len,
     return (res > 0) ? 0 : res;
 }
 
-size_t gcoap_req_send(const uint8_t *buf, size_t len,
-                      const sock_udp_ep_t *remote,
-                      gcoap_resp_handler_t resp_handler, void *context)
+ssize_t gcoap_req_send(const uint8_t *buf, size_t len,
+                       const sock_udp_ep_t *remote,
+                       gcoap_resp_handler_t resp_handler, void *context)
 {
     gcoap_request_memo_t *memo = NULL;
     unsigned msg_type  = (*buf & 0x30) >> 4;
@@ -913,7 +913,7 @@ size_t gcoap_req_send(const uint8_t *buf, size_t len,
         }
         DEBUG("gcoap: sock send failed: %d\n", (int)res);
     }
-    return (size_t)((res > 0) ? res : 0);
+    return ((res > 0) ? res : 0);
 }
 
 int gcoap_resp_init(coap_pkt_t *pdu, uint8_t *buf, size_t len, unsigned code)
diff --git a/sys/net/gnrc/Makefile.dep b/sys/net/gnrc/Makefile.dep
new file mode 100644
index 0000000000..965adcc389
--- /dev/null
+++ b/sys/net/gnrc/Makefile.dep
@@ -0,0 +1,429 @@
+ifneq (,$(filter gcoap,$(USEMODULE)))
+   USEMODULE += gnrc_sock_async
+endif
+
+ifneq (,$(filter sock_async,$(USEMODULE)))
+  USEMODULE += gnrc_sock_async
+endif
+
+ifneq (,$(filter gnrc_mac,$(USEMODULE)))
+  USEMODULE += gnrc_priority_pktqueue
+  USEMODULE += csma_sender
+  USEMODULE += evtimer
+  ifneq (,$(filter gnrc_netif,$(USEMODULE)))
+    USEMODULE += gnrc_netif_mac
+  endif
+endif
+
+ifneq (,$(filter gnrc_gomach,$(USEMODULE)))
+  USEMODULE += gnrc_netif
+  USEMODULE += gnrc_nettype_gomach
+  USEMODULE += random
+  USEMODULE += xtimer
+  USEMODULE += gnrc_mac
+  FEATURES_REQUIRED += periph_rtt
+endif
+
+ifneq (,$(filter gnrc_lorawan,$(USEMODULE)))
+  USEMODULE += ztimer_msec
+  USEMODULE += random
+  USEMODULE += hashes
+  USEMODULE += crypto_aes_128
+  USEMODULE += netdev_layer
+  USEMODULE += gnrc_nettype_lorawan
+endif
+
+ifneq (,$(filter gnrc_netdev_default,$(USEMODULE)))
+  # enable default network devices on the platform
+  USEMODULE += netdev_default
+  USEMODULE += netdev
+  USEMODULE += gnrc_netif
+endif
+
+ifneq (,$(filter gnrc_dhcpv6_%, $(USEMODULE)))
+  USEMODULE += gnrc_dhcpv6
+endif
+
+ifneq (,$(filter gnrc_dhcpv6_client,$(USEMODULE)))
+  USEMODULE += dhcpv6_client
+  USEMODULE += gnrc_ipv6_nib
+  USEMODULE += gnrc_netif
+  USEMODULE += gnrc_sock_udp
+endif
+
+ifneq (,$(filter gnrc_dhcpv6_client_6lbr,$(USEMODULE)))
+  USEMODULE += gnrc_dhcpv6_client_simple_pd
+endif
+
+ifneq (,$(filter gnrc_dhcpv6_client_simple_pd,$(USEMODULE)))
+  USEMODULE += gnrc_dhcpv6_client
+endif
+
+ifneq (,$(filter gnrc_uhcpc,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_uhcpc
+  USEMODULE += uhcpc
+  USEMODULE += gnrc_sock_udp
+  USEMODULE += fmt
+endif
+
+ifneq (,$(filter gnrc_%,$(filter-out gnrc_netapi gnrc_netreg gnrc_netif% gnrc_pkt%,$(USEMODULE))))
+  USEMODULE += gnrc
+endif
+
+ifneq (,$(filter gnrc_sock_%,$(USEMODULE)))
+  USEMODULE += gnrc_sock
+  ifneq (,$(filter sock_aux_timestamp,$(USEMODULE)))
+    USEMODULE += gnrc_netif_timestamp
+  endif
+endif
+
+ifneq (,$(filter gnrc_sock_async,$(USEMODULE)))
+  USEMODULE += gnrc_netapi_callbacks
+endif
+
+ifneq (,$(filter gnrc_sock_udp,$(USEMODULE)))
+  USEMODULE += gnrc_udp
+  USEMODULE += random     # to generate random ports
+endif
+
+ifneq (,$(filter gnrc_sock,$(USEMODULE)))
+  USEMODULE += gnrc_netapi_mbox
+  USEMODULE += sock
+endif
+
+ifneq (,$(filter gnrc_netapi_mbox,$(USEMODULE)))
+  USEMODULE += core_mbox
+endif
+
+ifneq (,$(filter gnrc_rpl_p2p,$(USEMODULE)))
+  USEMODULE += gnrc_rpl
+endif
+
+ifneq (,$(filter gnrc_rpl,$(USEMODULE)))
+  USEMODULE += gnrc_icmpv6
+  USEMODULE += gnrc_ipv6_nib
+  USEMODULE += trickle
+  ifeq (,$(filter ztimer_msec,$(USEMODULE)))
+    USEMODULE += xtimer
+  endif
+  USEMODULE += evtimer
+endif
+
+ifneq (,$(filter gnrc_netif,$(USEMODULE)))
+  USEMODULE += netif
+  USEMODULE += l2util
+  USEMODULE += fmt
+  ifneq (,$(filter netdev_ieee802154_submac,$(USEMODULE)))
+    USEMODULE += gnrc_netif_pktq
+  endif
+  ifneq (,$(filter netdev_ieee802154,$(USEMODULE)))
+    USEMODULE += gnrc_netif_ieee802154
+  endif
+  ifneq (,$(filter netdev_eth,$(USEMODULE)))
+    USEMODULE += gnrc_netif_ethernet
+  endif
+  ifneq (,$(filter gnrc_lorawan,$(USEMODULE)))
+    USEMODULE += gnrc_netif_lorawan
+  endif
+endif
+
+ifneq (,$(filter gnrc_netif_bus,$(USEMODULE)))
+  USEMODULE += core_msg_bus
+endif
+
+ifneq (,$(filter gnrc_netif_events,$(USEMODULE)))
+  USEMODULE += core_thread_flags
+  USEMODULE += event
+endif
+
+ifneq (,$(filter ieee802154 nrfmin esp_now cc110x gnrc_sixloenc,$(USEMODULE)))
+  ifneq (,$(filter gnrc_ipv6, $(USEMODULE)))
+    USEMODULE += gnrc_sixlowpan
+  endif
+  ifneq (,$(filter gnrc_ipv6_default, $(USEMODULE)))
+    USEMODULE += gnrc_sixlowpan_default
+  endif
+  ifneq (,$(filter gnrc_ipv6_router_default, $(USEMODULE)))
+    USEMODULE += gnrc_sixlowpan_router_default
+  endif
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_default,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib_6ln
+  USEMODULE += gnrc_sixlowpan
+  ifeq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
+    USEMODULE += gnrc_sixlowpan_frag
+  endif
+  USEMODULE += gnrc_sixlowpan_iphc
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_router_default,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib_6lr
+  ifeq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
+    USEMODULE += gnrc_sixlowpan_frag
+  endif
+  USEMODULE += gnrc_sixlowpan_iphc
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_border_router_default,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib_6lbr
+  USEMODULE += gnrc_ipv6_router_default
+  ifeq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
+    USEMODULE += gnrc_sixlowpan_frag
+  endif
+  USEMODULE += gnrc_sixlowpan_iphc
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag,$(USEMODULE)))
+  USEMODULE += gnrc_sixlowpan
+  USEMODULE += gnrc_sixlowpan_frag_fb
+  USEMODULE += gnrc_sixlowpan_frag_rb
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag_fb,$(USEMODULE)))
+  USEMODULE += core_msg
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag_minfwd,$(USEMODULE)))
+  USEMODULE += gnrc_netif_pktq
+  USEMODULE += gnrc_sixlowpan_frag
+  USEMODULE += gnrc_sixlowpan_frag_hint
+  USEMODULE += gnrc_sixlowpan_frag_vrb
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag_rb,$(USEMODULE)))
+  USEMODULE += xtimer
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag_sfr,$(USEMODULE)))
+  USEMODULE += gnrc_sixlowpan
+  USEMODULE += gnrc_sixlowpan_frag_fb
+  USEMODULE += gnrc_sixlowpan_frag_vrb
+  USEMODULE += gnrc_sixlowpan_frag_rb
+  USEMODULE += evtimer
+  USEMODULE += xtimer
+  ifneq (,$(filter gnrc_tx_sync,$(USEMODULE)))
+    # TODO: Implement gnrc_tx_sync for gnrc_sixlowpand_frag_sfr
+    $(error module gnrc_tx_sync conflicts with gnrc_sixlowpand_frag_sfr)
+  endif
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag_sfr_stats,$(USEMODULE)))
+  USEMODULE += gnrc_sixlowpan_frag_sfr
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_frag_vrb,$(USEMODULE)))
+  USEMODULE += xtimer
+  USEMODULE += gnrc_sixlowpan_frag_fb
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_iphc,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6
+  USEMODULE += gnrc_sixlowpan
+  USEMODULE += gnrc_sixlowpan_ctx
+  USEMODULE += gnrc_sixlowpan_iphc_nhc
+endif
+
+ifneq (,$(filter gnrc_sixlowpan,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_sixlowpan
+  USEMODULE += gnrc_nettype_sixlowpan
+  USEMODULE += sixlowpan
+  ifneq (,$(filter gnrc_netif,$(USEMODULE)))
+    USEMODULE += gnrc_netif_6lo
+  endif
+endif
+
+ifneq (,$(filter gnrc_sixlowpan_ctx,$(USEMODULE)))
+  USEMODULE += ipv6_addr
+  ifeq (,$(filter ztimer_msec,$(USEMODULE)))
+    USEMODULE += xtimer
+  endif
+endif
+
+ifneq (,$(filter gnrc_ipv6_default,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6
+  USEMODULE += gnrc_icmpv6
+endif
+
+ifneq (,$(filter gnrc_ipv6_router_default,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_router
+  USEMODULE += gnrc_icmpv6
+endif
+
+ifneq (,$(filter gnrc_ndp,$(USEMODULE)))
+  USEMODULE += gnrc_icmpv6
+  USEMODULE += gnrc_ipv6_hdr
+  USEMODULE += gnrc_netif
+endif
+
+ifneq (,$(filter gnrc_icmpv6_echo,$(USEMODULE)))
+  USEMODULE += gnrc_icmpv6
+  USEMODULE += gnrc_ipv6_hdr
+  USEMODULE += gnrc_netif_hdr
+endif
+
+ifneq (,$(filter gnrc_icmpv6_error,$(USEMODULE)))
+  USEMODULE += gnrc_icmpv6
+  USEMODULE += gnrc_ipv6_hdr
+  USEMODULE += gnrc_netif_hdr
+endif
+
+ifneq (,$(filter gnrc_icmpv6,$(USEMODULE)))
+  USEMODULE += inet_csum
+  USEMODULE += ipv6_hdr
+  USEMODULE += gnrc_nettype_icmpv6
+  USEMODULE += gnrc_nettype_ipv6
+  USEMODULE += icmpv6
+endif
+
+ifneq (,$(filter gnrc_rpl_srh,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_ext_rh
+endif
+
+ifneq (,$(filter gnrc_ipv6_ext_frag,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_ext
+  USEMODULE += xtimer
+endif
+
+ifneq (,$(filter gnrc_ipv6_ext_opt,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_ext
+endif
+
+ifneq (,$(filter gnrc_ipv6_ext_rh,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_ext
+endif
+
+ifneq (,$(filter gnrc_ipv6_ext,$(USEMODULE)))
+  USEMODULE += gnrc_nettype_ipv6
+  USEMODULE += gnrc_nettype_ipv6_ext
+endif
+
+ifneq (,$(filter gnrc_ipv6_whitelist,$(USEMODULE)))
+  USEMODULE += ipv6_addr
+endif
+
+ifneq (,$(filter gnrc_ipv6_blacklist,$(USEMODULE)))
+  USEMODULE += ipv6_addr
+endif
+
+ifneq (,$(filter gnrc_ipv6_router,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6
+  USEMODULE += gnrc_ipv6_nib_router
+endif
+
+ifneq (,$(filter gnrc_ipv6,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_ipv6
+  USEMODULE += inet_csum
+  USEMODULE += ipv6_addr
+  USEMODULE += gnrc_ipv6_hdr
+  USEMODULE += gnrc_ipv6_nib
+  USEMODULE += gnrc_netif
+  USEMODULE += gnrc_netif_ipv6
+  USEMODULE += gnrc_nettype_ipv6
+endif
+
+ifneq (,$(filter gnrc_ipv6_hdr,$(USEMODULE)))
+  USEMODULE += ipv6_hdr
+  USEMODULE += gnrc_pktbuf
+endif
+
+ifneq (,$(filter gnrc_ipv6_nib_6lbr,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib_6lr
+endif
+
+ifneq (,$(filter gnrc_ipv6_nib_6lr,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib_6ln
+  USEMODULE += gnrc_ipv6_nib_router
+endif
+
+ifneq (,$(filter gnrc_ipv6_nib_6ln,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib
+  USEMODULE += gnrc_sixlowpan_nd
+endif
+
+ifneq (,$(filter gnrc_ipv6_nib_dns,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib
+endif
+
+ifneq (,$(filter gnrc_ipv6_nib_router,$(USEMODULE)))
+  USEMODULE += gnrc_ipv6_nib
+endif
+
+ifneq (,$(filter gnrc_ipv6_nib,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_ipv6_nib
+  USEMODULE += evtimer
+  USEMODULE += gnrc_ndp
+  USEMODULE += gnrc_netif
+  USEMODULE += gnrc_netif_ipv6
+  USEMODULE += ipv6_addr
+  USEMODULE += random
+endif
+
+ifneq (,$(filter gnrc_udp,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_udp
+  USEMODULE += gnrc_nettype_udp
+  USEMODULE += inet_csum
+  USEMODULE += udp
+endif
+
+ifneq (,$(filter gnrc_tcp,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_tcp
+  USEMODULE += gnrc_nettype_tcp
+  USEMODULE += inet_csum
+  USEMODULE += random
+  USEMODULE += tcp
+  USEMODULE += evtimer_mbox
+endif
+
+ifneq (,$(filter gnrc_pktdump,$(USEMODULE)))
+  DEFAULT_MODULE += auto_init_gnrc_pktdump
+  USEMODULE += gnrc_pktbuf
+  USEMODULE += od
+endif
+
+ifneq (,$(filter gnrc,$(USEMODULE)))
+  USEMODULE += gnrc_netapi
+  USEMODULE += gnrc_netreg
+  USEMODULE += gnrc_netif
+  USEMODULE += gnrc_netif_hdr
+  USEMODULE += gnrc_pktbuf
+  ifneq (,$(filter sock_async, $(USEMODULE)))
+    USEMODULE += gnrc_sock_async
+  endif
+  ifneq (,$(filter sock_ip, $(USEMODULE)))
+    USEMODULE += gnrc_sock_ip
+  endif
+  ifneq (,$(filter sock_udp, $(USEMODULE)))
+    USEMODULE += gnrc_sock_udp
+  endif
+endif
+
+ifneq (,$(filter gnrc_pktbuf, $(USEMODULE)))
+  ifeq (,$(filter gnrc_pktbuf_%, $(USEMODULE)))
+    USEMODULE += gnrc_pktbuf_static
+  endif
+  ifeq (gnrc_pktbuf_cmd,$(filter gnrc_pktbuf_%, $(USEMODULE)))
+    USEMODULE += gnrc_pktbuf_static
+  endif
+  DEFAULT_MODULE += auto_init_gnrc_pktbuf
+  USEMODULE += gnrc_pkt
+endif
+
+ifneq (,$(filter gnrc_pktbuf_%, $(USEMODULE)))
+  USEMODULE += gnrc_pktbuf # make MODULE_GNRC_PKTBUF macro available for all implementations
+endif
+
+ifneq (,$(filter gnrc_netif_%,$(USEMODULE)))
+  USEMODULE += gnrc_netif
+endif
+
+ifneq (,$(filter gnrc_netif_pktq,$(USEMODULE)))
+  USEMODULE += xtimer
+endif
+
+ifneq (,$(filter gnrc_lwmac,$(USEMODULE)))
+  USEMODULE += gnrc_netif
+  USEMODULE += gnrc_nettype_lwmac
+  USEMODULE += gnrc_mac
+  FEATURES_REQUIRED += periph_rtt
+endif
diff --git a/sys/net/gnrc/application_layer/dhcpv6/client.c b/sys/net/gnrc/application_layer/dhcpv6/client.c
index 9dfd1629b4..2c95e3277c 100644
--- a/sys/net/gnrc/application_layer/dhcpv6/client.c
+++ b/sys/net/gnrc/application_layer/dhcpv6/client.c
@@ -18,7 +18,7 @@
 #include "log.h"
 #include "net/arp.h"
 #include "net/dhcpv6.h"
-#include "net/gnrc/dhcpv6/client/6lbr.h"
+#include "net/gnrc/dhcpv6/client/simple_pd.h"
 #include "net/gnrc/ipv6/nib/pl.h"
 #include "net/gnrc/sixlowpan/ctx.h"
 #include "net/gnrc/netif.h"
diff --git a/sys/net/gnrc/application_layer/dhcpv6/client_6lbr.c b/sys/net/gnrc/application_layer/dhcpv6/client_simple_pd.c
similarity index 93%
rename from sys/net/gnrc/application_layer/dhcpv6/client_6lbr.c
rename to sys/net/gnrc/application_layer/dhcpv6/client_simple_pd.c
index 57e776350d..4bdf55b339 100644
--- a/sys/net/gnrc/application_layer/dhcpv6/client_6lbr.c
+++ b/sys/net/gnrc/application_layer/dhcpv6/client_simple_pd.c
@@ -22,7 +22,7 @@
 #include "net/gnrc/ipv6/nib/ft.h"
 #include "net/gnrc/netif/internal.h"
 
-#include "net/gnrc/dhcpv6/client/6lbr.h"
+#include "net/gnrc/dhcpv6/client/simple_pd.h"
 
 #if IS_USED(MODULE_AUTO_INIT_DHCPV6_CLIENT)
 #error "Module `gnrc_dhcpv6_client_6lbr` is mutually exclusive to \
@@ -101,8 +101,13 @@ static void _configure_upstream_netif(gnrc_netif_t *upstream_netif)
 static void _configure_dhcpv6_client(void)
 {
     gnrc_netif_t *netif = NULL;
+    gnrc_netif_t *upstream = _find_upstream_netif();
     while ((netif = gnrc_netif_iter(netif))) {
-        if (gnrc_netif_is_6lo(netif)) {
+        if (IS_USED(MODULE_GNRC_DHCPV6_CLIENT_6LBR)
+            && !gnrc_netif_is_6lo(netif)) {
+            continue;
+        }
+        if (netif != upstream) {
             dhcpv6_client_req_ia_pd(netif->pid, 64U);
         }
     }
@@ -135,7 +140,7 @@ static void *_dhcpv6_cl_6lbr_thread(void *args)
     return NULL;
 }
 
-void gnrc_dhcpv6_client_6lbr_init(void)
+void gnrc_dhcpv6_client_simple_pd_init(void)
 {
     /* start DHCPv6 client thread to request prefix for WPAN */
     thread_create(_stack, DHCPV6_CLIENT_STACK_SIZE,
diff --git a/sys/net/gnrc/link_layer/lorawan/Kconfig b/sys/net/gnrc/link_layer/lorawan/Kconfig
index 14013b6f61..265b8cff43 100644
--- a/sys/net/gnrc/link_layer/lorawan/Kconfig
+++ b/sys/net/gnrc/link_layer/lorawan/Kconfig
@@ -16,16 +16,6 @@ menuconfig KCONFIG_USEMODULE_GNRC_LORAWAN
 
 if KCONFIG_USEMODULE_GNRC_LORAWAN
 
-config GNRC_LORAWAN_TIMER_DRIFT
-    int "Maximum timer drift"
-    default 10
-    range -1000 1000
-    help
-        The value is expressed in per mille. This is only a workaround to
-        compensate inaccurate timers. E.g. a value of 1 means there's a
-        positive drift of 0.1% (set timeout to 1000 ms => triggers after
-        1001 ms)
-
 config GNRC_LORAWAN_MIN_SYMBOLS_TIMEOUT
     int "Minimum symbols to detect a LoRa preamble"
     default 30
diff --git a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan.c b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan.c
index 6749feb75f..3a3cfa1ff8 100644
--- a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan.c
+++ b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan.c
@@ -27,16 +27,11 @@
 #include "net/lorawan/hdr.h"
 #include "net/loramac.h"
 #include "net/gnrc/lorawan/region.h"
+#include "timex.h"
 
 #define ENABLE_DEBUG 0
 #include "debug.h"
 
-/* This factor is used for converting "real" seconds into microcontroller
- * microseconds. This is done in order to correct timer drift.
- */
-#define _DRIFT_FACTOR (int)(US_PER_SEC * 100 / \
-                            (100 + (CONFIG_GNRC_LORAWAN_TIMER_DRIFT / 10.0)))
-
 #define GNRC_LORAWAN_DL_RX2_DR_MASK       (0x0F)    /**< DL Settings DR Offset mask */
 #define GNRC_LORAWAN_DL_RX2_DR_POS        (0)       /**< DL Settings DR Offset pos */
 #define GNRC_LORAWAN_DL_DR_OFFSET_MASK    (0x70)    /**< DL Settings RX2 DR mask */
@@ -52,10 +47,9 @@ static inline void gnrc_lorawan_mlme_reset(gnrc_lorawan_t *mac)
 
 static inline void gnrc_lorawan_mlme_backoff_init(gnrc_lorawan_t *mac)
 {
-    mac->mlme.backoff_msg.type = MSG_TYPE_MLME_BACKOFF_EXPIRE;
     mac->mlme.backoff_state = 0;
 
-    gnrc_lorawan_mlme_backoff_expire(mac);
+    gnrc_lorawan_mlme_backoff_expire_cb(mac);
 }
 
 static inline void gnrc_lorawan_mcps_reset(gnrc_lorawan_t *mac)
@@ -151,19 +145,33 @@ void gnrc_lorawan_open_rx_window(gnrc_lorawan_t *mac)
 {
     netdev_t *dev = gnrc_lorawan_get_netdev(mac);
 
-    mac->msg.type = MSG_TYPE_TIMEOUT;
     /* Switch to RX state */
     if (mac->state == LORAWAN_STATE_RX_1) {
-        xtimer_set_msg(&mac->rx, _DRIFT_FACTOR, &mac->msg, thread_getpid());
+        gnrc_lorawan_set_timer(mac, US_PER_SEC);
     }
     netopt_state_t state = NETOPT_STATE_RX;
 
     dev->driver->set(dev, NETOPT_STATE, &state, sizeof(state));
 }
 
+void gnrc_lorawan_timeout_cb(gnrc_lorawan_t *mac)
+{
+    switch(mac->state) {
+        case LORAWAN_STATE_RX_1:
+        case LORAWAN_STATE_RX_2:
+            gnrc_lorawan_open_rx_window(mac);
+            break;
+        case LORAWAN_STATE_JOIN:
+            gnrc_lorawan_trigger_join(mac);
+            break;
+        default:
+            gnrc_lorawan_event_ack_timeout(mac);
+            break;
+    }
+}
+
 void gnrc_lorawan_radio_tx_done_cb(gnrc_lorawan_t *mac)
 {
-    mac->msg.type = MSG_TYPE_TIMEOUT;
     mac->state = LORAWAN_STATE_RX_1;
 
     int rx_1;
@@ -172,7 +180,7 @@ void gnrc_lorawan_radio_tx_done_cb(gnrc_lorawan_t *mac)
     rx_1 = mac->mlme.activation == MLME_ACTIVATION_NONE ?
            CONFIG_LORAMAC_DEFAULT_JOIN_DELAY1 : mac->rx_delay;
 
-    xtimer_set_msg(&mac->rx, rx_1 * _DRIFT_FACTOR, &mac->msg, thread_getpid());
+    gnrc_lorawan_set_timer(mac, rx_1 * US_PER_SEC);
 
     uint8_t dr_offset = (mac->dl_settings & GNRC_LORAWAN_DL_DR_OFFSET_MASK) >>
                         GNRC_LORAWAN_DL_DR_OFFSET_POS;
@@ -234,12 +242,10 @@ void gnrc_lorawan_send_pkt(gnrc_lorawan_t *mac, iolist_t *psdu, uint8_t dr)
 void gnrc_lorawan_radio_rx_done_cb(gnrc_lorawan_t *mac, uint8_t *psdu,
                                    size_t size)
 {
+    assert(psdu);
     _sleep_radio(mac);
-    if (psdu == NULL) {
-        return;
-    }
     mac->state = LORAWAN_STATE_IDLE;
-    xtimer_remove(&mac->rx);
+    gnrc_lorawan_remove_timer(mac);
 
     uint8_t mtype = (*psdu & MTYPE_MASK) >> 5;
 
diff --git a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_crypto.c b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_crypto.c
index 4eb439f4eb..7cc67af245 100644
--- a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_crypto.c
+++ b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_crypto.c
@@ -95,7 +95,7 @@ void gnrc_lorawan_encrypt_payload(iolist_t *iolist, const le_uint32_t *dev_addr,
 
     lorawan_block_t *block = (lorawan_block_t *)a_block;
 
-    cipher_init(&AesContext, CIPHER_AES_128, appskey, LORAMAC_APPKEY_LEN);
+    cipher_init(&AesContext, CIPHER_AES, appskey, LORAMAC_APPKEY_LEN);
 
     block->fb = CRYPT_B0_START;
 
@@ -127,7 +127,7 @@ void gnrc_lorawan_encrypt_payload(iolist_t *iolist, const le_uint32_t *dev_addr,
 void gnrc_lorawan_decrypt_join_accept(const uint8_t *key, uint8_t *pkt,
                                       int has_clist, uint8_t *out)
 {
-    cipher_init(&AesContext, CIPHER_AES_128, key, LORAMAC_APPKEY_LEN);
+    cipher_init(&AesContext, CIPHER_AES, key, LORAMAC_APPKEY_LEN);
     cipher_encrypt(&AesContext, pkt, out);
 
     if (has_clist) {
@@ -145,7 +145,7 @@ void gnrc_lorawan_generate_session_keys(const uint8_t *app_nonce,
 
     memset(buf, 0, sizeof(buf));
 
-    cipher_init(&AesContext, CIPHER_AES_128, appkey, LORAMAC_APPSKEY_LEN);
+    cipher_init(&AesContext, CIPHER_AES, appkey, LORAMAC_APPSKEY_LEN);
 
     /* net_id comes right after app_nonce */
     memcpy(buf + 1, app_nonce,
diff --git a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mcps.c b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mcps.c
index ff6e2b1b49..26303d4231 100644
--- a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mcps.c
+++ b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mcps.c
@@ -118,6 +118,11 @@ int gnrc_lorawan_parse_dl(gnrc_lorawan_t *mac, uint8_t *buf, size_t len,
             return -1;
         }
 
+        if (pkt->port > LORAMAC_PORT_MAX) {
+            DEBUG("gnrc_lorawan: packet with port > 223. Drop\n");
+            return -1;
+        }
+
         if (buf < p_mic) {
             pkt->enc_payload.iol_base = buf;
             pkt->enc_payload.iol_len = p_mic - buf;
@@ -335,12 +340,8 @@ static void _handle_retransmissions(gnrc_lorawan_t *mac)
 {
     if (mac->mcps.nb_trials-- == 0) {
         _end_of_tx(mac, MCPS_CONFIRMED, -ETIMEDOUT);
-    }
-    else {
-        mac->msg.type = MSG_TYPE_MCPS_ACK_TIMEOUT;
-        xtimer_set_msg(&mac->rx, 1000000 + random_uint32_range(0,
-                                                               2000000), &mac->msg,
-                       thread_getpid());
+    } else {
+        gnrc_lorawan_set_timer(mac, 1000000 + random_uint32_range(0, 2000000));
     }
 }
 
diff --git a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mlme.c b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mlme.c
index dc43267807..774837c867 100644
--- a/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mlme.c
+++ b/sys/net/gnrc/link_layer/lorawan/gnrc_lorawan_mlme.c
@@ -54,6 +54,13 @@ static void _build_join_req_pkt(uint8_t *appeui, uint8_t *deveui,
                                     &hdr->mic);
 }
 
+void gnrc_lorawan_trigger_join(gnrc_lorawan_t *mac)
+{
+    iolist_t pkt = {.iol_base = mac->mcps.mhdr_mic, .iol_len =
+                    sizeof(lorawan_join_request_t), .iol_next = NULL};
+    gnrc_lorawan_send_pkt(mac, &pkt, mac->last_dr);
+}
+
 static int gnrc_lorawan_send_join_request(gnrc_lorawan_t *mac, uint8_t *deveui,
                                           uint8_t *appeui, uint8_t *appkey,
                                           uint8_t dr)
@@ -68,18 +75,15 @@ static int gnrc_lorawan_send_join_request(gnrc_lorawan_t *mac, uint8_t *deveui,
     mac->mlme.dev_nonce[0] = random_number & 0xFF;
     mac->mlme.dev_nonce[1] = (random_number >> 8) & 0xFF;
 
-    /* build join request */
-    uint8_t psdu[sizeof(lorawan_join_request_t)];
-
-    iolist_t pkt =
-    { .iol_base = &psdu, .iol_len = sizeof(psdu), .iol_next = NULL };
+    mac->last_dr = dr;
+    mac->state = LORAWAN_STATE_JOIN;
 
-    _build_join_req_pkt(appeui, deveui, appkey, mac->mlme.dev_nonce, psdu);
+    /* Use the buffer for MHDR */
+    _build_join_req_pkt(appeui, deveui, appkey, mac->mlme.dev_nonce, (uint8_t*) mac->mcps.mhdr_mic);
 
     /* We need a random delay for join request. Otherwise there might be
      * network congestion if a group of nodes start at the same time */
-    xtimer_usleep(random_uint32() & GNRC_LORAWAN_JOIN_DELAY_U32_MASK);
-    gnrc_lorawan_send_pkt(mac, &pkt, dr);
+    gnrc_lorawan_set_timer(mac, random_uint32() & GNRC_LORAWAN_JOIN_DELAY_U32_MASK);
 
     mac->mlme.backoff_budget -= mac->toa;
 
@@ -156,7 +160,7 @@ out:
     gnrc_lorawan_mlme_confirm(mac, &mlme_confirm);
 }
 
-void gnrc_lorawan_mlme_backoff_expire(gnrc_lorawan_t *mac)
+void gnrc_lorawan_mlme_backoff_expire_cb(gnrc_lorawan_t *mac)
 {
     uint8_t counter = mac->mlme.backoff_state & 0x1F;
     uint8_t state = mac->mlme.backoff_state >> 5;
@@ -183,9 +187,6 @@ void gnrc_lorawan_mlme_backoff_expire(gnrc_lorawan_t *mac)
 
     counter--;
     mac->mlme.backoff_state = state << 5 | (counter & 0x1F);
-    xtimer_set_msg(&mac->mlme.backoff_timer,
-                   GNRC_LORAWAN_BACKOFF_WINDOW_TICK,
-                   &mac->mlme.backoff_msg, thread_getpid());
 }
 
 static void _mlme_set(gnrc_lorawan_t *mac, const mlme_request_t *mlme_request,
diff --git a/sys/net/gnrc/link_layer/lorawan/include/gnrc_lorawan_internal.h b/sys/net/gnrc/link_layer/lorawan/include/gnrc_lorawan_internal.h
index d4afdf6170..afa0f4af9d 100644
--- a/sys/net/gnrc/link_layer/lorawan/include/gnrc_lorawan_internal.h
+++ b/sys/net/gnrc/link_layer/lorawan/include/gnrc_lorawan_internal.h
@@ -24,8 +24,6 @@
 #include "net/lora.h"
 #include "net/lorawan/hdr.h"
 #include "net/gnrc/pktbuf.h"
-#include "xtimer.h"
-#include "msg.h"
 #include "net/netdev.h"
 #include "net/netdev/layer.h"
 #include "net/loramac.h"
@@ -35,8 +33,6 @@ extern "C" {
 #endif
 
 #define MSG_TYPE_TIMEOUT             (0x3457)           /**< Timeout message type */
-#define MSG_TYPE_MCPS_ACK_TIMEOUT    (0x3458)           /**< ACK timeout message type */
-#define MSG_TYPE_MLME_BACKOFF_EXPIRE (0x3459)           /**< Backoff timer expiration message type */
 
 #define MTYPE_MASK           0xE0                       /**< MHDR mtype mask */
 #define MTYPE_JOIN_REQUEST   0x0                        /**< Join Request type */
@@ -61,6 +57,7 @@ extern "C" {
 #define LORAWAN_STATE_RX_1 (1)                          /**< MAC state machine in RX1 */
 #define LORAWAN_STATE_RX_2 (2)                          /**< MAC state machine in RX2 */
 #define LORAWAN_STATE_TX (3)                            /**< MAC state machine in TX */
+#define LORAWAN_STATE_JOIN (4)                          /**< MAC state machine in Join */
 
 #define GNRC_LORAWAN_DIR_UPLINK (0U)                    /**< uplink frame direction */
 #define GNRC_LORAWAN_DIR_DOWNLINK (1U)                  /**< downlink frame direction */
@@ -163,8 +160,6 @@ typedef struct {
  * @brief MLME service access point descriptor
  */
 typedef struct {
-    xtimer_t backoff_timer; /**< timer used for backoff expiration */
-    msg_t backoff_msg;      /**< msg for backoff expiration */
     uint8_t activation;     /**< Activation mechanism of the MAC layer */
     int pending_mlme_opts;  /**< holds pending mlme opts */
     uint32_t nid;           /**< current Network ID */
@@ -176,8 +171,6 @@ typedef struct {
 /**
  * @brief GNRC LoRaWAN mac descriptor */
 typedef struct {
-    xtimer_t rx;                                    /**< RX timer */
-    msg_t msg;                                      /**< MAC layer message descriptor */
     gnrc_lorawan_mcps_t mcps;                       /**< MCPS descriptor */
     gnrc_lorawan_mlme_t mlme;                       /**< MLME descriptor */
     void *mlme_buf;                                 /**< pointer to MLME buffer */
@@ -420,11 +413,12 @@ uint8_t gnrc_lorawan_region_mac_payload_max(uint8_t datarate);
 /**
  * @brief MLME Backoff expiration tick
  *
- *        Should be called every hour in order to maintain the Time On Air budget.
+ *        Must be called once an hour (right after calling @ref
+ *        gnrc_lorawan_init) in order to maintain the Time On Air budget.
  *
  * @param[in] mac pointer to the MAC descriptor
  */
-void gnrc_lorawan_mlme_backoff_expire(gnrc_lorawan_t *mac);
+void gnrc_lorawan_mlme_backoff_expire_cb(gnrc_lorawan_t *mac);
 
 /**
  * @brief Process and dispatch a full LoRaWAN packet
@@ -487,6 +481,13 @@ static inline void gnrc_lorawan_mac_release(gnrc_lorawan_t *mac)
  */
 void gnrc_lorawan_set_rx2_dr(gnrc_lorawan_t *mac, uint8_t rx2_dr);
 
+/**
+ * @brief Trigger the transmission of the Join Request packet.
+ *
+ * @param[in] mac pointer to the MAC descriptor
+ */
+void gnrc_lorawan_trigger_join(gnrc_lorawan_t *mac);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sys/net/gnrc/netif/Kconfig b/sys/net/gnrc/netif/Kconfig
index de4cb01adb..35acd68d85 100644
--- a/sys/net/gnrc/netif/Kconfig
+++ b/sys/net/gnrc/netif/Kconfig
@@ -61,4 +61,17 @@ config GNRC_NETIF_PKTQ_TIMER_US
         Set to -1 to deactivate dequeing by timer. For this it has to be ensured
         that none of the notifications by the driver are missed!
 
+config GNRC_NETIF_LORAWAN_NETIF_HDR
+    bool "Encode LoRaWAN port in GNRC netif header"
+    depends on USEMODULE_GNRC_LORAWAN
+    help
+        When set, GNRC Netif will interpret
+        the destination address of the GNRC netif header as
+        the LoRaWAN port. For downlinks, a GNRC netif header
+        with the received port in destination field will be
+        included in the first snip. From Release 2021.10 all
+        GNRC LoRaWAN packets will include the GNRC Netif
+        header. Therefore this parameter will be removed
+
+
 endif # KCONFIG_USEMODULE_GNRC_NETIF
diff --git a/sys/net/gnrc/netif/gnrc_netif.c b/sys/net/gnrc/netif/gnrc_netif.c
index 2f3e260029..59e9ca8c3f 100644
--- a/sys/net/gnrc/netif/gnrc_netif.c
+++ b/sys/net/gnrc/netif/gnrc_netif.c
@@ -56,11 +56,18 @@ static void _check_netdev_capabilities(netdev_t *dev);
 static void *_gnrc_netif_thread(void *args);
 static void _event_cb(netdev_t *dev, netdev_event_t event);
 
+typedef struct {
+    gnrc_netif_t *netif;
+    mutex_t init_done;
+    int result;
+} _netif_ctx_t;
+
 int gnrc_netif_create(gnrc_netif_t *netif, char *stack, int stacksize,
                       char priority, const char *name, netdev_t *netdev,
                       const gnrc_netif_ops_t *ops)
 {
     int res;
+    _netif_ctx_t ctx;
 
     if (IS_ACTIVE(DEVELHELP) && gnrc_netif_highlander() && netif_iter(NULL)) {
         LOG_WARNING("gnrc_netif: gnrc_netif_highlander() returned true but "
@@ -81,11 +88,20 @@ int gnrc_netif_create(gnrc_netif_t *netif, char *stack, int stacksize,
     netstats_nb_init(&netif->netif);
 #endif
 
+    /* prepare thread context */
+    ctx.netif = netif;
+    mutex_init(&ctx.init_done);
+    mutex_lock(&ctx.init_done);
+
     res = thread_create(stack, stacksize, priority, THREAD_CREATE_STACKTEST,
-                        _gnrc_netif_thread, (void *)netif, name);
-    (void)res;
+                        _gnrc_netif_thread, &ctx, name);
     assert(res > 0);
-    return 0;
+    (void)res;
+
+    /* wait for result of driver init */
+    mutex_lock(&ctx.init_done);
+
+    return ctx.result;
 }
 
 bool gnrc_netif_dev_is_6lo(const gnrc_netif_t *netif)
@@ -1364,8 +1380,13 @@ static void _test_options(gnrc_netif_t *netif)
             assert(netif->flags & GNRC_NETIF_FLAGS_HAS_L2ADDR);
             assert(netif->l2addr_len >= 3U && netif->l2addr_len <= 5U);
             break;
-        case NETDEV_TYPE_LORA: /* LoRa doesn't provide L2 ADDR */
         case NETDEV_TYPE_SLIP:
+#if IS_USED(MODULE_SLIPDEV_L2ADDR)
+            assert(netif->flags & GNRC_NETIF_FLAGS_HAS_L2ADDR);
+            assert(8U == netif->l2addr_len);
+            break;
+#endif /* IS_USED(MODULE_SLIPDEV_L2ADDR) */
+        case NETDEV_TYPE_LORA: /* LoRa doesn't provide L2 ADDR */
             assert(!(netif->flags & GNRC_NETIF_FLAGS_HAS_L2ADDR));
             assert(0U == netif->l2addr_len);
             /* don't check MTU here for now since I'm not sure the current
@@ -1633,6 +1654,7 @@ static void _send(gnrc_netif_t *netif, gnrc_pktsnip_t *pkt, bool push_back)
 
 static void *_gnrc_netif_thread(void *args)
 {
+    _netif_ctx_t *ctx = args;
     gnrc_netapi_opt_t *opt;
     gnrc_netif_t *netif;
     netdev_t *dev;
@@ -1641,7 +1663,7 @@ static void *_gnrc_netif_thread(void *args)
     msg_t msg_queue[GNRC_NETIF_MSG_QUEUE_SIZE];
 
     DEBUG("gnrc_netif: starting thread %i\n", thread_getpid());
-    netif = args;
+    netif = ctx->netif;
     gnrc_netif_acquire(netif);
     dev = netif->dev;
     netif->pid = thread_getpid();
@@ -1658,9 +1680,11 @@ static void *_gnrc_netif_thread(void *args)
     dev->event_callback = _event_cb;
     dev->context = netif;
     /* initialize low-level driver */
-    res = dev->driver->init(dev);
-    if (res < 0) {
-        LOG_ERROR("gnrc_netif: netdev init failed: %d\n", res);
+    ctx->result = dev->driver->init(dev);
+    /* signal that driver init is done */
+    mutex_unlock(&ctx->init_done);
+    if (ctx->result < 0) {
+        LOG_ERROR("gnrc_netif: netdev init failed: %d\n", ctx->result);
         return NULL;
     }
     netif_register(&netif->netif);
diff --git a/sys/net/gnrc/netif/gnrc_netif_device_type.c b/sys/net/gnrc/netif/gnrc_netif_device_type.c
index 4d0e9ab842..3103bdf7bd 100644
--- a/sys/net/gnrc/netif/gnrc_netif_device_type.c
+++ b/sys/net/gnrc/netif/gnrc_netif_device_type.c
@@ -56,6 +56,11 @@ netopt_t gnrc_netif_get_l2addr_opt(const gnrc_netif_t *netif)
                 }
             }
             break;
+#endif
+#if defined(MODULE_SLIPDEV_L2ADDR)
+        case NETDEV_TYPE_SLIP:
+            res = NETOPT_ADDRESS_LONG;
+            break;
 #endif
         default:
             break;
diff --git a/sys/net/gnrc/netif/ieee802154/gnrc_netif_ieee802154.c b/sys/net/gnrc/netif/ieee802154/gnrc_netif_ieee802154.c
index 5fbef5a2b2..d1d324afbe 100644
--- a/sys/net/gnrc/netif/ieee802154/gnrc_netif_ieee802154.c
+++ b/sys/net/gnrc/netif/ieee802154/gnrc_netif_ieee802154.c
@@ -129,6 +129,11 @@ static gnrc_pktsnip_t *_recv(gnrc_netif_t *netif)
             gnrc_netif_hdr_t *hdr = netif_snip->data;
             hdr->lqi = rx_info.lqi;
             hdr->rssi = rx_info.rssi;
+#if IS_USED(MODULE_GNRC_NETIF_TIMESTAMP)
+            if (rx_info.flags & NETDEV_RX_IEEE802154_INFO_FLAG_TIMESTAMP) {
+                gnrc_netif_hdr_set_timestamp(hdr, rx_info.timestamp);
+            }
+#endif
             gnrc_netif_hdr_set_netif(hdr, netif);
             pkt = gnrc_pkt_append(pkt, netif_snip);
         }
@@ -198,6 +203,11 @@ static gnrc_pktsnip_t *_recv(gnrc_netif_t *netif)
 #endif
             hdr->lqi = rx_info.lqi;
             hdr->rssi = rx_info.rssi;
+#if IS_USED(MODULE_GNRC_NETIF_TIMESTAMP)
+            if (rx_info.flags & NETDEV_RX_IEEE802154_INFO_FLAG_TIMESTAMP) {
+                gnrc_netif_hdr_set_timestamp(hdr, rx_info.timestamp);
+            }
+#endif
             gnrc_netif_hdr_set_netif(hdr, netif);
             dev->driver->get(dev, NETOPT_PROTO, &pkt->type, sizeof(pkt->type));
             if (IS_ACTIVE(ENABLE_DEBUG)) {
@@ -245,7 +255,7 @@ static int _send(gnrc_netif_t *netif, gnrc_pktsnip_t *pkt)
     size_t src_len, dst_len;
     uint8_t mhr_len;
 #if IS_USED(MODULE_IEEE802154_SECURITY)
-    uint8_t mhr[IEEE802154_MAX_HDR_LEN + IEEE802154_MAX_AUX_HDR_LEN];
+    uint8_t mhr[IEEE802154_MAX_HDR_LEN + IEEE802154_SEC_MAX_AUX_HDR_LEN];
 #else
     uint8_t mhr[IEEE802154_MAX_HDR_LEN];
 #endif
@@ -336,7 +346,7 @@ static int _send(gnrc_netif_t *netif, gnrc_pktsnip_t *pkt)
 
         iolist_header.iol_next = (iolist_t *)pkt->next;
 
-        uint8_t mic[IEEE802154_MAC_SIZE];
+        uint8_t mic[IEEE802154_SEC_MAX_MAC_SIZE];
         uint8_t mic_size = 0;
 
         if (flags & NETDEV_IEEE802154_SECURITY_EN) {
diff --git a/sys/net/gnrc/netif/init_devs/auto_init_cc2420.c b/sys/net/gnrc/netif/init_devs/auto_init_cc2420.c
index 49b94e008a..a21824eeba 100644
--- a/sys/net/gnrc/netif/init_devs/auto_init_cc2420.c
+++ b/sys/net/gnrc/netif/init_devs/auto_init_cc2420.c
@@ -57,7 +57,7 @@ void auto_init_cc2420(void)
     for (unsigned i = 0; i < CC2420_NUMOF; i++) {
         LOG_DEBUG("[auto_init_netif] initializing cc2420 #%u\n", i);
 
-        cc2420_setup(&cc2420_devs[i], &cc2420_params[i]);
+        cc2420_setup(&cc2420_devs[i], &cc2420_params[i], i);
         gnrc_netif_ieee802154_create(&_netif[i], _cc2420_stacks[i], CC2420_MAC_STACKSIZE,
                                      CC2420_MAC_PRIO, "cc2420",
                                      (netdev_t *)&cc2420_devs[i]);
diff --git a/sys/net/gnrc/netif/init_devs/auto_init_ethos.c b/sys/net/gnrc/netif/init_devs/auto_init_ethos.c
index adaf636b2f..79e4fe64ca 100644
--- a/sys/net/gnrc/netif/init_devs/auto_init_ethos.c
+++ b/sys/net/gnrc/netif/init_devs/auto_init_ethos.c
@@ -20,15 +20,18 @@
 #include "log.h"
 #include "debug.h"
 #include "ethos.h"
+#include "ethos_params.h"
 #include "periph/uart.h"
 #include "net/gnrc/netif/ethernet.h"
 
+#define ETHOS_NUM ARRAY_SIZE(ethos_params)
+
 /**
  * @brief global ethos object, used by stdio_uart
  */
-ethos_t ethos;
+ethos_t ethos[ETHOS_NUM];
 
-static gnrc_netif_t _netif;
+static gnrc_netif_t _netif[ETHOS_NUM];
 
 /**
  * @brief   Define stack parameters for the MAC layer thread
@@ -42,24 +45,21 @@ static gnrc_netif_t _netif;
 /**
  * @brief   Stacks for the MAC layer threads
  */
-static char _netdev_eth_stack[ETHOS_MAC_STACKSIZE];
+static char _netdev_eth_stack[ETHOS_NUM][ETHOS_MAC_STACKSIZE];
 
-static uint8_t _inbuf[2048];
+static uint8_t _inbuf[ETHOS_NUM][2048];
 
 void auto_init_ethos(void)
 {
-    LOG_DEBUG("[auto_init_netif] initializing ethos #0\n");
+    for (unsigned i = 0; i < ETHOS_NUM; ++i) {
+        LOG_DEBUG("[auto_init_netif] initializing ethos #%u\n", i);
 
-    /* setup netdev device */
-    ethos_params_t p;
-    p.uart      = ETHOS_UART;
-    p.baudrate  = ETHOS_BAUDRATE;
-    p.buf       = _inbuf;
-    p.bufsize   = sizeof(_inbuf);
-    ethos_setup(&ethos, &p);
+        /* setup netdev device */
+        ethos_setup(&ethos[i], &ethos_params[i], i, _inbuf[i], sizeof(_inbuf[i]));
 
-    /* initialize netdev<->gnrc adapter state */
-    gnrc_netif_ethernet_create(&_netif, _netdev_eth_stack, ETHOS_MAC_STACKSIZE,
-                               ETHOS_MAC_PRIO, "ethos", (netdev_t *)&ethos);
+        /* initialize netdev<->gnrc adapter state */
+        gnrc_netif_ethernet_create(&_netif[i], _netdev_eth_stack[i], ETHOS_MAC_STACKSIZE,
+                                   ETHOS_MAC_PRIO, "ethos", (netdev_t *)&ethos[i]);
+    }
 }
 /** @} */
diff --git a/sys/net/gnrc/netif/init_devs/auto_init_slipdev.c b/sys/net/gnrc/netif/init_devs/auto_init_slipdev.c
index 7781a7e318..2dca489e59 100644
--- a/sys/net/gnrc/netif/init_devs/auto_init_slipdev.c
+++ b/sys/net/gnrc/netif/init_devs/auto_init_slipdev.c
@@ -48,7 +48,7 @@ void auto_init_slipdev(void)
 
         LOG_DEBUG("[auto_init_netif] initializing slip #%u\n", i);
 
-        slipdev_setup(&slipdevs[i], p);
+        slipdev_setup(&slipdevs[i], p, i);
         gnrc_netif_raw_create(&_netif[i], _slipdev_stacks[i], SLIPDEV_STACKSIZE,
                               SLIPDEV_PRIO, "slipdev",
                               (netdev_t *)&slipdevs[i]);
diff --git a/sys/net/gnrc/netif/lorawan/gnrc_netif_lorawan.c b/sys/net/gnrc/netif/lorawan/gnrc_netif_lorawan.c
index 6dabb4a474..4dd6104dfc 100644
--- a/sys/net/gnrc/netif/lorawan/gnrc_netif_lorawan.c
+++ b/sys/net/gnrc/netif/lorawan/gnrc_netif_lorawan.c
@@ -18,6 +18,7 @@
 
 #include "net/gnrc/pktbuf.h"
 #include "net/gnrc/netif.h"
+#include "net/gnrc/netif/hdr.h"
 #include "net/gnrc/netif/lorawan.h"
 #include "net/gnrc/netif/internal.h"
 #include "net/gnrc/lorawan.h"
@@ -27,9 +28,11 @@
 #include "net/gnrc/lorawan/region.h"
 #include "net/gnrc/netreg.h"
 
-#define ENABLE_DEBUG 0
+#define ENABLE_DEBUG    (0)
 #include "debug.h"
 
+#define MSG_TYPE_MLME_BACKOFF_EXPIRE (0x3458)           /**< Backoff timer expiration message type */
+
 static uint8_t _nwkskey[LORAMAC_NWKSKEY_LEN];
 static uint8_t _appskey[LORAMAC_APPSKEY_LEN];
 static uint8_t _appkey[LORAMAC_APPKEY_LEN];
@@ -37,6 +40,9 @@ static uint8_t _deveui[LORAMAC_DEVEUI_LEN];
 static uint8_t _appeui[LORAMAC_APPEUI_LEN];
 static uint8_t _devaddr[LORAMAC_DEVADDR_LEN];
 
+static msg_t timeout_msg = {.type = MSG_TYPE_TIMEOUT};
+static msg_t backoff_msg = {.type = MSG_TYPE_MLME_BACKOFF_EXPIRE};
+
 static int _send(gnrc_netif_t *netif, gnrc_pktsnip_t *pkt);
 static gnrc_pktsnip_t *_recv(gnrc_netif_t *netif);
 static void _msg_handler(gnrc_netif_t *netif, msg_t *msg);
@@ -73,6 +79,18 @@ void gnrc_lorawan_mlme_confirm(gnrc_lorawan_t *mac, mlme_confirm_t *confirm)
     }
 }
 
+void gnrc_lorawan_set_timer(gnrc_lorawan_t *mac, uint32_t us)
+{
+    gnrc_netif_lorawan_t *lw_netif = container_of(mac, gnrc_netif_lorawan_t, mac);
+    ztimer_set_msg(ZTIMER_MSEC, &lw_netif->timer, us/1000, &timeout_msg, thread_getpid());
+}
+
+void gnrc_lorawan_remove_timer(gnrc_lorawan_t *mac)
+{
+    gnrc_netif_lorawan_t *lw_netif = container_of(mac, gnrc_netif_lorawan_t, mac);
+    ztimer_remove(ZTIMER_MSEC, &lw_netif->timer);
+}
+
 static inline void _set_be_addr(gnrc_lorawan_t *mac, uint8_t *be_addr)
 {
     uint32_t tmp = byteorder_bebuftohl(be_addr);
@@ -90,19 +108,47 @@ static inline void _set_be_addr(gnrc_lorawan_t *mac, uint8_t *be_addr)
 
 void gnrc_lorawan_mcps_indication(gnrc_lorawan_t *mac, mcps_indication_t *ind)
 {
-    (void)mac;
+    gnrc_netif_t *netif = container_of(mac, gnrc_netif_t, lorawan.mac);
+    gnrc_nettype_t nettype = IS_ACTIVE(CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR)
+                     ? GNRC_NETTYPE_UNDEF
+                     : GNRC_NETTYPE_LORAWAN;
+    uint32_t demux = IS_ACTIVE(CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR)
+                     ? GNRC_NETREG_DEMUX_CTX_ALL
+                     : ind->data.port;
+
+    assert(ind->data.port >= LORAMAC_PORT_MIN && ind->data.port <= LORAMAC_PORT_MAX);
+
     gnrc_pktsnip_t *pkt = gnrc_pktbuf_add(NULL, ind->data.pkt->iol_base,
                                           ind->data.pkt->iol_len,
-                                          GNRC_NETTYPE_LORAWAN);
+                                          nettype);
     if (!pkt) {
         DEBUG("gnrc_lorawan: mcps_indication: couldn't allocate pktbuf\n");
         return;
     }
 
-    if (!gnrc_netapi_dispatch_receive(GNRC_NETTYPE_LORAWAN, ind->data.port,
-                                      pkt)) {
-        gnrc_pktbuf_release(pkt);
+    if (IS_ACTIVE(CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR)) {
+        gnrc_pktsnip_t *netif_snip = gnrc_netif_hdr_build(NULL, 0,
+                                                          &ind->data.port,
+                                                          sizeof(ind->data.port));
+        if (netif_snip == NULL) {
+            DEBUG("gnrc_lorawan_netif: no space left in packet buffer\n");
+            goto release;
+        }
+
+        gnrc_netif_hdr_t *hdr = netif_snip->data;
+        gnrc_netif_hdr_set_netif(hdr, netif);
+        pkt = gnrc_pkt_append(pkt, netif_snip);
     }
+
+    if (!gnrc_netapi_dispatch_receive(nettype, demux, pkt)) {
+        DEBUG("gnrc_lorawan_netif: unable to forward packet\n")
+        goto release;
+    }
+
+    return;
+
+release:
+    gnrc_pktbuf_release(pkt);
 }
 
 void gnrc_lorawan_mlme_indication(gnrc_lorawan_t *mac, mlme_indication_t *ind)
@@ -134,13 +180,13 @@ static void _rx_done(gnrc_lorawan_t *mac)
         DEBUG("_recv_lorawan: cannot allocate pktsnip.\n");
         /* Discard packet on netdev device */
         dev->driver->recv(dev, NULL, bytes_expected, NULL);
-        gnrc_lorawan_radio_rx_done_cb(mac, NULL, 0);
+        gnrc_lorawan_radio_rx_error_cb(mac);
         return;
     }
     nread = dev->driver->recv(dev, pkt->data, bytes_expected, &rx_info);
     if (nread <= 0) {
         gnrc_pktbuf_release(pkt);
-        gnrc_lorawan_radio_rx_done_cb(mac, NULL, 0);
+        gnrc_lorawan_radio_rx_error_cb(mac);
         return;
     }
 
@@ -228,8 +274,11 @@ static void _init(gnrc_netif_t *netif)
     _memcpy_reversed(netif->lorawan.appeui, _appeui, sizeof(_appeui));
 
     _set_be_addr(&netif->lorawan.mac, _devaddr);
-    gnrc_lorawan_init(&netif->lorawan.mac, netif->lorawan.nwkskey,
-                      netif->lorawan.appskey);
+    gnrc_lorawan_init(&netif->lorawan.mac, netif->lorawan.nwkskey, netif->lorawan.appskey);
+
+    ztimer_set_msg(ZTIMER_MSEC, &netif->lorawan.backoff_timer,
+                   GNRC_LORAWAN_BACKOFF_WINDOW_TICK / 1000,
+                   &backoff_msg, thread_getpid());
 }
 
 int gnrc_netif_lorawan_create(gnrc_netif_t *netif, char *stack, int stacksize,
@@ -251,23 +300,54 @@ static int _send(gnrc_netif_t *netif, gnrc_pktsnip_t *payload)
     mlme_request_t mlme_request;
     mlme_confirm_t mlme_confirm;
 
+    uint8_t port;
+    int res = -EINVAL;
+
+    assert(payload);
+
+    if (IS_ACTIVE(CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR)) {
+        gnrc_netif_hdr_t *netif_hdr;
+        const uint8_t *dst;
+        netif_hdr = payload->data;
+        dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);
+
+        assert(payload->type == GNRC_NETTYPE_NETIF);
+        port = dst[0];
+
+        if (netif_hdr->dst_l2addr_len != sizeof(port)) {
+            goto end;
+        }
+
+        /* Remove the netif hdr snip and point to the MSDU */
+        payload = gnrc_pktbuf_remove_snip(payload, payload);
+
+    }
+    else {
+        port = netif->lorawan.port;
+    }
+
     if (netif->lorawan.flags & GNRC_NETIF_LORAWAN_FLAGS_LINK_CHECK) {
         mlme_request.type = MLME_LINK_CHECK;
         gnrc_lorawan_mlme_request(&netif->lorawan.mac, &mlme_request,
                                   &mlme_confirm);
     }
+
     mcps_request_t req =
     { .type = netif->lorawan.ack_req ? MCPS_CONFIRMED : MCPS_UNCONFIRMED,
       .data =
-      { .pkt = (iolist_t *)payload, .port = netif->lorawan.port,
+      { .pkt = (iolist_t *)payload, .port = port,
           .dr = netif->lorawan.datarate } };
     mcps_confirm_t conf;
 
     gnrc_lorawan_mcps_request(&netif->lorawan.mac, &req, &conf);
-    if (conf.status < 0) {
-        gnrc_pktbuf_release_error(payload, conf.status);
+    res = conf.status;
+
+    if (res < 0) {
+        gnrc_pktbuf_release_error(payload, res);
     }
-    return conf.status;
+
+end:
+    return res;
 }
 
 static void _msg_handler(gnrc_netif_t *netif, msg_t *msg)
@@ -276,13 +356,13 @@ static void _msg_handler(gnrc_netif_t *netif, msg_t *msg)
     (void)msg;
     switch (msg->type) {
         case MSG_TYPE_TIMEOUT:
-            gnrc_lorawan_open_rx_window(&netif->lorawan.mac);
-            break;
-        case MSG_TYPE_MCPS_ACK_TIMEOUT:
-            gnrc_lorawan_event_ack_timeout(&netif->lorawan.mac);
+            gnrc_lorawan_timeout_cb(&netif->lorawan.mac);
             break;
         case MSG_TYPE_MLME_BACKOFF_EXPIRE:
-            gnrc_lorawan_mlme_backoff_expire(&netif->lorawan.mac);
+            gnrc_lorawan_mlme_backoff_expire_cb(&netif->lorawan.mac);
+            ztimer_set_msg(ZTIMER_MSEC, &netif->lorawan.backoff_timer,
+                           GNRC_LORAWAN_BACKOFF_WINDOW_TICK / 1000,
+                           &backoff_msg, thread_getpid());
         default:
             break;
     }
diff --git a/sys/net/gnrc/network_layer/ipv6/nib/_nib-6lr.h b/sys/net/gnrc/network_layer/ipv6/nib/_nib-6lr.h
index 60054a703b..44dd896bae 100644
--- a/sys/net/gnrc/network_layer/ipv6/nib/_nib-6lr.h
+++ b/sys/net/gnrc/network_layer/ipv6/nib/_nib-6lr.h
@@ -118,12 +118,6 @@ gnrc_pktsnip_t *_copy_and_handle_aro(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6
                                      const sixlowpan_nd_opt_ar_t *aro,
                                      const ndp_opt_t *sl2ao);
 
-/**
- * @brief   Sets the @ref GNRC_NETIF_FLAGS_IPV6_RTR_ADV flags of an interface
- *
- * @param[in] netif The interface.
- */
-void _set_rtr_adv(gnrc_netif_t *netif);
 #else   /* CONFIG_GNRC_IPV6_NIB_6LR || defined(DOXYGEN) */
 #define _rtr_sol_on_6lr(netif, icmpv6)  (false)
 #define _get_ar_state(nbr)              (_ADDR_REG_STATUS_IGNORE)
@@ -133,7 +127,6 @@ void _set_rtr_adv(gnrc_netif_t *netif);
  */
 #define _copy_and_handle_aro(netif, ipv6, icmpv6, aro, sl2ao) \
                                         (NULL)
-#define _set_rtr_adv(netif)             (void)netif
 #endif  /* CONFIG_GNRC_IPV6_NIB_6LR || defined(DOXYGEN) */
 
 #ifdef __cplusplus
diff --git a/sys/net/gnrc/network_layer/ipv6/nib/_nib-router.h b/sys/net/gnrc/network_layer/ipv6/nib/_nib-router.h
index 51705029f9..1798ee5c40 100644
--- a/sys/net/gnrc/network_layer/ipv6/nib/_nib-router.h
+++ b/sys/net/gnrc/network_layer/ipv6/nib/_nib-router.h
@@ -46,8 +46,7 @@ static inline void _init_iface_router(gnrc_netif_t *netif)
     netif->ipv6.ra_sent = 0;
     netif->flags |= GNRC_NETIF_FLAGS_IPV6_FORWARDING;
 
-    if (!IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR) ||
-        IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LBR)) {
+    if (IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_ADV_ROUTER)) {
         netif->flags |= GNRC_NETIF_FLAGS_IPV6_RTR_ADV;
     }
 
diff --git a/sys/net/gnrc/network_layer/ipv6/nib/_nib-slaac.c b/sys/net/gnrc/network_layer/ipv6/nib/_nib-slaac.c
index 1771eb119f..46bfb3a0cb 100644
--- a/sys/net/gnrc/network_layer/ipv6/nib/_nib-slaac.c
+++ b/sys/net/gnrc/network_layer/ipv6/nib/_nib-slaac.c
@@ -163,7 +163,7 @@ void _remove_tentative_addr(gnrc_netif_t *netif, const ipv6_addr_t *addr)
          * not change hardware address to retry SLAAC => use purely
          * DHCPv6 instead */
         /* TODO: implement IA_NA for DHCPv6 */
-        /* then => tgt_netif->aac_mode = GNRC_NETIF_AAC_DHCP; */
+        /* then => tgt_netif->aac_mode |= GNRC_NETIF_AAC_DHCP; */
         DEBUG("nib: would set interface %i to DHCPv6, "
               "but is not implemented yet", netif->pid);
     }
diff --git a/sys/net/gnrc/network_layer/ipv6/nib/nib.c b/sys/net/gnrc/network_layer/ipv6/nib/nib.c
index 4575c82e0f..44699579b4 100644
--- a/sys/net/gnrc/network_layer/ipv6/nib/nib.c
+++ b/sys/net/gnrc/network_layer/ipv6/nib/nib.c
@@ -133,7 +133,7 @@ void gnrc_ipv6_nib_init_iface(gnrc_netif_t *netif)
 #if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_SLAAC) || IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LN)
     /* TODO: set differently dependent on CONFIG_GNRC_IPV6_NIB_SLAAC if
      * alternatives exist */
-    netif->ipv6.aac_mode = GNRC_NETIF_AAC_AUTO;
+    netif->ipv6.aac_mode |= GNRC_NETIF_AAC_AUTO;
 #endif  /* CONFIG_GNRC_IPV6_NIB_SLAAC || CONFIG_GNRC_IPV6_NIB_6LN */
     _init_iface_router(netif);
     gnrc_netif_init_6ln(netif);
@@ -168,6 +168,7 @@ void gnrc_ipv6_nib_init_iface(gnrc_netif_t *netif)
 static bool _on_link(const ipv6_addr_t *dst, unsigned *iface)
 {
     _nib_offl_entry_t *entry = NULL;
+    uint8_t best_pfx = 0;
 
 #if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LN)
     if (*iface != 0) {
@@ -178,11 +179,15 @@ static bool _on_link(const ipv6_addr_t *dst, unsigned *iface)
 #endif  /* CONFIG_GNRC_IPV6_NIB_6LN */
     while ((entry = _nib_offl_iter(entry))) {
         if ((entry->mode & _PL) && (entry->flags & _PFX_ON_LINK) &&
-            (ipv6_addr_match_prefix(dst, &entry->pfx) >= entry->pfx_len)) {
+            (ipv6_addr_match_prefix(dst, &entry->pfx) >= entry->pfx_len) &&
+            (entry->pfx_len > best_pfx)) {
             *iface = _nib_onl_get_if(entry->next_hop);
-            return true;
+            best_pfx = entry->pfx_len;
         }
     }
+    if (best_pfx) {
+        return true;
+    }
     return ipv6_addr_is_link_local(dst);
 }
 
@@ -223,6 +228,10 @@ int gnrc_ipv6_nib_get_next_hop_l2addr(const ipv6_addr_t *dst,
                 /* release pre-assumed netif */
                 gnrc_netif_release(netif);
                 netif = _acquire_new_iface(iface);
+                /* get node from proper interface */
+                if (netif != NULL) {
+                    node = _nib_onl_get(dst, netif->pid);
+                }
             }
             if ((netif == NULL) ||
                 !_resolve_addr(dst, netif, pkt, nce, node)) {
@@ -872,6 +881,7 @@ static void _handle_nbr_sol(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6,
                             const ndp_nbr_sol_t *nbr_sol, size_t icmpv6_len)
 {
     size_t tmp_len = icmpv6_len - sizeof(ndp_nbr_sol_t);
+    gnrc_netif_t *tgt_netif;
     int tgt_idx;
     ndp_opt_t *opt;
 
@@ -897,13 +907,23 @@ static void _handle_nbr_sol(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6,
               ipv6_addr_to_str(addr_str, &ipv6->dst, sizeof(addr_str)));
         return;
     }
-    /* check if target is assigned only now in case the length was wrong */
-    tgt_idx = gnrc_netif_ipv6_addr_idx(netif, &nbr_sol->tgt);
+
+    /* check if the address belongs to this host */
+    tgt_netif = gnrc_netif_get_by_ipv6_addr(&nbr_sol->tgt);
+
+    if (tgt_netif != NULL) {
+        /* check if target is assigned only now in case the length was wrong */
+        tgt_idx = gnrc_netif_ipv6_addr_idx(tgt_netif, &nbr_sol->tgt);
+    } else {
+        tgt_idx = -1;
+    }
+
     if (tgt_idx < 0) {
         DEBUG("nib: Target address %s is not assigned to the local interface\n",
               ipv6_addr_to_str(addr_str, &nbr_sol->tgt, sizeof(addr_str)));
         return;
     }
+
     /* pre-check option length */
     FOREACH_OPT(nbr_sol, opt, tmp_len) {
         if (tmp_len > icmpv6_len) {
@@ -925,19 +945,16 @@ static void _handle_nbr_sol(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6,
     DEBUG("     - Destination address: %s\n",
           ipv6_addr_to_str(addr_str, &ipv6->dst, sizeof(addr_str)));
 #if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_SLAAC)
-    gnrc_netif_t *tgt_netif = gnrc_netif_get_by_ipv6_addr(&nbr_sol->tgt);
 
     if (tgt_netif != NULL) {
-        int idx;
-
         gnrc_netif_acquire(tgt_netif);
-        idx = gnrc_netif_ipv6_addr_idx(tgt_netif, &nbr_sol->tgt);
+        tgt_idx = gnrc_netif_ipv6_addr_idx(tgt_netif, &nbr_sol->tgt);
         /* if idx < 0:
          * nbr_sol->tgt was removed between getting tgt_netif by nbr_sol->tgt
          * and gnrc_netif_acquire(tgt_netif). This is like `tgt_netif` would
          * have been NULL in the first place so just continue as if it would
          * have. */
-        if ((idx >= 0) && gnrc_netif_ipv6_addr_dad_trans(tgt_netif, idx)) {
+        if ((tgt_idx >= 0) && gnrc_netif_ipv6_addr_dad_trans(tgt_netif, tgt_idx)) {
             if (!ipv6_addr_is_unspecified(&ipv6->src)) {
                 /* (see https://tools.ietf.org/html/rfc4862#section-5.4.3) */
                 DEBUG("nib: Neighbor is performing AR, but target address is "
@@ -947,7 +964,7 @@ static void _handle_nbr_sol(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6,
             }
             /* cancel validation timer */
             evtimer_del(&_nib_evtimer,
-                        &tgt_netif->ipv6.addrs_timers[idx].event);
+                        &tgt_netif->ipv6.addrs_timers[tgt_idx].event);
             /* _remove_tentative_addr() context switches to `tgt_netif->pid` so
              * release `tgt_netif`. We are done here anyway. */
             gnrc_netif_release(tgt_netif);
diff --git a/sys/net/gnrc/network_layer/ipv6/nib/nib_pl.c b/sys/net/gnrc/network_layer/ipv6/nib/nib_pl.c
index 6ddd8c94fa..054c90ead1 100644
--- a/sys/net/gnrc/network_layer/ipv6/nib/nib_pl.c
+++ b/sys/net/gnrc/network_layer/ipv6/nib/nib_pl.c
@@ -69,7 +69,7 @@ int gnrc_ipv6_nib_pl_set(unsigned iface,
         (ipv6_addr_match_prefix(&netif->ipv6.addrs[idx], pfx) >= pfx_len)) {
         dst->flags |= _PFX_ON_LINK;
     }
-    if (netif->ipv6.aac_mode == GNRC_NETIF_AAC_AUTO) {
+    if (netif->ipv6.aac_mode & GNRC_NETIF_AAC_AUTO) {
         dst->flags |= _PFX_SLAAC;
     }
 #if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LBR) && IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_MULTIHOP_P6C)
diff --git a/sys/net/gnrc/network_layer/ndp/gnrc_ndp.c b/sys/net/gnrc/network_layer/ndp/gnrc_ndp.c
index 2fc4d16437..9f9a8a1e14 100644
--- a/sys/net/gnrc/network_layer/ndp/gnrc_ndp.c
+++ b/sys/net/gnrc/network_layer/ndp/gnrc_ndp.c
@@ -331,11 +331,16 @@ void gnrc_ndp_nbr_adv_send(const ipv6_addr_t *tgt, gnrc_netif_t *netif,
     gnrc_netif_acquire(netif);
     do {    /* XXX: hidden goto */
         int tgt_idx;
+        gnrc_netif_t *tgt_netif = gnrc_netif_get_by_ipv6_addr(tgt);
 
-        if ((tgt_idx = gnrc_netif_ipv6_addr_idx(netif, tgt)) < 0) {
+        if (tgt_netif == NULL) {
             DEBUG("ndp: tgt not assigned to interface. Abort sending\n");
             break;
         }
+
+        tgt_idx = gnrc_netif_ipv6_addr_idx(tgt_netif, tgt);
+        assert(tgt_idx >= 0);
+
         if (gnrc_netif_is_rtr(netif) && gnrc_netif_is_rtr_adv(netif)) {
             adv_flags |= NDP_NBR_ADV_FLAGS_R;
         }
@@ -368,7 +373,7 @@ void gnrc_ndp_nbr_adv_send(const ipv6_addr_t *tgt, gnrc_netif_t *netif,
         }
         /* TODO: also check if the node provides proxy services for tgt */
         if ((pkt != NULL) &&
-            (netif->ipv6.addrs_flags[tgt_idx] &
+            (tgt_netif->ipv6.addrs_flags[tgt_idx] &
              GNRC_NETIF_IPV6_ADDRS_FLAGS_ANYCAST)) {
             /* TL2A is not supplied and tgt is not anycast */
             adv_flags |= NDP_NBR_ADV_FLAGS_O;
@@ -538,7 +543,7 @@ void gnrc_ndp_rtr_adv_send(gnrc_netif_t *netif, const ipv6_addr_t *src,
         if (!fin) {
             adv_ltime = netif->ipv6.rtr_ltime;
         }
-        if (netif->ipv6.aac_mode == GNRC_NETIF_AAC_DHCP) {
+        if (netif->ipv6.aac_mode & GNRC_NETIF_AAC_DHCP) {
             flags |= NDP_RTR_ADV_FLAGS_M;
             if (netif->flags & GNRC_NETIF_FLAGS_IPV6_ADV_O_FLAG) {
                 flags |= NDP_RTR_ADV_FLAGS_O;
diff --git a/sys/net/gnrc/routing/rpl/gnrc_rpl.c b/sys/net/gnrc/routing/rpl/gnrc_rpl.c
index 154b031632..cc42f6453b 100644
--- a/sys/net/gnrc/routing/rpl/gnrc_rpl.c
+++ b/sys/net/gnrc/routing/rpl/gnrc_rpl.c
@@ -26,6 +26,12 @@
 #include "mutex.h"
 #include "evtimer.h"
 #include "random.h"
+#if IS_USED(MODULE_ZTIMER_MSEC)
+#include "ztimer.h"
+#include "timex.h"
+#else
+#include "xtimer.h"
+#endif
 #include "gnrc_rpl_internal/globals.h"
 
 #include "net/gnrc/rpl.h"
@@ -41,8 +47,13 @@ static char _stack[GNRC_RPL_STACK_SIZE];
 kernel_pid_t gnrc_rpl_pid = KERNEL_PID_UNDEF;
 const ipv6_addr_t ipv6_addr_all_rpl_nodes = GNRC_RPL_ALL_NODES_ADDR;
 #ifdef MODULE_GNRC_RPL_P2P
+#if IS_USED(MODULE_ZTIMER_MSEC)
+static uint32_t _lt_time = GNRC_RPL_LIFETIME_UPDATE_STEP * MS_PER_SEC;
+static ztimer_t _lt_timer;
+#else
 static uint32_t _lt_time = GNRC_RPL_LIFETIME_UPDATE_STEP * US_PER_SEC;
 static xtimer_t _lt_timer;
+#endif
 static msg_t _lt_msg = { .type = GNRC_RPL_MSG_TYPE_LIFETIME_UPDATE };
 #endif
 static msg_t _msg_q[GNRC_RPL_MSG_QUEUE_SIZE];
@@ -96,8 +107,13 @@ kernel_pid_t gnrc_rpl_init(kernel_pid_t if_pid)
         gnrc_rpl_of_manager_init();
         evtimer_init_msg(&gnrc_rpl_evtimer);
 #ifdef MODULE_GNRC_RPL_P2P
+#if IS_USED(MODULE_ZTIMER_MSEC)
+        ztimer_set_msg(ZTIMER_MSEC, &_lt_timer, _lt_time,
+                       &_lt_msg, gnrc_rpl_pid);
+#else
         xtimer_set_msg(&_lt_timer, _lt_time, &_lt_msg, gnrc_rpl_pid);
 #endif
+#endif
 
 #ifdef MODULE_NETSTATS_RPL
         memset(&gnrc_rpl_netstats, 0, sizeof(gnrc_rpl_netstats));
@@ -332,7 +348,11 @@ void _update_lifetime(void)
 {
     gnrc_rpl_p2p_update();
 
+#if IS_USED(MODULE_ZTIMER_MSEC)
+    ztimer_set_msg(ZTIMER_MSEC, &_lt_timer, _lt_time, &_lt_msg, gnrc_rpl_pid);
+#else
     xtimer_set_msg(&_lt_timer, _lt_time, &_lt_msg, gnrc_rpl_pid);
+#endif
 }
 #endif
 
diff --git a/sys/net/gnrc/routing/rpl/gnrc_rpl_control_messages.c b/sys/net/gnrc/routing/rpl/gnrc_rpl_control_messages.c
index 2e18583be2..2c30383678 100644
--- a/sys/net/gnrc/routing/rpl/gnrc_rpl_control_messages.c
+++ b/sys/net/gnrc/routing/rpl/gnrc_rpl_control_messages.c
@@ -19,6 +19,11 @@
 #include <assert.h>
 #include <string.h>
 #include "kernel_defines.h"
+#if IS_USED(MODULE_ZTIMER_MSEC)
+#include "ztimer.h"
+#else
+#include "xtimer.h"
+#endif
 
 #include "net/af.h"
 #include "net/icmpv6.h"
@@ -322,7 +327,11 @@ gnrc_pktsnip_t *_dio_prefix_info_build(gnrc_pktsnip_t *pkt, gnrc_rpl_dodag_t *do
     prefix_info->prefix_len = 64;
     if (_get_pl_entry(dodag->iface, &dodag->dodag_id, prefix_info->prefix_len,
                       &ple)) {
+#if IS_USED(MODULE_ZTIMER_MSEC)
+        uint32_t now = (uint32_t)ztimer_now(ZTIMER_MSEC);
+#else
         uint32_t now = (xtimer_now_usec64() / US_PER_MS) & UINT32_MAX;
+#endif
         uint32_t valid_ltime = (ple.valid_until < UINT32_MAX) ?
                                (ple.valid_until - now) / MS_PER_SEC : UINT32_MAX;
         uint32_t pref_ltime = (ple.pref_until < UINT32_MAX) ?
diff --git a/sys/net/gnrc/sock/include/gnrc_sock_internal.h b/sys/net/gnrc/sock/include/gnrc_sock_internal.h
index 550a0e164a..80dff66be3 100644
--- a/sys/net/gnrc/sock/include/gnrc_sock_internal.h
+++ b/sys/net/gnrc/sock/include/gnrc_sock_internal.h
@@ -125,7 +125,7 @@ static inline void gnrc_ep_set(sock_ip_ep_t *out, const sock_ip_ep_t *in,
                                size_t in_size)
 {
     memcpy(out, in, in_size);
-    if (gnrc_netif_highlander()) {
+    if (gnrc_netif_highlander() && (out->netif == 0)) {
         /* set interface implicitly */
         gnrc_netif_t *netif = gnrc_netif_iter(NULL);
 
diff --git a/sys/net/link_layer/eui_provider/eui_provider.c b/sys/net/link_layer/eui_provider/eui_provider.c
index 54e348ff11..95c5446ada 100644
--- a/sys/net/link_layer/eui_provider/eui_provider.c
+++ b/sys/net/link_layer/eui_provider/eui_provider.c
@@ -13,6 +13,7 @@
  * @author  Benjamin Valentin <benjamin.valentin@ml-pa.com>
  */
 
+#include "assert.h"
 #include "eui48_provider_params.h"
 #include "eui64_provider_params.h"
 #include "luid.h"
@@ -23,8 +24,13 @@ void netdev_eui48_get(netdev_t *netdev, eui48_t *addr)
     unsigned i = EUI48_PROVIDER_NUMOF;
     while (i--) {
 #ifdef MODULE_NETDEV_REGISTER
-        if (eui48_conf[i].type != netdev->type &&
-            eui48_conf[i].type != NETDEV_ANY) {
+        /* using NETDEV_ANY causes conflicts if there is another interface
+         * of a different type. Require EUI  providers to be locked to an
+         * interface type for uniqueness.
+         */
+        assert(eui48_conf[i].type != NETDEV_ANY);
+
+        if (eui48_conf[i].type != netdev->type) {
             continue;
         }
 
@@ -48,8 +54,13 @@ void netdev_eui64_get(netdev_t *netdev, eui64_t *addr)
     unsigned i = EUI64_PROVIDER_NUMOF;
     while (i--) {
 #ifdef MODULE_NETDEV_REGISTER
-        if (eui64_conf[i].type != netdev->type &&
-            eui64_conf[i].type != NETDEV_ANY) {
+        /* using NETDEV_ANY causes conflicts if there is another interface
+         * of a different type. Require EUI  providers to be locked to an
+         * interface type for uniqueness.
+         */
+        assert(eui64_conf[i].type != NETDEV_ANY);
+
+        if (eui64_conf[i].type != netdev->type) {
             continue;
         }
 
diff --git a/sys/net/link_layer/ieee802154/Kconfig b/sys/net/link_layer/ieee802154/Kconfig
index 8201fa3c55..b50e1d9337 100644
--- a/sys/net/link_layer/ieee802154/Kconfig
+++ b/sys/net/link_layer/ieee802154/Kconfig
@@ -82,5 +82,19 @@ if KCONFIG_USEMODULE_IEEE802154
     config IEEE802154_DEFAULT_CSMA_CA_MAX
         int "IEEE802.15.4 default CSMA-CA maximum backoff exponent"
         default 5
+    config IEEE802154_AUTO_ACK_DISABLE
+        bool "Disable Auto ACK support" if !USEPKG_OPENWSN
+        default y if USEPKG_OPENWSN
+
+menuconfig KCONFIG_USEMODULE_IEEE802154_SECURITY
+    bool "Configure IEEE802.15.4 Security"
+    depends on USEMODULE_IEEE802154_SECURITY
+    help
+        Configure IEEE802.15.4 security module using Kconfig
+
+    config IEEE802154_SEC_DEFAULT_KEY
+        string "Default key to be used for encryption and decryption (>=16B)"
+        default "pizza_margherita"
+        depends on KCONFIG_USEMODULE_IEEE802154_SECURITY
 
 endif # KCONFIG_USEMODULE_IEEE802154
diff --git a/sys/net/link_layer/ieee802154/ieee802154.c b/sys/net/link_layer/ieee802154/ieee802154.c
index ae687703d6..d466ae8dfc 100644
--- a/sys/net/link_layer/ieee802154/ieee802154.c
+++ b/sys/net/link_layer/ieee802154/ieee802154.c
@@ -241,4 +241,31 @@ int ieee802154_get_dst(const uint8_t *mhr, uint8_t *dst, le_uint16_t *dst_pan)
     return 0;
 }
 
+int ieee802154_dst_filter(const uint8_t *mhr, uint16_t pan,
+                          network_uint16_t short_addr, const eui64_t *ext_addr)
+{
+    uint8_t dst_addr[IEEE802154_LONG_ADDRESS_LEN];
+    le_uint16_t dst_pan;
+    uint8_t pan_bcast[] = IEEE802154_PANID_BCAST;
+
+    int addr_len = ieee802154_get_dst(mhr, dst_addr, &dst_pan);
+
+    /* filter PAN ID */
+    if ((memcmp(pan_bcast, dst_pan.u8, 2) != 0) &&
+        (memcmp(&pan, dst_pan.u8, 2) != 0)) {
+        return 1;
+    }
+
+    /* check destination address */
+    if (((addr_len == IEEE802154_SHORT_ADDRESS_LEN) &&
+          (memcmp(&short_addr.u8, dst_addr, addr_len) == 0 ||
+           memcmp(ieee802154_addr_bcast, dst_addr, addr_len) == 0)) ||
+        ((addr_len == IEEE802154_LONG_ADDRESS_LEN) &&
+          (memcmp(ext_addr->uint8, dst_addr, addr_len) == 0))) {
+        return 0;
+    }
+
+    return 1;
+}
+
 /** @} */
diff --git a/sys/net/link_layer/ieee802154/security.c b/sys/net/link_layer/ieee802154/security.c
index 63eedd9fc6..3271b86557 100644
--- a/sys/net/link_layer/ieee802154/security.c
+++ b/sys/net/link_layer/ieee802154/security.c
@@ -34,6 +34,15 @@ static inline uint16_t _min(uint16_t a, uint16_t b)
     return a < b ? a : b;
 }
 
+static void _set_key(ieee802154_sec_context_t *ctx,
+                     const uint8_t *key)
+{
+    if (ctx->dev.cipher_ops->set_key) {
+        ctx->dev.cipher_ops->set_key(&ctx->dev, key, IEEE802154_SEC_BLOCK_SIZE);
+    }
+    memcpy(ctx->cipher.context.context, key, IEEE802154_SEC_KEY_LENGTH);
+}
+
 /**
  * @brief   Perform an ECB block cipher for IEEE 802.15.4 security layer.
  *
@@ -48,7 +57,13 @@ static inline uint16_t _min(uint16_t a, uint16_t b)
 static void _sec_ecb(const ieee802154_sec_dev_t *dev,
                      uint8_t *cipher,
                      const uint8_t *plain,
-                     uint8_t nblocks);
+                     uint8_t nblocks)
+{
+    cipher_encrypt_ecb(&((ieee802154_sec_context_t *)dev->ctx)->cipher,
+                       plain,
+                       nblocks * IEEE802154_SEC_BLOCK_SIZE,
+                       cipher);
+}
 
 /**
  * @brief   Perform a CBC block cipher for IEEE 802.15.4 security layer MIC
@@ -67,7 +82,14 @@ static void _sec_cbc(const ieee802154_sec_dev_t *dev,
                      uint8_t *cipher,
                      uint8_t *iv,
                      const uint8_t *plain,
-                     uint8_t nblocks);
+                     uint8_t nblocks)
+{
+    cipher_encrypt_cbc(&((ieee802154_sec_context_t *)dev->ctx)->cipher,
+                       iv,
+                       plain,
+                       nblocks * IEEE802154_SEC_BLOCK_SIZE,
+                       cipher);
+}
 
 /**
  * @brief Flag field of CCM input block
@@ -96,27 +118,27 @@ static inline uint8_t _ccm_flag(uint8_t M, uint8_t L)
 
 static inline uint8_t _get_sec_level(uint8_t scf)
 {
-    return (scf & IEEE802154_SCF_SECLEVEL_MASK)
-           >> IEEE802154_SCF_SECLEVEL_SHIFT;
+    return (scf & IEEE802154_SEC_SCF_SECLEVEL_MASK)
+           >> IEEE802154_SEC_SCF_SECLEVEL_SHIFT;
 }
 
 static inline uint8_t _get_key_id_mode(uint8_t scf)
 {
-    return (scf & IEEE802154_SCF_KEYMODE_MASK)
-           >> IEEE802154_SCF_KEYMODE_SHIFT;
+    return (scf & IEEE802154_SEC_SCF_KEYMODE_MASK)
+           >> IEEE802154_SEC_SCF_KEYMODE_SHIFT;
 }
 
 static inline uint8_t _mac_size(uint8_t sec_level)
 {
     switch (sec_level) {
-        case IEEE802154_SCF_SECLEVEL_MIC32:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC32:
+        case IEEE802154_SEC_SCF_SECLEVEL_MIC32:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC32:
             return 4;
-        case IEEE802154_SCF_SECLEVEL_MIC64:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC64:
+        case IEEE802154_SEC_SCF_SECLEVEL_MIC64:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC64:
             return 8;
-        case IEEE802154_SCF_SECLEVEL_MIC128:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC128:
+        case IEEE802154_SEC_SCF_SECLEVEL_MIC128:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC128:
             return 16;
         default:
             return 0;
@@ -127,12 +149,12 @@ static inline uint8_t _mac_size(uint8_t sec_level)
 static inline bool _req_mac(uint8_t sec_level)
 {
     switch (sec_level) {
-        case IEEE802154_SCF_SECLEVEL_MIC32:
-        case IEEE802154_SCF_SECLEVEL_MIC64:
-        case IEEE802154_SCF_SECLEVEL_MIC128:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC32:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC64:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC128:
+        case IEEE802154_SEC_SCF_SECLEVEL_MIC32:
+        case IEEE802154_SEC_SCF_SECLEVEL_MIC64:
+        case IEEE802154_SEC_SCF_SECLEVEL_MIC128:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC32:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC64:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC128:
             return true;
         default:
             return false;
@@ -143,10 +165,10 @@ static inline bool _req_mac(uint8_t sec_level)
 static inline bool _req_encryption(uint8_t sec_level)
 {
     switch (sec_level) {
-        case IEEE802154_SCF_SECLEVEL_ENC:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC32:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC64:
-        case IEEE802154_SCF_SECLEVEL_ENC_MIC128:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC32:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC64:
+        case IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC128:
             return true;
         default:
             return false;
@@ -156,30 +178,30 @@ static inline bool _req_encryption(uint8_t sec_level)
 static inline void _memxor(void *dst, const void* src, size_t size)
 {
     while (size--) {
-        ((uint8_t *)dst)[size] ^= ((uint8_t *)src)[size];
+        ((uint8_t *)dst)[size] ^= ((const uint8_t *)src)[size];
     }
 }
 
 static inline uint8_t _scf(uint8_t sec_level, uint8_t key_mode)
 {
-    return (sec_level << IEEE802154_SCF_SECLEVEL_SHIFT) |
-           (key_mode << IEEE802154_SCF_KEYMODE_SHIFT);
+    return (sec_level << IEEE802154_SEC_SCF_SECLEVEL_SHIFT) |
+           (key_mode << IEEE802154_SEC_SCF_KEYMODE_SHIFT);
 }
 
 static inline uint8_t _get_aux_hdr_size(uint8_t security_level,
                                         uint8_t key_mode)
 {
-    if (security_level == IEEE802154_SCF_SECLEVEL_NONE) {
+    if (security_level == IEEE802154_SEC_SCF_SECLEVEL_NONE) {
             return 0;
     }
     switch (key_mode) {
-        case IEEE802154_SCF_KEYMODE_IMPLICIT:
+        case IEEE802154_SEC_SCF_KEYMODE_IMPLICIT:
             return 5;
-        case IEEE802154_SCF_KEYMODE_INDEX:
+        case IEEE802154_SEC_SCF_KEYMODE_INDEX:
             return 6;
-        case IEEE802154_SCF_KEYMODE_SHORT_INDEX:
+        case IEEE802154_SEC_SCF_KEYMODE_SHORT_INDEX:
             return 10;
-        case IEEE802154_SCF_KEYMODE_HW_INDEX:
+        case IEEE802154_SEC_SCF_KEYMODE_HW_INDEX:
             return 14;
         default:
             return 0;
@@ -187,7 +209,7 @@ static inline uint8_t _get_aux_hdr_size(uint8_t security_level,
 }
 
 static uint8_t _set_aux_hdr(const ieee802154_sec_context_t *ctx,
-                            ieee802154_aux_sec_t *ahr)
+                            ieee802154_sec_aux_t *ahr)
 {
     ahr->scf = _scf(ctx->security_level, ctx->key_id_mode);
     /* If you look in the specification: Annex C,
@@ -195,20 +217,20 @@ static uint8_t _set_aux_hdr(const ieee802154_sec_context_t *ctx,
     ahr->fc = byteorder_htoll(ctx->frame_counter).u32;
     size_t len = 5;
     switch (ctx->key_id_mode) {
-        case IEEE802154_SCF_KEYMODE_IMPLICIT:
+        case IEEE802154_SEC_SCF_KEYMODE_IMPLICIT:
             break;
-        case IEEE802154_SCF_KEYMODE_INDEX:
+        case IEEE802154_SEC_SCF_KEYMODE_INDEX:
             memcpy(ahr->key_id, &ctx->key_index, 1);
             len++;
             break;
-        case IEEE802154_SCF_KEYMODE_SHORT_INDEX:
+        case IEEE802154_SEC_SCF_KEYMODE_SHORT_INDEX:
             memcpy(ahr->key_id, ctx->key_source, 4);
             memcpy(ahr->key_id + 4, &ctx->key_index, 1);
             len += 5;
             break;
-        case IEEE802154_SCF_KEYMODE_HW_INDEX:
+        case IEEE802154_SEC_SCF_KEYMODE_HW_INDEX:
             memcpy(ahr->key_id, ctx->key_source, 8);
-            memcpy(ahr->key_id + 4, &ctx->key_index, 1);
+            memcpy(ahr->key_id + 8, &ctx->key_index, 1);
             len += 9;
             break;
         default:
@@ -220,10 +242,10 @@ static uint8_t _set_aux_hdr(const ieee802154_sec_context_t *ctx,
 /**
  * @brief   Construct the first block A0 for CTR
  */
-static inline void _init_ctr_A0(ieee802154_ccm_block_t *A0,
-                               uint32_t frame_counter,
-                               uint8_t security_level,
-                               const uint8_t *src_address)
+static inline void _init_ctr_A0(ieee802154_sec_ccm_block_t *A0,
+                                uint32_t frame_counter,
+                                uint8_t security_level,
+                                const uint8_t *src_address)
 {
     A0->flags = _ccm_flag(0, 2);
     A0->nonce.frame_counter = htonl(frame_counter);
@@ -235,7 +257,7 @@ static inline void _init_ctr_A0(ieee802154_ccm_block_t *A0,
 /**
  * @brief   In CTR, the blocks Ai differ in a successive counter
  */
-static inline void _advance_ctr_Ai(ieee802154_ccm_block_t *Ai)
+static inline void _advance_ctr_Ai(ieee802154_sec_ccm_block_t *Ai)
 {
     Ai->counter = htons(ntohs(Ai->counter) + 1);
 }
@@ -243,12 +265,12 @@ static inline void _advance_ctr_Ai(ieee802154_ccm_block_t *Ai)
 /**
  * @brief   Construct the first block B0 for CBC-MAC
  */
-static inline void _init_cbc_B0(ieee802154_ccm_block_t *B0,
-                               uint32_t frame_counter,
-                               uint8_t security_level,
-                               uint16_t m_len,
-                               uint8_t mic_size,
-                               const uint8_t *src_address)
+static inline void _init_cbc_B0(ieee802154_sec_ccm_block_t *B0,
+                                uint32_t frame_counter,
+                                uint8_t security_level,
+                                uint16_t m_len,
+                                uint8_t mic_size,
+                                const uint8_t *src_address)
 {
     B0->flags = _ccm_flag(mic_size, 2);
     B0->nonce.frame_counter = htonl(frame_counter),
@@ -259,7 +281,7 @@ static inline void _init_cbc_B0(ieee802154_ccm_block_t *B0,
 
 static const uint8_t *_get_encryption_key(const ieee802154_sec_context_t *ctx,
                                           const uint8_t *mhr, uint8_t mhr_len,
-                                          const ieee802154_aux_sec_t *ahr)
+                                          const ieee802154_sec_aux_t *ahr)
 {
     (void)mhr;
     (void)mhr_len;
@@ -271,7 +293,7 @@ static const uint8_t *_get_encryption_key(const ieee802154_sec_context_t *ctx,
 
 static const uint8_t *_get_decryption_key(const ieee802154_sec_context_t *ctx,
                                           const uint8_t *mhr, uint8_t mhr_len,
-                                          const ieee802154_aux_sec_t *ahr)
+                                          const ieee802154_sec_aux_t *ahr)
 {
     (void)mhr;
     (void)mhr_len;
@@ -321,23 +343,15 @@ static uint8_t _cbc_next(ieee802154_sec_context_t *ctx,
     return s;
 }
 
-static void _set_key(ieee802154_sec_context_t *ctx, const uint8_t *key)
-{
-    if (ctx->dev.cipher_ops->set_key) {
-        ctx->dev.cipher_ops->set_key(&ctx->dev, key, IEEE802154_SEC_BLOCK_SIZE);
-    }
-    memcpy(ctx->cipher.context.context, key, IEEE802154_SEC_KEY_LENGTH);
-}
-
 static void _comp_mic(ieee802154_sec_context_t *ctx,
-                      uint8_t mic[IEEE802154_MAC_SIZE],
-                      ieee802154_ccm_block_t *B0,
+                      uint8_t mic[IEEE802154_SEC_MAX_MAC_SIZE],
+                      ieee802154_sec_ccm_block_t *B0,
                       const void *a, uint16_t a_len,
                       const void *m, uint16_t m_len)
 {
     uint8_t tmp[IEEE802154_SEC_BLOCK_SIZE] = { 0 };
     uint16_t off;
-    memset(mic, 0, IEEE802154_MAC_SIZE);
+    memset(mic, 0, IEEE802154_SEC_MAX_MAC_SIZE);
     _cbc_next(ctx, mic, tmp, (uint8_t *)B0, sizeof(*B0));
     byteorder_htobebufs(tmp, a_len);
     off = _min(sizeof(tmp) - sizeof(uint16_t), a_len);
@@ -352,7 +366,7 @@ static void _comp_mic(ieee802154_sec_context_t *ctx,
 }
 
 static void _ctr(ieee802154_sec_context_t *ctx,
-                 ieee802154_ccm_block_t *A0,
+                 ieee802154_sec_ccm_block_t *A0,
                  const void *m, uint16_t m_len)
 {
     uint8_t tmp1[IEEE802154_SEC_BLOCK_SIZE] = { 0 };
@@ -366,7 +380,7 @@ static void _ctr(ieee802154_sec_context_t *ctx,
 }
 
 static void _ctr_mic(ieee802154_sec_context_t *ctx,
-                     ieee802154_ccm_block_t *A0,
+                     ieee802154_sec_ccm_block_t *A0,
                      void *mic, uint8_t mic_size)
 {
     uint8_t tmp1[IEEE802154_SEC_BLOCK_SIZE] = { 0 };
@@ -382,15 +396,15 @@ void ieee802154_sec_init(ieee802154_sec_context_t *ctx)
     /* device driver can override this */
     ctx->dev.ctx = ctx;
     /* MIC64 is the only mandatory security mode */
-    ctx->security_level = IEEE802154_SCF_SECLEVEL_ENC_MIC64;
-    ctx->key_id_mode = IEEE802154_SCF_KEYMODE_IMPLICIT;
+    ctx->security_level = IEEE802154_SEC_SCF_SECLEVEL_ENC_MIC64;
+    ctx->key_id_mode = IEEE802154_SEC_SCF_KEYMODE_IMPLICIT;
     memset(ctx->key_source, 0, sizeof(ctx->key_source));
     ctx->key_index = 0;
     ctx->frame_counter = 0;
-    uint8_t key[] = IEEE802154_DEFAULT_KEY;
-
+    uint8_t key[] = CONFIG_IEEE802154_SEC_DEFAULT_KEY;
+    assert(sizeof(key) >= IEEE802154_SEC_KEY_LENGTH);
     assert(CIPHER_MAX_CONTEXT_SIZE >= IEEE802154_SEC_KEY_LENGTH);
-    cipher_init(&ctx->cipher, CIPHER_AES_128, key, IEEE802154_SEC_KEY_LENGTH);
+    cipher_init(&ctx->cipher, CIPHER_AES, key, IEEE802154_SEC_KEY_LENGTH);
 }
 
 int ieee802154_sec_encrypt_frame(ieee802154_sec_context_t *ctx,
@@ -403,7 +417,7 @@ int ieee802154_sec_encrypt_frame(ieee802154_sec_context_t *ctx,
        ACKs are not encrypted. */
     assert((*((uint8_t *)header)) & IEEE802154_FCF_TYPE_DATA);
 
-    if (ctx->security_level == IEEE802154_SCF_SECLEVEL_NONE) {
+    if (ctx->security_level == IEEE802154_SEC_SCF_SECLEVEL_NONE) {
         *mic_size = 0;
         return IEEE802154_SEC_OK;
     }
@@ -414,7 +428,7 @@ int ieee802154_sec_encrypt_frame(ieee802154_sec_context_t *ctx,
     }
 
     /* write the auxiliary header */
-    ieee802154_aux_sec_t *aux = (ieee802154_aux_sec_t *)(header + *header_size);
+    ieee802154_sec_aux_t *aux = (ieee802154_sec_aux_t *)(header + *header_size);
     uint8_t aux_size = _get_aux_hdr_size(ctx->security_level, ctx->key_id_mode);
     _set_aux_hdr(ctx, aux);
 
@@ -430,7 +444,7 @@ int ieee802154_sec_encrypt_frame(ieee802154_sec_context_t *ctx,
     uint8_t *m = payload;
     uint16_t a_len = *header_size + aux_size;
     uint16_t m_len = payload_size;
-    ieee802154_ccm_block_t ccm; /* Ai or Bi */
+    ieee802154_sec_ccm_block_t ccm; /* Ai or Bi */
 
     /* compute MIC */
     if (_req_mac(ctx->security_level)) {
@@ -463,7 +477,7 @@ int ieee802154_sec_decrypt_frame(ieee802154_sec_context_t *ctx,
     assert(*header & IEEE802154_FCF_TYPE_DATA);
 
     /* read the fields of the auxiliary header */
-    ieee802154_aux_sec_t *aux = (ieee802154_aux_sec_t *)(header + *header_size);
+    ieee802154_sec_aux_t *aux = (ieee802154_sec_aux_t *)(header + *header_size);
     uint8_t security_level = _get_sec_level(aux->scf);
     uint8_t key_mode = _get_key_id_mode(aux->scf);
     uint8_t aux_size = _get_aux_hdr_size(security_level, key_mode);
@@ -471,7 +485,7 @@ int ieee802154_sec_decrypt_frame(ieee802154_sec_context_t *ctx,
     /* remember that the frame counter was stored in little endian */
     uint32_t frame_counter = byteorder_ltohl((le_uint32_t){aux->fc});
 
-    if (security_level == IEEE802154_SCF_SECLEVEL_NONE) {
+    if (security_level == IEEE802154_SEC_SCF_SECLEVEL_NONE) {
         *payload = header + *header_size;
         *payload_size = frame_size - *header_size;
         *mic = NULL;
@@ -496,7 +510,7 @@ int ieee802154_sec_decrypt_frame(ieee802154_sec_context_t *ctx,
     uint16_t a_len = *header_size + aux_size;
     uint16_t c_len = *payload_size;
     uint8_t *mac = *mic;
-    ieee802154_ccm_block_t ccm; /* Ai or Bi */
+    ieee802154_sec_ccm_block_t ccm; /* Ai or Bi */
 
     /* TODO:
        A better implementation would check if the received frame counter is
@@ -517,7 +531,7 @@ int ieee802154_sec_decrypt_frame(ieee802154_sec_context_t *ctx,
     }
     /* check MIC */
     if (_req_mac(security_level)) {
-        uint8_t tmp_mic[IEEE802154_MAC_SIZE];
+        uint8_t tmp_mic[IEEE802154_SEC_MAX_MAC_SIZE];
         _init_cbc_B0(&ccm, frame_counter, security_level, c_len, mac_size, src_address);
         _comp_mic(ctx, tmp_mic, &ccm, a, a_len, c, c_len);
         if (memcmp(tmp_mic, *mic, mac_size)) {
@@ -527,27 +541,3 @@ int ieee802154_sec_decrypt_frame(ieee802154_sec_context_t *ctx,
     *header_size += aux_size;
     return IEEE802154_SEC_OK;
 }
-
-static void _sec_ecb(const ieee802154_sec_dev_t *dev,
-                     uint8_t *cipher,
-                     const uint8_t *plain,
-                     uint8_t nblocks)
-{
-    cipher_encrypt_ecb(&((ieee802154_sec_context_t *)dev->ctx)->cipher,
-                       plain,
-                       nblocks * IEEE802154_SEC_BLOCK_SIZE,
-                       cipher);
-}
-
-static void _sec_cbc(const ieee802154_sec_dev_t *dev,
-                     uint8_t *cipher,
-                     uint8_t *iv,
-                     const uint8_t *plain,
-                     uint8_t nblocks)
-{
-    cipher_encrypt_cbc(&((ieee802154_sec_context_t *)dev->ctx)->cipher,
-                       iv,
-                       plain,
-                       nblocks * IEEE802154_SEC_BLOCK_SIZE,
-                       cipher);
-}
diff --git a/sys/net/link_layer/ieee802154/submac.c b/sys/net/link_layer/ieee802154/submac.c
index f9ea58a933..3869dcc630 100644
--- a/sys/net/link_layer/ieee802154/submac.c
+++ b/sys/net/link_layer/ieee802154/submac.c
@@ -76,7 +76,7 @@ static int _perform_csma_ca(ieee802154_submac_t *submac)
         submac->csma_retries_nb++;
     }
     else {
-        ieee802154_radio_set_rx_mode(dev, IEEE802154_RX_AACK_ENABLED);
+        ieee802154_radio_set_frame_filter_mode(dev, IEEE802154_FILTER_ACCEPT);
         _tx_end(submac, TX_STATUS_MEDIUM_BUSY, NULL);
     }
 
@@ -134,7 +134,7 @@ static void _perform_retrans(ieee802154_submac_t *submac)
         ieee802154_csma_ca_transmit(submac);
     }
     else {
-        ieee802154_radio_set_rx_mode(dev, IEEE802154_RX_AACK_ENABLED);
+        ieee802154_radio_set_frame_filter_mode(dev, IEEE802154_FILTER_ACCEPT);
         _tx_end(submac, TX_STATUS_NO_ACK, NULL);
     }
 }
@@ -169,8 +169,7 @@ void ieee802154_submac_rx_done_cb(ieee802154_submac_t *submac)
             ieee802154_tx_info_t tx_info;
             tx_info.retrans = submac->retrans;
             bool fp = (ack[0] & IEEE802154_FCF_FRAME_PEND);
-            ieee802154_radio_set_rx_mode(submac->dev,
-                                         IEEE802154_RX_AACK_ENABLED);
+            ieee802154_radio_set_frame_filter_mode(submac->dev, IEEE802154_FILTER_ACCEPT);
             _tx_end(submac, fp ? TX_STATUS_FRAME_PENDING : TX_STATUS_SUCCESS,
                     &tx_info);
         }
@@ -216,7 +215,7 @@ static void _handle_tx_success(ieee802154_submac_t *submac,
         _tx_end(submac, info->status, info);
     }
     else {
-        ieee802154_radio_set_rx_mode(dev, IEEE802154_RX_WAIT_FOR_ACK);
+        ieee802154_radio_set_frame_filter_mode(dev, IEEE802154_FILTER_ACK_ONLY);
 
         /* Handle ACK reception */
         ieee802154_submac_ack_timer_set(submac, ACK_TIMEOUT_US);
@@ -363,12 +362,10 @@ int ieee802154_submac_init(ieee802154_submac_t *submac, const network_uint16_t *
     /* If the radio is still not in TRX_OFF state, spin */
     while (ieee802154_radio_confirm_on(dev) == -EAGAIN) {}
 
-    /* Enable Auto ACK */
-    ieee802154_radio_set_rx_mode(dev, IEEE802154_RX_AACK_ENABLED);
-
     /* Configure address filter */
-    ieee802154_radio_set_hw_addr_filter(dev, &submac->short_addr,
-                                        &submac->ext_addr, &submac->panid);
+    ieee802154_radio_config_addr_filter(dev, IEEE802154_AF_SHORT_ADDR, &submac->short_addr);
+    ieee802154_radio_config_addr_filter(dev, IEEE802154_AF_EXT_ADDR, &submac->ext_addr);
+    ieee802154_radio_config_addr_filter(dev, IEEE802154_AF_PANID, &submac->panid);
 
     /* Configure PHY settings (mode, channel, TX power) */
     ieee802154_phy_conf_t conf =
diff --git a/sys/net/link_layer/l2util/l2util.c b/sys/net/link_layer/l2util/l2util.c
index b4da4f62de..c1437d75ff 100644
--- a/sys/net/link_layer/l2util/l2util.c
+++ b/sys/net/link_layer/l2util/l2util.c
@@ -123,6 +123,11 @@ int l2util_eui64_from_addr(int dev_type, const uint8_t *addr, size_t addr_len,
                 return -EINVAL;
             }
 #endif /* defined (MODULE_NRF24L01P_NG) */
+#if defined(MODULE_SLIPDEV_L2ADDR)
+        case NETDEV_TYPE_SLIP:
+            memcpy(eui64, addr, addr_len);
+            return sizeof(eui64_t);
+#endif /* defined(MODULE_SLIPDEV_L2ADDR) */
         default:
             (void)addr;
             (void)addr_len;
@@ -230,6 +235,11 @@ int l2util_ipv6_iid_to_addr(int dev_type, const eui64_t *iid, uint8_t *addr)
             memcpy(&addr[addr_len - 3], &iid->uint8[5], 3);
             return addr_len;
 #endif /* defined(MODULE_NRF24L01P_NG) */
+#if defined(MODULE_SLIPDEV_L2ADDR)
+        case NETDEV_TYPE_SLIP:
+            memcpy(addr, iid, sizeof(eui64_t));
+            return sizeof(eui64_t);
+#endif /* defined(MODULE_SLIP) */
         default:
             (void)iid;
             (void)addr;
@@ -288,6 +298,10 @@ int l2util_ndp_addr_len_from_l2ao(int dev_type,
             (void)opt;
             return 5; /* maximum length */
 #endif /* defined(MODULE_NRF24L01P_NG) */
+#if defined(MODULE_SLIPDEV_L2ADDR)
+        case NETDEV_TYPE_SLIP:
+            return sizeof(eui64_t);
+#endif /* defined(MODULE_SLIPDEV_L2ADDR) */
         default:
             (void)opt;
 #ifdef DEVELHELP
diff --git a/sys/ps/ps.c b/sys/ps/ps.c
index 73c0277e6d..5fe1acf050 100644
--- a/sys/ps/ps.c
+++ b/sys/ps/ps.c
@@ -12,19 +12,21 @@
  * @file
  * @brief   UNIX like ps command
  * @author  Kaspar Schleiser <kaspar@schleiser.de>
+ *
+ * @note    The entry 'runtime_usec' in 'MODULE_SCHEDSTATISTICS' is limited
+ *          to 2**32 microseconds. So the entry gets reset after ~1.2 hours.
  * @}
  */
 
 #include <stdio.h>
 #include <assert.h>
 
-#include "thread.h"
-#include "sched.h"
 #include "thread.h"
 #include "sched.h"
 
 #ifdef MODULE_SCHEDSTATISTICS
 #include "schedstatistics.h"
+#include "xtimer.h"
 #endif
 
 #ifdef MODULE_TLSF_MALLOC
@@ -50,7 +52,7 @@ void ps(void)
            "| stack  ( used) ( free) | base addr  | current     "
 #endif
 #ifdef MODULE_SCHEDSTATISTICS
-           "| runtime  | switches"
+           "| runtime  | switches  | runtime_usec "
 #endif
            "\n",
 #ifdef CONFIG_THREAD_NAMES
@@ -89,11 +91,11 @@ void ps(void)
         thread_t *p = thread_get(i);
 
         if (p != NULL) {
-            thread_status_t state = thread_get_status(p);                          /* copy state */
-            const char *sname = thread_state_to_string(state);                     /* get state name */
-            const char *queued = thread_is_active(p) ? "Q" : "_";                  /* get queued flag */
+            thread_status_t state = thread_get_status(p);                   /* copy state */
+            const char *sname = thread_state_to_string(state);              /* get state name */
+            const char *queued = thread_is_active(p) ? "Q" : "_";           /* get queued flag */
 #ifdef DEVELHELP
-            int stacksz = p->stack_size;                                           /* get stack size */
+            int stacksz = p->stack_size;                                    /* get stack size */
             overall_stacksz += stacksz;
             int stack_free = thread_measure_stack_free(p->stack_start);
             stacksz -= stack_free;
@@ -102,6 +104,7 @@ void ps(void)
 #ifdef MODULE_SCHEDSTATISTICS
             /* multiply with 100 for percentage and to avoid floats/doubles */
             uint64_t runtime_ticks = sched_pidlist[i].runtime_ticks * 100;
+            xtimer_ticks32_t xtimer_ticks = {sched_pidlist[i].runtime_ticks};
             unsigned runtime_major = runtime_ticks / rt_sum;
             unsigned runtime_minor = ((runtime_ticks % rt_sum) * 1000) / rt_sum;
             unsigned switches = sched_pidlist[i].schedules;
@@ -115,7 +118,7 @@ void ps(void)
                    " | %6i (%5i) (%5i) | %10p | %10p "
 #endif
 #ifdef MODULE_SCHEDSTATISTICS
-                   " | %2d.%03d%% |  %8u"
+                   " | %2d.%03d%% |  %8u  | %10"PRIu32" "
 #endif
                    "\n",
                    p->pid,
@@ -128,7 +131,7 @@ void ps(void)
                    (void *)p->stack_start, (void *)p->sp
 #endif
 #ifdef MODULE_SCHEDSTATISTICS
-                   , runtime_major, runtime_minor, switches
+                   , runtime_major, runtime_minor, switches, xtimer_usec_from_ticks(xtimer_ticks)
 #endif
                   );
         }
diff --git a/sys/random/Kconfig b/sys/random/Kconfig
index f771737ee7..21aaaabc67 100644
--- a/sys/random/Kconfig
+++ b/sys/random/Kconfig
@@ -25,7 +25,7 @@ config MODULE_PRNG_FORTUNA
     select MODULE_XTIMER
     select MODULE_FORTUNA
     select MODULE_CRYPTO
-    depends on MODULE_CRYPTO_AES
+    select MODULE_CRYPTO_AES_128
 
 config MODULE_PRNG_HWRNG
     bool "Hardware RNG"
diff --git a/sys/shell/commands/sc_gnrc_rpl.c b/sys/shell/commands/sc_gnrc_rpl.c
index beb90fb2ce..098b55586c 100644
--- a/sys/shell/commands/sc_gnrc_rpl.c
+++ b/sys/shell/commands/sc_gnrc_rpl.c
@@ -24,7 +24,6 @@
 #include "net/gnrc/rpl/dodag.h"
 #include "utlist.h"
 #include "trickle.h"
-#include "xtimer.h"
 #ifdef MODULE_GNRC_RPL_P2P
 #include "net/gnrc/rpl/p2p.h"
 #include "net/gnrc/rpl/p2p_dodag.h"
@@ -236,6 +235,11 @@ int _stats(void)
 
 int _gnrc_rpl_dodag_show(void)
 {
+    if (gnrc_rpl_pid == KERNEL_PID_UNDEF) {
+        printf("RPL not initializied\n");
+        return 1;
+    }
+
     printf("instance table:\t");
     for (uint8_t i = 0; i < GNRC_RPL_INSTANCES_NUMOF; ++i) {
         if (gnrc_rpl_instances[i].state == 0) {
@@ -279,7 +283,6 @@ int _gnrc_rpl_dodag_show(void)
 
     gnrc_rpl_dodag_t *dodag = NULL;
     char addr_str[IPV6_ADDR_MAX_STR_LEN];
-    uint64_t tc;
 
     for (uint8_t i = 0; i < GNRC_RPL_INSTANCES_NUMOF; ++i) {
         if (gnrc_rpl_instances[i].state == 0) {
@@ -293,16 +296,13 @@ int _gnrc_rpl_dodag_show(void)
                 gnrc_rpl_instances[i].mop, gnrc_rpl_instances[i].of->ocp,
                 gnrc_rpl_instances[i].min_hop_rank_inc, gnrc_rpl_instances[i].max_rank_inc);
 
-        tc = xtimer_left_usec(&dodag->trickle.msg_timer);
-        tc = (int64_t) tc == 0 ? 0 : tc / US_PER_SEC;
-
         printf("\tdodag [%s | R: %d | OP: %s | PIO: %s | "
-               "TR(I=[%d,%d], k=%d, c=%d, TC=%" PRIu32 "s)]\n",
+               "TR(I=[%d,%d], k=%d, c=%d)]\n",
                ipv6_addr_to_str(addr_str, &dodag->dodag_id, sizeof(addr_str)),
                dodag->my_rank, (dodag->node_status == GNRC_RPL_LEAF_NODE ? "Leaf" : "Router"),
                ((dodag->dio_opts & GNRC_RPL_REQ_DIO_OPT_PREFIX_INFO) ? "on" : "off"),
                (1 << dodag->dio_min), dodag->dio_interval_doubl, dodag->trickle.k,
-               dodag->trickle.c, (uint32_t) (tc & 0xFFFFFFFF));
+               dodag->trickle.c);
 
 #ifdef MODULE_GNRC_RPL_P2P
         if (dodag->instance->mop == GNRC_RPL_P2P_MOP) {
diff --git a/sys/trickle/trickle.c b/sys/trickle/trickle.c
index 1b03b19b7f..ab37140d10 100644
--- a/sys/trickle/trickle.c
+++ b/sys/trickle/trickle.c
@@ -53,9 +53,14 @@ void trickle_interval(trickle_t *trickle)
     /* old_interval == trickle->I / 2 */
     trickle->t = random_uint32_range(old_interval, trickle->I);
 
+#if IS_USED(MODULE_ZTIMER_MSEC)
+    ztimer_set_msg(ZTIMER_MSEC, &trickle->msg_timer, (trickle->t + diff),
+                   &trickle->msg, trickle->pid);
+#else
     uint64_t msg_time = (trickle->t + diff) * US_PER_MS;
     xtimer_set_msg64(&trickle->msg_timer, msg_time, &trickle->msg,
                      trickle->pid);
+#endif
 }
 
 void trickle_reset_timer(trickle_t *trickle)
@@ -88,7 +93,11 @@ void trickle_start(kernel_pid_t pid, trickle_t *trickle, uint16_t msg_type,
 
 void trickle_stop(trickle_t *trickle)
 {
+#if IS_USED(MODULE_ZTIMER_MSEC)
+    ztimer_remove(ZTIMER_MSEC, &trickle->msg_timer);
+#else
     xtimer_remove(&trickle->msg_timer);
+#endif
 }
 
 void trickle_increment_counter(trickle_t *trickle)
diff --git a/sys/ztimer/Kconfig b/sys/ztimer/Kconfig
index 47e0fc97c7..c6720f6b13 100644
--- a/sys/ztimer/Kconfig
+++ b/sys/ztimer/Kconfig
@@ -15,7 +15,11 @@ menuconfig MODULE_ZTIMER
 
 if MODULE_ZTIMER
 
+config ZTIMER_CUSTOM_BACKEND_CONFIGURATION
+    bool "Override default backend selection"
+
 menu "Backends"
+    visible if ZTIMER_CUSTOM_BACKEND_CONFIGURATION
 
 config MODULE_ZTIMER_PERIPH_RTC
     bool "RTC peripheral"
@@ -26,7 +30,6 @@ config MODULE_ZTIMER_PERIPH_RTT
     bool "RTT peripheral"
     depends on HAS_PERIPH_RTT
     select MODULE_PERIPH_RTT
-    default y if !MODULE_ZTIMER_PERIPH_TIMER
 
 config MODULE_ZTIMER_PERIPH_PTP
     bool "PTP peripheral"
@@ -37,7 +40,6 @@ config MODULE_ZTIMER_PERIPH_TIMER
     bool "Timer peripheral"
     depends on HAS_PERIPH_TIMER
     select MODULE_PERIPH_TIMER
-    default y
 
 endmenu # Backends
 
@@ -45,18 +47,56 @@ menu "Clocks"
 
 config MODULE_ZTIMER_USEC
     bool "Microseconds"
-    depends on MODULE_ZTIMER_PERIPH_TIMER
+    select MODULE_ZTIMER_PERIPH_TIMER
 
 config MODULE_ZTIMER_MSEC
     bool "Milliseconds"
-    depends on MODULE_ZTIMER_PERIPH_TIMER || MODULE_ZTIMER_PERIPH_RTT
+
+choice
+    bool "Backend"
+    depends on MODULE_ZTIMER_MSEC
+    default ZTIMER_MSEC_BACKEND_RTT
+
+config ZTIMER_MSEC_BACKEND_TIMER
+    bool "Timer"
+    select MODULE_ZTIMER_PERIPH_TIMER
+
+config ZTIMER_MSEC_BACKEND_RTT
+    bool "RTT"
+    depends on HAS_PERIPH_RTT
+    select MODULE_ZTIMER_PERIPH_RTT
+
+endchoice
 
 config MODULE_ZTIMER_SEC
     bool "Seconds"
-    depends on MODULE_ZTIMER_PERIPH_TIMER || MODULE_ZTIMER_PERIPH_RTT || MODULE_ZTIMER_PERIPH_RTC
 
-endmenu # Clocks
+choice
+    bool "Backend"
+    depends on MODULE_ZTIMER_SEC
+    default ZTIMER_SEC_BACKEND_RTC if !BOARD_NATIVE && \
+                                      !CPU_COMMON_SAM0 && \
+                                      !CPU_COMMON_EFM32 && \
+                                      !CPU_FAM_F1
+    default ZTIMER_SEC_BACKEND_RTT
+
+config ZTIMER_SEC_BACKEND_TIMER
+    bool "Timer"
+    select MODULE_ZTIMER_PERIPH_TIMER
+
+config ZTIMER_SEC_BACKEND_RTT
+    bool "RTT"
+    depends on HAS_PERIPH_RTT
+    select MODULE_ZTIMER_PERIPH_RTT
 
+config ZTIMER_SEC_BACKEND_RTC
+    bool "RTC"
+    depends on HAS_PERIPH_RTC
+    select MODULE_ZTIMER_PERIPH_RTC
+
+endchoice
+
+endmenu # Clocks
 
 menu "Frequency conversion"
 
diff --git a/sys/ztimer/Makefile.dep b/sys/ztimer/Makefile.dep
index 9c874a2727..3ffe696b5d 100644
--- a/sys/ztimer/Makefile.dep
+++ b/sys/ztimer/Makefile.dep
@@ -89,4 +89,22 @@ endif
 
 ifneq (,$(filter ztimer_msec,$(USEMODULE)))
   USEMODULE += ztimer
+  FEATURES_OPTIONAL += periph_rtt
+  # HACK: periph_rtt will get used only in the next iteration but an updated
+  # state for FEATURES_USED is needed here so include `features_check.inc.mk`
+  # here instead.
+  # An other option would be to check FEATURES_PROVIDED this would avoid the
+  # order of inclusion problem but it would no take into account possible conflicts
+  # and is also currently not allowed in the build system.
+  # An other alternative would be to delay to the next loop, but this produce a
+  # case where another loop is not executed and the conditional not evaluated
+  # If these kind of usecases pop up before Kconfig migration is completed
+  # then another alternative would be introduce a variable to require an extra
+  # loop independent of USEMODULE, FEATURES_REQUIRED and USEPKG
+  include $(RIOTMAKE)/features_check.inc.mk
+  ifneq (,$(filter periph_rtt,$(FEATURES_USED)))
+    USEMODULE += ztimer_periph_rtt
+  else
+    USEMODULE += ztimer_periph_timer
+  endif
 endif
diff --git a/sys/ztimer/Makefile.include b/sys/ztimer/Makefile.include
new file mode 100644
index 0000000000..679b774e3a
--- /dev/null
+++ b/sys/ztimer/Makefile.include
@@ -0,0 +1,15 @@
+# Convert xtimer into a pseudo module if its API is already implemented by
+# ztimer's compatibility wrapper
+ifneq (,$(filter ztimer_xtimer_compat,$(USEMODULE)))
+  PSEUDOMODULES += xtimer
+endif
+
+# By defaul use highest possible RTT_FREQUENCY for platforms that allow it. This
+# might not be the most optimized for conversion guarantees that ztimer_periph_rtt
+# will have a capable backend.
+ifneq (,$(filter ztimer_periph_rtt,$(USEMODULE)))
+  ifneq (,$(filter stm32 nrf5% sam% kinetis efm32,$(CPU)))
+    RTT_FREQUENCY ?= RTT_MAX_FREQUENCY
+    CFLAGS += -DRTT_FREQUENCY=$(RTT_FREQUENCY)
+  endif
+endif
diff --git a/sys/ztimer/convert.c b/sys/ztimer/convert.c
index 19232f4016..921a478155 100644
--- a/sys/ztimer/convert.c
+++ b/sys/ztimer/convert.c
@@ -46,6 +46,9 @@ void ztimer_convert_init(ztimer_convert_t *ztimer_convert,
             .arg = ztimer_convert,
         },
         .super.max_value = max_value,
+#  ifdef MODULE_PM_LAYERED
+        .super.block_pm_mode = ZTIMER_CLOCK_NO_REQUIRED_PM_MODE,
+#  endif
     };
 
     *ztimer_convert = tmp;
diff --git a/sys/ztimer/convert_frac.c b/sys/ztimer/convert_frac.c
index c614b3c6a0..0d3dc66ecd 100644
--- a/sys/ztimer/convert_frac.c
+++ b/sys/ztimer/convert_frac.c
@@ -111,4 +111,7 @@ void ztimer_convert_frac_init(ztimer_convert_frac_t *self,
         self->round = freq_self / freq_lower;
         self->super.super.max_value = UINT32_MAX;
     }
+#ifdef MODULE_PM_LAYERED
+    self->super.super.block_pm_mode = ZTIMER_CLOCK_NO_REQUIRED_PM_MODE;
+#endif
 }
diff --git a/tests/bench_xtimer/Makefile b/tests/bench_xtimer/Makefile
index 95c6279ec0..5b8c926e7e 100644
--- a/tests/bench_xtimer/Makefile
+++ b/tests/bench_xtimer/Makefile
@@ -56,6 +56,7 @@ LOW_MEMORY_BOARDS += \
   opencm904 \
   saml10-xpro \
   saml11-xpro \
+  seeeduino_xiao \
   sensebox_samd21 \
   serpente \
   sodaq-autonomo \
diff --git a/tests/congure_test/congure_impl.c b/tests/congure_test/congure_impl.c
index 24732600e6..1400e39b10 100644
--- a/tests/congure_test/congure_impl.c
+++ b/tests/congure_test/congure_impl.c
@@ -22,7 +22,7 @@ int congure_test_snd_setup(congure_test_snd_t *c, unsigned id)
     if (id > 0) {
         return -1;
     }
-    congure_mock_snd_setup(c);
+    congure_mock_snd_setup(c, NULL);
     return 0;
 }
 
diff --git a/tests/congure_test/tests/01-run.py b/tests/congure_test/tests/01-run.py
index 5fc8ef0901..677606cf2d 100755
--- a/tests/congure_test/tests/01-run.py
+++ b/tests/congure_test/tests/01-run.py
@@ -24,10 +24,10 @@ class TestCongUREBase(unittest.TestCase):
     @classmethod
     def setUpClass(cls):
         cls.ctrl = RIOTCtrl()
+        cls.ctrl.reset()
         cls.ctrl.start_term()
         if cls.DEBUG:
             cls.ctrl.term.logfile = sys.stdout
-        cls.ctrl.reset()
         cls.shell = ShellInteraction(cls.ctrl)
         cls.json_parser = RapidJSONShellInteractionParser()
         cls.json_parser.set_parser_args(
diff --git a/tests/cpp_exclude/Makefile b/tests/cpp_exclude/Makefile
index 5ae51e9253..ae0cd13f5d 100644
--- a/tests/cpp_exclude/Makefile
+++ b/tests/cpp_exclude/Makefile
@@ -3,6 +3,6 @@ include ../Makefile.tests_common
 FEATURES_REQUIRED += cpp libstdcpp
 
 USEMODULE += module_exclude
-EXTERNAL_MODULE_DIRS += $(CURDIR)/module_exclude
+EXTERNAL_MODULE_DIRS += external_modules
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/cpp_exclude/module_exclude/Makefile b/tests/cpp_exclude/external_modules/module_exclude/Makefile
similarity index 100%
rename from tests/cpp_exclude/module_exclude/Makefile
rename to tests/cpp_exclude/external_modules/module_exclude/Makefile
diff --git a/tests/cpp_exclude/module_exclude/Makefile.dep b/tests/cpp_exclude/external_modules/module_exclude/Makefile.dep
similarity index 100%
rename from tests/cpp_exclude/module_exclude/Makefile.dep
rename to tests/cpp_exclude/external_modules/module_exclude/Makefile.dep
diff --git a/tests/cpp_exclude/module_exclude/Makefile.include b/tests/cpp_exclude/external_modules/module_exclude/Makefile.include
similarity index 100%
rename from tests/cpp_exclude/module_exclude/Makefile.include
rename to tests/cpp_exclude/external_modules/module_exclude/Makefile.include
diff --git a/tests/cpp_exclude/module_exclude/module.cpp b/tests/cpp_exclude/external_modules/module_exclude/module.cpp
similarity index 100%
rename from tests/cpp_exclude/module_exclude/module.cpp
rename to tests/cpp_exclude/external_modules/module_exclude/module.cpp
diff --git a/tests/cpp_exclude/module_exclude/module.hpp b/tests/cpp_exclude/external_modules/module_exclude/module.hpp
similarity index 100%
rename from tests/cpp_exclude/module_exclude/module.hpp
rename to tests/cpp_exclude/external_modules/module_exclude/module.hpp
diff --git a/tests/cpp_exclude/module_exclude/module_excluded.cpp b/tests/cpp_exclude/external_modules/module_exclude/module_excluded.cpp
similarity index 100%
rename from tests/cpp_exclude/module_exclude/module_excluded.cpp
rename to tests/cpp_exclude/external_modules/module_exclude/module_excluded.cpp
diff --git a/tests/cpp_ext/Makefile b/tests/cpp_ext/Makefile
index 0c0a24138e..57effc953e 100644
--- a/tests/cpp_ext/Makefile
+++ b/tests/cpp_ext/Makefile
@@ -3,6 +3,6 @@ include ../Makefile.tests_common
 FEATURES_REQUIRED += cpp libstdcpp
 
 USEMODULE += module
-EXTERNAL_MODULE_DIRS += $(CURDIR)/module
+EXTERNAL_MODULE_DIRS += external_modules
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/cpp_ext/module/Makefile b/tests/cpp_ext/external_modules/module/Makefile
similarity index 100%
rename from tests/cpp_ext/module/Makefile
rename to tests/cpp_ext/external_modules/module/Makefile
diff --git a/tests/cpp_ext/module/Makefile.dep b/tests/cpp_ext/external_modules/module/Makefile.dep
similarity index 100%
rename from tests/cpp_ext/module/Makefile.dep
rename to tests/cpp_ext/external_modules/module/Makefile.dep
diff --git a/tests/cpp_ext/module/Makefile.include b/tests/cpp_ext/external_modules/module/Makefile.include
similarity index 100%
rename from tests/cpp_ext/module/Makefile.include
rename to tests/cpp_ext/external_modules/module/Makefile.include
diff --git a/tests/cpp_ext/module/module.cc b/tests/cpp_ext/external_modules/module/module.cc
similarity index 100%
rename from tests/cpp_ext/module/module.cc
rename to tests/cpp_ext/external_modules/module/module.cc
diff --git a/tests/cpp_ext/module/module.cpp b/tests/cpp_ext/external_modules/module/module.cpp
similarity index 100%
rename from tests/cpp_ext/module/module.cpp
rename to tests/cpp_ext/external_modules/module/module.cpp
diff --git a/tests/cpp_ext/module/module.hh b/tests/cpp_ext/external_modules/module/module.hh
similarity index 100%
rename from tests/cpp_ext/module/module.hh
rename to tests/cpp_ext/external_modules/module/module.hh
diff --git a/tests/disp_dev/Makefile b/tests/disp_dev/Makefile
index 94579d55a2..4d728d33db 100644
--- a/tests/disp_dev/Makefile
+++ b/tests/disp_dev/Makefile
@@ -3,7 +3,6 @@ include ../Makefile.tests_common
 
 DISABLE_MODULE += test_utils_interactive_sync
 
-USEMODULE += ili9341
 USEMODULE += disp_dev
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/disp_dev/Makefile.ci b/tests/disp_dev/Makefile.ci
index bb2d6aa68a..3bd15033b1 100644
--- a/tests/disp_dev/Makefile.ci
+++ b/tests/disp_dev/Makefile.ci
@@ -7,6 +7,8 @@ BOARD_INSUFFICIENT_MEMORY := \
     atmega1284p \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
     derfmega128 \
     mega-xplained \
     microduino-corerf \
diff --git a/tests/disp_dev/main.c b/tests/disp_dev/main.c
index e658128905..de40b10098 100644
--- a/tests/disp_dev/main.c
+++ b/tests/disp_dev/main.c
@@ -22,40 +22,44 @@
 
 #include "disp_dev.h"
 
-#include "ili9341.h"
-#include "ili9341_params.h"
-#include "ili9341_disp_dev.h"
-
 #include "riot_logo.h"
 
 #include "test_utils/expect.h"
 
-static ili9341_t ili9341;
+#if IS_USED(MODULE_ILI9341)
+#include "ili9341.h"
+#endif
+
+#define DISPLAY_BUFFER_MAX_SIZE (320)
+static uint16_t display_buffer[DISPLAY_BUFFER_MAX_SIZE] = { 0 };
 
 int main(void)
 {
-    ili9341_init(&ili9341, &ili9341_params[0]);
-
-    disp_dev_t *dev = (disp_dev_t *)&ili9341;
-    dev->driver = &ili9341_disp_dev_driver;
+    /* Use the first screen */
+    disp_dev_reg_t *disp_dev = disp_dev_reg_find_screen(0);
+    if (!disp_dev) {
+        puts("No screen found!");
+        return -1;
+    }
 
-    disp_dev_set_invert(dev, true);
+    disp_dev_set_invert(disp_dev->dev, true);
     disp_dev_backlight_on();
 
-    uint16_t max_width = disp_dev_width(dev);
-    uint16_t max_height = disp_dev_height(dev);
+    uint16_t max_width = disp_dev_width(disp_dev->dev);
+    uint16_t max_height = disp_dev_height(disp_dev->dev);
 
-    expect(max_width == ili9341.params->lines);
+#if IS_USED(MODULE_ILI9341)
+    ili9341_t *ili9341 = (ili9341_t *)disp_dev->dev;
+    expect(ili9341);
+    expect(max_width == ili9341->params->lines);
     expect(max_height == 240);
+#endif
 
-    uint16_t color = 0;
     for (uint16_t y = 0; y < max_height; ++y) {
-        for (uint16_t x = 0; x < max_width; ++x) {
-            disp_dev_map(dev, x, x, y, y, &color);
-        }
+        disp_dev_map(disp_dev->dev, 0, max_width - 1, y, y, display_buffer);
     }
 
-    disp_dev_map(dev, 95, 222, 85, 153, (const uint16_t *)picture);
+    disp_dev_map(disp_dev->dev, 95, 222, 85, 153, (const uint16_t *)picture);
 
     puts("SUCCESS");
 
diff --git a/tests/driver_at86rf215/Makefile b/tests/driver_at86rf215/Makefile
index f54d6765b5..bdddfa34f0 100644
--- a/tests/driver_at86rf215/Makefile
+++ b/tests/driver_at86rf215/Makefile
@@ -3,5 +3,6 @@ BOARD ?= openmote-b
 # the radio driver to test
 USEMODULE += at86rf215
 USEMODULE += at86rf215_batmon
+USEMODULE += at86rf215_timestamp
 
 include ../driver_netdev_common/Makefile.netdev.mk
diff --git a/tests/driver_at86rf215/Makefile.ci b/tests/driver_at86rf215/Makefile.ci
index 397996ca9c..6f458549a9 100644
--- a/tests/driver_at86rf215/Makefile.ci
+++ b/tests/driver_at86rf215/Makefile.ci
@@ -7,6 +7,8 @@ BOARD_INSUFFICIENT_MEMORY := \
     atmega1284p \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
     bluepill-stm32f030c8 \
     derfmega128 \
     i-nucleo-lrwan1 \
diff --git a/tests/driver_atwinc15x0/Makefile b/tests/driver_atwinc15x0/Makefile
index 0542cb1cdb..cbc8738aaa 100644
--- a/tests/driver_atwinc15x0/Makefile
+++ b/tests/driver_atwinc15x0/Makefile
@@ -2,6 +2,6 @@
 USEMODULE = atwinc15x0
 
 # msp430-gcc doesn't support -Wno-discarded-qualifiers
-FEATURES_BLACKLIST += arch_msp430
+FEATURES_BLACKLIST += arch_msp430 cpu_core_atxmega
 
 include ../driver_netdev_common/Makefile.netdev.mk
diff --git a/tests/driver_bmx280/Makefile b/tests/driver_bmx280/Makefile
index 6bacf6e181..28280bd052 100644
--- a/tests/driver_bmx280/Makefile
+++ b/tests/driver_bmx280/Makefile
@@ -3,6 +3,7 @@ include ../Makefile.tests_common
 DRIVER ?= bme280_i2c
 
 USEMODULE += fmt
+USEMODULE += xtimer
 USEMODULE += $(DRIVER)
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/driver_bmx280/app.config.test b/tests/driver_bmx280/app.config.test
index eaeb37e778..1c765ce9ec 100644
--- a/tests/driver_bmx280/app.config.test
+++ b/tests/driver_bmx280/app.config.test
@@ -2,3 +2,4 @@
 # application configuration. This is only needed during migration.
 CONFIG_MODULE_BME280_I2C=y
 CONFIG_MODULE_FMT=y
+CONFIG_MODULE_XTIMER=y
diff --git a/tests/driver_cc110x/Makefile.ci b/tests/driver_cc110x/Makefile.ci
index 2ce9fe8b90..c03f8d4ad0 100644
--- a/tests/driver_cc110x/Makefile.ci
+++ b/tests/driver_cc110x/Makefile.ci
@@ -7,6 +7,8 @@ BOARD_INSUFFICIENT_MEMORY := \
     atmega1284p \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
     blackpill \
     bluepill \
     bluepill-stm32f030c8 \
diff --git a/tests/driver_enc28j60/Makefile.ci b/tests/driver_enc28j60/Makefile.ci
index efd592bb4a..dabf97cd3e 100644
--- a/tests/driver_enc28j60/Makefile.ci
+++ b/tests/driver_enc28j60/Makefile.ci
@@ -7,6 +7,8 @@ BOARD_INSUFFICIENT_MEMORY := \
     atmega1284p \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
     bluepill-stm32f030c8 \
     derfmega128 \
     i-nucleo-lrwan1 \
diff --git a/tests/driver_encx24j600/Makefile.ci b/tests/driver_encx24j600/Makefile.ci
index 7f7f4d0b7d..c856df2cca 100644
--- a/tests/driver_encx24j600/Makefile.ci
+++ b/tests/driver_encx24j600/Makefile.ci
@@ -6,6 +6,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-uno \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
     i-nucleo-lrwan1 \
     msb-430 \
     msb-430h \
diff --git a/tests/driver_kw2xrf/Makefile.ci b/tests/driver_kw2xrf/Makefile.ci
index 57b75c3dab..db32a4cc9e 100644
--- a/tests/driver_kw2xrf/Makefile.ci
+++ b/tests/driver_kw2xrf/Makefile.ci
@@ -6,6 +6,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-uno \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
     bluepill-stm32f030c8 \
     i-nucleo-lrwan1 \
     nucleo-f031k6 \
diff --git a/tests/driver_lis2dh12/Makefile b/tests/driver_lis2dh12/Makefile
index 3cc425d3df..d47e568630 100644
--- a/tests/driver_lis2dh12/Makefile
+++ b/tests/driver_lis2dh12/Makefile
@@ -6,6 +6,7 @@ DRIVER ?= lis2dh12_spi
 USEMODULE += fmt
 USEMODULE += xtimer
 USEMODULE += shell
+USEMODULE += shell_commands
 USEMODULE += $(DRIVER)
 
 # for using lis2dh12 with interrupt function
diff --git a/tests/driver_lis2dh12/app.config.test b/tests/driver_lis2dh12/app.config.test
index 54c15469d2..98d38424d2 100644
--- a/tests/driver_lis2dh12/app.config.test
+++ b/tests/driver_lis2dh12/app.config.test
@@ -3,6 +3,7 @@
 CONFIG_MODULE_FMT=y
 CONFIG_MODULE_XTIMER=y
 CONFIG_MODULE_SHELL=y
+CONFIG_MODULE_SHELL_COMMANDS=y
 CONFIG_MODULE_LIS2DH12=y
 CONFIG_MODULE_LIS2DH12_SPI=y
 
diff --git a/tests/driver_lis2dh12/main.c b/tests/driver_lis2dh12/main.c
index b8e7b8014d..2daa98a210 100644
--- a/tests/driver_lis2dh12/main.c
+++ b/tests/driver_lis2dh12/main.c
@@ -14,13 +14,15 @@
  * @brief       Test application for LIS2DH12 accelerometer driver
  *
  * @author      Jan Mohr <jan.mohr@ml-pa.com>
+ * @author      Benjamin Valentin <benjamin.valentin@ml-pa.com>
  *
  * @}
  */
 
-#include "stdio.h"
-#include "string.h"
-#include "stdlib.h"
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <limits.h>
 #include "xtimer.h"
 #include "fmt.h"
 #include "thread.h"
@@ -33,129 +35,12 @@
 #define ENABLE_DEBUG 0
 #include "debug.h"
 
-#define REFERENCE_DEFAULT 10 /* LSB according to SCALE */
-
-#define THOLD_SHOCK_MILLIG_DEFAULT 1500
-#define NUM_DATA_SHOCK_DETECT 7  /* detect shock in NUM last FIFO samples */
-
 /* device specific */
-#define NUM_AXES 3
 #define NUM_FIFO_VALUES 32
 
-/* axis define for click */
-#define X_CLICK 1
-#define Y_CLICK 2
-#define Z_CLICK 3
-#define DCLICK_DEFAULT 40   /* default threshold for double click */
-
-#ifdef MODULE_LIS2DH12_INT
-static kernel_pid_t lis2dh12_process;
-#endif /* MODULE_LIS2DH12_INT */
-
-int __attribute__((weak)) shell_lis2dh12_cmd(int argc, char** argv);
-
-static const shell_command_t shell_commands[] = {
-                { "lis", "Command with multiple subcommands.", shell_lis2dh12_cmd },
-                { NULL, NULL, NULL },
-};
-
-char lis2dh12_process_stack[THREAD_STACKSIZE_MAIN];
-
-/* setting the double click order */
-static LIS2DH12_CLICK_SRC_t click_src_reg;
-static lis2dh12_click_t click_cfg = {
-    .enable_DOUBLE = true,
-    .enable_X_CLICK = true,
-    .enable_Y_CLICK = true,
-    .enable_Z_CLICK = true,
-    .noINT_latency = true,
-    .CLICK_thold = DCLICK_DEFAULT,
-    .TIME_limit = 4,    /* 4 ODR cycles -> 40ms */
-    .TIME_latency = 16, /* 16 ODR cycles -> 160ms */
-    .TIME_window = 10,  /* 10 ODR cycles -> 100ms */
-};
-
 /* allocate device descriptor */
 static lis2dh12_t dev;
 
-#ifdef MODULE_LIS2DH12_INT
-/* Interrupt lines */
-static uint8_t line1 = 1;
-static uint8_t line2 = 2;
-
-/* Interrupt params */
-static lis2dh12_int_params_t params_int1 = {0};
-static lis2dh12_int_params_t params_int2 = {0};
-
-/* Interrupt source register */
-static uint8_t int1_src;
-#endif /* MODULE_LIS2DH12_INT */
-
-/* FIFO data memory */
-static lis2dh12_fifo_data_t data_fifo[NUM_FIFO_VALUES];
-/* FIFO configuration */
-static lis2dh12_fifo_t fifo_cfg = {
-    .FIFO_set_INT2 = false,
-    .FIFO_watermark = 10,
-    .FIFO_mode = LIS2DH12_FIFO_MODE_STREAMtoFIFO,
-};
-
-/* Memory to print current data */
-static char str_out[3][8];
-
-/* current lis acceleration data */
-static int16_t data_lis[3];
-
-/* highpass configuration */
-lis2dh12_highpass_t highpass_cfg = {
-    .Highpass_mode = LIS2DH12_HP_MODE_REFERENCE,
-    .Highpass_freq = LIS2DH12_HP_FREQ_DIV100,
-    .CLICK_enable = false,
-    .INT1_enable = false,
-    .INT2_enable = false,
-    .DATA_OUT_enable = false,
-};
-
-/* reference data */
-static uint8_t reference_value;
-
-/* shock threshold */
-static int16_t shock_thold;
-
-#ifdef MODULE_LIS2DH12_INT
-/* previous values */
-static int16_t old_data_lis[3];
-static uint8_t int1_src_old;
-
-/* lis2dh12 interrupt callback function. */
-static void lis2dh12_int_cb(void* l) {
-
-    /* disable IRQ until lis_process is done */
-    gpio_irq_disable(dev.p->int1_pin);
-    gpio_irq_disable(dev.p->int2_pin);
-
-    /* reset click source */
-    lis2dh12_read_click_src(&dev, &click_src_reg);
-    DEBUG("[INT]: CLICK_SRC 0x%x\n", click_src_reg.reg);
-
-    uint8_t line = *(uint8_t*)l;
-    printf("Info: INT_line: %d\n", line);
-
-    lis2dh12_read_reference(&dev, &reference_value);
-    DEBUG("[INT]: REF: 0x%x\n", reference_value);
-
-    lis2dh12_read_int_src(&dev, &int1_src, 1);
-    DEBUG("[INT]: INT_SRC 0x%x\n", int1_src);
-    DEBUG("[INT]: INT_SRC - IA %d; ZH %d; ZL %d; YH %d; YL %d; XH %d; XL %d.\n",
-            int1_src & LIS2DH12_INT_SRC_IA,
-            int1_src & LIS2DH12_INT_SRC_ZH, int1_src & LIS2DH12_INT_SRC_ZL,
-            int1_src & LIS2DH12_INT_SRC_YH, int1_src & LIS2DH12_INT_SRC_YL,
-            int1_src & LIS2DH12_INT_SRC_XH, int1_src & LIS2DH12_INT_SRC_XL);
-
-    thread_wakeup(lis2dh12_process);
-}
-#endif /* MODULE_LIS2DH12_INT */
-
 void lis2dh12_test_init(void) {
 
     if (IS_USED(MODULE_LIS2DH12_SPI)) {
@@ -173,534 +58,320 @@ void lis2dh12_test_init(void) {
     }
 
     /* change LIS settings */
-    lis2dh12_set_powermode(&dev, LIS2DH12_POWER_LOW);
+    lis2dh12_set_resolution(&dev, LIS2DH12_POWER_LOW);
     lis2dh12_set_datarate(&dev, LIS2DH12_RATE_100HZ);
-    lis2dh12_set_scale(&dev, LIS2DH12_SCALE_4G);
-
-#ifdef MODULE_LIS2DH12_INT
-    /* set interrupt pins */
-    gpio_t pin1 = dev.p->int1_pin;
-    gpio_t pin2 = dev.p->int2_pin;
-
-    /* set Interrupt params */
-    if (gpio_is_valid(pin1)) {
-        /* enables interrupt on all axes above the threshold value */
-        params_int1.int_config = LIS2DH12_INT_CFG_XHIE
-                               | LIS2DH12_INT_CFG_YHIE
-                               | LIS2DH12_INT_CFG_ZHIE;
-        params_int1.int_duration = 1;
-        params_int1.cb = lis2dh12_int_cb;
-        params_int1.arg = &line1;
-    }
-    if (gpio_is_valid(pin2)) {
-        /* enables interrupt on Y-axis below the threshold value */
-        params_int2.int_config = LIS2DH12_INT_CFG_YLIE;
-        params_int2.int_duration = 1;
-        params_int2.cb = lis2dh12_int_cb;
-        params_int2.arg = &line2;
-    }
+    lis2dh12_set_scale(&dev, LIS2DH12_SCALE_16G);
 
-    if (gpio_init_int(pin1, GPIO_IN, GPIO_RISING, lis2dh12_int_cb, &line1)) {
-        DEBUG("[lis_init]: INT1 failed\n");
-    }
-    else {
-        DEBUG("[lis_init]: INT1 done\n");
-    }
+    /* configure FIFO */
+    lis2dh12_fifo_t fifo_cfg = {
+        .FIFO_mode = LIS2DH12_FIFO_MODE_STREAM,
+    };
 
-    if (gpio_init_int(pin2, GPIO_IN, GPIO_RISING, lis2dh12_int_cb, &line2)) {
-        DEBUG("[lis_init]: INT2 failed\n");
-    }
-    else {
-        DEBUG("[lis_init]: INT2 done\n");
-    }
-#endif /* MODULE_LIS2DH12_INT */
-
-    /* enable FIFO */
     lis2dh12_set_fifo(&dev, &fifo_cfg);
-
-    /* enable click detection */
-    lis2dh12_set_click(&dev, &click_cfg);
-
-    /* set default shock value */
-    shock_thold = THOLD_SHOCK_MILLIG_DEFAULT;
-
-    /* read registers to reset device */
-    lis2dh12_read_click_src(&dev, &click_src_reg);
-    lis2dh12_read_reference(&dev, &reference_value);
-#ifdef MODULE_LIS2DH12_INT
-    lis2dh12_read_int_src(&dev, &int1_src, 1);
-#endif /* MODULE_LIS2DH12_INT */
 }
 
 #ifdef MODULE_LIS2DH12_INT
 void* lis2dh12_test_process(void* arg) {
     (void) arg;
+
+    /* start processing */
+    DEBUG("[Process]: start process\n");
+
     while (1) {
-        /* start processing */
-        DEBUG("[Process]: start process\n");
-
-        /* read FIFO_src before getting data */
-        LIS2DH12_FIFO_SRC_REG_t fifo_src;
-        lis2dh12_read_fifo_src(&dev, &fifo_src);
-        DEBUG("[Process]: FIFO SRC 0x%x\n", fifo_src.reg);
-        DEBUG("[Process]: WTM %x, OVRN %d, EMPTY %d, FSS %d\n", fifo_src.bit.WTM,
-                                fifo_src.bit.OVRN_FIFO, fifo_src.bit.EMPTY, fifo_src.bit.FSS);
-
-        /* get fifo data */
-        uint8_t number_read = lis2dh12_read_fifo_data(&dev, data_fifo, NUM_FIFO_VALUES);
-
-        /* read FIFO_src after getting data */
-        lis2dh12_read_fifo_src(&dev, &fifo_src);
-        DEBUG("[Process]: FIFO SRC 0x%x\n", fifo_src.reg);
-        DEBUG("[Process]: WTM %x, OVRN %d, EMPTY %d, FSS %d\n", fifo_src.bit.WTM,
-                                fifo_src.bit.OVRN_FIFO, fifo_src.bit.EMPTY, fifo_src.bit.FSS);
-
-        /* display FIFO data */
-        if (ENABLE_DEBUG) {
-            for (int i = 0; i < number_read; i++){
-                printf("[Process]: X[%2d]  %d\n", i, data_fifo[i].X_AXIS);
-                printf("[Process]: Y[%2d]  %d\n", i, data_fifo[i].Y_AXIS);
-                printf("[Process]: Z[%2d]  %d\n", i, data_fifo[i].Z_AXIS);
-            }
-        }
 
-        /* After the Interrupt the FIFO needs to be enabled again. */
-        lis2dh12_restart_fifo(&dev);
-
-        /* check if shock occurred*/
-        uint16_t max_data_X = 0;
-        uint16_t max_data_Y = 0;
-        uint16_t max_data_Z = 0;
-
-        bool X_shock_pos = false;
-        bool Y_shock_pos = false;
-        bool Z_shock_pos = false;
-
-        for (uint8_t entry = NUM_FIFO_VALUES - NUM_DATA_SHOCK_DETECT; entry < NUM_FIFO_VALUES;
-                entry++) {
-            uint16_t abs_X = data_fifo[entry].X_AXIS >= 0 ? data_fifo[entry].X_AXIS :
-                                                            -1*data_fifo[entry].X_AXIS;
-            uint16_t abs_Y = data_fifo[entry].Y_AXIS >= 0 ? data_fifo[entry].Y_AXIS :
-                                                            -1*data_fifo[entry].Y_AXIS;
-            uint16_t abs_Z = data_fifo[entry].Z_AXIS >= 0 ? data_fifo[entry].Z_AXIS :
-                                                            -1*data_fifo[entry].Z_AXIS;
-
-            /* check X shock direction */
-            if (max_data_X <= abs_X) {
-                max_data_X = abs_X;
-                X_shock_pos = (data_fifo[entry].X_AXIS >= 0);
-            }
-            /* check Y shock direction */
-            if (max_data_Y <= abs_Y) {
-                max_data_Y = abs_Y;
-                Y_shock_pos = (data_fifo[entry].Y_AXIS >= 0);
-            }
-            /* check Z shock direction */
-            if (max_data_Z <= abs_Z) {
-                max_data_Z = abs_Z;
-                Z_shock_pos = (data_fifo[entry].Z_AXIS >= 0);
-            }
-        }
+        /* wait for interrupt */
+        int int1_src = lis2dh12_wait_event(&dev, LIS2DH12_INT1, false);
 
-        DEBUG("[Process]: oldX %d, oldY %d, oldZ %d\n", old_data_lis[0], old_data_lis[1],
-                    old_data_lis[2]);
-        DEBUG("[Process]: maxX %d, maxY %d, maxZ %d\n", max_data_X, max_data_Y, max_data_Z);
-
-        /* X shock */
-        int16_t diff_value = max_data_X - old_data_lis[0];
-        if (diff_value >= shock_thold) {
-            if (X_shock_pos) {
-                puts("positive X shock detected.");
-            }
-            else {
-                puts("negative X shock detected.");
-            }
-        }
-        /* Y shock */
-        diff_value = max_data_Y - old_data_lis[1];
-        if (diff_value >= shock_thold) {
-            if (Y_shock_pos) {
-                puts("positive Y shock detected.");
-            }
-            else {
-                puts("negative Y shock detected.");
-            }
-        }
-        /* Z shock */
-        diff_value = max_data_Z - old_data_lis[2];
-        if (diff_value >= shock_thold) {
-            if (Z_shock_pos) {
-                puts("positive Z shock detected.");
-            }
-            else {
-                puts("negative Z shock detected.");
-            }
+        if (int1_src <= 0) {
+            printf("error: %d\n", int1_src);
+            continue;
         }
 
-        /* check for roll */
-        /* roll conditions
-         *
-         * only 180°, changes can be detected with 6D reg in INT1_SRC
-         * change in ZH and ZL -> X-roll (device flipped from top to bottom)
-         * change in YH and YL -> Z-roll
-         * change in XH and XL -> Y-roll
-         */
-        DEBUG("[Process]: OLD - IA %d; ZH %d; ZL %d; YH %d; YL %d; XH %d; XL %d.\n",
-                    int1_src_old & LIS2DH12_INT_SRC_IA,
-                    int1_src_old & LIS2DH12_INT_SRC_ZH, int1_src_old & LIS2DH12_INT_SRC_ZL,
-                    int1_src_old & LIS2DH12_INT_SRC_YH, int1_src_old & LIS2DH12_INT_SRC_YL,
-                    int1_src_old & LIS2DH12_INT_SRC_XH, int1_src_old & LIS2DH12_INT_SRC_XL);
-
-        DEBUG("[Process]: NEW - IA %d; ZH %d; ZL %d; YH %d; YL %d; XH %d; XL %d.\n",
-                    int1_src & LIS2DH12_INT_SRC_IA,
-                    int1_src & LIS2DH12_INT_SRC_ZH, int1_src & LIS2DH12_INT_SRC_ZL,
-                    int1_src & LIS2DH12_INT_SRC_YH, int1_src & LIS2DH12_INT_SRC_YL,
-                    int1_src & LIS2DH12_INT_SRC_XH, int1_src & LIS2DH12_INT_SRC_XL);
-
-        if (((int1_src_old & LIS2DH12_INT_SRC_ZH) != (int1_src & LIS2DH12_INT_SRC_ZH))
-                && ((int1_src_old & LIS2DH12_INT_SRC_ZL) != (int1_src & LIS2DH12_INT_SRC_ZL))) {
-            printf("X roll detected.\n");
+        if (LIS2DH12_INT_SRC_1(int1_src) & LIS2DH12_INT_SRC_IA) {
+            puts("event 1");
         }
-        if (((int1_src_old & LIS2DH12_INT_SRC_XH) != (int1_src & LIS2DH12_INT_SRC_XH))
-                && ((int1_src_old & LIS2DH12_INT_SRC_YL) != (int1_src & LIS2DH12_INT_SRC_YL))) {
-            printf("Z roll detected.\n");
+        if (LIS2DH12_INT_SRC_2(int1_src) & LIS2DH12_INT_SRC_IA) {
+            puts("event 2");
         }
-        if (((int1_src_old & LIS2DH12_INT_SRC_YH) != (int1_src & LIS2DH12_INT_SRC_YH))
-                && ((int1_src_old & LIS2DH12_INT_SRC_XL) != (int1_src & LIS2DH12_INT_SRC_XL))) {
-            printf("Y roll detected.\n");
+        if (LIS2DH12_INT_SRC_CLICK(int1_src) & LIS2DH12_INT_SRC_IA) {
+            puts("click event");
         }
-
-        int1_src_old = int1_src;
-
-        /* check click order */
-        /*
-         * idea is to do a sequence of double clicks, to enable the device
-         *
-         */
-        /* click_src read during interrupt callback */
-        DEBUG("[Process]: clickSRC 0x%x\n", click_src_reg.reg);
-
-        if (click_src_reg.bit.IA && click_src_reg.bit.DClick) {
-            /* X-Double */
-            if (click_src_reg.bit.X_AXIS && !click_src_reg.bit.Y_AXIS
-                && !click_src_reg.bit.Z_AXIS) {
-                int8_t sign = click_src_reg.bit.Sign ? -1 : 1;
-                printf("got X-DCLICK, sign %d\n", sign);
-            }
-            /* Y-Double */
-            if (!click_src_reg.bit.X_AXIS && click_src_reg.bit.Y_AXIS
-                && !click_src_reg.bit.Z_AXIS) {
-                int8_t sign = click_src_reg.bit.Sign ? -1 : 1;
-                printf("got Y-DCLICK, sign %d\n", sign);
-            }
-            /* Z-Double */
-            if (!click_src_reg.bit.X_AXIS && !click_src_reg.bit.Y_AXIS
-                && click_src_reg.bit.Z_AXIS) {
-                int8_t sign = click_src_reg.bit.Sign ? -1 : 1;
-                printf("got Z-DCLICK, sign %d\n", sign);
-            }
-        }
-
-        /* enable IRQ again */
-        gpio_irq_enable(dev.p->int1_pin);
-        gpio_irq_enable(dev.p->int2_pin);
-
-        /* thread will sleep until next wokeup_lis */
-        thread_sleep();
     }
 
     return NULL;
 }
 #endif /* MODULE_LIS2DH12_INT */
 
-int shell_lis2dh12_cmd(int argc, char **argv) {
+static int shell_is2dh12_read(int argc, char **argv)
+{
+    (void)argc;
+    (void)argv;
+
+    lis2dh12_fifo_data_t data;
 
-    printf("Command: lis %s %s\n", (argc > 1) ? argv[1] : "",
-           (argc > 2) ? argv[2] : "");
-#ifdef MODULE_LIS2DH12_INT
-    const char * usage = "USAGE: lis <subcommand> [arg], with subcommand "
-                         "in (enable, disable, read, read_fifo, clear_data, "
-                         "set-click, set-thold-shock, set-thold-inter, "
-                         "set-highpass, change_rate, change_power, change_scale).";
-#else
-    const char * usage = "USAGE: lis <subcommand> [arg], with subcommand "
-                         "in (enable, disable, read, read_fifo, clear_data, "
-                         "change_rate, change_power, change_scale).";
-#endif /* MODULE_LIS2DH12_INT */
+    lis2dh12_read(&dev, &data);
 
-    /* MISSING command */
-    if (argc < 2) {
-        printf("Error: Missing sub-command. %s\n", usage);
-        return -1;
-    }
+    /* Memory to print current data */
+    char str_out[3][8];
 
-    /* enable disable device */
-    else if (strncmp(argv[1], "enable", sizeof("enable")) == 0) {
-        if (lis2dh12_poweron(&dev) != LIS2DH12_OK) {
-            puts("unable to poweron device.");
-        }
-        return 1;
+    /* format data */
+    for (unsigned j = 0; j < 3; ++j) {
+        size_t len = fmt_s16_dfp(str_out[j], data.data[j], -3);
+        str_out[j][len] = '\0';
     }
-    else if (strncmp(argv[1], "disable", sizeof("disable")) == 0) {
-        if (lis2dh12_poweroff(&dev) != LIS2DH12_OK) {
-            puts("unable to poweroff device.");
-            return -1;
-        }
-        return 1;
+
+    printf("X: %6s  Y: %6s  Z: %6s\n", str_out[0], str_out[1], str_out[2]);
+
+    return 0;
+}
+
+static int shell_is2dh12_read_fifo(int argc, char **argv)
+{
+    uint8_t num = NUM_FIFO_VALUES;
+    lis2dh12_fifo_data_t data[NUM_FIFO_VALUES];
+
+    if (argc > 1) {
+        num = atoi(argv[1]);
     }
 
-    /* read acceleration data */
-    else if (strncmp(argv[1], "read", sizeof("read")) == 0) {
-        uint8_t amount = (argc < 3) ? 1 : atoi(argv[2]);
-        uint8_t amt = 0;
-
-        /* read sensor data */
-        for (amt = 0; amt < amount; amt++){
-            if (lis2dh12_read(&dev, data_lis) != LIS2DH12_OK) {
-                puts("error: no data from sensor");
-                return -1;
-            }
-            /* format data */
-            for (int i = 0; i < 3; i++) {
-                size_t len = fmt_s16_dfp(str_out[i], data_lis[i], -3);
-                str_out[i][len] = '\0';
-            }
-
-            /* print data to STDIO */
-            printf("X: %6s  Y: %6s  Z: %6s\n", str_out[0], str_out[1], str_out[2]);
-
-            xtimer_msleep(250);
+    num = lis2dh12_read_fifo_data(&dev, data, num);
+
+    /* print data */
+    for (unsigned i = 0; i < num; ++i) {
+
+        /* Memory to print current data */
+        char str_out[3][8];
+
+        /* format data */
+        for (unsigned j = 0; j < 3; ++j) {
+            size_t len = fmt_s16_dfp(str_out[j], data[i].data[j], -3);
+            str_out[j][len] = '\0';
         }
-        return 1;
+
+        printf("[%2u] X: %6s  Y: %6s  Z: %6s\n", i, str_out[0], str_out[1], str_out[2]);
     }
-    else if (strncmp(argv[1], "read_fifo", sizeof("read_fifo")) == 0) {
-        uint8_t number = 0;
-        if ((argc < 3) || (number = atoi(argv[2])) > 32) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain number of FIFO values to read (max. 32)).");
-            puts("USAGE: lis read_fifo [number]");
-            return -1;
-        }
 
-        /* read raw data from FIFO */
-        uint8_t number_read = lis2dh12_read_fifo_data(&dev, data_fifo, number);
+    return 0;
+}
 
-        DEBUG("[lis_command]: fifo_read %d elements.\n", number_read);
+static int shell_is2dh12_threshold(int argc, char **argv)
+{
+    uint8_t slot;
+    uint32_t mg;
+    uint32_t us = 0;
+    uint8_t axis = LIS2DH12_INT_CFG_XHIE
+                 | LIS2DH12_INT_CFG_YHIE
+                 | LIS2DH12_INT_CFG_ZHIE;
+
+    if (argc < 3) {
+        printf("usage: %s <slot> <mg> [µs]\n", argv[0]);
+        return -1;
+    }
 
-        /* print data */
-        for (int entry = 0; entry < number_read; entry++){
+    slot = atoi(argv[1]);
+    mg   = atoi(argv[2]);
 
-            /* format data */
-            size_t len = fmt_s16_dfp(str_out[0], data_fifo[entry].X_AXIS, -3);
-            str_out[0][len] = '\0';
-            len = fmt_s16_dfp(str_out[1], data_fifo[entry].Y_AXIS, -3);
-            str_out[1][len] = '\0';
-            len = fmt_s16_dfp(str_out[2], data_fifo[entry].Z_AXIS, -3);
-            str_out[2][len] = '\0';
+    if (argc > 3) {
+        us = atoi(argv[3]);
+    }
 
-            printf("[%2d] X: %6s  Y: %6s  Z: %6s\n", entry, str_out[0], str_out[1], str_out[2]);
-        }
-        return 1;
+    if (slot < 1 || slot > 2) {
+        puts("event slot must be either 1 or 2");
+        return -1;
     }
 
-    /* clear memory */
-    else if (strncmp(argv[1], "clear_data", sizeof("clear_data")) == 0) {
+    lis2dh12_cfg_threshold_event(&dev, mg, us, axis, slot, LIS2DH12_INT1);
 
-        lis2dh12_clear_data(&dev);
-        return 1;
-    }
+    return 0;
+}
 
-#ifdef MODULE_LIS2DH12_INT
-    /* set commands */
-    else if (strncmp(argv[1], "set-click", sizeof("set-click")) == 0) {
-        uint8_t thold = 0;
-        if ((argc < 3) || (thold = atoi(argv[2])) > 127) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain a threshold value below 128. "
-                 "The LSB changes according to selected SCALE "
-                 "(@2G LSB=16mg; @4G LSB=32mg; @8G LSB=62mg: @16G LSB=186mg).");
-            puts("USAGE: lis set-click [thold]");
-            return -1;
-        }
+static int shell_is2dh12_click(int argc, char **argv)
+{
+    uint32_t mg;
+    uint32_t us = 0;
+    uint32_t us_delay = 0;
+    uint32_t us_double = 0;
+    uint8_t clicks = LIS2DH12_CLICK_X_SINGLE
+                   | LIS2DH12_CLICK_Y_SINGLE
+                   | LIS2DH12_CLICK_Z_SINGLE;
 
-        click_cfg.CLICK_thold = thold;
-        lis2dh12_set_click(&dev, &click_cfg);
+    if (argc < 2) {
+        printf("usage: %s <mg> [µs] [dead time µs] [double click µs]\n", argv[0]);
+        return -1;
+    }
 
-        /* enable click interrupt */
-        params_int1.int_type = LIS2DH12_INT_TYPE_I1_CLICK;
-        lis2dh12_set_int(&dev, &params_int1, LIS2DH12_INT1);
+    mg = atoi(argv[1]);
 
-        return 1;
+    if (argc > 2) {
+        us = atoi(argv[2]);
     }
-    else if (strncmp(argv[1], "set-thold-shock", sizeof("set-thold-shock")) == 0) {
-        uint16_t thold = 0;
-        if ((argc < 3) || !(thold = atoi(argv[2]))) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain a threshold value in [mg] below the max SCALE. "
-                 "(@2G below 2000; @4G below 4000; and so on)");
-            puts("USAGE: lis set-thold-shock [thold]");
-            return -1;
-        }
-        shock_thold = thold;
-        return 1;
+
+    if (argc > 3) {
+        us_delay = atoi(argv[3]);
     }
-    else if (strncmp(argv[1], "set-thold-inter", sizeof("set-thold-inter")) == 0) {
-        uint8_t line = 0;
-        if ((argc < 4) || (line = atoi(argv[3])) > 2) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain threshold value and interrupt line (1 or 2). "
-                 "The threshold LSB changes according to selected SCALE "
-                 "(@2G LSB=16mg; @4G LSB=32mg; @8G LSB=62mg: @16G LSB=186mg).");
-            puts("To disable interrupt set thold to 0.");
-            puts("USAGE: lis set-thold-inter [thold] [line]");
-            return -1;
-        }
-        uint8_t thold = atoi(argv[2]);
-        if (line == 1) {
-            if (!thold) {
-                params_int1.int_config = 0;
-            }
-            else {
-                /* enables all axes for acceleration above threshold */
-                params_int1.int_config = LIS2DH12_INT_CFG_XHIE
-                                       | LIS2DH12_INT_CFG_YHIE
-                                       | LIS2DH12_INT_CFG_ZHIE;
-            }
-            params_int1.int_type = LIS2DH12_INT_TYPE_I1_IA1;
-            params_int1.int_threshold = thold;
-
-            lis2dh12_set_int(&dev, &params_int1, LIS2DH12_INT1);
-        }
-        else if (line == 2){
-            if (!thold) {
-                params_int2.int_config = 0;
-            }
-            else {
-                /* enables Y-axis for acceleration under the threshold */
-                params_int2.int_config = LIS2DH12_INT_CFG_YLIE;
-            }
-            params_int2.int_type = LIS2DH12_INT_TYPE_I2_IA2;
-            params_int2.int_threshold = thold;
-            lis2dh12_set_int(&dev, &params_int2, LIS2DH12_INT2);
-        }
-        if (thold) {
-            printf("Info: Interrupt thold = %d on line %d.\n", thold, line);
-        }
-        else {
-            printf("Info: Interrupt disabled.\n");
-        }
 
-        return 1;
+    if (argc > 4) {
+        us_double = atoi(argv[4]);
+        clicks |= clicks << 1;
     }
 
-    else if (strncmp(argv[1], "set-highpass", sizeof("set-highpass")) == 0) {
-        uint8_t out = 0;
-        uint8_t reference = atoi(argv[2]);
-        if ((argc < 4) || (out = atoi(argv[3])) > 3) {
-            puts("Error: Missing parameter.");
-            puts("The command should contains the number of an output which gets filtered "
-                 "and the reference value less than 255. "
-                 "Possible outputs are IA1 (1) or IA2 (2) or CLICK (3) "
-                 "or (0) to disable the filter.");
-            puts("USAGE: lis set-highpass [reference] [out_number]");
-            return -1;
-        }
+    lis2dh12_cfg_click_event(&dev, mg, us, us_delay, us_double, clicks, LIS2DH12_INT1);
 
-        if (out) {
-            /* enable filter for output */
-            highpass_cfg.DATA_OUT_enable = 0;
-
-            /* enable HP for interrupt */
-            if (out == 1) {
-                highpass_cfg.INT1_enable = 1;
-            }
-            else if (out == 2) {
-                highpass_cfg.INT2_enable = 1;
-            }
-            else {
-                /* enable filter for click function */
-                highpass_cfg.CLICK_enable = 1;
-            }
-            printf("Info: Filter set to %d on output %d.\n", reference, out);
-        }
-        else {
-            printf("Info: Filter disabled.\n");
-        }
+    return 0;
+}
 
-        lis2dh12_set_reference(&dev, reference);
-        lis2dh12_set_highpass(&dev, &highpass_cfg);
-        return 1;
+static int shell_is2dh12_power(int argc, char **argv)
+{
+    bool on;
+
+    if (argc > 1 && (!strcmp(argv[1], "on") || !strcmp(argv[1], "1"))) {
+        on = true;
+    } else if (argc > 1 && (!strcmp(argv[1], "off") || !strcmp(argv[1], "0"))) {
+        on = false;
+    } else {
+        printf("usage: %s <on|off>\n", argv[0]);
+        return -1;
     }
-#endif /* MODULE_LIS2DH12_INT */
 
-    /* change sampling rate */
-    else if (strncmp(argv[1], "change_rate", sizeof("change_rate")) == 0) {
-        uint8_t rate = 0;
-        if ((argc < 3) || (rate = atoi(argv[2])) > 9) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain a number for sampling rate. "
-                 "Possible outputs are 1Hz (1), 10Hz (2), 25Hz (3), "
-                 "50Hz (4), 100Hz (5), 200Hz (6) or 400Hz (7).");
-            puts("USAGE: lis change_rate [samplingrate]");
-            return -1;
-        }
+    if (on) {
+        lis2dh12_poweron(&dev);
+    } else {
+        lis2dh12_poweroff(&dev);
+    }
+
+    return 0;
+}
+
+static int shell_is2dh12_set_resolution(int argc, char **argv)
+{
+    unsigned resolution = UINT_MAX;
 
-        lis2dh12_set_datarate(&dev, rate);
-        return 1;
+    const char* resolutions[4] = {
+        "off",
+        "8-bit",
+        "10-bit",
+        "12-bit",
+    };
+
+    if (argc > 1) {
+        resolution = atoi(argv[1]);
+    } else {
+        printf("current resolution: %s\n", resolutions[lis2dh12_get_resolution(&dev)]);
     }
 
-    /* change power mode */
-    else if (strncmp(argv[1], "change_power", sizeof("change_power")) == 0) {
-        uint8_t power = 0;
-        if ((argc < 3) || (power = atoi(argv[2])) > 9) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain a number for power mode. "
-                 "Possible outputs are POWER_DOWN (0), POWER_LOW (1), "
-                 "POWER_NORMAL (2) or POWER_HIGH (3).");
-            puts("USAGE: lis change_power [powermode]");
-            return -1;
+    if (resolution > LIS2DH12_POWER_HIGH) {
+        printf("usage: %s <mode>\n", argv[0]);
+        puts("where <mode> is:");
+        for (unsigned i = 0; i < ARRAY_SIZE(resolutions); ++i) {
+            printf("\t%u: %s\n", i, resolutions[i]);
         }
+        return -1;
+    }
+
+    lis2dh12_set_resolution(&dev, resolution);
+
+    return 0;
+}
 
-        lis2dh12_set_powermode(&dev, power);
-        return 1;
+static int shell_is2dh12_set_rate(int argc, char **argv)
+{
+    unsigned rate = UINT_MAX;
+
+    if (argc > 1) {
+        rate = atoi(argv[1]);
+    } else {
+        printf("Current sampling rate: %u Hz\n", lis2dh12_get_datarate(&dev));
     }
 
-    /* change scale value */
-    else if (strncmp(argv[1], "change_scale", sizeof("change_scale")) == 0) {
-        uint8_t scale = 0;
-        if ((argc < 3) || (scale = atoi(argv[2])) > 3) {
-            puts("Error: Missing parameter.");
-            puts("The command should contain a number for scale value. "
-                 "Possible values are SCALE_2G (0), SCALE_4G (1), "
-                 "SCALE_8G (2) or SCALE_16G (3).");
-            puts("USAGE: lis change_scale [scale]");
-            return -1;
-        }
+    if (rate > LIS2DH12_RATE_VERYHIGH) {
+        printf("usage: %s <rate>\n", argv[0]);
+        puts("where <rate> is:");
+        puts("\t1: 1 Hz");
+        puts("\t2: 10 Hz");
+        puts("\t3: 25 Hz");
+        puts("\t4: 50 Hz");
+        puts("\t5: 100 Hz");
+        puts("\t6: 200 Hz");
+        puts("\t7: 400 Hz");
+        puts("\t8: 1620 Hz");
+        puts("\t9: 5376 Hz");
+        return -1;
+    }
+
+    lis2dh12_set_datarate(&dev, rate);
+
+    return 0;
+}
 
-        lis2dh12_set_scale(&dev, scale<<4);
-        return 1;
+static int shell_is2dh12_set_scale(int argc, char **argv)
+{
+    unsigned scale = UINT_MAX;
+
+    const uint8_t scales[] = {
+        2, 4, 8, 16
+    };
+
+    if (argc > 1) {
+        scale = atoi(argv[1]);
+    } else {
+        printf("current range: ± %ug\n", scales[lis2dh12_get_scale(&dev)]);
     }
 
-    /* UNKNOWN */
-    else {
-        printf("Error: Unknown sub-command. %s\n", usage);
+    if (scale > LIS2DH12_SCALE_16G) {
+        printf("usage: %s <scale>\n", argv[0]);
+        puts("where <scale> is:");
+        for (unsigned i = 0; i < ARRAY_SIZE(scales); ++i) {
+            printf("\t%u: ± %ug\n", i, scales[i]);
+        }
+
         return -1;
     }
+
+    lis2dh12_set_scale(&dev, scale);
+
+    return 0;
 }
 
+static int shell_is2dh12_read_temp(int argc, char **argv)
+{
+    (void)argc;
+    (void)argv;
+
+    int16_t temp;
+    lis2dh12_read_temperature(&dev, &temp);
+
+    printf("%d.%02d °C\n", temp / 100, temp % 100);
+
+    return 0;
+}
+
+static const shell_command_t shell_commands[] = {
+    { "read", "Read acceleration data", shell_is2dh12_read },
+    { "read_fifo", "Read acceleration data from fifo", shell_is2dh12_read_fifo },
+    { "threshold", "Configure threshold event", shell_is2dh12_threshold },
+    { "click", "Configure click event", shell_is2dh12_click },
+    { "power", "Enable / Disable the sensor", shell_is2dh12_power },
+    { "resolution", "Get/Set resolution", shell_is2dh12_set_resolution },
+    { "rate", "Get/Set sampline rate", shell_is2dh12_set_rate },
+    { "scale", "Get/Set measuring range", shell_is2dh12_set_scale },
+    { "temp", "Read temperature data", shell_is2dh12_read_temp },
+    { NULL, NULL, NULL },
+};
+
 int main(void)
 {
+    /* init lis */
+    lis2dh12_test_init();
 
 #ifdef MODULE_LIS2DH12_INT
+    static char lis2dh12_process_stack[THREAD_STACKSIZE_MAIN];
+
     /* processing lis2dh12 acceleration data */
-    lis2dh12_process = thread_create(lis2dh12_process_stack, sizeof(lis2dh12_process_stack),
-                  THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_SLEEPING,
+    thread_create(lis2dh12_process_stack, sizeof(lis2dh12_process_stack),
+                  THREAD_PRIORITY_MAIN - 1, THREAD_CREATE_STACKTEST,
                   lis2dh12_test_process, NULL, "lis2dh12_process");
 #endif /* MODULE_LIS2DH12_INT */
 
-    /* init lis */
-    lis2dh12_test_init();
-
     /* running shell */
     char line_buf[SHELL_DEFAULT_BUFSIZE];
     shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);
diff --git a/tests/driver_mrf24j40/Makefile.ci b/tests/driver_mrf24j40/Makefile.ci
index 586364d983..72ac56be14 100644
--- a/tests/driver_mrf24j40/Makefile.ci
+++ b/tests/driver_mrf24j40/Makefile.ci
@@ -6,6 +6,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-uno \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
     bluepill-stm32f030c8 \
     i-nucleo-lrwan1 \
     nucleo-f031k6 \
diff --git a/tests/driver_nrf24l01p_ng/Makefile.ci b/tests/driver_nrf24l01p_ng/Makefile.ci
index 3386c82573..0949f760d5 100644
--- a/tests/driver_nrf24l01p_ng/Makefile.ci
+++ b/tests/driver_nrf24l01p_ng/Makefile.ci
@@ -8,6 +8,8 @@ BOARD_INSUFFICIENT_MEMORY := \
     atmega128rfa1 \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
     bluepill-stm32f030c8 \
     derfmega128 \
     i-nucleo-lrwan1 \
diff --git a/tests/driver_si70xx/Makefile b/tests/driver_si70xx/Makefile
index 862de8b58e..e80b4b1bac 100644
--- a/tests/driver_si70xx/Makefile
+++ b/tests/driver_si70xx/Makefile
@@ -1,6 +1,8 @@
 include ../Makefile.tests_common
 
-# This test should also work with Si7006, Si7013 and Si7020 variants.
-USEMODULE += si7021
+# This test should also work with si7006, si7013, si7020 and si705x variants.
+SI70XX_VARIANT ?= si7021
+
+USEMODULE += $(SI70XX_VARIANT)
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/driver_si70xx/main.c b/tests/driver_si70xx/main.c
index 56c8d26333..f148401cc1 100644
--- a/tests/driver_si70xx/main.c
+++ b/tests/driver_si70xx/main.c
@@ -29,10 +29,10 @@ int main(void)
 {
     si70xx_t dev;
 
-    puts("SI7021 temperature and humidity sensor test application");
+    puts("SI70XX temperature and humidity sensor test application");
 
     /* initialize the sensor */
-    printf("Initializing sensor... ");
+    puts("Initializing sensor... ");
 
     if (si70xx_init(&dev, &si70xx_params[0]) == 0) {
         puts("[OK]");
@@ -42,13 +42,17 @@ int main(void)
         return 1;
     }
 
+    printf("Found SI70%02d sensor, revision %d\n", si70xx_get_id(&dev),
+           si70xx_get_revision(&dev));
+
     /* read temperature and humidity every 1 seconds */
     bool both = false;
 
-    int16_t temperature;
-    uint16_t humidity;
-
     while (1) {
+        int16_t temperature;
+#if SI70XX_HAS_HUMIDITY_SENSOR
+        uint16_t humidity;
+
         /* rotate the way of getting the data */
         if (both) {
             si70xx_get_both(&dev, &humidity, &temperature);
@@ -57,12 +61,17 @@ int main(void)
             temperature = si70xx_get_temperature(&dev);
             humidity = si70xx_get_relative_humidity(&dev);
         }
-
+#else /* SI70XX_HAS_HUMIDITY_SENSOR */
+        temperature = si70xx_get_temperature(&dev);
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR */
         both = !both;
 
         /* display results */
+#if SI70XX_HAS_HUMIDITY_SENSOR
         printf("relative humidity: %d.%02d\n", humidity / 100, humidity % 100);
-        printf("temperature: %d.%02d C\n", temperature / 100, temperature % 100);
+#endif /* SI70XX_HAS_HUMIDITY_SENSOR */
+        printf("temperature: %d.%02d C\n", temperature / 100,
+               temperature % 100);
 
         /* sleep between measurements */
         xtimer_msleep(1000);
diff --git a/tests/driver_sx127x/main.c b/tests/driver_sx127x/main.c
index 3fcc8662eb..6f5063a3a7 100644
--- a/tests/driver_sx127x/main.c
+++ b/tests/driver_sx127x/main.c
@@ -67,30 +67,32 @@ int lora_setup_cmd(int argc, char **argv)
     /* Check bandwidth value */
     int bw = atoi(argv[1]);
     uint8_t lora_bw;
-    switch (bw) {
-        case 125:
-            puts("setup: setting 125KHz bandwidth");
-            lora_bw = LORA_BW_125_KHZ;
-            break;
-
-        case 250:
-            puts("setup: setting 250KHz bandwidth");
-            lora_bw = LORA_BW_250_KHZ;
-            break;
-
-        case 500:
-            puts("setup: setting 500KHz bandwidth");
-            lora_bw = LORA_BW_500_KHZ;
-            break;
 
-        default:
-            puts("[Error] setup: invalid bandwidth value given, "
-                 "only 125, 250 or 500 allowed.");
-            return -1;
+    switch (bw) {
+    case 125:
+        puts("setup: setting 125KHz bandwidth");
+        lora_bw = LORA_BW_125_KHZ;
+        break;
+
+    case 250:
+        puts("setup: setting 250KHz bandwidth");
+        lora_bw = LORA_BW_250_KHZ;
+        break;
+
+    case 500:
+        puts("setup: setting 500KHz bandwidth");
+        lora_bw = LORA_BW_500_KHZ;
+        break;
+
+    default:
+        puts("[Error] setup: invalid bandwidth value given, "
+             "only 125, 250 or 500 allowed.");
+        return -1;
     }
 
     /* Check spreading factor value */
     uint8_t lora_sf = atoi(argv[2]);
+
     if (lora_sf < 7 || lora_sf > 12) {
         puts("[Error] setup: invalid spreading factor value given");
         return -1;
@@ -98,6 +100,7 @@ int lora_setup_cmd(int argc, char **argv)
 
     /* Check coding rate value */
     int cr = atoi(argv[3]);
+
     if (cr < 5 || cr > 8) {
         puts("[Error ]setup: invalid coding rate value given");
         return -1;
@@ -106,6 +109,7 @@ int lora_setup_cmd(int argc, char **argv)
 
     /* Configure radio device */
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     netdev->driver->set(netdev, NETOPT_BANDWIDTH,
                         &lora_bw, sizeof(lora_bw));
     netdev->driver->set(netdev, NETOPT_SPREADING_FACTOR,
@@ -125,6 +129,7 @@ int random_cmd(int argc, char **argv)
 
     netdev_t *netdev = (netdev_t *)&sx127x;
     uint32_t rand;
+
     netdev->driver->get(netdev, NETOPT_RANDOM, &rand, sizeof(rand));
     printf("random: number from sx127x: %u\n",
            (unsigned int)rand);
@@ -245,6 +250,7 @@ int send_cmd(int argc, char **argv)
     };
 
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     if (netdev->driver->send(netdev, &iolist) == -ENOTSUP) {
         puts("Cannot send: radio is still transmitting");
     }
@@ -260,12 +266,15 @@ int listen_cmd(int argc, char **argv)
     netdev_t *netdev = (netdev_t *)&sx127x;
     /* Switch to continuous listen mode */
     const netopt_enable_t single = false;
+
     netdev->driver->set(netdev, NETOPT_SINGLE_RECEIVE, &single, sizeof(single));
     const uint32_t timeout = 0;
+
     netdev->driver->set(netdev, NETOPT_RX_TIMEOUT, &timeout, sizeof(timeout));
 
     /* Switch to RX state */
     netopt_state_t state = NETOPT_STATE_RX;
+
     netdev->driver->set(netdev, NETOPT_STATE, &state, sizeof(state));
 
     printf("Listen mode set\n");
@@ -282,6 +291,7 @@ int syncword_cmd(int argc, char **argv)
 
     netdev_t *netdev = (netdev_t *)&sx127x;
     uint8_t syncword;
+
     if (strstr(argv[1], "get") != NULL) {
         netdev->driver->get(netdev, NETOPT_SYNCWORD, &syncword,
                             sizeof(syncword));
@@ -315,6 +325,7 @@ int channel_cmd(int argc, char **argv)
 
     netdev_t *netdev = (netdev_t *)&sx127x;
     uint32_t chan;
+
     if (strstr(argv[1], "get") != NULL) {
         netdev->driver->get(netdev, NETOPT_CHANNEL_FREQUENCY, &chan,
                             sizeof(chan));
@@ -349,6 +360,7 @@ int rx_timeout_cmd(int argc, char **argv)
 
     netdev_t *netdev = (netdev_t *)&sx127x;
     uint16_t rx_timeout;
+
     if (strstr(argv[1], "set") != NULL) {
         if (argc < 3) {
             puts("usage: rx_timeout set <rx_timeout>");
@@ -372,15 +384,18 @@ int reset_cmd(int argc, char **argv)
     (void)argc;
     (void)argv;
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     puts("resetting sx127x...");
     netopt_state_t state = NETOPT_STATE_RESET;
+
     netdev->driver->set(netdev, NETOPT_STATE, &state, sizeof(netopt_state_t));
     return 0;
 }
 
-static void _set_opt(netdev_t *netdev, netopt_t opt, bool val, char* str_help)
+static void _set_opt(netdev_t *netdev, netopt_t opt, bool val, char *str_help)
 {
     netopt_enable_t en = val ? NETOPT_ENABLE : NETOPT_DISABLE;
+
     netdev->driver->set(netdev, opt, &en, sizeof(en));
     printf("Successfully ");
     if (val) {
@@ -395,12 +410,14 @@ static void _set_opt(netdev_t *netdev, netopt_t opt, bool val, char* str_help)
 int crc_cmd(int argc, char **argv)
 {
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     if (argc < 3 || strcmp(argv[1], "set") != 0) {
         printf("usage: %s set <1|0>\n", argv[0]);
         return 1;
     }
 
     int tmp = atoi(argv[2]);
+
     _set_opt(netdev, NETOPT_INTEGRITY_CHECK, tmp, "CRC check");
     return 0;
 }
@@ -408,12 +425,14 @@ int crc_cmd(int argc, char **argv)
 int implicit_cmd(int argc, char **argv)
 {
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     if (argc < 3 || strcmp(argv[1], "set") != 0) {
         printf("usage: %s set <1|0>\n", argv[0]);
         return 1;
     }
 
     int tmp = atoi(argv[2]);
+
     _set_opt(netdev, NETOPT_FIXED_HEADER, tmp, "implicit header");
     return 0;
 }
@@ -421,12 +440,14 @@ int implicit_cmd(int argc, char **argv)
 int payload_cmd(int argc, char **argv)
 {
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     if (argc < 3 || strcmp(argv[1], "set") != 0) {
         printf("usage: %s set <payload length>\n", argv[0]);
         return 1;
     }
 
     uint16_t tmp = atoi(argv[2]);
+
     netdev->driver->set(netdev, NETOPT_PDU_SIZE, &tmp, sizeof(tmp));
     printf("Successfully set payload to %i\n", tmp);
     return 0;
@@ -444,7 +465,7 @@ static const shell_command_t shell_commands[] = {
     { "register", "Get/Set value(s) of registers of sx127x", register_cmd },
     { "send",     "Send raw payload string",                 send_cmd },
     { "listen",   "Start raw payload listener",              listen_cmd },
-    { "reset",    "Reset the sx127x device",                 reset_cmd},
+    { "reset",    "Reset the sx127x device",                 reset_cmd },
     { NULL, NULL, NULL }
 };
 
@@ -464,35 +485,35 @@ static void _event_cb(netdev_t *dev, netdev_event_t event)
         size_t len;
         netdev_lora_rx_info_t packet_info;
         switch (event) {
-            case NETDEV_EVENT_RX_STARTED:
-                puts("Data reception started");
-                break;
-
-            case NETDEV_EVENT_RX_COMPLETE:
-                len = dev->driver->recv(dev, NULL, 0, 0);
-                dev->driver->recv(dev, message, len, &packet_info);
-                printf(
-                    "{Payload: \"%s\" (%d bytes), RSSI: %i, SNR: %i, TOA: %" PRIu32 "}\n",
-                    message, (int)len,
-                    packet_info.rssi, (int)packet_info.snr,
-                    sx127x_get_time_on_air((const sx127x_t *)dev, len));
-                break;
-
-            case NETDEV_EVENT_TX_COMPLETE:
-                sx127x_set_sleep(&sx127x);
-                puts("Transmission completed");
-                break;
-
-            case NETDEV_EVENT_CAD_DONE:
-                break;
-
-            case NETDEV_EVENT_TX_TIMEOUT:
-                sx127x_set_sleep(&sx127x);
-                break;
-
-            default:
-                printf("Unexpected netdev event received: %d\n", event);
-                break;
+        case NETDEV_EVENT_RX_STARTED:
+            puts("Data reception started");
+            break;
+
+        case NETDEV_EVENT_RX_COMPLETE:
+            len = dev->driver->recv(dev, NULL, 0, 0);
+            dev->driver->recv(dev, message, len, &packet_info);
+            printf(
+                "{Payload: \"%s\" (%d bytes), RSSI: %i, SNR: %i, TOA: %" PRIu32 "}\n",
+                message, (int)len,
+                packet_info.rssi, (int)packet_info.snr,
+                sx127x_get_time_on_air((const sx127x_t *)dev, len));
+            break;
+
+        case NETDEV_EVENT_TX_COMPLETE:
+            sx127x_set_sleep(&sx127x);
+            puts("Transmission completed");
+            break;
+
+        case NETDEV_EVENT_CAD_DONE:
+            break;
+
+        case NETDEV_EVENT_TX_TIMEOUT:
+            sx127x_set_sleep(&sx127x);
+            break;
+
+        default:
+            printf("Unexpected netdev event received: %d\n", event);
+            break;
         }
     }
 }
@@ -502,6 +523,7 @@ void *_recv_thread(void *arg)
     (void)arg;
 
     static msg_t _msg_q[SX127X_LORA_MSG_QUEUE];
+
     msg_init_queue(_msg_q, SX127X_LORA_MSG_QUEUE);
 
     while (1) {
@@ -521,6 +543,7 @@ int main(void)
 {
     sx127x.params = sx127x_params[0];
     netdev_t *netdev = (netdev_t *)&sx127x;
+
     netdev->driver = &sx127x_driver;
 
     if (netdev->driver->init(netdev) < 0) {
@@ -542,6 +565,7 @@ int main(void)
     /* start the shell */
     puts("Initialization successful - starting the shell now");
     char line_buf[SHELL_DEFAULT_BUFSIZE];
+
     shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);
 
     return 0;
diff --git a/tests/driver_w5100/Makefile.ci b/tests/driver_w5100/Makefile.ci
index 28ea82d339..fcbdf2a160 100644
--- a/tests/driver_w5100/Makefile.ci
+++ b/tests/driver_w5100/Makefile.ci
@@ -6,6 +6,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-uno \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
     bluepill-stm32f030c8 \
     i-nucleo-lrwan1 \
     msb-430 \
diff --git a/tests/emcute/README.md b/tests/emcute/README.md
index fc310d3659..ab891133e4 100644
--- a/tests/emcute/README.md
+++ b/tests/emcute/README.md
@@ -4,5 +4,5 @@ This is a test application for emcute. It is supposed to be run with the test
 scripts in `tests/`:
 
 ```
-BOARD="<your choice> make flash test"
+BOARD="<your choice> make flash test-as-root"
 ```
diff --git a/tests/emcute/tests-as-root/01-run.py b/tests/emcute/tests-as-root/01-run.py
index 9414162ed8..3d4f65be94 100755
--- a/tests/emcute/tests-as-root/01-run.py
+++ b/tests/emcute/tests-as-root/01-run.py
@@ -64,7 +64,7 @@ class MQTTSNServer(Automaton):
         super(MQTTSNServer, self).__init__(*args, **kwargs)
 
     def parse_args(self, spawn, bind_addr, topic_name, mode, pub_interval,
-                   qos_level=0,
+                   qos_level=0, retain=False,
                    data_len_start=1, data_len_end=1000, data_len_step=1,
                    bind_port=SERVER_PORT, family=socket.AF_INET,
                    type=socket.SOCK_DGRAM, proto=0, *args, **kwargs):
@@ -78,6 +78,7 @@ class MQTTSNServer(Automaton):
         self.data_len = data_len_start
         self.data_len_end = data_len_end
         self.data_len_step = data_len_step
+        self.retain = retain
         self.last_mid = random.randint(0, 0xffff)
         self.topics = []
         self.registered_topics = []
@@ -159,24 +160,28 @@ class MQTTSNServer(Automaton):
             # send deliberately broken length packets
             # (to small payload, len field < 256)
             self.last_packet = mqttsn.MQTTSN(len=128) / mqttsn.MQTTSNPublish(
-                qos=self._qos_flags, tid=tid, mid=mid, data="128"
+                qos=self._qos_flags, tid=tid, mid=mid, retain=self.retain,
+                data="128"
             )
             self.send(self.last_packet)
             # send deliberately broken length packets
             # (to small payload, len field >= 256)
             self.last_packet = mqttsn.MQTTSN(len=400) / mqttsn.MQTTSNPublish(
-                qos=self._qos_flags, tid=tid, mid=mid, data="400"
+                qos=self._qos_flags, tid=tid, mid=mid, retain=self.retain,
+                data="400"
             )
             self.send(self.last_packet)
             # send deliberately broken length packets (too large payload)
             self.last_packet = mqttsn.MQTTSN(len=10) / mqttsn.MQTTSNPublish(
-                qos=self._qos_flags, tid=tid, mid=mid, data="X" * 20
+                qos=self._qos_flags, tid=tid, mid=mid, retain=self.retain,
+                data="X" * 20
             )
             self.send(self.last_packet)
             return subscription, mid
         if self.data_len < self.data_len_end:
             self.last_packet = mqttsn.MQTTSN() / mqttsn.MQTTSNPublish(
-                qos=self._qos_flags, tid=tid, mid=mid, data="X" * self.data_len
+                qos=self._qos_flags, tid=tid, mid=mid, retain=self.retain,
+                data="X" * self.data_len
             )
             self.send(self.last_packet)
             return subscription, mid
@@ -465,6 +470,12 @@ def testfunc(child):
         {"qos_level": 1, "mode": "sub", "topic_name": "/test",
          "data_len_start": 0, "data_len_end": DATA_MAX_LEN,
          "data_len_step": 50},
+        {"qos_level": 0, "mode": "sub", "topic_name": "/test",
+         "data_len_start": 0, "data_len_end": DATA_MAX_LEN,
+         "data_len_step": 50, "retain": True},
+        {"qos_level": 1, "mode": "sub", "topic_name": "/test",
+         "data_len_start": 0, "data_len_end": DATA_MAX_LEN,
+         "data_len_step": 50, "retain": True},
         {"qos_level": 1, "mode": "sub",
          "topic_name": "/" + ("x" * (TOPIC_MAX_LEN - 1)),
          "data_len_start": 8, "data_len_end": 9},
diff --git a/tests/event_ztimer/Makefile b/tests/event_ztimer/Makefile
new file mode 100644
index 0000000000..bce9ef00d5
--- /dev/null
+++ b/tests/event_ztimer/Makefile
@@ -0,0 +1,9 @@
+include ../Makefile.tests_common
+
+FORCE_ASSERTS = 1
+USEMODULE += event_thread
+USEMODULE += event_callback
+USEMODULE += event_timeout_ztimer
+USEMODULE += event_periodic
+
+include $(RIOTBASE)/Makefile.include
diff --git a/tests/event_ztimer/Makefile.ci b/tests/event_ztimer/Makefile.ci
new file mode 100644
index 0000000000..b5de876337
--- /dev/null
+++ b/tests/event_ztimer/Makefile.ci
@@ -0,0 +1,9 @@
+BOARD_INSUFFICIENT_MEMORY := \
+    arduino-duemilanove \
+    arduino-leonardo \
+    arduino-nano \
+    arduino-uno \
+    atmega328p \
+    atmega328p-xplained-mini \
+    nucleo-l011k4 \
+    #
diff --git a/tests/event_ztimer/main.c b/tests/event_ztimer/main.c
new file mode 100644
index 0000000000..da1119f62c
--- /dev/null
+++ b/tests/event_ztimer/main.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       event_timeout application using ztimer
+ *
+ * @author      Kaspar Schleiser <kaspar@schleiser.de>
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ *
+ * @}
+ */
+
+#include <stdio.h>
+
+#include "atomic_utils.h"
+#include "test_utils/expect.h"
+#include "timex.h"
+#include "thread.h"
+#include "mutex.h"
+#include "event.h"
+#include "event/timeout.h"
+#include "event/periodic.h"
+#include "event/thread.h"
+#include "event/callback.h"
+#include "ztimer.h"
+#include "ztimer/periodic.h"
+
+#define EVENT_TIMEOUT_TIME       (1 * US_PER_SEC)
+
+static void callback_never(void *arg);
+static void callback_timed(void *arg);
+static void callback_4times(void *arg);
+
+static uint8_t iter;
+static event_timeout_t event_timeout;
+static event_timeout_t event_timeout_cleared;
+static event_periodic_t event_periodic;
+static event_callback_t event_4times = EVENT_CALLBACK_INIT(callback_4times, &iter);
+static event_callback_t event_timed = EVENT_CALLBACK_INIT(callback_timed, &iter);
+static event_callback_t event_never = EVENT_CALLBACK_INIT(callback_never, 0);
+static uint32_t before;
+static mutex_t lock = MUTEX_INIT_LOCKED;
+
+static void callback_timed(void *arg)
+{
+    expect(arg == event_timed.arg);
+    uint32_t now = ztimer_now(ZTIMER_USEC);
+    expect((now - before) >= 1 * US_PER_SEC);
+    printf("triggered timed callback after %" PRIu32 "us\n", now - before);
+    mutex_unlock(&lock);
+}
+
+static void callback_4times(void *arg)
+{
+    uint8_t *count = (uint8_t *)arg;
+
+    *count = *count + 1;
+    uint32_t now = event_periodic.timer.last;
+    uint32_t elapsed = now - before;
+    before = now;
+    expect((elapsed) >= 1 * US_PER_SEC);
+    if (*count <= 4) {
+        printf("trigger %d of periodic timeout, elapsed time: %" PRIu32 " us\n",
+               *count, elapsed);
+    }
+    if (*count == 4) {
+        event_periodic_stop(&event_periodic);
+        mutex_unlock(&lock);
+    }
+    else if (*count > 4) {
+        /* this callback should never be called */
+        puts("this should only be called 4 times");
+        puts("[FAILED]");
+        while (1) {
+            expect(false);
+        }
+    }
+}
+
+static void callback_never(void *arg)
+{
+    (void)arg;
+    /* this callback should never be called */
+    puts("this should never happen");
+    puts("[FAILED]");
+    while (1) {
+        expect(false);
+    }
+}
+
+int main(void)
+{
+    iter = 0;
+    puts("posting periodic timed callback with timeout 1sec");
+    event_periodic_init(&event_periodic, ZTIMER_USEC, EVENT_PRIO_MEDIUM,
+                        &event_4times.super);
+    event_periodic_start(&event_periodic, EVENT_TIMEOUT_TIME);
+    before = event_periodic.timer.last;
+    puts("waiting for periodic callback to be triggered 4 times");
+    mutex_lock(&lock);
+    puts("posting timed callback with timeout 0.5sec, clear right after");
+    event_timeout_ztimer_init(&event_timeout_cleared, ZTIMER_USEC,
+                              EVENT_PRIO_MEDIUM, &event_never.super);
+    event_timeout_set(&event_timeout_cleared, EVENT_TIMEOUT_TIME / 2);
+    event_timeout_clear(&event_timeout_cleared);
+    puts("posting timed callback with timeout 1sec");
+    event_timeout_ztimer_init(&event_timeout, ZTIMER_USEC, EVENT_PRIO_MEDIUM,
+                              &event_timed.super);
+    before = ztimer_now(ZTIMER_USEC);
+    event_timeout_set(&event_timeout, EVENT_TIMEOUT_TIME);
+    puts("waiting for timed callback to trigger");
+    mutex_lock(&lock);
+    puts("[SUCCESS]");
+    return 0;
+}
diff --git a/tests/event_ztimer/tests/01-run.py b/tests/event_ztimer/tests/01-run.py
new file mode 100755
index 0000000000..a8c5d9b211
--- /dev/null
+++ b/tests/event_ztimer/tests/01-run.py
@@ -0,0 +1,19 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2016 Kaspar Schleiser <kaspar@schleiser.de>
+#               2017 Sebastian Meiling <s@mlng.net>
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import sys
+from testrunner import run
+
+
+def testfunc(child):
+    child.expect_exact(u"[SUCCESS]")
+
+
+if __name__ == "__main__":
+    sys.exit(run(testfunc))
diff --git a/tests/events/main.c b/tests/events/main.c
index 7b44ece504..1a26907609 100644
--- a/tests/events/main.c
+++ b/tests/events/main.c
@@ -23,11 +23,16 @@
 #include <stdio.h>
 
 #include "test_utils/expect.h"
+#include "timex.h"
 #include "thread.h"
 #include "event.h"
 #include "event/timeout.h"
 #include "event/callback.h"
+#if IS_USED(MODULE_ZTIMER)
+#include "ztimer.h"
+#else
 #include "xtimer.h"
+#endif
 
 #define STACKSIZE               THREAD_STACKSIZE_DEFAULT
 #define PRIO                    (THREAD_PRIORITY_MAIN - 1)
@@ -83,7 +88,11 @@ static void timed_callback(void *arg)
     order++;
     expect(order == 6);
     expect(arg == event_callback.arg);
+#if IS_USED(MODULE_ZTIMER)
+    uint32_t now = ztimer_now(ZTIMER_USEC);
+#else
     uint32_t now = xtimer_now_usec();
+#endif
     expect((now - before >= 100000LU));
     printf("triggered timed callback with arg 0x%08x after %" PRIu32 "us\n", (unsigned)arg, now - before);
     puts("[SUCCESS]");
@@ -177,7 +186,11 @@ int main(void)
 
     puts("posting timed callback with timeout 1sec");
     event_timeout_init(&event_timeout, &queue, (event_t *)&event_callback);
+#if IS_USED(MODULE_ZTIMER)
+    before = ztimer_now(ZTIMER_USEC);
+#else
     before = xtimer_now_usec();
+#endif
     event_timeout_set(&event_timeout, (1 * US_PER_SEC));
 
     event_timeout_t event_timeout_canceled;
diff --git a/tests/external_module_dirs/Makefile b/tests/external_module_dirs/Makefile
index d271608df2..f44d1e3e8e 100644
--- a/tests/external_module_dirs/Makefile
+++ b/tests/external_module_dirs/Makefile
@@ -2,6 +2,6 @@ include ../Makefile.tests_common
 USEMODULE += random
 
 USEMODULE += external_module
-EXTERNAL_MODULE_DIRS += $(CURDIR)/external_module
+EXTERNAL_MODULE_DIRS += external_modules
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/external_module_dirs/external_module/Makefile b/tests/external_module_dirs/external_modules/external_module/Makefile
similarity index 100%
rename from tests/external_module_dirs/external_module/Makefile
rename to tests/external_module_dirs/external_modules/external_module/Makefile
diff --git a/tests/external_module_dirs/external_module/Makefile.dep b/tests/external_module_dirs/external_modules/external_module/Makefile.dep
similarity index 100%
rename from tests/external_module_dirs/external_module/Makefile.dep
rename to tests/external_module_dirs/external_modules/external_module/Makefile.dep
diff --git a/tests/external_module_dirs/external_module/Makefile.include b/tests/external_module_dirs/external_modules/external_module/Makefile.include
similarity index 100%
rename from tests/external_module_dirs/external_module/Makefile.include
rename to tests/external_module_dirs/external_modules/external_module/Makefile.include
diff --git a/tests/external_module_dirs/external_module/external_module.c b/tests/external_module_dirs/external_modules/external_module/external_module.c
similarity index 100%
rename from tests/external_module_dirs/external_module/external_module.c
rename to tests/external_module_dirs/external_modules/external_module/external_module.c
diff --git a/tests/external_module_dirs/external_module/include/external_module.h b/tests/external_module_dirs/external_modules/external_module/include/external_module.h
similarity index 100%
rename from tests/external_module_dirs/external_module/include/external_module.h
rename to tests/external_module_dirs/external_modules/external_module/include/external_module.h
diff --git a/tests/kconfig/external_module_1/Makefile b/tests/external_module_dirs/external_modules/external_module_not_used/Makefile
similarity index 100%
rename from tests/kconfig/external_module_1/Makefile
rename to tests/external_module_dirs/external_modules/external_module_not_used/Makefile
diff --git a/tests/external_module_dirs/external_modules/external_module_not_used/this_should_not_compile.c b/tests/external_module_dirs/external_modules/external_module_not_used/this_should_not_compile.c
new file mode 100644
index 0000000000..6f0c42ad8e
--- /dev/null
+++ b/tests/external_module_dirs/external_modules/external_module_not_used/this_should_not_compile.c
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 Otto-von-Guericke-Universität Magdeburg
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       Test the EXTERNAL_MODULE_DIRS feature
+ * @note        Define a shared variable
+ *
+ * @author      Marian Buschsieweke <marian.buschsieweke@ovgu.de>
+ *
+ * @}
+ */
+
+#error "This is should not be compiled"
+
+typedef int dont_be_pedantic;
diff --git a/tests/gnrc_dhcpv6_client_6lbr/tests-as-root/01-run.py b/tests/gnrc_dhcpv6_client_6lbr/tests-as-root/01-run.py
index 28e85b9087..a4b3015321 100755
--- a/tests/gnrc_dhcpv6_client_6lbr/tests-as-root/01-run.py
+++ b/tests/gnrc_dhcpv6_client_6lbr/tests-as-root/01-run.py
@@ -14,19 +14,23 @@ import time
 
 from scapy.all import AsyncSniffer, sendp, Ether, IPv6, UDP
 from scapy.all import DHCP6_Solicit, DHCP6_Advertise, DHCP6_Request, DHCP6_Reply
-from scapy.all import DHCP6OptClientId, DHCP6OptServerId, DHCP6OptIA_PD, DHCP6OptUnknown
+from scapy.all import DHCP6OptClientId, DHCP6OptServerId, DHCP6OptIA_PD
 from scapy.all import DUID_LL, DHCP6OptIAPrefix
 from testrunner import run
 
+try:
+    from scapy.all import DHCP6OptMudUrl
+    mud_option_loaded = True
+except ImportError:
+    from scapy.all import DHCP6OptUnknown
+    DHCP6OptMudUrl = DHCP6OptUnknown
+    mud_option_loaded = False
 
 TIMEOUT = 1
 
 MUD_OPTION_CODE = 112
 MUD_TEST_URL = b'https://example.org'
 
-# MUD URL option in DHCPv6 is not yet supported by scapy
-DHCP6OptMUD = DHCP6OptUnknown
-
 
 def get_upstream_netif(child):
     child.sendline("ifconfig")
@@ -161,11 +165,15 @@ def testfunc(child):
     # and is still asking for a prefix delegation
     assert DHCP6OptIA_PD in pkt
 
-    assert DHCP6OptMUD in pkt
-    mud_option = pkt[DHCP6OptMUD]
-    assert mud_option.optcode == 112
+    assert DHCP6OptMudUrl in pkt
+    mud_option = pkt[DHCP6OptMudUrl]
     assert mud_option.optlen == len(MUD_TEST_URL)
-    assert mud_option.data == MUD_TEST_URL
+
+    if mud_option_loaded:
+        assert mud_option.mudstring == MUD_TEST_URL
+    else:
+        assert mud_option.optcode == MUD_OPTION_CODE
+        assert mud_option.data == MUD_TEST_URL
 
     # reply to request with reply and a prefix provided
     trid = pkt[DHCP6_Request].trid
diff --git a/tests/gnrc_sixlowpan_frag_minfwd/Makefile.ci b/tests/gnrc_sixlowpan_frag_minfwd/Makefile.ci
index 630b8e80a9..6d8650893c 100644
--- a/tests/gnrc_sixlowpan_frag_minfwd/Makefile.ci
+++ b/tests/gnrc_sixlowpan_frag_minfwd/Makefile.ci
@@ -19,6 +19,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     microduino-corerf \
     msb-430 \
     msb-430h \
+    nucleo-f302r8 \
     nucleo-f030r8 \
     nucleo-f031k6 \
     nucleo-f042k6 \
@@ -37,6 +38,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     stm32f030f4-demo \
     stm32f0discovery \
     stm32l0538-disco \
+    stm32mp157c-dk2 \
     telosb \
     waspmote-pro \
     z1 \
diff --git a/tests/ieee802154_hal/main.c b/tests/ieee802154_hal/main.c
index a3bf2be2c7..18a9b8bcb3 100644
--- a/tests/ieee802154_hal/main.c
+++ b/tests/ieee802154_hal/main.c
@@ -48,7 +48,6 @@ static xtimer_t timer_ack;
 static mutex_t lock;
 
 static const char *str_states[3]= {"TRX_OFF", "RX", "TX"};
-static ieee802154_rx_mode_t current_rx_mode;
 static eui64_t ext_addr;
 static network_uint16_t short_addr;
 static uint8_t seq;
@@ -86,7 +85,7 @@ static void _ack_timeout(event_t *event)
     (void) event;
     ieee802154_dev_t *dev = ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID);
 
-    ieee802154_radio_set_rx_mode(dev, current_rx_mode);
+    ieee802154_radio_set_frame_filter_mode(dev, IEEE802154_FILTER_ACCEPT);
 }
 
 static event_t _ack_timeout_ev = {
@@ -217,8 +216,8 @@ static void _send(iolist_t *pkt)
     while(ieee802154_radio_confirm_set_trx_state(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID)) == -EAGAIN);
 
     /* Trigger the transmit and wait for the mutex unlock (TX_DONE event) */
+    ieee802154_radio_set_frame_filter_mode(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), IEEE802154_FILTER_ACK_ONLY);
     ieee802154_radio_request_transmit(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID));
-    ieee802154_radio_set_rx_mode(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), IEEE802154_RX_WAIT_FOR_ACK);
     mutex_lock(&lock);
 
     event_post(EVENT_PRIO_HIGHEST, &_tx_finish_ev);
@@ -241,12 +240,16 @@ static int _init(void)
     ieee802154_radio_request_on(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID));
     while(ieee802154_radio_confirm_on(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID)) == -EAGAIN) {}
 
-    current_rx_mode = IEEE802154_RX_AACK_ENABLED;
-    ieee802154_radio_set_rx_mode(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), current_rx_mode);
+    ieee802154_radio_set_frame_filter_mode(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), IEEE802154_FILTER_ACCEPT);
 
     uint16_t panid = CONFIG_IEEE802154_DEFAULT_PANID;
     /* Set all IEEE addresses */
-    ieee802154_radio_set_hw_addr_filter(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), &short_addr, &ext_addr, &panid);
+    ieee802154_radio_config_addr_filter(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID),
+                                        IEEE802154_AF_SHORT_ADDR, &short_addr);
+    ieee802154_radio_config_addr_filter(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID),
+                                        IEEE802154_AF_EXT_ADDR, &ext_addr);
+    ieee802154_radio_config_addr_filter(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID),
+                                        IEEE802154_AF_PANID, &panid);
 
     /* Set PHY configuration */
     ieee802154_phy_conf_t conf = {.channel=CONFIG_IEEE802154_DEFAULT_CHANNEL, .page=CONFIG_IEEE802154_DEFAULT_SUBGHZ_PAGE, .pow=CONFIG_IEEE802154_DEFAULT_TXPOWER};
@@ -457,33 +460,24 @@ int txtsnd(int argc, char **argv)
     return send(addr, res, len);
 }
 
-static int rx_mode_cmd(int argc, char **argv)
+static int promisc(int argc, char **argv)
 {
-    ieee802154_rx_mode_t conf;
+    ieee802154_filter_mode_t conf;
     if (argc < 2) {
-        printf("Usage: %s <on|off|pend|promisc>", argv[0]);
+        printf("Usage: %s <on|off>", argv[0]);
         return 1;
     }
 
-    if (strcmp(argv[1], "pend") == 0) {
-        conf = IEEE802154_RX_AACK_FRAME_PENDING;
-        puts("ACK enabled with Frame Pending");
-    }
-    else if (strcmp(argv[1], "off") == 0) {
-        conf = IEEE802154_RX_AACK_DISABLED;
-        puts("ACK disabled");
-    }
-    else if (strcmp(argv[1], "promisc") == 0) {
-        conf = IEEE802154_RX_PROMISC;
-        puts("Promiscuous mode enabled");
+    if (strcmp(argv[1], "on") == 0) {
+        conf = IEEE802154_FILTER_PROMISC;
+        puts("Enabled promiscuos mode");
     }
     else {
-        conf = IEEE802154_RX_AACK_ENABLED;
-        puts("ACK enabled");
+        conf = IEEE802154_FILTER_ACCEPT;
+        puts("Disabled promiscuos mode");
     }
 
-    current_rx_mode = conf;
-    ieee802154_radio_set_rx_mode(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), conf);
+    ieee802154_radio_set_frame_filter_mode(ieee802154_hal_test_get_dev(RADIO_DEFAULT_ID), conf);
     return 0;
 }
 
@@ -729,7 +723,7 @@ static const shell_command_t shell_commands[] = {
     { "test_states", "Test state changes", _test_states },
     { "cca", "Perform CCA", _cca },
     { "config_cca", "Config CCA parameters", _config_cca_cmd },
-    { "rx_mode", "Enable/Disable AACK or set Frame Pending bit or set promiscuos mode", rx_mode_cmd },
+    { "promisc", "Set promiscuos mode", promisc },
     { "tx_mode", "Enable CSMA-CA, CCA or direct transmission", txmode_cmd },
     { "caps", "Get a list of caps supported by the device", _caps_cmd },
     { NULL, NULL, NULL }
diff --git a/tests/kconfig/Makefile b/tests/kconfig/Makefile
index 349e455e41..5e73126239 100644
--- a/tests/kconfig/Makefile
+++ b/tests/kconfig/Makefile
@@ -2,7 +2,6 @@ include ../Makefile.tests_common
 
 USEMODULE += external_module_1
 USEMODULE += external_module_2
-EXTERNAL_MODULE_DIRS += $(CURDIR)/external_module_1
-EXTERNAL_MODULE_DIRS += $(CURDIR)/external_module_2
+EXTERNAL_MODULE_DIRS += external_modules
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/kconfig/external_module_1/Kconfig b/tests/kconfig/external_modules/external_module_1/Kconfig
similarity index 100%
rename from tests/kconfig/external_module_1/Kconfig
rename to tests/kconfig/external_modules/external_module_1/Kconfig
diff --git a/tests/kconfig/external_module_2/Makefile b/tests/kconfig/external_modules/external_module_1/Makefile
similarity index 100%
rename from tests/kconfig/external_module_2/Makefile
rename to tests/kconfig/external_modules/external_module_1/Makefile
diff --git a/tests/kconfig/external_module_1/Makefile.include b/tests/kconfig/external_modules/external_module_1/Makefile.include
similarity index 100%
rename from tests/kconfig/external_module_1/Makefile.include
rename to tests/kconfig/external_modules/external_module_1/Makefile.include
diff --git a/tests/kconfig/external_module_1/include/external_module_1.h b/tests/kconfig/external_modules/external_module_1/include/external_module_1.h
similarity index 100%
rename from tests/kconfig/external_module_1/include/external_module_1.h
rename to tests/kconfig/external_modules/external_module_1/include/external_module_1.h
diff --git a/tests/kconfig/external_module_2/Kconfig b/tests/kconfig/external_modules/external_module_2/Kconfig
similarity index 100%
rename from tests/kconfig/external_module_2/Kconfig
rename to tests/kconfig/external_modules/external_module_2/Kconfig
diff --git a/tests/pkg_utensor/models/Makefile b/tests/kconfig/external_modules/external_module_2/Makefile
similarity index 100%
rename from tests/pkg_utensor/models/Makefile
rename to tests/kconfig/external_modules/external_module_2/Makefile
diff --git a/tests/kconfig/external_module_2/Makefile.include b/tests/kconfig/external_modules/external_module_2/Makefile.include
similarity index 100%
rename from tests/kconfig/external_module_2/Makefile.include
rename to tests/kconfig/external_modules/external_module_2/Makefile.include
diff --git a/tests/kconfig/external_module_2/include/external_module_2.h b/tests/kconfig/external_modules/external_module_2/include/external_module_2.h
similarity index 100%
rename from tests/kconfig/external_module_2/include/external_module_2.h
rename to tests/kconfig/external_modules/external_module_2/include/external_module_2.h
diff --git a/tests/malloc/main.c b/tests/malloc/main.c
index 67db274ad1..04e9eb44ac 100644
--- a/tests/malloc/main.c
+++ b/tests/malloc/main.c
@@ -24,6 +24,8 @@
 #include <string.h>
 #include <inttypes.h>
 
+#include "test_utils/expect.h"
+
 #ifndef CHUNK_SIZE
 #ifdef BOARD_NATIVE
 #define CHUNK_SIZE          (1024 * 1024U)
@@ -78,10 +80,13 @@ static void free_memory(struct node *head)
 {
     struct node *old_head;
 
+    uint32_t freed = 0;
+
     while (head) {
         if (head->ptr) {
             if (total > CHUNK_SIZE) {
                 total -= CHUNK_SIZE;
+                freed++;
             }
             printf("Free %"PRIu32" Bytes at 0x%p, total %"PRIu32"\n",
                    (uint32_t)CHUNK_SIZE, head->ptr, total);
@@ -100,12 +105,25 @@ static void free_memory(struct node *head)
 
         total -= sizeof(struct node);
     }
+
+    printf("Free count: %"PRIu32"\n", freed);
 }
 
 int main(void)
 {
     uint32_t allocations = 0;
 
+    /* modern compilers warn about nonsense calls to calloc, but this is exactly what we want to
+     * test */
+#pragma GCC diagnostic push
+#if !defined(__clang__) && (__GNUC__ > 6)
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
+#endif
+    /* test if an overflow is correctly detected by calloc(): the size below overflows by 1 byte */
+    /* cppcheck-suppress leakReturnValNotUsed (should return NULL, so nothing to free anyway) */
+    expect(NULL == calloc(SIZE_MAX / 16 + 1, 16));
+#pragma GCC diagnostic pop
+
     printf("CHUNK_SIZE: %"PRIu32"\n", (uint32_t)CHUNK_SIZE);
     printf("NUMBER_OF_TESTS: %d\n", NUMBER_OF_TESTS);
 
diff --git a/tests/malloc/tests/01-run.py b/tests/malloc/tests/01-run.py
index fea0d3c031..a29812b9da 100755
--- a/tests/malloc/tests/01-run.py
+++ b/tests/malloc/tests/01-run.py
@@ -12,6 +12,7 @@ from testrunner import run
 # For BOARD's with large amount of RAM allocating all chunks takes longer
 # than 10s
 ALLOCATION_TIMEOUT = 20
+FREE_TIMEOUT = ALLOCATION_TIMEOUT
 
 
 def testfunc(child):
@@ -30,9 +31,11 @@ def testfunc(child):
         if initial_allocations == 0:
             initial_allocations = allocations
         assert initial_allocations == allocations
-        for _ in range(allocations):
-            child.expect(r"Free {} Bytes at 0x[a-z0-9]+, total [a-z0-9]+\r\n"
-                         .format(chunk_size))
+        child.expect(r"Free {} Bytes at 0x[a-z0-9]+, total [a-z0-9]+\r\n"
+                     .format(chunk_size))
+        child.expect(r'Free count: (\d+)\r\n', timeout=FREE_TIMEOUT)
+        freed = int(child.match.group(1))
+        assert freed == allocations
     child.expect_exact("[SUCCESS]")
 
 
diff --git a/tests/msg_queue_print/Makefile b/tests/msg_queue_print/Makefile
new file mode 100644
index 0000000000..24bb481657
--- /dev/null
+++ b/tests/msg_queue_print/Makefile
@@ -0,0 +1,3 @@
+include ../Makefile.tests_common
+
+include $(RIOTBASE)/Makefile.include
diff --git a/tests/msg_queue_print/main.c b/tests/msg_queue_print/main.c
new file mode 100644
index 0000000000..0a2523471b
--- /dev/null
+++ b/tests/msg_queue_print/main.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin,
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       testing msg_queue_print
+ *
+ *
+ * @author      Julian Holzwarth <julian.holzwarth@fu-berlin.de>
+ *
+ */
+
+#include <stdio.h>
+#include <inttypes.h>
+
+#include "msg.h"
+
+#define QUEUE_SIZE 8
+
+msg_t msg_queue[QUEUE_SIZE];
+
+int main(void)
+{
+    msg_t messages[QUEUE_SIZE];
+
+    msg_queue_print();
+    msg_init_queue(msg_queue, QUEUE_SIZE);
+    msg_queue_print();
+
+    for (int i = 0; i < QUEUE_SIZE; i++) {
+        messages[i].type = i;
+        messages[i].content.value = i;
+        msg_send_to_self(&messages[i]);
+    }
+
+    msg_queue_print();
+    puts("DONE");
+    return 0;
+}
diff --git a/tests/msg_queue_print/tests/01-run.py b/tests/msg_queue_print/tests/01-run.py
new file mode 100755
index 0000000000..bc1ce91703
--- /dev/null
+++ b/tests/msg_queue_print/tests/01-run.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+#  Copyright (C) 2021 Freie Universität Berlin,
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+# @author      Julian Holzwarth <julian.holzwarth@fu-berlin.de>
+
+import os
+import sys
+from testrunner import run
+
+
+def testfunc(child):
+    child.expect("No message queue")
+    child.expect(r"Message queue of thread \d+\r\n")
+    child.expect_exact('size: 8 (avail: 0)')
+    child.expect(r"Message queue of thread \d+\r\n")
+    child.expect_exact('size: 8 (avail: 8)')
+    if os.environ.get('BOARD') == 'native':
+        child.expect_exact('type: 0x0000, content: 0 ((nil))')
+    else:
+        child.expect(r'type: 0x0000, content: 0 \((0x)?0+\)')
+    child.expect_exact('type: 0x0001, content: 1 (0x1)')
+    child.expect_exact('type: 0x0002, content: 2 (0x2)')
+    child.expect_exact('type: 0x0003, content: 3 (0x3)')
+    child.expect_exact('type: 0x0004, content: 4 (0x4)')
+    child.expect_exact('type: 0x0005, content: 5 (0x5)')
+    child.expect_exact('type: 0x0006, content: 6 (0x6)')
+    child.expect_exact('type: 0x0007, content: 7 (0x7)')
+    child.expect_exact('DONE')
+
+
+if __name__ == "__main__":
+    sys.exit(run(testfunc))
diff --git a/tests/nimble_l2cap_server/nimble.inc.mk b/tests/nimble_l2cap_server/nimble.inc.mk
index 6c3b98b3f0..ec1a7e5cd9 100644
--- a/tests/nimble_l2cap_server/nimble.inc.mk
+++ b/tests/nimble_l2cap_server/nimble.inc.mk
@@ -26,11 +26,21 @@ CFLAGS += -DAPP_CID=$(APP_CID)
 # configure NimBLE
 USEPKG += nimble
 MSYS_CNT ?= 40
-CFLAGS += -DMYNEWT_VAL_BLE_L2CAP_COC_MAX_NUM=1
-CFLAGS += -DMYNEWT_VAL_BLE_L2CAP_COC_MPS=250
+# For this test we use the controllers link layer data length extension
+CFLAGS += -DMYNEWT_VAL_BLE_LL_CFG_FEAT_DATA_LEN_EXT=1
+CFLAGS += -DMYNEWT_VAL_BLE_LL_MAX_PKT_SIZE=251
+# Enable L2CAP connection oriented channels, 1 is sufficient for this test
 CFLAGS += -DMYNEWT_VAL_BLE_MAX_CONNECTIONS=1
+CFLAGS += -DMYNEWT_VAL_BLE_L2CAP_COC_MAX_NUM=1
+# For maximum efficiency, we set the maximum L2CAP fragment size to the same
+# value as the maximum link layer packet size.
+# WARNING: this value MUST never be larger than MYNEWT_VAL_BLE_LL_MAX_PKT_SIZE
+CFLAGS += -DMYNEWT_VAL_BLE_L2CAP_COC_MPS=MYNEWT_VAL_BLE_LL_MAX_PKT_SIZE
+# To be able to handle large packets, we must increase the default packet buffer
+# used by NimBLE.
+# In order to store a full L2CAP fragment/link layer packet in a single block,
+# we need to cater for a 48 byte overhead per block.
 CFLAGS += -DMYNEWT_VAL_MSYS_1_BLOCK_COUNT=$(MSYS_CNT)
-CFLAGS += -DMYNEWT_VAL_MSYS_1_BLOCK_SIZE=298
-CFLAGS += -DMYNEWT_VAL_BLE_LL_CFG_FEAT_DATA_LEN_EXT=1
+CFLAGS += -DMYNEWT_VAL_MSYS_1_BLOCK_SIZE="(MYNEWT_VAL_BLE_L2CAP_COC_MPS + 48)"
 
 INCLUDES += -I$(RIOTBASE)/tests/nimble_l2cap_server/include
diff --git a/tests/periph_flashpage/main.c b/tests/periph_flashpage/main.c
index 27eb769483..b00d67afc4 100644
--- a/tests/periph_flashpage/main.c
+++ b/tests/periph_flashpage/main.c
@@ -40,10 +40,18 @@
 
 /* When writing raw bytes on flash, data must be correctly aligned. */
 #define ALIGNMENT_ATTR __attribute__((aligned(FLASHPAGE_WRITE_BLOCK_ALIGNMENT)))
+
+/* We must not write chunks smaller than FLASHPAGE_WRITE_BLOCK_SIZE */
+#if FLASHPAGE_WRITE_BLOCK_SIZE > 64
+#define RAW_BUF_SIZE FLASHPAGE_WRITE_BLOCK_SIZE
+#else
+#define RAW_BUF_SIZE 64
+#endif
+
 /*
  * @brief   Allocate an aligned buffer for raw writings
  */
-static char raw_buf[64] ALIGNMENT_ATTR;
+static char raw_buf[RAW_BUF_SIZE] ALIGNMENT_ATTR;
 
 #ifdef MODULE_PERIPH_FLASHPAGE_PAGEWISE
 /**
@@ -373,6 +381,8 @@ static int cmd_test_last_raw(int argc, char **argv)
     (void) argc;
     (void) argv;
 
+    memset(raw_buf, 0, sizeof(raw_buf));
+
     /* try to align */
     memcpy(raw_buf, "test12344321tset", 16);
 #if defined(CPU_CC430) || defined(CPU_MSP430FXYZ)
@@ -382,7 +392,7 @@ static int cmd_test_last_raw(int argc, char **argv)
     /* erase the page first */
     flashpage_erase(TEST_LAST_AVAILABLE_PAGE);
 
-    flashpage_write(flashpage_addr(TEST_LAST_AVAILABLE_PAGE), raw_buf, strlen(raw_buf));
+    flashpage_write(flashpage_addr(TEST_LAST_AVAILABLE_PAGE), raw_buf, sizeof(raw_buf));
 
     /* verify that previous write_raw effectively wrote the desired data */
     if (memcmp(flashpage_addr(TEST_LAST_AVAILABLE_PAGE), raw_buf, strlen(raw_buf)) != 0) {
diff --git a/tests/periph_gpio_arduino/app.config.test b/tests/periph_gpio_arduino/app.config.test
index 8aa13b683f..7b56244a34 100644
--- a/tests/periph_gpio_arduino/app.config.test
+++ b/tests/periph_gpio_arduino/app.config.test
@@ -3,4 +3,3 @@
 CONFIG_MODULE_PERIPH_GPIO=y
 CONFIG_MODULE_SHELL=y
 CONFIG_MODULE_ARDUINO=y
-CONFIG_MODULE_XTIMER=y
diff --git a/tests/periph_rtc/Makefile b/tests/periph_rtc/Makefile
index e549720ff4..3d33287f19 100644
--- a/tests/periph_rtc/Makefile
+++ b/tests/periph_rtc/Makefile
@@ -1,6 +1,7 @@
 include ../Makefile.tests_common
 
-FEATURES_REQUIRED = periph_rtc
+FEATURES_REQUIRED += periph_rtc
+FEATURES_OPTIONAL += periph_rtc_ms
 
 DISABLE_MODULE += periph_init_rtc
 
diff --git a/tests/periph_rtc/main.c b/tests/periph_rtc/main.c
index 09c4c41999..db798a6fd0 100644
--- a/tests/periph_rtc/main.c
+++ b/tests/periph_rtc/main.c
@@ -47,6 +47,18 @@ static void print_time(const char *label, const struct tm *time)
             time->tm_sec);
 }
 
+static void print_time_ms(const char *label, const struct tm *time, uint16_t ms)
+{
+    printf("%s  %04d-%02d-%02d %02d:%02d:%02d.%03d\n", label,
+            time->tm_year + TM_YEAR_OFFSET,
+            time->tm_mon + 1,
+            time->tm_mday,
+            time->tm_hour,
+            time->tm_min,
+            time->tm_sec,
+            ms);
+}
+
 static void inc_secs(struct tm *time, unsigned val)
 {
     time->tm_sec += val;
@@ -81,8 +93,14 @@ int main(void)
     rtc_set_time(&time);
 
     /* read RTC to confirm value */
-    rtc_get_time(&time);
-    print_time("Clock value is now ", &time);
+    if (IS_USED(MODULE_PERIPH_RTC_MS)) {
+        uint16_t ms;
+        rtc_get_time_ms(&time, &ms);
+        print_time_ms("Clock value is now ", &time, ms);
+    } else {
+        rtc_get_time(&time);
+        print_time("Clock value is now ", &time);
+    }
 
     /* set initial alarm */
     inc_secs(&time, PERIOD);
@@ -95,17 +113,32 @@ int main(void)
 
     /* clear alarm */
     rtc_clear_alarm();
-    rtc_get_time(&time);
-    print_time("  Alarm cleared at ", &time);
+    if (IS_USED(MODULE_PERIPH_RTC_MS)) {
+        uint16_t ms;
+        rtc_get_time_ms(&time, &ms);
+        print_time_ms("  Alarm cleared at ", &time, ms);
+    } else {
+        rtc_get_time(&time);
+        print_time("  Alarm cleared at ", &time);
+    }
 
     /* verify alarm has been cleared */
     xtimer_sleep(PERIOD);
-    rtc_get_time(&time);
+
+    const char *message;
     if (mutex_trylock(&rtc_mtx)) {
-        print_time("   Error: Alarm at ", &time);
+        message = "   Error: Alarm at ";
+    } else {
+        message = "       No alarm at ";
     }
-    else {
-        print_time("       No alarm at ", &time);
+
+    if (IS_USED(MODULE_PERIPH_RTC_MS)) {
+        uint16_t ms;
+        rtc_get_time_ms(&time, &ms);
+        print_time_ms(message, &time, ms);
+    } else {
+        rtc_get_time(&time);
+        print_time(message, &time);
     }
 
     /* set alarm */
diff --git a/tests/periph_rtt/Makefile b/tests/periph_rtt/Makefile
index 72bb287f2b..5c70de4683 100644
--- a/tests/periph_rtt/Makefile
+++ b/tests/periph_rtt/Makefile
@@ -9,7 +9,7 @@ DISABLE_MODULE += periph_init_rtt
 include $(RIOTBASE)/Makefile.include
 
 # Put board specific dependencies here
-ifeq (stm32,$(CPU))
+ifneq (,$(filter stm32 kinetis,$(CPU)))
   ifneq (f1,$(CPU_FAM))
     # all stm32% but stm32f1 RTT are based on a 16 bit LPTIM, if using the default
     # 32768KHz configuration TICKS_TO_WAIT will overflow
diff --git a/tests/pkg_cryptoauthlib_internal-tests/Makefile.ci b/tests/pkg_cryptoauthlib_internal-tests/Makefile.ci
index 965a0b66a5..b88784ce41 100644
--- a/tests/pkg_cryptoauthlib_internal-tests/Makefile.ci
+++ b/tests/pkg_cryptoauthlib_internal-tests/Makefile.ci
@@ -8,6 +8,8 @@ BOARD_INSUFFICIENT_MEMORY := \
     atmega256rfr2-xpro \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
     avr-rss2 \
     blackpill \
     bluepill \
diff --git a/tests/pkg_edhoc_c/Makefile b/tests/pkg_edhoc_c/Makefile
new file mode 100644
index 0000000000..760b57c07f
--- /dev/null
+++ b/tests/pkg_edhoc_c/Makefile
@@ -0,0 +1,39 @@
+include ../Makefile.tests_common
+
+# Edhoc related packages
+USEPKG += edhoc-c
+USEMODULE += edhoc-c_crypto_tinycrypt
+# USEMODULE += edhoc-c_crypto_wolfssl
+USEMODULE += edhoc-c_cbor_nanocbor
+
+# Include packages that pull up and auto-init the link layer.
+# NOTE: 6LoWPAN will be included if IEEE802.15.4 devices are present
+USEMODULE += gnrc_netdev_default
+
+USEMODULE += auto_init_gnrc_netif
+# Specify the mandatory networking modules for IPv6 and UDP
+USEMODULE += gnrc_ipv6_router_default
+USEMODULE += sock_udp
+# Additional networking modules that can be dropped if not needed
+USEMODULE += gnrc_icmpv6_echo
+USEMODULE += nanocoap_sock
+
+# include this for printing IP addresses
+USEMODULE += shell
+USEMODULE += shell_commands
+USEMODULE += ps
+USEMODULE += xtimer
+
+# This is an optimized stack value based on testing, if you observe
+# a segmentation fault please increase this stack size.
+CFLAGS += -DTHREAD_STACKSIZE_MAIN=3*THREAD_STACKSIZE_LARGE
+
+# Include responder code
+CONFIG_INITIATOR ?= 1
+CFLAGS += -DCONFIG_INITIATOR=$(CONFIG_INITIATOR)
+# Include responder code
+CONFIG_RESPONDER ?= 1
+CFLAGS += -DCONFIG_RESPONDER=$(CONFIG_RESPONDER)
+
+include $(RIOTBASE)/Makefile.include
+include $(RIOTMAKE)/default-radio-settings.inc.mk
diff --git a/tests/pkg_edhoc_c/Makefile.ci b/tests/pkg_edhoc_c/Makefile.ci
new file mode 100644
index 0000000000..9ac65fe348
--- /dev/null
+++ b/tests/pkg_edhoc_c/Makefile.ci
@@ -0,0 +1,51 @@
+BOARD_INSUFFICIENT_MEMORY := \
+    airfy-beacon \
+    b-l072z-lrwan1 \
+    blackpill \
+    blackpill-128kib \
+    bluepill \
+    bluepill-128kib \
+    bluepill-stm32f030c8 \
+    calliope-mini \
+    cc1350-launchpad \
+    cc2650-launchpad \
+    cc2650stk \
+    e104-bt5010a-tb \
+    e104-bt5011a-tb \
+    hifive1 \
+    hifive1b \
+    i-nucleo-lrwan1 \
+    im880b \
+    lsn50 \
+    maple-mini \
+    microbit \
+    nrf51dk \
+    nrf51dongle \
+    nrf6310 \
+    nucleo-f030r8 \
+    nucleo-f031k6 \
+    nucleo-f042k6 \
+    nucleo-f070rb \
+    nucleo-f072rb \
+    nucleo-f103rb \
+    nucleo-f302r8 \
+    nucleo-f303k8 \
+    nucleo-f334r8 \
+    nucleo-l011k4 \
+    nucleo-l031k6 \
+    nucleo-l053r8 \
+    nucleo-l073rz \
+    olimexino-stm32 \
+    opencm904 \
+    samd10-xmini \
+    saml10-xpro \
+    saml11-xpro \
+    slstk3400a \
+    spark-core \
+    stk3200 \
+    stm32f030f4-demo \
+    stm32f0discovery \
+    stm32l0538-disco \
+    stm32mp157c-dk2 \
+    yunjia-nrf51822 \
+    #
diff --git a/tests/pkg_edhoc_c/README.md b/tests/pkg_edhoc_c/README.md
new file mode 100644
index 0000000000..cf5aec6f2c
--- /dev/null
+++ b/tests/pkg_edhoc_c/README.md
@@ -0,0 +1,418 @@
+# EDHOC-C test application
+
+This test application sets up a RIOT node that can run as an EDHOC handshake
+initiator and/or responder. The handshake can be run between two RIOT nodes or
+between a RIOT node and a Linux host or for testing purposes the node can
+perform an auto-handshake.
+
+In this example credentials based on LAKE IETF WG are used. These are RPK keys.
+Normally different credentials should be used depending on the authentication
+method, but currently no validation is done so the same credentials can be
+used for any method.
+
+## EDHOC handshake between host and RIOT node
+
+### Pre-requisites
+
+- install [py-edhoc](https://github.com/openwsn-berkeley/py-edhoc):
+
+```
+$ pip install edhoc
+```
+
+This will install two cli utils `edhoc-responder` and `edhoc-initiator` to
+facilitate testing.
+
+#### `native`
+
+- if using native set up a tap interface:
+
+```
+$ sudo ip tuntap add tap0 mode tap user ${USER}
+$ sudo ip link set tap0 up
+```
+
+#### physical `BOARD`
+
+- If using any other (non-emulated) `BOARD` then in one terminal:
+
+```
+ $ sudo dist/tools/ethos/setup_network.sh riot0 2001:db8::/64
+```
+
+This will create a tap interface called `riot0`, owned by the user. It will
+also run an instance of uhcpcd, which starts serving the prefix
+`2001:db8::/64`. Keep the shell open as long as you need the network.
+Make sure to exit the "make term" instance from the next section *before*
+exiting this, as otherwise the "riot0" interface doesn't get cleaned up
+properly.
+
+### Responder
+
+Find out the ipv6 address of the device is by running the `ifconfig`
+command in the shell.
+
+```
+ifconfig
+Starting the shell
+> ifconfig
+ifconfig
+Iface  5  HWaddr: 0A:94:29:80:74:23
+          L2-PDU:1500  MTU:1500  HL:64  RTR
+          RTR_ADV
+          Source address length: 6
+          Link type: wired
+          inet6 addr: fe80::894:29ff:fe80:7423  scope: link  VAL
+          inet6 group: ff02::2
+          inet6 group: ff02::1
+          inet6 group: ff02::1:ff80:7423
+```
+
+In this case its `fe80::894:29ff:fe80:7423` and since we setup `tap0` as
+the tap interface the device is reachable at `[fe80::894:29ff:fe80:7423%tap0]`.
+
+Initiate the handshake by running the `edhoc-initiator` cli tool:
+
+```
+$ edhoc-initiator  fe80::894:29ff:fe80:7423%tap0]
+INFO:root:POST (EdhocState.MSG_1_SENT)  b'\x01\x00X \x89\x8f\xf7\x9a\x02\x06z\x16\xea\x1e\xcc\xb9\x0f\xa5"F\xf5\xaaM\xd6\xec\x07k\xba\x02Y\xd9\x04\xb7\xec\x8b\x0c@'
+INFO:root:CHANGED (EdhocState.MSG_1_SENT)  b'X q\xa3\xd5\x99\xc2\x1d\xa1\x89\x02\xa1\xae\xa8\x10\xb2\xb68,\xcd\x8d_\x9b\xf0\x19R\x81uL^\xbc\xaf0\x1e\x13XP\x99\xd58\x01\xa7%\xbf\xd6\xa4\xe7\x1d\x04\x84\xb7U\xec8=\xf7z\x91n\xc0\xdb\xc0+\xba|!\xa2\x00\x80{OX_r\x8bg\x1a\xd6x\xa4:\xac\xd3;x\xeb\xd5f\xcd\x00O\xc6\xf1\xd4\x06\xf0\x1d\x97\x04\xe7\x05\xb2\x15R\xa9\xeb(\xea1j\xb6P7\xd7\x17\x86.'
+INFO:root:POST (EdhocState.MSG_3_SENT)  b'\x01\x00X \x89\x8f\xf7\x9a\x02\x06z\x16\xea\x1e\xcc\xb9\x0f\xa5"F\xf5\xaaM\xd6\xec\x07k\xba\x02Y\xd9\x04\xb7\xec\x8b\x0c@'
+INFO:root:EDHOC key exchange successfully completed:
+INFO:root: - connection IDr: b'+'
+INFO:root: - connection IDi: b''
+INFO:root: - aead algorithm: AES_CCM_16_64_128
+INFO:root: - hash algorithm: SHA_256
+INFO:root: - OSCORE secret : b'Y!1k\xae\x12\xc9\xc4\xd2\xb9\xfb \xcc\x1a\x12\xdd'
+INFO:root: - OSCORE salt   : b'\xad\xf9\xfd\xbed\x98\xa3\x02'
+```
+
+And on the device (responder):
+
+```
+> [responder]: received an EDHOC message (len 37)
+0x01 0x00 0x58 0x20 0x89 0x8f 0xf7 0x9a
+0x02 0x06 0x7a 0x16 0xea 0x1e 0xcc 0xb9
+0x0f 0xa5 0x22 0x46 0xf5 0xaa 0x4d 0xd6
+0xec 0x07 0x6b 0xba 0x02 0x59 0xd9 0x04
+0xb7 0xec 0x8b 0x0c 0x40
+
+[responder]: sending msg2 (117 bytes)
+0x58 0x20 0x71 0xa3 0xd5 0x99 0xc2 0x1d
+0xa1 0x89 0x02 0xa1 0xae 0xa8 0x10 0xb2
+0xb6 0x38 0x2c 0xcd 0x8d 0x5f 0x9b 0xf0
+0x19 0x52 0x81 0x75 0x4c 0x5e 0xbc 0xaf
+0x30 0x1e 0x13 0x58 0x50 0x99 0xd5 0x38
+0x01 0xa7 0x25 0xbf 0xd6 0xa4 0xe7 0x1d
+0x04 0x84 0xb7 0x55 0xec 0x38 0x3d 0xf7
+0x7a 0x91 0x6e 0xc0 0xdb 0xc0 0x2b 0xba
+0x7c 0x21 0xa2 0x00 0x80 0x7b 0x4f 0x58
+0x5f 0x72 0x8b 0x67 0x1a 0xd6 0x78 0xa4
+0x3a 0xac 0xd3 0x3b 0x78 0xeb 0xd5 0x66
+0xcd 0x00 0x4f 0xc6 0xf1 0xd4 0x06 0xf0
+0x1d 0x97 0x04 0xe7 0x05 0xb2 0x15 0x52
+0xa9 0xeb 0x28 0xea 0x31 0x6a 0xb6 0x50
+0x37 0xd7 0x17 0x86 0x2e
+
+[responder]: received an EDHOC message (len 91)
+0x13 0x58 0x58 0x2d 0x88 0xff 0x86 0xda
+0x47 0x48 0x2c 0x0d 0xfa 0x55 0x9a 0xc8
+0x24 0xa4 0xa7 0x83 0xd8 0x70 0xc9 0xdb
+0xa4 0x78 0x05 0xe8 0xaa 0xfb 0xad 0x69
+0x74 0xc4 0x96 0x46 0x58 0x65 0x03 0xfa
+0x9b 0xbf 0x3e 0x00 0x01 0x2c 0x03 0x7e
+0xaf 0x56 0xe4 0x5e 0x30 0x19 0x20 0x83
+0x9b 0x81 0x3a 0x53 0xf6 0xd4 0xc5 0x57
+0x48 0x0f 0x6c 0x79 0x7d 0x5b 0x76 0xf0
+0xe4 0x62 0xf5 0xf5 0x7a 0x3d 0xb6 0xd2
+0xb5 0x0c 0x32 0x31 0x9f 0x34 0x0f 0x4a
+0xc5 0xaf 0x9a
+
+[responder]: finalize exchange
+[responder]: handshake successfully completed
+```
+
+### Initiator
+
+First find out the local ipv6 address of the tap interface:
+
+```
+ifconfig tap0
+tap0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
+        inet6 fe80::894:29ff:fe80:7422  prefixlen 64  scopeid 0x20<link>
+        ether 0a:94:29:80:74:22  txqueuelen 1000  (Ethernet)
+        RX packets 68  bytes 5962 (5.9 KB)
+        RX errors 0  dropped 0  overruns 0  frame 0
+        TX packets 542  bytes 55480 (55.4 KB)
+        TX errors 0  dropped 1 overruns 0  carrier 0  collisions 0
+```
+
+In this case its `fe80::894:29ff:fe80:7422`. Next start the `py-edhoc`
+based responder.
+
+```
+$ edhoc-reponder
+INFO:root:Booting CoAP server
+INFO:root:Initializing 'core' resource
+INFO:root:Initializing 'edhoc' resource
+```
+
+Now from the RIOT shell initiate the handshake:
+
+```
+Starting the shell
+> ini handshake fe80::894:29ff:fe80:7422 5683
+init handshake fe80::894:29ff:fe80:7422 5683
+[initiator]: sending message (37 bytes)
+0x01 0x00 0x58 0x20 0x71 0xa3 0xd5 0x99
+0xc2 0x1d 0xa1 0x89 0x02 0xa1 0xae 0xa8
+0x10 0xb2 0xb6 0x38 0x2c 0xcd 0x8d 0x5f
+0x9b 0xf0 0x19 0x52 0x81 0x75 0x4c 0x5e
+0xbc 0xaf 0x30 0x1e 0x13
+
+[initiator]: send 37 bytes to fe80::894:29ff:fe80:7422 on port 5683
+
+[initiator]: received a message (124 bytes):
+0x58 0x20 0x71 0xa3 0xd5 0x99 0xc2 0x1d
+0xa1 0x89 0x02 0xa1 0xae 0xa8 0x10 0xb2
+0xb6 0x38 0x2c 0xcd 0x8d 0x5f 0x9b 0xf0
+0x19 0x52 0x81 0x75 0x4c 0x5e 0xbc 0xaf
+0x30 0x1e 0x13 0x58 0x50 0x99 0xe1 0x3b
+0xa4 0x65 0x44 0x44 0xe8 0xb6 0xd4 0x04
+0x01 0x1e 0x01 0xa3 0x29 0xa3 0x26 0x05
+0x45 0x99 0x33 0x95 0xf9 0x34 0x2b 0x43
+0xa7 0x54 0xf9 0xe1 0x8b 0x0f 0xdc 0x46
+0xc2 0xcc 0x4e 0x25 0x24 0x77 0xe0 0x83
+0x52 0x0b 0xf4 0x36 0x74 0x53 0xb6 0x2b
+0xbf 0x3e 0x14 0xb7 0xb0 0xea 0x0e 0xee
+0x84 0xc5 0x5b 0x9e 0x64 0xfc 0x03 0x97
+0xc0 0x45 0x18 0x6d 0x14 0xdb 0x88 0x8c
+0x73 0x2f 0x95 0x52 0xf5 0x68 0xd1 0x61
+0x56 0x6c 0xd1 0x61
+
+[initiator]: sending message (91 bytes)
+0x13 0x58 0x58 0x49 0x7a 0x3e 0x46 0xac
+0xa1 0x36 0xbf 0xff 0xb9 0x5c 0x00 0x46
+0x89 0x69 0x68 0x4a 0xe8 0x2d 0x83 0xf0
+0xe5 0xc5 0xe3 0x3f 0x8f 0x17 0xdf 0x7c
+0x72 0xe1 0xf2 0x9e 0x7a 0x2a 0xe8 0x88
+0x75 0x16 0xd2 0x6a 0xe3 0xa7 0x73 0x76
+0xe8 0xe5 0x22 0x14 0x43 0x6d 0xb0 0x37
+0xb8 0x48 0x31 0xf3 0xa9 0xb3 0xfc 0x82
+0x9c 0x4a 0x92 0x19 0x2c 0x3e 0x4a 0xfe
+0x42 0x6c 0x11 0x39 0x6c 0x48 0x48 0x06
+0x6b 0xf0 0xed 0x2e 0xff 0x16 0x91 0x08
+0xf4 0xee 0x6e
+
+[initiator]: send 91 bytes to fe80::894:29ff:fe80:7422 on port 5683
+
+[initiator]: handshake successfully completed
+```
+
+And on the `edhoc-responder`:
+
+```
+INFO:root:CHANGED (EdhocState.MSG_2_SENT)  b'X q\xa3\xd5\x99\xc2\x1d\xa1\x89\x02\xa1\xae\xa8\x10\xb2\xb68,\xcd\x8d_\x9b\xf0\x19R\x81uL^\xbc\xaf0\x1e\x13XP\x99\xe1;\xa4eDD\xe8\xb6\xd4\x04\x01\x1e\x01\xa3)\xa3&\x05E\x993\x95\xf94+C\xa7T\xf9\xe1\x8b\x0f\xdcF\xc2\xccN%$w\xe0\x83R\x0b\xf46tS\xb6+\xbf>\x14\xb7\xb0\xea\x0e\xee\x84\xc5[\x9ed\xfc\x03\x97\xc0E\x18m\x14\xdb\x88\x8cs/\x95R\xf5'
+INFO:root:POST (EdhocState.MSG_2_SENT)  b'\x13XXIz>F\xac\xa16\xbf\xff\xb9\\\x00F\x89ihJ\xe8-\x83\xf0\xe5\xc5\xe3?\x8f\x17\xdf|r\xe1\xf2\x9ez*\xe8\x88u\x16\xd2j\xe3\xa7sv\xe8\xe5"\x14Cm\xb07\xb8H1\xf3\xa9\xb3\xfc\x82\x9cJ\x92\x19,>J\xfeBl\x119lHH\x06k\xf0\xed.\xff\x16\x91\x08\xf4\xeen'
+INFO:root:EDHOC key exchange successfully completed:
+INFO:root: - connection IDr: b'+'
+INFO:root: - connection IDi: b'+'
+INFO:root: - aead algorithm: AES_CCM_16_64_128
+INFO:root: - hash algorithm: SHA_256
+INFO:root: - OSCORE secret : b'\xd8\x1e\xa3@\xec\xe3?3\xe1\xfe\x8a\x1d\x0c|\xd0\xbe'
+INFO:root: - OSCORE salt   : b'\x87\xf9J\xf7\x82Tq\xa3'
+```
+
+Congratulations you have performed an EDHOC handshake fo your HOST to
+a RIOT node running as the initiator and responder. In all cases you can
+now derive symmetric encryption keys from the shared master secret, in this
+case a shell command `initiator/responder oscore` is available that derives
+keys that could be used for an OSCORE context:
+
+```
+> ini oscore
+init oscore
+OSCORE secret:
+0x43 0x83 0x97 0xe7 0xa8 0x3b 0xd7 0x35
+0xdf 0x0d 0x47 0xdc 0x45 0x44 0xa4 0x63
+
+OSCORE salt:
+0x22 0x3b 0x3c 0xb1 0x03 0xc8 0xa3 0xd0
+```
+
+## EDHOC handshake between two RIOT nodes
+
+### Pre-requisites
+
+#### `native`
+
+- if using `native` `BOARD`'s then create two tap interfaces linked
+through a bridge:
+
+```
+sudo dist/tools/tapsetup/tapsetup -c 2
+```
+
+- bootstrap the `BOARD`s and specify the tap interface to use for each
+
+```
+PORT=tap0 make -C tests/pkg_edhoc_c all term
+PORT=tap1 make -C tests/pkg_edhoc_c all term
+```
+
+#### physical `BOARD`s
+
+- for other `BOARD`s make sure the chosen `BOARD`s has a netdev
+through which they will be able to communicate.
+
+- bootstrap the `BOARD`s
+
+```
+make -C tests/pkg_edhoc_c flash term
+```
+
+### Perform the handshake
+
+One of the devices shall be the initiator and the other one the responder.
+Both are already setup to listen for the first message.
+
+In the shell of the node that will act as the responder identify its ipv6
+address:
+
+```
+Starting the shell
+> ifconfig
+ifconfig
+Iface  5  HWaddr: D6:76:BB:62:F2:AE
+          L2-PDU:1500  MTU:1500  HL:64  RTR
+          RTR_ADV
+          Source address length: 6
+          Link type: wired
+          inet6 addr: fe80::d476:bbff:fe62:f2ae  scope: link  VAL
+          inet6 group: ff02::2
+          inet6 group: ff02::1
+          inet6 group: ff02::1:ff62:f2ae
+```
+
+In this case `fe80::d476:bbff:fe62:f2ae`.
+
+From the initiator now start the handshake:
+
+```
+initiator handshake fe80::d476:bbff:fe62:f2ae 5683
+```
+
+Yo should see the different messages being exchanged on both nodes, and
+now both can derive OSCORE keys as well with the `responder/initiator oscore`
+command:
+
+- initiator:
+
+```
+> ini handshake fe80::d476:bbff:fe62:f2ae 5683
+init handshake fe80::d476:bbff:fe62:f2ae 5683
+[initiator]: sending message (37 bytes)
+0x01 0x00 0x58 0x20 0x71 0xa3 0xd5 0x99
+0xc2 0x1d 0xa1 0x89 0x02 0xa1 0xae 0xa8
+0x10 0xb2 0xb6 0x38 0x2c 0xcd 0x8d 0x5f
+0x9b 0xf0 0x19 0x52 0x81 0x75 0x4c 0x5e
+0xbc 0xaf 0x30 0x1e 0x13
+[initiator]: send 37 bytes to fe80::d476:bbff:fe62:f2ae on port 5683
+
+[initiator]: received a message (126 bytes):
+0x58 0x20 0x71 0xa3 0xd5 0x99 0xc2 0x1d
+0xa1 0x89 0x02 0xa1 0xae 0xa8 0x10 0xb2
+0xb6 0x38 0x2c 0xcd 0x8d 0x5f 0x9b 0xf0
+0x19 0x52 0x81 0x75 0x4c 0x5e 0xbc 0xaf
+0x30 0x1e 0x13 0x58 0x50 0x99 0xe1 0x3b
+0xa4 0x65 0x44 0x44 0xe8 0xb6 0xd4 0x04
+0x01 0x1e 0x01 0xa3 0x29 0xa3 0x26 0x05
+0x45 0x99 0x33 0x95 0xf9 0x34 0x2b 0x43
+0xa7 0x54 0xf9 0xe1 0x8b 0x0f 0xdc 0x46
+0xc2 0xcc 0x4e 0x25 0x24 0x77 0xe0 0x83
+0x52 0x0b 0xf4 0x36 0x74 0x53 0xb6 0x2b
+0xbf 0x3e 0x14 0xb7 0xb0 0xea 0x0e 0xee
+0x84 0xc5 0x5b 0x9e 0x64 0xfc 0x03 0x97
+0xc0 0x45 0x18 0x6d 0x14 0xdb 0x88 0x8c
+0x73 0x2f 0x95 0x52 0xf5 0x60 0x56 0x6c
+0xa1 0x60 0x56 0x70 0xa1 0x60
+[initiator]: sending message (91 bytes)
+0x13 0x58 0x58 0x49 0x7a 0x3e 0x46 0xac
+0xa1 0x36 0xbf 0xff 0xb9 0x5c 0x00 0x46
+0x89 0x69 0x68 0x4a 0xe8 0x2d 0x83 0xf0
+0xe5 0xc5 0xe3 0x3f 0x8f 0x17 0xdf 0x7c
+0x72 0xe1 0xf2 0x9e 0x7a 0x2a 0xe8 0x88
+0x75 0x16 0xd2 0x6a 0xe3 0xa7 0x73 0x76
+0xe8 0xe5 0x22 0x14 0x43 0x6d 0xb0 0x37
+0xb8 0x48 0x31 0xf3 0xa9 0xb3 0xfc 0x82
+0x9c 0x4a 0x92 0x19 0x2c 0x3e 0x4a 0xfe
+0x42 0x6c 0x11 0x39 0x6c 0x48 0x48 0x06
+0x6b 0xf0 0xed 0x2e 0xff 0x16 0x91 0x08
+0xf4 0xee 0x6e
+[initiator]: send 91 bytes to fe80::d476:bbff:fe62:f2ae on port 5683
+
+[initiator]: handshake successfully completed
+```
+
+- responder:
+
+```
+> [responder]: received an EDHOC message (len 37)
+0x01 0x00 0x58 0x20 0x71 0xa3 0xd5 0x99
+0xc2 0x1d 0xa1 0x89 0x02 0xa1 0xae 0xa8
+0x10 0xb2 0xb6 0x38 0x2c 0xcd 0x8d 0x5f
+0x9b 0xf0 0x19 0x52 0x81 0x75 0x4c 0x5e
+0xbc 0xaf 0x30 0x1e 0x13
+[responder]: sending msg2 (117 bytes)
+0x58 0x20 0x71 0xa3 0xd5 0x99 0xc2 0x1d
+0xa1 0x89 0x02 0xa1 0xae 0xa8 0x10 0xb2
+0xb6 0x38 0x2c 0xcd 0x8d 0x5f 0x9b 0xf0
+0x19 0x52 0x81 0x75 0x4c 0x5e 0xbc 0xaf
+0x30 0x1e 0x13 0x58 0x50 0x99 0xe1 0x3b
+0xa4 0x65 0x44 0x44 0xe8 0xb6 0xd4 0x04
+0x01 0x1e 0x01 0xa3 0x29 0xa3 0x26 0x05
+0x45 0x99 0x33 0x95 0xf9 0x34 0x2b 0x43
+0xa7 0x54 0xf9 0xe1 0x8b 0x0f 0xdc 0x46
+0xc2 0xcc 0x4e 0x25 0x24 0x77 0xe0 0x83
+0x52 0x0b 0xf4 0x36 0x74 0x53 0xb6 0x2b
+0xbf 0x3e 0x14 0xb7 0xb0 0xea 0x0e 0xee
+0x84 0xc5 0x5b 0x9e 0x64 0xfc 0x03 0x97
+0xc0 0x45 0x18 0x6d 0x14 0xdb 0x88 0x8c
+0x73 0x2f 0x95 0x52 0xf5
+[responder]: received an EDHOC message (len 91)
+0x13 0x58 0x58 0x49 0x7a 0x3e 0x46 0xac
+0xa1 0x36 0xbf 0xff 0xb9 0x5c 0x00 0x46
+0x89 0x69 0x68 0x4a 0xe8 0x2d 0x83 0xf0
+0xe5 0xc5 0xe3 0x3f 0x8f 0x17 0xdf 0x7c
+0x72 0xe1 0xf2 0x9e 0x7a 0x2a 0xe8 0x88
+0x75 0x16 0xd2 0x6a 0xe3 0xa7 0x73 0x76
+0xe8 0xe5 0x22 0x14 0x43 0x6d 0xb0 0x37
+0xb8 0x48 0x31 0xf3 0xa9 0xb3 0xfc 0x82
+0x9c 0x4a 0x92 0x19 0x2c 0x3e 0x4a 0xfe
+0x42 0x6c 0x11 0x39 0x6c 0x48 0x48 0x06
+0x6b 0xf0 0xed 0x2e 0xff 0x16 0x91 0x08
+0xf4 0xee 0x6e
+[responder]: finalize exchange
+[responder]: handshake successfully completed
+```
+
+- oscore keys:
+
+```
+> ini oscore
+init oscore
+OSCORE secret:
+0x43 0x83 0x97 0xe7 0xa8 0x3b 0xd7 0x35
+0xdf 0x0d 0x47 0xdc 0x45 0x44 0xa4 0x63
+
+OSCORE salt:
+0x22 0x3b 0x3c 0xb1 0x03 0xc8 0xa3 0xd0
+```
+
+## EDHOC automatic test
+
+As long as a BOARD with a netdev interface is used is as simple as:
+
+```
+$ make -C tests/pkg_edhoc_c flash test-with-config
+```
diff --git a/tests/pkg_edhoc_c/common.c b/tests/pkg_edhoc_c/common.c
new file mode 100644
index 0000000000..a242eceeb7
--- /dev/null
+++ b/tests/pkg_edhoc_c/common.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       EDHOC initiator/responder common setup code
+ *
+ * @author      Timothy Claeys <timothy.claeys@inria.fr>
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "kernel_defines.h"
+#include "edhoc/edhoc.h"
+#include "edhoc_keys.h"
+
+#define ENABLE_DEBUG        0
+#include "debug.h"
+
+#define CRED_DB_SIZE        ARRAY_SIZE(cred_db)
+
+int _cred_cb(const uint8_t *k, size_t k_len, const uint8_t **o, size_t *o_len)
+{
+    for (uint8_t i = 0; i < (uint8_t)CRED_DB_SIZE; i++) {
+        if (cred_db[i].id_len == k_len) {
+            if (memcmp(cred_db[i].id, k, k_len) == 0) {
+                *o = cred_db[i].cred;
+                *o_len = cred_db[i].cred_len;
+                return 0;
+            }
+        }
+    }
+    *o = NULL;
+    *o_len = 0;
+    return EDHOC_ERR_INVALID_CRED_ID;
+}
+
+void print_bstr(const uint8_t *bstr, size_t bstr_len)
+{
+    for (size_t i = 0; i < bstr_len; i++) {
+        if ((i + 1) % 8 == 0) {
+            printf("0x%02x \n", bstr[i]);
+        }
+        else {
+            printf("0x%02x ", bstr[i]);
+        }
+    }
+    printf("\n");
+}
+
+int edhoc_setup(edhoc_ctx_t *ctx, edhoc_conf_t *conf, edhoc_role_t role,
+                cose_key_t *auth_key, cred_id_t *cred_id, rpk_t *rpk,
+                void *hash_ctx)
+{
+    /* clear/init context and configuration */
+    edhoc_ctx_init(ctx);
+    edhoc_conf_init(conf);
+    cred_id_init(cred_id);
+    cred_rpk_init(rpk);
+    cose_key_init(auth_key);
+
+    /* only for testing load preset keys for role */
+    const uint8_t *cbor_auth_key = NULL;
+    const uint8_t *cbor_rpk = NULL;
+    const uint8_t *cbor_rpk_id = NULL;
+    size_t cbor_auth_key_len = 0;
+    size_t cbor_rpk_len = 0;
+    size_t cbor_rpk_id_len;
+
+    if (role == EDHOC_IS_RESPONDER) {
+        DEBUG_PUTS("[edhoc]: setting up responder");
+        cbor_auth_key = resp_cbor_auth_key;
+        cbor_auth_key_len = sizeof(resp_cbor_auth_key);
+        cbor_rpk = resp_cbor_rpk;
+        cbor_rpk_len = sizeof(resp_cbor_rpk);
+        cbor_rpk_id = resp_cbor_rpk_id;
+        cbor_rpk_id_len = sizeof(resp_cbor_rpk_id);
+    }
+    else {
+        DEBUG_PUTS("[edhoc]: setting up initiator");
+        cbor_auth_key = init_cbor_auth_key;
+        cbor_auth_key_len = sizeof(init_cbor_auth_key);
+        cbor_rpk = init_cbor_rpk;
+        cbor_rpk_len = sizeof(init_cbor_rpk);
+        cbor_rpk_id = init_cbor_rpk_id;
+        cbor_rpk_id_len = sizeof(init_cbor_rpk_id);
+    }
+
+    DEBUG_PUTS("[edhoc]: load private authentication key");
+    if (cose_key_from_cbor(auth_key, cbor_auth_key, cbor_auth_key_len) != 0) {
+        return -1;
+    }
+
+    DEBUG_PUTS("[edhoc]: load and set CBOR RPK");
+    if (cred_rpk_from_cbor(rpk, cbor_rpk, cbor_rpk_len) != 0) {
+        return -1;
+    }
+
+    DEBUG_PUTS("[edhoc]: load credential identifier information");
+    if (cred_id_from_cbor(cred_id, cbor_rpk_id, cbor_rpk_id_len) != 0) {
+        return -1;
+    }
+
+    DEBUG_PUTS("[edhoc]: set up EDHOC callbacks and role");
+    edhoc_conf_setup_ad_callbacks(conf, NULL, NULL, NULL);
+    if (edhoc_conf_setup_role(conf, role) != 0) {
+        return -1;
+    }
+
+    DEBUG_PUTS("[edhoc]: set up EDHOC credentials");
+    if (edhoc_conf_setup_credentials(conf, auth_key, CRED_TYPE_RPK, rpk, cred_id, _cred_cb) != 0) {
+        return -1;
+    }
+
+    DEBUG_PUTS("[edhoc]: EDHOC context setup");
+    edhoc_ctx_setup(ctx, conf, hash_ctx);
+
+    return 0;
+}
+
+void edhoc_oscore_exporter(edhoc_ctx_t *ctx, uint8_t *secret, size_t secret_len,
+                           uint8_t *salt, size_t salt_len)
+{
+    edhoc_exporter(ctx, "OSCORE secret", secret_len, secret, secret_len);
+    edhoc_exporter(ctx, "OSCORE salt", salt_len, salt, salt_len);
+
+    puts("OSCORE secret:");
+    print_bstr(secret, secret_len);
+    puts("OSCORE salt:");
+    print_bstr(salt, salt_len);
+}
diff --git a/tests/pkg_edhoc_c/edhoc_keys.h b/tests/pkg_edhoc_c/edhoc_keys.h
new file mode 100644
index 0000000000..1178df7bcd
--- /dev/null
+++ b/tests/pkg_edhoc_c/edhoc_keys.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       Certificates and keys for the edhoc example. This values
+ *              are taken from the IETF lake WG test vectors, specifically
+ *              test vector 34900, see:
+ *              https://github.com/lake-wg/edhoc/blob/5ef58e6ee998f4b9aca4b53b35e87375ca356f32/test-vectors-05/vectors.txt
+ *
+ * @author      Timothy Claeys <timothy.claeys@inria.fr>
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ *
+ * @}
+ */
+
+#ifndef EDHOC_KEYS_H
+#define EDHOC_KEYS_H
+
+#include <inttypes.h>
+
+#include "kernel_defines.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* initiator CBOR-encoded authentication key */
+static const uint8_t init_cbor_auth_key[] = {
+    0xa4, 0x01, 0x01, 0x20, 0x06, 0x21, 0x58, 0x20,
+    0x2c, 0x44, 0x0c, 0xc1, 0x21, 0xf8, 0xd7, 0xf2,
+    0x4c, 0x3b, 0x0e, 0x41, 0xae, 0xda, 0xfe, 0x9c,
+    0xaa, 0x4f, 0x4e, 0x7a, 0xbb, 0x83, 0x5e, 0xc3,
+    0x0f, 0x1d, 0xe8, 0x8a, 0xdb, 0x96, 0xff, 0x71,
+    0x23, 0x58, 0x20, 0x2b, 0xbe, 0xa6, 0x55, 0xc2,
+    0x33, 0x71, 0xc3, 0x29, 0xcf, 0xbd, 0x3b, 0x1f,
+    0x02, 0xc6, 0xc0, 0x62, 0x03, 0x38, 0x37, 0xb8,
+    0xb5, 0x90, 0x99, 0xa4, 0x43, 0x6f, 0x66, 0x60,
+    0x81, 0xb0, 0x8e
+};
+
+/* initiator CBOR-encoded ephemeral key */
+static const uint8_t init_cbor_eph_key[] = {
+    0xa4, 0x01, 0x01, 0x20, 0x04, 0x21, 0x58, 0x20,
+    0x8d, 0x3e, 0xf5, 0x6d, 0x1b, 0x75, 0x0a, 0x43,
+    0x51, 0xd6, 0x8a, 0xc2, 0x50, 0xa0, 0xe8, 0x83,
+    0x79, 0x0e, 0xfc, 0x80, 0xa5, 0x38, 0xa4, 0x44,
+    0xee, 0x9e, 0x2b, 0x57, 0xe2, 0x44, 0x1a, 0x7c,
+    0x23, 0x58, 0x20, 0xae, 0x11, 0xa0, 0xdb, 0x86,
+    0x3c, 0x02, 0x27, 0xe5, 0x39, 0x92, 0xfe, 0xb8,
+    0xf5, 0x92, 0x4c, 0x50, 0xd0, 0xa7, 0xba, 0x6e,
+    0xea, 0xb4, 0xad, 0x1f, 0xf2, 0x45, 0x72, 0xf4,
+    0xf5, 0x7c, 0xfa
+};
+
+/* initiator CBOR-encoded RPK */
+static const uint8_t init_cbor_rpk[] = {
+    0xa4, 0x01, 0x01, 0x20, 0x04, 0x21, 0x58, 0x20,
+    0x2c, 0x44, 0x0c, 0xc1, 0x21, 0xf8, 0xd7, 0xf2,
+    0x4c, 0x3b, 0x0e, 0x41, 0xae, 0xda, 0xfe, 0x9c,
+    0xaa, 0x4f, 0x4e, 0x7a, 0xbb, 0x83, 0x5e, 0xc3,
+    0x0f, 0x1d, 0xe8, 0x8a, 0xdb, 0x96, 0xff, 0x71,
+    0x6c, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74,
+    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x60
+};
+
+/* initiator CBOR-encoded rpk identifier */
+static const uint8_t init_cbor_rpk_id[] = {
+    0xa1, 0x04, 0x41, 0x23
+};
+
+/* initiator CBOR-encoded rpk identifier */
+static const uint8_t init_cbor_rpk_id_value[] = {
+    0x23
+};
+
+/* initiator session identifier preset */
+static const uint8_t init_cid[] = {
+    0x16
+};
+
+/* responder CBOR-encoded authentication key */
+static const uint8_t resp_cbor_auth_key[] = {
+    0xa4, 0x01, 0x01, 0x20, 0x06, 0x21, 0x58, 0x20,
+    0xa3, 0xff, 0x26, 0x35, 0x95, 0xbe, 0xb3, 0x77,
+    0xd1, 0xa0, 0xce, 0x1d, 0x04, 0xda, 0xd2, 0xd4,
+    0x09, 0x66, 0xac, 0x6b, 0xcb, 0x62, 0x20, 0x51,
+    0xb8, 0x46, 0x59, 0x18, 0x4d, 0x5d, 0x9a, 0x32,
+    0x23, 0x58, 0x20, 0xbb, 0x50, 0x1a, 0xac, 0x67,
+    0xb9, 0xa9, 0x5f, 0x97, 0xe0, 0xed, 0xed, 0x6b,
+    0x82, 0xa6, 0x62, 0x93, 0x4f, 0xbb, 0xfc, 0x7a,
+    0xd1, 0xb7, 0x4c, 0x1f, 0xca, 0xd6, 0x6a, 0x07,
+    0x94, 0x22, 0xd0
+};
+
+/* responder CBOR-encoded ephemeral key */
+static const uint8_t resp_cbor_eph_key[] = {
+    0xa4, 0x01, 0x01, 0x20, 0x04, 0x21, 0x58, 0x20,
+    0x52, 0xfb, 0xa0, 0xbd, 0xc8, 0xd9, 0x53, 0xdd,
+    0x86, 0xce, 0x1a, 0xb2, 0xfd, 0x7c, 0x05, 0xa4,
+    0x65, 0x8c, 0x7c, 0x30, 0xaf, 0xdb, 0xfc, 0x33,
+    0x01, 0x04, 0x70, 0x69, 0x45, 0x1b, 0xaf, 0x35,
+    0x23, 0x58, 0x20, 0xc6, 0x46, 0xcd, 0xdc, 0x58,
+    0x12, 0x6e, 0x18, 0x10, 0x5f, 0x01, 0xce, 0x35,
+    0x05, 0x6e, 0x5e, 0xbc, 0x35, 0xf4, 0xd4, 0xcc,
+    0x51, 0x07, 0x49, 0xa3, 0xa5, 0xe0, 0x69, 0xc1,
+    0x16, 0x16, 0x9a
+};
+
+/* responder CBOR-encoded RPK */
+static const uint8_t resp_cbor_rpk[] = {
+    0xa4, 0x01, 0x01, 0x20, 0x04, 0x21, 0x58, 0x20,
+    0xa3, 0xff, 0x26, 0x35, 0x95, 0xbe, 0xb3, 0x77,
+    0xd1, 0xa0, 0xce, 0x1d, 0x04, 0xda, 0xd2, 0xd4,
+    0x09, 0x66, 0xac, 0x6b, 0xcb, 0x62, 0x20, 0x51,
+    0xb8, 0x46, 0x59, 0x18, 0x4d, 0x5d, 0x9a, 0x32,
+    0x6c, 0x73, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74,
+    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x60
+};
+
+
+/* responder CBOR-encoded rpk identifier */
+static const uint8_t resp_cbor_rpk_id[] = {
+    0xa1, 0x04, 0x41, 0x05
+};
+
+/* responder CBOR-encoded rpk identifier */
+static const uint8_t resp_cbor_rpk_id_value[] = {
+    0x05
+};
+
+/* responder session identifier preset */
+static const uint8_t resp_cid[] = {
+    0x00
+};
+
+/**
+ * @brief     Credential database  entry
+ */
+typedef struct {
+    const uint8_t *id;      /**< credential id pointer */
+    size_t id_len;          /**< credential id length */
+    const uint8_t *cred;    /**< credential pointer */
+    size_t cred_len;        /**< credential length */
+} cred_db_entry_t;
+
+/* credential database */
+static const cred_db_entry_t cred_db[] = {
+    {
+        resp_cbor_rpk_id_value,
+        sizeof(resp_cbor_rpk_id_value),
+        resp_cbor_rpk,
+        sizeof(resp_cbor_rpk)
+    },
+    {
+        init_cbor_rpk_id_value,
+        sizeof(init_cbor_rpk_id_value),
+        init_cbor_rpk,
+        sizeof(init_cbor_rpk)
+    },
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EDHOC_KEYS_H */
diff --git a/tests/pkg_edhoc_c/initiator.c b/tests/pkg_edhoc_c/initiator.c
new file mode 100644
index 0000000000..ecca88ff57
--- /dev/null
+++ b/tests/pkg_edhoc_c/initiator.c
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       EDHOC coap initiator implementation
+ *
+ * @author      Timothy Claeys <timothy.claeys@inria.fr>
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ */
+
+
+#include <stdio.h>
+
+#include "net/ipv6.h"
+#include "net/nanocoap_sock.h"
+#include "shell.h"
+
+#include "edhoc/edhoc.h"
+#include "edhoc_keys.h"
+
+#if IS_USED(MODULE_WOLFSSL)
+#include "wolfssl/wolfcrypt/sha256.h"
+#elif IS_USED(MODULE_TINYCRYPT)
+#include "tinycrypt/sha256.h"
+#endif
+
+#define ENABLE_DEBUG        0
+#include "debug.h"
+
+#define COAP_BUF_SIZE     (256U)
+
+#if IS_ACTIVE(CONFIG_INITIATOR)
+
+extern void print_bstr(const uint8_t *bstr, size_t bstr_len);
+extern int edhoc_setup(edhoc_ctx_t *ctx, edhoc_conf_t *conf, edhoc_role_t role,
+                       cose_key_t *auth_key, cred_id_t *cred_id, rpk_t *rpk,
+                       void *hash_ctx);
+extern void edhoc_oscore_exporter(edhoc_ctx_t *ctx, uint8_t *secret, size_t secret_len,
+                                  uint8_t *salt, size_t salt_len);
+
+static edhoc_ctx_t _ctx;
+static edhoc_conf_t _conf;
+static rpk_t _rpk;
+static cred_id_t _cred_id;
+static cose_key_t _auth_key;
+#if IS_USED(MODULE_WOLFSSL)
+static wc_Sha256 _sha_i;
+#elif IS_USED(MODULE_TINYCRYPT)
+struct tc_sha256_state_struct _sha_i;
+#endif
+static uint8_t _method;
+static uint8_t _suite;
+
+static ssize_t _send(coap_pkt_t *pkt, size_t len, char *addr_str, uint16_t port)
+{
+    ipv6_addr_t addr;
+    sock_udp_ep_t remote;
+
+    remote.family = AF_INET6;
+    remote.port = port;
+
+    /* parse for interface */
+    char *iface = ipv6_addr_split_iface(addr_str);
+    if (!iface) {
+        if (gnrc_netif_numof() == 1) {
+            /* assign the single interface found in gnrc_netif_numof() */
+            remote.netif = (uint16_t)gnrc_netif_iter(NULL)->pid;
+        }
+        else {
+            remote.netif = SOCK_ADDR_ANY_NETIF;
+        }
+    }
+    else {
+        int pid = atoi(iface);
+        if (gnrc_netif_get_by_pid(pid) == NULL) {
+            puts("[initiator]: interface not valid");
+            return 0;
+        }
+        remote.netif = pid;
+    }
+
+    /* parse destination address */
+    if (ipv6_addr_from_str(&addr, addr_str) == NULL) {
+        puts("[initiator]: unable to parse destination address");
+        return 0;
+    }
+    if ((remote.netif == SOCK_ADDR_ANY_NETIF) && ipv6_addr_is_link_local(&addr)) {
+        puts("[initiator]: must specify interface for link local target");
+        return 0;
+    }
+    memcpy(&remote.addr.ipv6[0], &addr.u8[0], sizeof(addr.u8));
+
+    return nanocoap_request(pkt, NULL, &remote, len);
+}
+
+static ssize_t _build_coap_pkt(coap_pkt_t *pkt, uint8_t *buf, ssize_t buflen,
+                               uint8_t *payload, ssize_t payload_len)
+{
+    uint8_t token[2] = { 0xDA, 0xEC };
+    ssize_t len = 0;
+
+    /* set pkt buffer */
+    pkt->hdr = (coap_hdr_t *)buf;
+    /* build header, confirmed message always post */
+    ssize_t hdrlen = coap_build_hdr(pkt->hdr, COAP_TYPE_CON, token,
+                                    sizeof(token), COAP_METHOD_POST, 1);
+    coap_pkt_init(pkt, buf, buflen, hdrlen);
+    coap_opt_add_string(pkt, COAP_OPT_URI_PATH, "/.well-known/edhoc", '/');
+    coap_opt_add_uint(pkt, COAP_OPT_CONTENT_FORMAT, COAP_FORMAT_OCTET);
+    len = coap_opt_finish(pkt, COAP_OPT_FINISH_PAYLOAD);
+    /* copy msg payload */
+    pkt->payload_len = payload_len;
+    memcpy(pkt->payload, payload, payload_len);
+    len += pkt->payload_len;
+    return len;
+}
+
+int _handshake_cmd(int argc, char **argv)
+{
+    uint8_t buf[COAP_BUF_SIZE] = { 0 };
+    coap_pkt_t pkt;
+    ssize_t len = 0;
+    uint16_t port = COAP_PORT;
+    uint8_t msg[COAP_BUF_SIZE];
+    ssize_t msg_len = 0;
+
+    /* correlation value is transport specific */
+    corr_t corr = CORR_1_2;
+
+    if (argc < 2) {
+        printf("usage: %s <addr>[%%iface] <port>\n", argv[0]);
+        return -1;
+    }
+    if (argc == 3) {
+        port = atoi(argv[2]);
+    }
+
+    /* reset state */
+    _ctx.state = EDHOC_WAITING;
+
+    if ((msg_len = edhoc_create_msg1(&_ctx, corr, _method, _suite, msg, sizeof(msg))) > 0) {
+        printf("[initiator]: sending msg1 (%d bytes):\n", (int) msg_len);
+        print_bstr(msg, msg_len);
+        _build_coap_pkt(&pkt, buf, sizeof(buf), msg, msg_len);
+        len = _send(&pkt, COAP_BUF_SIZE, argv[1], port);
+    }
+    else {
+        puts("[initiator]: failed to create msg1");
+        return -1;
+    }
+    if (len < 0) {
+        puts("[initiator]: failed to send msg1");
+        return -1;
+    }
+
+    printf("[initiator]: received a message (%d bytes):\n", pkt.payload_len);
+    print_bstr(pkt.payload, pkt.payload_len);
+
+    if ((msg_len = edhoc_create_msg3(&_ctx, pkt.payload, pkt.payload_len, msg, sizeof(msg))) > 0) {
+        printf("[initiator]: sending msg3 (%d bytes):\n", (int) msg_len);
+        print_bstr(msg, msg_len);
+        _build_coap_pkt(&pkt, buf, sizeof(buf), msg, msg_len);
+        len = _send(&pkt, COAP_BUF_SIZE, argv[1], port);
+    }
+    else {
+        puts("[initiator]: failed to create msg3");
+        return -1;
+    }
+
+    if (edhoc_init_finalize(&_ctx)) {
+        puts("[initiator]: handshake failed");
+        return -1;
+    }
+
+    puts("[initiator]: handshake successfully completed");
+
+    printf("[initiator]: Transcript hash 4 (%d bytes):\n", EDHOC_DIGEST_SIZE);
+    print_bstr(_ctx.session.th4, EDHOC_DIGEST_SIZE);
+
+    _ctx.state = EDHOC_FINALIZED;
+
+    return 0;
+}
+
+static void _print_initiator_usage(void)
+{
+    puts("Usage:");
+    puts("\tinit set method <sgn-sgn|sgn-stat|stat-sgn|stat-stat>:"
+         " choose authentication method [initiator-responder]");
+    puts("\tinit set suite <0|1>: choose cypher-suit, only 0 and 1 support");
+    puts("\tinit handshake <addr>[%%iface] <port>: start handshake");
+    puts("\tinit oscore: derive OSCORE secret and salt");
+}
+
+static int _set_cmd(int argc, char **argv)
+{
+    if (argc < 2) {
+        _print_initiator_usage();
+        return -1;
+    }
+
+    if (!strcmp(argv[1], "method")) {
+        if (!strcmp(argv[2], "sgn-sgn")) {
+            _method = EDHOC_AUTH_SIGN_SIGN;
+        }
+        else if (!strcmp(argv[2], "sgn-stat")) {
+            _method = EDHOC_AUTH_SIGN_STATIC;
+        }
+        else if (!strcmp(argv[2], "stat-sgn")) {
+            _method = EDHOC_AUTH_STATIC_SIGN;
+        }
+        else if (!strcmp(argv[2], "stat-stat")) {
+            _method = EDHOC_AUTH_STATIC_STATIC;
+        }
+        else {
+            printf("error: invalid method %s, sgn-sgn|sgn-stat|stat-sgn|stat-stat\n", argv[1]);
+            return -1;
+        }
+    }
+
+    if (!strcmp(argv[1], "suite")) {
+        uint8_t suite = atoi(argv[2]);
+        if (suite > 1) {
+            puts("error: only cypher suits 0 and 1 are supported");
+            return -1;
+        }
+        _suite = suite;
+    }
+
+    return 0;
+}
+
+int initiator_cmd(int argc, char **argv)
+{
+    if (argc < 2) {
+        _print_initiator_usage();
+        return -1;
+    }
+
+    if (!strcmp(argv[1], "set")) {
+        return _set_cmd(argc - 1, &argv[1]);
+    }
+
+    if (!strcmp(argv[1], "handshake")) {
+        return _handshake_cmd(argc - 1, &argv[1]);
+    }
+
+    if (!strcmp(argv[1], "oscore")) {
+        if (_ctx.state == EDHOC_FINALIZED) {
+            uint8_t secret[16];
+            uint8_t salt[8];
+            edhoc_oscore_exporter(&_ctx, secret, sizeof(secret), salt, sizeof(salt));
+        }
+        else {
+            puts("error: perform edhoc handshake first");
+        }
+    }
+
+    return 0;
+}
+
+int initiator_cli_init(void)
+{
+    /* default to static-static (method 3) since we are using RPK keys */
+    _method = EDHOC_AUTH_STATIC_STATIC;
+    _suite = EDHOC_CIPHER_SUITE_0;
+    if (edhoc_setup(&_ctx, &_conf, EDHOC_IS_INITIATOR, &_auth_key, &_cred_id,
+                    &_rpk, &_sha_i)) {
+        puts("[initiator]: error during setup");
+        return -1;
+    }
+    /* use fixed values only for testing purposes */
+    puts("[initiator]: load ephemeral key: ONLY FOR TESTING");
+    if (edhoc_load_ephkey(&_ctx, init_cbor_eph_key, sizeof(init_cbor_eph_key)) != 0) {
+        return -1;
+    }
+    puts("[initiator]: preset cid: ONLY FOR TESTING");
+    if (edhoc_session_preset_cidi(&_ctx, init_cid, sizeof(init_cid)) != 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+#endif /* CONFIG_INITIATOR */
diff --git a/tests/pkg_edhoc_c/main.c b/tests/pkg_edhoc_c/main.c
new file mode 100644
index 0000000000..fa478b43bb
--- /dev/null
+++ b/tests/pkg_edhoc_c/main.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       EDHOC handhshake over COAP using EDHOC-C
+ *
+ * @author      Timothy Claeys <timothy.claeys@inria.fr>
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ */
+
+#include <stdio.h>
+
+#include "net/nanocoap_sock.h"
+#include "shell.h"
+#include "thread.h"
+
+#include "edhoc/edhoc.h"
+#include "edhoc_keys.h"
+
+#define MAIN_QUEUE_SIZE     (4)
+static msg_t _main_msg_queue[MAIN_QUEUE_SIZE];
+
+#if IS_ACTIVE(CONFIG_RESPONDER)
+static char _nanocoap_server_stack[THREAD_STACKSIZE_MAIN];
+#define NANOCOAP_SERVER_QUEUE_SIZE     (4)
+static msg_t _nanocoap_server_msg_queue[NANOCOAP_SERVER_QUEUE_SIZE];
+#define NANOCOAP_BUF_SIZE   (512U)
+extern int responder_cli_init(void);
+extern int responder_cmd(int argc, char **argv);
+#endif
+
+#if IS_ACTIVE(CONFIG_INITIATOR)
+extern int initiator_cmd(int argc, char **argv);
+extern int initiator_cli_init(void);
+#endif
+
+static const shell_command_t shell_commands[] = {
+
+#if IS_ACTIVE(CONFIG_INITIATOR)
+    { "init", "EDHOC Initiator cli", initiator_cmd },
+#endif
+#if IS_ACTIVE(CONFIG_RESPONDER)
+    { "resp", "EDHOC Responder cli", responder_cmd },
+#endif
+    { NULL, NULL, NULL }
+};
+
+#if IS_ACTIVE(CONFIG_RESPONDER)
+static void *_nanocoap_server_thread(void *arg)
+{
+    (void)arg;
+
+    /* nanocoap_server uses gnrc sock which uses gnrc which needs a msg queue */
+    msg_init_queue(_nanocoap_server_msg_queue, NANOCOAP_SERVER_QUEUE_SIZE);
+
+    /* initialize nanocoap server instance */
+    uint8_t buf[NANOCOAP_BUF_SIZE];
+    sock_udp_ep_t local = { .port = COAP_PORT, .family = AF_INET6 };
+    nanocoap_server(&local, buf, sizeof(buf));
+
+    return NULL;
+}
+#endif
+
+int main(void)
+{
+#if IS_ACTIVE(CONFIG_INITIATOR)
+    if (initiator_cli_init()) {
+        return -1;
+    }
+#endif
+#if IS_ACTIVE(CONFIG_RESPONDER)
+    if (responder_cli_init()) {
+        return -1;
+    }
+
+    /* start nanocoap server thread */
+    thread_create(_nanocoap_server_stack, sizeof(_nanocoap_server_stack),
+                  THREAD_PRIORITY_MAIN - 1,
+                  THREAD_CREATE_STACKTEST,
+                  _nanocoap_server_thread, NULL, "nanocoap server");
+#endif
+
+    /* the shell contains commands that receive packets via GNRC and thus
+       needs a msg queue */
+    msg_init_queue(_main_msg_queue, MAIN_QUEUE_SIZE);
+
+    puts("Starting the shell");
+    char line_buf[SHELL_DEFAULT_BUFSIZE];
+    shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);
+
+    /* should be never reached */
+    return 0;
+}
diff --git a/tests/pkg_edhoc_c/responder.c b/tests/pkg_edhoc_c/responder.c
new file mode 100644
index 0000000000..860571e4ac
--- /dev/null
+++ b/tests/pkg_edhoc_c/responder.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       EDHOC coap responder implementation
+ *
+ * @author      Timothy Claeys <timothy.claeys@inria.fr>
+ * @author      Francisco Molina <francois-xavier.molina@inria.fr>
+ *
+ */
+
+#include <stdio.h>
+
+#include "net/ipv6.h"
+#include "net/nanocoap_sock.h"
+#include "shell.h"
+
+#include "edhoc/edhoc.h"
+#include "edhoc_keys.h"
+
+#if IS_USED(MODULE_WOLFSSL)
+#include "wolfssl/wolfcrypt/sha256.h"
+#elif IS_USED(MODULE_TINYCRYPT)
+#include "tinycrypt/sha256.h"
+#endif
+
+#define ENABLE_DEBUG        0
+#include "debug.h"
+
+#define COAP_BUF_SIZE     (256U)
+
+#if IS_ACTIVE(CONFIG_RESPONDER)
+
+extern void print_bstr(const uint8_t *bstr, size_t bstr_len);
+extern int edhoc_setup(edhoc_ctx_t *ctx, edhoc_conf_t *conf, edhoc_role_t role,
+                       cose_key_t *auth_key, cred_id_t *cred_id, rpk_t *rpk,
+                       void *hash_ctx);
+extern void edhoc_oscore_exporter(edhoc_ctx_t *ctx, uint8_t *secret, size_t secret_len,
+                                  uint8_t *salt, size_t salt_len);
+
+static edhoc_ctx_t _ctx;
+static edhoc_conf_t _conf;
+static rpk_t _rpk;
+static cred_id_t _cred_id;
+static cose_key_t _auth_key;
+#if IS_USED(MODULE_WOLFSSL)
+static wc_Sha256 _sha_r;
+#elif IS_USED(MODULE_TINYCRYPT)
+struct tc_sha256_state_struct _sha_r;
+#endif
+
+ssize_t _edhoc_handler(coap_pkt_t *pkt, uint8_t *buf, size_t len, void *context)
+{
+    (void)context;
+    ssize_t msg_len = 0;
+
+    printf("[responder]: received an EDHOC message (len %d):\n", pkt->payload_len);
+    print_bstr(pkt->payload, pkt->payload_len);
+
+    if (_ctx.state == EDHOC_FINALIZED || _ctx.state == EDHOC_FAILED) {
+        _ctx.state = EDHOC_WAITING;
+    }
+
+    if (_ctx.state == EDHOC_WAITING) {
+        uint8_t msg[COAP_BUF_SIZE];
+        if ((msg_len =
+                 edhoc_create_msg2(&_ctx, pkt->payload, pkt->payload_len, msg, sizeof(msg))) >= 0) {
+            printf("[responder]: sending msg2 (%d bytes):\n", (int) msg_len);
+            print_bstr(msg, msg_len);
+            msg_len = coap_reply_simple(pkt, COAP_CODE_204, buf, len, COAP_FORMAT_OCTET, msg,
+                                        msg_len);
+        }
+        else {
+            puts("[responder]: failed to create msg2");
+            coap_reply_simple(pkt, COAP_CODE_404, buf, len, COAP_FORMAT_TEXT, NULL, 0);
+            return -1;
+        }
+    }
+    else if (_ctx.state == EDHOC_SENT_MESSAGE_2) {
+        puts("[responder]: finalize exchange");
+        edhoc_resp_finalize(&_ctx, pkt->payload, pkt->payload_len, false, NULL, 0);
+        msg_len = coap_reply_simple(pkt, COAP_CODE_204, buf, len, COAP_FORMAT_OCTET, NULL, 0);
+    }
+
+    if (_ctx.state == EDHOC_FINALIZED) {
+        puts("[responder]: handshake successfully completed");
+    }
+
+    return msg_len;
+}
+
+/* must be sorted by path (ASCII order) */
+const coap_resource_t coap_resources[] = {
+    COAP_WELL_KNOWN_CORE_DEFAULT_HANDLER,
+    { "/.well-known/edhoc", COAP_POST, _edhoc_handler, NULL },
+};
+
+const unsigned coap_resources_numof = ARRAY_SIZE(coap_resources);
+
+int responder_cmd(int argc, char **argv)
+{
+    if (argc < 2) {
+        puts("Usage:");
+        puts("\tresp oscore: derive OSCORE secret and salt");
+        return -1;
+    }
+
+    if (!strcmp(argv[1], "oscore")) {
+        if (_ctx.state == EDHOC_FINALIZED) {
+            uint8_t secret[16];
+            uint8_t salt[8];
+            edhoc_oscore_exporter(&_ctx, secret, sizeof(secret), salt, sizeof(salt));
+        }
+        else {
+            puts("error: perform edhoc handshake first");
+        }
+    }
+
+    return 0;
+}
+
+int responder_cli_init(void)
+{
+    if (edhoc_setup(&_ctx, &_conf, EDHOC_IS_RESPONDER, &_auth_key, &_cred_id,
+                    &_rpk, &_sha_r)) {
+        puts("[responder]: error during setup");
+        return -1;
+    }
+
+    /* use fixed values only for testing purposes */
+    puts("[responder]: load ephemeral key: ONLY FOR TESTING");
+    if (edhoc_load_ephkey(&_ctx, resp_cbor_eph_key, sizeof(resp_cbor_eph_key)) != 0) {
+        return -1;
+    }
+    puts("[responder]: preset cid: ONLY FOR TESTING");
+    if (edhoc_session_preset_cidr(&_ctx, resp_cid, sizeof(resp_cid)) != 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+#endif /* CONFIG_RESPONDER */
diff --git a/tests/pkg_edhoc_c/tests-with-config/01-run.py b/tests/pkg_edhoc_c/tests-with-config/01-run.py
new file mode 100755
index 0000000000..680fec0058
--- /dev/null
+++ b/tests/pkg_edhoc_c/tests-with-config/01-run.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import os
+import sys
+
+from testrunner import run
+
+# Default COAP port on which the edhoc responder is running
+COAP_PORT = int(os.getenv("COAP_PORT", "5683"))
+
+LAKE_WG_EDHOC_TV_34900_MSG1 = \
+    "0x0d 0x00 0x58 0x20 0x8d 0x3e 0xf5 0x6d\n" + \
+    "0x1b 0x75 0x0a 0x43 0x51 0xd6 0x8a 0xc2\n" + \
+    "0x50 0xa0 0xe8 0x83 0x79 0x0e 0xfc 0x80\n" + \
+    "0xa5 0x38 0xa4 0x44 0xee 0x9e 0x2b 0x57\n" + \
+    "0xe2 0x44 0x1a 0x7c 0x21"
+
+LAKE_WG_EDHOC_TV_34900_MSG2 = \
+    "0x58 0x20 0x52 0xfb 0xa0 0xbd 0xc8 0xd9\n" + \
+    "0x53 0xdd 0x86 0xce 0x1a 0xb2 0xfd 0x7c\n" + \
+    "0x05 0xa4 0x65 0x8c 0x7c 0x30 0xaf 0xdb\n" + \
+    "0xfc 0x33 0x01 0x04 0x70 0x69 0x45 0x1b\n" + \
+    "0xaf 0x35 0x37 0x4a 0xa3 0xf1 0xbd 0x5d\n" + \
+    "0x02 0x8d 0x19 0xcf 0x3c 0x99"
+
+LAKE_WG_EDHOC_TV_34900_MSG3 = \
+    "0x37 0x52 0xd5 0x53 0x5f 0x31 0x47 0xe8\n" + \
+    "0x5f 0x1c 0xfa 0xcd 0x9e 0x78 0xab 0xf9\n" + \
+    "0xe0 0xa8 0x1b 0xbf"
+
+LAKE_WG_EDHOC_TV_34900_TH4 = \
+    "0x7c 0xcf 0xde 0xdc 0x2c 0x10 0xca 0x03\n" + \
+    "0x56 0xe9 0x57 0xb9 0xf6 0xa5 0x92 0xe0\n" + \
+    "0xfa 0x74 0xdb 0x2a 0xb5 0x4f 0x59 0x24\n" + \
+    "0x40 0x96 0xf9 0xa2 0xac 0x56 0xd2 0x07"
+
+LAKE_WG_EDHOC_TV_34900_OSCORE_SECRET = \
+    "0x5b 0xb2 0xae 0xe2 0x5b 0x16 0x0e 0x7c\n" + \
+    "0x6d 0x26 0x12 0xb0 0xa6 0x01 0x09 0x16"
+
+LAKE_WG_EDHOC_TV_34900_OSCORE_SALT = \
+    "0x8e 0x44 0x92 0x10 0xe0 0x3b 0xc2 0x9d"
+
+
+def get_ipv6_addr(child):
+    child.expect_exact('>')
+    child.sendline('ifconfig')
+    # Get device local address
+    child.expect(
+        r"inet6\s+addr:\s+(?P<lladdr>[0-9a-fA-F:]+:[A-Fa-f:0-9]+)"
+        "  scope: link  VAL"
+    )
+
+    return child.match.group("lladdr").lower()
+
+
+def testfunc(child):
+    child.sendline("init handshake {} {}".format(
+        get_ipv6_addr(child), COAP_PORT))
+    child.expect_exact("[initiator]: sending msg1 (37 bytes):")
+    for line in LAKE_WG_EDHOC_TV_34900_MSG1.split('\n'):
+        child.expect_exact(line)
+    child.expect_exact("[responder]: received an EDHOC message (len 37):")
+    child.expect_exact("[responder]: sending msg2 (46 bytes):")
+    for line in LAKE_WG_EDHOC_TV_34900_MSG2.split('\n'):
+        child.expect_exact(line)
+    child.expect_exact("[initiator]: received a message (46 bytes):")
+    child.expect_exact("[initiator]: sending msg3 (20 bytes)")
+    for line in LAKE_WG_EDHOC_TV_34900_MSG3.split('\n'):
+        child.expect_exact(line)
+    child.expect_exact("[responder]: finalize exchange")
+    child.expect_exact("[responder]: handshake successfully completed")
+    child.expect_exact("[initiator]: handshake successfully completed")
+    child.expect_exact("[initiator]: Transcript hash 4 (32 bytes):")
+    for line in LAKE_WG_EDHOC_TV_34900_TH4.split('\n'):
+        child.expect_exact(line)
+    child.sendline("init oscore")
+    child.expect_exact("OSCORE secret:")
+    for line in LAKE_WG_EDHOC_TV_34900_OSCORE_SECRET.split('\n'):
+        child.expect_exact(line)
+    child.expect_exact("OSCORE salt:")
+    child.expect_exact(LAKE_WG_EDHOC_TV_34900_OSCORE_SALT)
+    child.sendline("resp oscore")
+    child.expect_exact("OSCORE secret:")
+    for line in LAKE_WG_EDHOC_TV_34900_OSCORE_SECRET.split('\n'):
+        child.expect_exact(line)
+    child.expect_exact("OSCORE salt:")
+    child.expect_exact(LAKE_WG_EDHOC_TV_34900_OSCORE_SALT)
+
+
+if __name__ == "__main__":
+    sys.exit(run(testfunc))
diff --git a/tests/pkg_lvgl/app.config.sample b/tests/pkg_lvgl/app.config.sample
new file mode 100644
index 0000000000..e2682577f4
--- /dev/null
+++ b/tests/pkg_lvgl/app.config.sample
@@ -0,0 +1,5 @@
+# Sample lvgl configuration
+CONFIG_KCONFIG_USEPKG_LVGL=y
+CONFIG_LV_COLOR_DEPTH_16=y
+CONFIG_LV_COLOR_16_SWAP=y
+CONFIG_LV_MEM_SIZE_KILOBYTES=5
diff --git a/tests/pkg_lvgl/app.config.test b/tests/pkg_lvgl/app.config.test
new file mode 100644
index 0000000000..76c76f4330
--- /dev/null
+++ b/tests/pkg_lvgl/app.config.test
@@ -0,0 +1,2 @@
+CONFIG_PACKAGE_LVGL=y
+CONFIG_MODULE_LVGL_CONTRIB=y
diff --git a/tests/pkg_lvgl/main.c b/tests/pkg_lvgl/main.c
index 751f60efb8..44ea287982 100644
--- a/tests/pkg_lvgl/main.c
+++ b/tests/pkg_lvgl/main.c
@@ -111,9 +111,8 @@ void sysmon_create(void)
     info_label = lv_label_create(win, NULL);
     lv_label_set_recolor(info_label, true);
 
-    /* Refresh the chart and label manually at first */
+    /* Create the task used to refresh the chart and label */
     refr_task = lv_task_create(sysmon_task, REFR_TIME, LV_TASK_PRIO_LOW, NULL);
-    sysmon_task(NULL);
 }
 
 int main(void)
@@ -121,10 +120,10 @@ int main(void)
     /* Enable backlight */
     disp_dev_backlight_on();
 
-    lvgl_start();
-
     /* Create the system monitor widget */
     sysmon_create();
 
+    lvgl_run();
+
     return 0;
 }
diff --git a/tests/pkg_lvgl_touch/app.config.sample b/tests/pkg_lvgl_touch/app.config.sample
new file mode 100644
index 0000000000..e2682577f4
--- /dev/null
+++ b/tests/pkg_lvgl_touch/app.config.sample
@@ -0,0 +1,5 @@
+# Sample lvgl configuration
+CONFIG_KCONFIG_USEPKG_LVGL=y
+CONFIG_LV_COLOR_DEPTH_16=y
+CONFIG_LV_COLOR_16_SWAP=y
+CONFIG_LV_MEM_SIZE_KILOBYTES=5
diff --git a/tests/pkg_lvgl_touch/app.config.test b/tests/pkg_lvgl_touch/app.config.test
new file mode 100644
index 0000000000..19adbf3bb9
--- /dev/null
+++ b/tests/pkg_lvgl_touch/app.config.test
@@ -0,0 +1,5 @@
+CONFIG_PACKAGE_LVGL=y
+CONFIG_MODULE_LVGL_CONTRIB=y
+
+# Add touch capabilities
+CONFIG_MODULE_LVGL_CONTRIB_TOUCH=y
diff --git a/tests/pkg_lvgl_touch/main.c b/tests/pkg_lvgl_touch/main.c
index 0b76ef9edb..acb40e3b58 100644
--- a/tests/pkg_lvgl_touch/main.c
+++ b/tests/pkg_lvgl_touch/main.c
@@ -57,7 +57,7 @@ int main(void)
     lv_obj_t * label = lv_label_create(btn, NULL);
     lv_label_set_text(label, "Click me");
 
-    lvgl_start();
+    lvgl_run();
 
     return 0;
 }
diff --git a/tests/pkg_openwsn_sock_udp/Makefile b/tests/pkg_openwsn_sock_udp/Makefile
index 2e7df699ef..e564fdd903 100644
--- a/tests/pkg_openwsn_sock_udp/Makefile
+++ b/tests/pkg_openwsn_sock_udp/Makefile
@@ -38,7 +38,7 @@ USEMODULE += sock_udp
 
 # Mock OpenWSN scheduler to handle the udp_transmit task.
 USEMODULE += openwsn_scheduler_mock
-EXTERNAL_MODULE_DIRS += $(CURDIR)/scheduler
+EXTERNAL_MODULE_DIRS += external_modules
 
 # Explicitly include ztimer to enable timeout
 USEMODULE += ztimer_usec
diff --git a/tests/pkg_openwsn_sock_udp/scheduler/Makefile b/tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/Makefile
similarity index 50%
rename from tests/pkg_openwsn_sock_udp/scheduler/Makefile
rename to tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/Makefile
index 317693d201..48422e909a 100644
--- a/tests/pkg_openwsn_sock_udp/scheduler/Makefile
+++ b/tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/Makefile
@@ -1,3 +1 @@
-MODULE := openwsn_scheduler_mock
-
 include $(RIOTBASE)/Makefile.base
diff --git a/tests/pkg_openwsn_sock_udp/scheduler/Makefile.include b/tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/Makefile.include
similarity index 100%
rename from tests/pkg_openwsn_sock_udp/scheduler/Makefile.include
rename to tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/Makefile.include
diff --git a/tests/pkg_openwsn_sock_udp/scheduler/include/scheduler_types.h b/tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/include/scheduler_types.h
similarity index 100%
rename from tests/pkg_openwsn_sock_udp/scheduler/include/scheduler_types.h
rename to tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/include/scheduler_types.h
diff --git a/tests/pkg_openwsn_sock_udp/scheduler/scheduler.c b/tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/scheduler.c
similarity index 100%
rename from tests/pkg_openwsn_sock_udp/scheduler/scheduler.c
rename to tests/pkg_openwsn_sock_udp/external_modules/openwsn_scheduler_mock/scheduler.c
diff --git a/tests/pkg_qdsa/Makefile b/tests/pkg_qdsa/Makefile
index 7d855c09dc..29a486e486 100644
--- a/tests/pkg_qdsa/Makefile
+++ b/tests/pkg_qdsa/Makefile
@@ -2,7 +2,7 @@ include ../Makefile.tests_common
 
 CFLAGS += -DTHREAD_STACKSIZE_MAIN=\(4*THREAD_STACKSIZE_DEFAULT\)
 
-USEPKG += qDSA
+USEPKG += qdsa
 USEMODULE += random
 USEMODULE += embunit
 
diff --git a/tests/pkg_qdsa/app.config.test b/tests/pkg_qdsa/app.config.test
index f76f62ad49..cd44dc772c 100644
--- a/tests/pkg_qdsa/app.config.test
+++ b/tests/pkg_qdsa/app.config.test
@@ -1,3 +1,7 @@
 CONFIG_MODULE_EMBUNIT=y
 CONFIG_MODULE_RANDOM=y
+# Should be autoselecting the MODULE_PRNG_HWRNG if possible
+# Since the makefile cannot we have to override until end of migration
+# Remove when TEST_KCONFIG is complete
+CONFIG_MODULE_PRNG_TINYMT32=y
 CONFIG_PACKAGE_QDSA=y
diff --git a/tests/pkg_qr-code-generator/Kconfig b/tests/pkg_qr-code-generator/Kconfig
new file mode 100644
index 0000000000..e22856bd2b
--- /dev/null
+++ b/tests/pkg_qr-code-generator/Kconfig
@@ -0,0 +1,10 @@
+config APPLICATION
+    bool
+    default y
+    imply MODULE_DISP_DEV if BOARD_HAS_DISPLAY
+    depends on TEST_KCONFIG
+
+config BOARD_HAS_DISPLAY
+    bool
+    default y
+    depends on BOARD_PINETIME || BOARD_ADAFRUIT_CLUE || BOARD_STM32F429I_DISC1 || BOARD_STM32F429I_DISCO || BOARD_ESP32_WROVER_KIT
diff --git a/tests/pkg_qr-code-generator/Makefile b/tests/pkg_qr-code-generator/Makefile
new file mode 100644
index 0000000000..f728b51e4a
--- /dev/null
+++ b/tests/pkg_qr-code-generator/Makefile
@@ -0,0 +1,13 @@
+include ../Makefile.tests_common
+
+USEPKG += qr-code-generator
+
+MESSAGE_TO_ENCODE ?= "https://riot-os.org"
+
+CFLAGS += -DMESSAGE_TO_ENCODE=\"$(MESSAGE_TO_ENCODE)\"
+
+# This application provides a 'Kconfig' file and we want to explicitly disable
+# Kconfig by default by setting this variable to empty
+SHOULD_RUN_KCONFIG ?=
+
+include $(RIOTBASE)/Makefile.include
diff --git a/tests/pkg_qr-code-generator/Makefile.board.dep b/tests/pkg_qr-code-generator/Makefile.board.dep
new file mode 100644
index 0000000000..debabcf92e
--- /dev/null
+++ b/tests/pkg_qr-code-generator/Makefile.board.dep
@@ -0,0 +1,4 @@
+# Boards with a screen can use disp_dev
+ifneq (,$(filter stm32f429i-disc% pinetime adafruit-clue esp32-wrover-kit,$(BOARD)))
+  USEMODULE += disp_dev
+endif
diff --git a/tests/pkg_qr-code-generator/app.config.test b/tests/pkg_qr-code-generator/app.config.test
new file mode 100644
index 0000000000..105f736641
--- /dev/null
+++ b/tests/pkg_qr-code-generator/app.config.test
@@ -0,0 +1 @@
+CONFIG_PACKAGE_QR-CODE-GENERATOR=y
diff --git a/tests/pkg_qr-code-generator/main.c b/tests/pkg_qr-code-generator/main.c
new file mode 100644
index 0000000000..5c97c32c90
--- /dev/null
+++ b/tests/pkg_qr-code-generator/main.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2021 Inria
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     tests
+ * @{
+ *
+ * @file
+ * @brief       Test application for the qr-code-generator package
+ *
+ * @author      Alexandre Abadie <alexandre.abadie@inria.fr>
+ *
+ * @}
+ */
+
+#include <stdio.h>
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "test_utils/expect.h"
+
+#include "qrcodegen.h"
+
+#ifdef MODULE_DISP_DEV
+#include "disp_dev.h"
+#endif
+
+#ifndef MESSAGE_TO_ENCODE
+#define MESSAGE_TO_ENCODE   "unknown"
+#endif
+
+/* Compute buffer sizes based on the message to encode len to avoid a
+ * failed assertion in qrcodegen */
+#define ENCODER_VERSION     (sizeof(MESSAGE_TO_ENCODE) >> 3)
+static uint8_t qr0[qrcodegen_BUFFER_LEN_FOR_VERSION(ENCODER_VERSION)];
+static uint8_t buffer[qrcodegen_BUFFER_LEN_FOR_VERSION(ENCODER_VERSION)];
+
+#ifdef MODULE_DISP_DEV
+#define DISPLAY_BUFFER_MAX_SIZE (320)
+static uint16_t display_buffer[DISPLAY_BUFFER_MAX_SIZE] = { 0 };
+#endif
+
+int main(void)
+{
+    expect(ENCODER_VERSION <= qrcodegen_VERSION_MAX);
+
+    if (!qrcodegen_encodeText(MESSAGE_TO_ENCODE,
+                              buffer, qr0, qrcodegen_Ecc_MEDIUM,
+                              qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX,
+                              qrcodegen_Mask_AUTO, true)) {
+        puts("Encoding error");
+        return -1;
+    }
+
+    int size = qrcodegen_getSize(qr0);
+
+#ifdef MODULE_DISP_DEV
+    /* Use the first screen */
+    disp_dev_reg_t *disp_dev = disp_dev_reg_find_screen(0);
+    if (!disp_dev) {
+        puts("No screen found!");
+        return -1;
+    }
+    disp_dev_backlight_on();
+
+    /* Compute scaling factor and height/width offsets */
+    const uint8_t scale = disp_dev_height(disp_dev->dev) / size;
+    const uint8_t w_offset = (disp_dev_width(disp_dev->dev) - (size * scale)) / 2;
+    const uint8_t h_offset = (disp_dev_height(disp_dev->dev) - (size * scale)) / 2;
+
+    /* Clear the screen */
+    for (uint16_t y = 0; y < disp_dev_height(disp_dev->dev); y ++) {
+        disp_dev_map(disp_dev->dev, 0, disp_dev_width(disp_dev->dev) - 1, y, y, display_buffer);
+    }
+
+    /* Prepare a subset of the display buffer for white tiles */
+    for (int w = 0; w < scale; w++) {
+        for (int h = 0; h < scale; h++) {
+            display_buffer[w + h * scale] = UINT16_MAX;
+        }
+    }
+#endif
+
+    for (int y = 0; y < size; y++) {
+        for (int x = 0; x < size; x++) {
+#ifdef MODULE_DISP_DEV
+            if (qrcodegen_getModule(qr0, x, y)) {
+                disp_dev_map(disp_dev->dev,
+                             w_offset + (x * scale), w_offset + ((x + 1)* scale) - 1,
+                             h_offset + (y * scale), h_offset + ((y + 1)* scale) - 1,
+                             display_buffer);
+            }
+#endif
+            printf("%s", qrcodegen_getModule(qr0, x, y) ? "██" : "  ");
+
+        }
+        puts("");
+    }
+
+    return 0;
+}
diff --git a/tests/pkg_qr-code-generator/tests/01-run.py b/tests/pkg_qr-code-generator/tests/01-run.py
new file mode 100755
index 0000000000..d3961f6a21
--- /dev/null
+++ b/tests/pkg_qr-code-generator/tests/01-run.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2021 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import sys
+from testrunner import run
+
+
+QR_CODE = (
+    "██████████████  ██████████    ██    ██████████████\n"
+    "██          ██  ██    ██      ████  ██          ██\n"
+    "██  ██████  ██  ████    ██  ████    ██  ██████  ██\n"
+    "██  ██████  ██  ████        ██      ██  ██████  ██\n"
+    "██  ██████  ██  ██████████  ████    ██  ██████  ██\n"
+    "██          ██    ██  ██    ████    ██          ██\n"
+    "██████████████  ██  ██  ██  ██  ██  ██████████████\n"
+    "                ██      ██████  ██                \n"
+    "  ████  ██  ████    ██████  ██████  ██  ██████████\n"
+    "  ████    ██  ████████  ██        ████          ██\n"
+    "  ██  ████████  ██  ██  ████                ██████\n"
+    "██████  ██    ██    ██  ██            ██      ██  \n"
+    "          ████████  ██  ██        ██████  ██  ████\n"
+    "  ██          ████    ██  ██    ██████    ██    ██\n"
+    "██    ██    ██    ████████        ██  ██    ██████\n"
+    "  ██    ████  ████    ██        ██  ██  ██    ██  \n"
+    "██      ██  ██████          ████████████████      \n"
+    "                ██████    ██  ████      ████  ████\n"
+    "██████████████  ████████  ████████  ██  ████  ████\n"
+    "██          ██    ██  ██████    ██      ████    ██\n"
+    "██  ██████  ██  ██████████      ████████████    ██\n"
+    "██  ██████  ██    ████  ██  ██        ████████    \n"
+    "██  ██████  ██  ██  ████      ██  ██    ██      ██\n"
+    "██          ██  ████    ██████████      ████  ██  \n"
+    "██████████████          ██      ██  ████      ████\n"
+)
+
+
+def testfunc(child):
+    for line in QR_CODE.split("\n"):
+        child.expect_exact(line)
+    print("\nSUCCESS")
+
+
+if __name__ == "__main__":
+    sys.exit(run(testfunc))
diff --git a/tests/pkg_semtech-loramac/Makefile.ci b/tests/pkg_semtech-loramac/Makefile.ci
index d79a66f7ce..eef0cd323f 100644
--- a/tests/pkg_semtech-loramac/Makefile.ci
+++ b/tests/pkg_semtech-loramac/Makefile.ci
@@ -5,6 +5,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-uno \
     atmega328p \
     atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
     nucleo-f031k6 \
     nucleo-f042k6 \
     nucleo-l011k4 \
diff --git a/tests/pkg_semtech-loramac/README.md b/tests/pkg_semtech-loramac/README.md
index 3da6d09fc5..e2cf16efee 100644
--- a/tests/pkg_semtech-loramac/README.md
+++ b/tests/pkg_semtech-loramac/README.md
@@ -256,7 +256,7 @@ for ABP. The test assumes that both devices have the same Application EUI.
 
 2. flash device with the appropriate keys and test
 
-    $ DEVEUI=<...> APPEUI=<...> APPKEY=<...> DEVADDR=<...> NWKSKEY=<...> APPSKEY=<...> RX2_DR=<...> IOTLAB_NODE=auto-ssh make -C tests/pkg_semtech-loramac flash test
+    $ DEVEUI=<...> APPEUI=<...> APPKEY=<...> DEVADDR=<...> NWKSKEY=<...> APPSKEY=<...> RX2_DR=<...> IOTLAB_NODE=auto make -C tests/pkg_semtech-loramac flash test
 
 3. stop the iotlab experiment:
 
@@ -265,4 +265,4 @@ for ABP. The test assumes that both devices have the same Application EUI.
 _note_: if you have multiple running experiments you will need to set `IOTLAB_EXP_ID`
         to the appropriate experiment, when using the `iotlab-exp` you will see a:
         `Waiting that experiment 175694 gets in state Running`. That number matches
-        the experiment id you started.
\ No newline at end of file
+        the experiment id you started.
diff --git a/tests/pkg_tensorflow-lite/Makefile b/tests/pkg_tensorflow-lite/Makefile
index 698b61a04f..cdb9b2b7c0 100644
--- a/tests/pkg_tensorflow-lite/Makefile
+++ b/tests/pkg_tensorflow-lite/Makefile
@@ -14,7 +14,7 @@ ifeq (mnist,$(EXAMPLE))
   # default for now
   DISABLE_MODULE += cortexm_fpu
   USEMODULE += $(EXAMPLE)
-  EXTERNAL_MODULE_DIRS += $(CURDIR)/$(EXAMPLE)
+  EXTERNAL_MODULE_DIRS += external_modules
 else
   # Use upstream example
   USEMODULE += tensorflow-lite-$(EXAMPLE)
diff --git a/tests/pkg_tensorflow-lite/Makefile.ci b/tests/pkg_tensorflow-lite/Makefile.ci
index 30c0a786cc..0cd2baf66d 100644
--- a/tests/pkg_tensorflow-lite/Makefile.ci
+++ b/tests/pkg_tensorflow-lite/Makefile.ci
@@ -1,6 +1,9 @@
 BOARD_INSUFFICIENT_MEMORY := \
     airfy-beacon \
-    arduino-mkr% \
+    arduino-mkr1000 \
+    arduino-mkrfox1200 \
+    arduino-mkrwan1300 \
+    arduino-mkrzero \
     b-l072z-lrwan1 \
     blackpill \
     bluepill \
@@ -14,11 +17,20 @@ BOARD_INSUFFICIENT_MEMORY := \
     nrf51dk \
     nrf51dongle \
     nrf6310 \
-    nucleo-f0% \
+    nucleo-f030r8 \
+    nucleo-f031k6 \
+    nucleo-f042k6 \
+    nucleo-f070rb \
+    nucleo-f072rb \
+    nucleo-f091rc \
     nucleo-f302r8 \
     nucleo-f303k8 \
     nucleo-f334r8 \
-    nucleo-l0% \
+    nucleo-g071rb \
+    nucleo-l011k4 \
+    nucleo-l031k6 \
+    nucleo-l053r8 \
+    nucleo-l073rz \
     phynode-kw41z \
     samd10-xmini \
     samd21-xpro \
@@ -30,7 +42,11 @@ BOARD_INSUFFICIENT_MEMORY := \
     samr34-xpro \
     sensebox_samd21 \
     slstk3400a \
-    sodaq-% \
+    sodaq-autonomo \
+    sodaq-explorer \
+    sodaq-one \
+    sodaq-sara-aff \
+    sodaq-sara-sff \
     stk3200 \
     stm32f030f4-demo \
     stm32f0discovery \
diff --git a/tests/pkg_tensorflow-lite/mnist/.gitignore b/tests/pkg_tensorflow-lite/external_modules/mnist/.gitignore
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/.gitignore
rename to tests/pkg_tensorflow-lite/external_modules/mnist/.gitignore
diff --git a/tests/pkg_tensorflow-lite/mnist/Makefile b/tests/pkg_tensorflow-lite/external_modules/mnist/Makefile
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/Makefile
rename to tests/pkg_tensorflow-lite/external_modules/mnist/Makefile
diff --git a/tests/pkg_tensorflow-lite/mnist/digit b/tests/pkg_tensorflow-lite/external_modules/mnist/digit
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/digit
rename to tests/pkg_tensorflow-lite/external_modules/mnist/digit
diff --git a/tests/pkg_tensorflow-lite/mnist/generate_digit.py b/tests/pkg_tensorflow-lite/external_modules/mnist/generate_digit.py
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/generate_digit.py
rename to tests/pkg_tensorflow-lite/external_modules/mnist/generate_digit.py
diff --git a/tests/pkg_tensorflow-lite/mnist/main_functions.cc b/tests/pkg_tensorflow-lite/external_modules/mnist/main_functions.cc
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/main_functions.cc
rename to tests/pkg_tensorflow-lite/external_modules/mnist/main_functions.cc
diff --git a/tests/pkg_tensorflow-lite/mnist/mnist_mlp.py b/tests/pkg_tensorflow-lite/external_modules/mnist/mnist_mlp.py
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/mnist_mlp.py
rename to tests/pkg_tensorflow-lite/external_modules/mnist/mnist_mlp.py
diff --git a/tests/pkg_tensorflow-lite/mnist/model.tflite b/tests/pkg_tensorflow-lite/external_modules/mnist/model.tflite
similarity index 100%
rename from tests/pkg_tensorflow-lite/mnist/model.tflite
rename to tests/pkg_tensorflow-lite/external_modules/mnist/model.tflite
diff --git a/tests/pkg_umorse/Makefile.ci b/tests/pkg_umorse/Makefile.ci
new file mode 100644
index 0000000000..36f350148a
--- /dev/null
+++ b/tests/pkg_umorse/Makefile.ci
@@ -0,0 +1,2 @@
+BOARD_INSUFFICIENT_MEMORY := \
+    nucleo-l011k4 \
diff --git a/tests/pkg_utensor/Makefile b/tests/pkg_utensor/Makefile
index b5b6d8e691..1daff36282 100644
--- a/tests/pkg_utensor/Makefile
+++ b/tests/pkg_utensor/Makefile
@@ -7,7 +7,7 @@ BLOBS += digit
 
 # Include C++ model and training weights code as an external module
 USEMODULE += models
-EXTERNAL_MODULE_DIRS += $(CURDIR)/models
+EXTERNAL_MODULE_DIRS += external_modules
 
 include $(RIOTBASE)/Makefile.include
 
diff --git a/tests/pkg_utensor/external_modules/models/Makefile b/tests/pkg_utensor/external_modules/models/Makefile
new file mode 100644
index 0000000000..48422e909a
--- /dev/null
+++ b/tests/pkg_utensor/external_modules/models/Makefile
@@ -0,0 +1 @@
+include $(RIOTBASE)/Makefile.base
diff --git a/tests/pkg_utensor/models/Makefile.include b/tests/pkg_utensor/external_modules/models/Makefile.include
similarity index 100%
rename from tests/pkg_utensor/models/Makefile.include
rename to tests/pkg_utensor/external_modules/models/Makefile.include
diff --git a/tests/pkg_utensor/models/deep_mlp.cpp b/tests/pkg_utensor/external_modules/models/deep_mlp.cpp
similarity index 100%
rename from tests/pkg_utensor/models/deep_mlp.cpp
rename to tests/pkg_utensor/external_modules/models/deep_mlp.cpp
diff --git a/tests/pkg_utensor/models/deep_mlp.hpp b/tests/pkg_utensor/external_modules/models/deep_mlp.hpp
similarity index 100%
rename from tests/pkg_utensor/models/deep_mlp.hpp
rename to tests/pkg_utensor/external_modules/models/deep_mlp.hpp
diff --git a/tests/pkg_utensor/models/deep_mlp_weight.hpp b/tests/pkg_utensor/external_modules/models/deep_mlp_weight.hpp
similarity index 100%
rename from tests/pkg_utensor/models/deep_mlp_weight.hpp
rename to tests/pkg_utensor/external_modules/models/deep_mlp_weight.hpp
diff --git a/tests/pkg_utensor/main.cpp b/tests/pkg_utensor/main.cpp
index 8ff11d25fe..d85f4cea57 100644
--- a/tests/pkg_utensor/main.cpp
+++ b/tests/pkg_utensor/main.cpp
@@ -23,7 +23,7 @@
 
 #include "blob/digit.h"         //contains a sample taken from the MNIST test set
 
-#include "models/deep_mlp.hpp"  //generated model file
+#include "deep_mlp.hpp"         //generated model file
 #include "tensor.hpp"           //useful tensor classes
 
 int main()
diff --git a/tests/pthread_cooperation/Makefile b/tests/pthread_cooperation/Makefile
index 184da9ce8c..a9a67f8f13 100644
--- a/tests/pthread_cooperation/Makefile
+++ b/tests/pthread_cooperation/Makefile
@@ -2,7 +2,7 @@ include ../Makefile.tests_common
 
 # nucleo-f303k8 doesn't have enough RAM to run the test so we reduce the stack
 # size for every thread
-ifneq (,$(filter nucleo-f303k8,$(BOARD)))
+ifneq (,$(filter nucleo-f303k8 nucleo-f334r8,$(BOARD)))
   CFLAGS += -DTHREAD_STACKSIZE_DEFAULT=512
 endif
 
diff --git a/tests/riotboot_flashwrite/Makefile b/tests/riotboot_flashwrite/Makefile
index d118d97ce3..c34233ac25 100644
--- a/tests/riotboot_flashwrite/Makefile
+++ b/tests/riotboot_flashwrite/Makefile
@@ -1,61 +1,77 @@
-DEVELHELP ?= 0
+# If no BOARD is found in the environment, use this default:
 BOARD ?= samr21-xpro
+
 include ../Makefile.tests_common
 
 # Include packages that pull up and auto-init the link layer.
-# NOTE: 6LoWPAN will be included if IEEE802.15.4 devices are present
-USEMODULE += gnrc_netdev_default
 USEMODULE += auto_init_gnrc_netif
 # Specify the mandatory networking modules for IPv6 and UDP
 USEMODULE += gnrc_ipv6_default
-USEMODULE += gnrc_ipv6_router_default
 USEMODULE += sock_udp
 # Additional networking modules that can be dropped if not needed
 USEMODULE += gnrc_icmpv6_echo
 
+# Required for nanocoap server
 USEMODULE += nanocoap_sock
 
 # include this for printing IP addresses
+USEMODULE += shell
 USEMODULE += shell_commands
 
-# Comment this out to enable code in RIOT that does safety checking
-# which is not needed in a production environment but helps in the
-# development process:
-#DEVELHELP = 1
-
-# Use different settings when compiling for one of the following (low-memory)
-# boards
-LOW_MEMORY_BOARDS := nucleo-f334r8
-
-# uncomment these to use ethos
-#USEMODULE += stdio_ethos gnrc_uhcpc
-#
-## ethos baudrate can be configured from make command
-#ETHOS_BAUDRATE ?= 115200
-#CFLAGS += -DETHOS_BAUDRATE=$(ETHOS_BAUDRATE)
-
-ifneq (,$(filter $(BOARD),$(LOW_MEMORY_BOARDS)))
-  $(info Using low-memory configuration for microcoap_server.)
-  ## low-memory tuning values
-  USEMODULE += prng_minstd
-endif
-
 # include riotboot modules
 USEMODULE += riotboot_flashwrite
 FEATURES_REQUIRED += riotboot
 
-# Change this to 0 show compiler invocation lines by default:
-QUIET ?= 1
+# Change this to 0 to not use ethos and instead include 6LoWPAN if
+# IEEE802.15.4 devices are present
+USE_ETHOS ?= 1
+
+ifeq (1,$(USE_ETHOS))
+  USEMODULE += stdio_ethos
+  USEMODULE += gnrc_uhcpc
+
+  # ethos baudrate can be configured from make command
+  ETHOS_BAUDRATE ?= 115200
+  CFLAGS += -DETHOS_BAUDRATE=$(ETHOS_BAUDRATE)
+
+  # make sure ethos and uhcpd are built
+  TERMDEPS += host-tools
+
+  # For local testing, run
+  #
+  #     $ cd dist/tools/ethos; sudo ./setup_network.sh riot0 2001:db8::0/64
+  #
+  #... in another shell and keep it running.
+  export TAP ?= riot0
+  TERMPROG = $(RIOTTOOLS)/ethos/ethos
+  TERMFLAGS = $(TAP) $(PORT)
+else
+  USEMODULE += gnrc_netdev_default
+endif
+
+# Ensure both slot bin files are always generated and linked to avoid compiling
+# during the test. This ensures that "BUILD_IN_DOCKER=1 make test"
+# can rely on them being present without having to trigger re-compilation.
+BUILD_FILES += $(SLOT_RIOT_ELFS:%.elf=%.bin)
+
+# The test needs the linked slot binaries without header in order to be able to
+# create final binaries with specific APP_VER values. The CI RasPi test workers
+# don't compile themselves, thus add the required files here so they will be
+# submitted along with the test jobs.
+TEST_EXTRA_FILES += $(SLOT_RIOT_ELFS)
 
 include $(RIOTBASE)/Makefile.include
 
-ifneq (,$(filter $(BOARD),$(LOW_MEMORY_BOARDS)))
-  # lower pktbuf buffer size
-  # Set GNRC_PKTBUF_SIZE via CFLAGS if not being set via Kconfig.
-  ifndef CONFIG_GNRC_PKTBUF_SIZE
-    CFLAGS += -DCONFIG_GNRC_PKTBUF_SIZE=1000
-  endif
+# lower pktbuf size to something sufficient for this application
+# Set GNRC_PKTBUF_SIZE via CFLAGS if not being set via Kconfig.
+ifndef CONFIG_GNRC_PKTBUF_SIZE
+  CFLAGS += -DCONFIG_GNRC_PKTBUF_SIZE=2000
 endif
 
 # Set a custom channel if needed
 include $(RIOTMAKE)/default-radio-settings.inc.mk
+
+.PHONY: host-tools
+
+host-tools:
+	$(Q)env -u CC -u CFLAGS make -C $(RIOTTOOLS)
diff --git a/tests/riotboot_flashwrite/README.md b/tests/riotboot_flashwrite/README.md
index eb30334868..76dd90198c 100644
--- a/tests/riotboot_flashwrite/README.md
+++ b/tests/riotboot_flashwrite/README.md
@@ -8,11 +8,38 @@ over network without *any* kind of authentication or other security!
 Please see the README of examples/nanocoap_server for instructions on how to
 set up a network for testing.
 
-# How to test
+## Requirements
+
+This test uses [aiocoap](https://pypi.org/project/aiocoap/) to send the firmware to the device over coap.
+
+### How to test over Ethos
+
+First set up the network:
+
+    $ sudo dist/tools/ethos/setup_network.sh riot0 2001:db8::/64
+
+Then provide de device and test:
+
+    $ BOARD=<board> make flash test-with-config
+
+### How to test over the air (802.15.4)
+
+On another device setup a BR and start `start_network.sh` on that device serial
+port.
+
+    $ BOARD=<board> make -C examples/gnrc_border_router flash
+
+    $ sudo dist/tools/ethos/start_network.sh /dev/ttyACMx riot0 2001:db8::/64
+
+Then provide the device and test:
+
+    $ USE_ETHOS=0 BOARD=<board> make flash test-with-config
+
+### Manual test
 
 First, compile and flash with riotboot enabled:
 
-    $ BOARD=<board> make riotboot/flash
+    $ BOARD=<board> make flash
 
 Confirm it booted from slot 0 (it should print "Current slot=0"), then
 recompile in order to get an image for the second slot with a newer version
diff --git a/tests/riotboot_flashwrite/main.c b/tests/riotboot_flashwrite/main.c
index 3c7246f87c..ebf6144f01 100644
--- a/tests/riotboot_flashwrite/main.c
+++ b/tests/riotboot_flashwrite/main.c
@@ -19,43 +19,111 @@
 
 #include <stdio.h>
 
+#include "thread.h"
+#include "irq.h"
 #include "net/nanocoap_sock.h"
-#include "xtimer.h"
+
+#include "shell.h"
+
 #include "riotboot/slot.h"
+#include "riotboot/flashwrite.h"
 
 #define COAP_INBUF_SIZE (256U)
 
+/* Extend stacksize of nanocoap server thread */
+static char _nanocoap_server_stack[THREAD_STACKSIZE_DEFAULT + THREAD_EXTRA_STACKSIZE_PRINTF];
+#define NANOCOAP_SERVER_QUEUE_SIZE     (8)
+static msg_t _nanocoap_server_msg_queue[NANOCOAP_SERVER_QUEUE_SIZE];
+
 #define MAIN_QUEUE_SIZE     (8)
 static msg_t _main_msg_queue[MAIN_QUEUE_SIZE];
 
-/* import "ifconfig" shell command, used for printing addresses */
-extern int _gnrc_netif_config(int argc, char **argv);
+static void *_nanocoap_server_thread(void *arg)
+{
+    (void)arg;
 
-int main(void)
+    /* nanocoap_server uses gnrc sock which uses gnrc which needs a msg queue */
+    msg_init_queue(_nanocoap_server_msg_queue, NANOCOAP_SERVER_QUEUE_SIZE);
+
+    /* initialize nanocoap server instance */
+    uint8_t buf[COAP_INBUF_SIZE];
+    sock_udp_ep_t local = { .port=COAP_PORT, .family=AF_INET6 };
+    nanocoap_server(&local, buf, sizeof(buf));
+
+    return NULL;
+}
+
+static int cmd_print_riotboot_hdr(int argc, char **argv)
 {
-    puts("riotboot_flashwrite test application");
+    (void)argc;
+    (void)argv;
 
     int current_slot = riotboot_slot_current();
-    printf("Current slot=%d\n", current_slot);
-    riotboot_slot_print_hdr(current_slot);
+    if (current_slot != -1) {
+        /* Sometimes, udhcp output messes up the following printfs.  That
+         * confuses the test script. As a workaround, just disable interrupts
+         * for a while.
+         */
+        unsigned state = irq_disable();
+        riotboot_slot_print_hdr(current_slot);
+        irq_restore(state);
+    }
+    else {
+        puts("[FAILED] You're not running riotboot");
+    }
+    return 0;
+}
 
-    /* nanocoap_server uses gnrc sock which uses gnrc which needs a msg queue */
-    msg_init_queue(_main_msg_queue, MAIN_QUEUE_SIZE);
+static int cmd_print_current_slot(int argc, char **argv)
+{
+    (void)argc;
+    (void)argv;
+    /* Sometimes, udhcp output messes up the following printfs.  That
+     * confuses the test script. As a workaround, just disable interrupts
+     * for a while.
+     */
+    unsigned state = irq_disable();
+    printf("Running from slot %d\n", riotboot_slot_current());
+    irq_restore(state);
+    return 0;
+}
+
+static int cmd_riotboot_invalidate(int argc, char **argv)
+{
+    if (argc < 2) {
+        puts("usage: riotboot-invalidate <slot number>");
+    }
+    riotboot_flashwrite_invalidate(atoi(argv[1]));
+    return 0;
+}
+
+static const shell_command_t shell_commands[] = {
+    { "current-slot", "Print current slot number", cmd_print_current_slot },
+    { "riotboot-hdr", "Print current slot header", cmd_print_riotboot_hdr },
+    { "riotboot-invalidate", "Invalidate slot <slot number>", cmd_riotboot_invalidate },
+    { NULL, NULL, NULL }
+};
 
-    puts("");
+int main(void)
+{
+    puts("riotboot_flashwrite test application");
 
-    puts("Waiting for address autoconfiguration...");
-    xtimer_sleep(3);
+    cmd_print_current_slot(0, NULL);
+    cmd_print_riotboot_hdr(0, NULL);
 
-    /* print network addresses */
-    puts("Configured network interfaces:");
-    _gnrc_netif_config(0, NULL);
+    /* start nanocoap server thread */
+    thread_create(_nanocoap_server_stack, sizeof(_nanocoap_server_stack),
+                  THREAD_PRIORITY_MAIN - 1,
+                  THREAD_CREATE_STACKTEST,
+                  _nanocoap_server_thread, NULL, "nanocoap server");
 
-    /* initialize nanocoap server instance */
-    uint8_t buf[COAP_INBUF_SIZE];
-    sock_udp_ep_t local = { .port=COAP_PORT, .family=AF_INET6 };
-    nanocoap_server(&local, buf, sizeof(buf));
+    /* the shell contains commands that receive packets via GNRC and thus
+       needs a msg queue */
+    msg_init_queue(_main_msg_queue, MAIN_QUEUE_SIZE);
+
+    puts("Starting the shell");
+    char line_buf[SHELL_DEFAULT_BUFSIZE];
+    shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);
 
-    /* should be never reached */
     return 0;
 }
diff --git a/tests/riotboot_flashwrite/tests-with-config/01-run.py b/tests/riotboot_flashwrite/tests-with-config/01-run.py
new file mode 100755
index 0000000000..4752a2a9ec
--- /dev/null
+++ b/tests/riotboot_flashwrite/tests-with-config/01-run.py
@@ -0,0 +1,163 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2019 Inria
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import os
+import subprocess
+import sys
+import time
+
+from testrunner import run
+from testrunner import utils
+
+
+UPDATING_TIMEOUT = 10
+
+USE_ETHOS = int(os.getenv("USE_ETHOS", "1"))
+TAP = os.getenv("TAP", "riot0")
+BINDIR = os.getenv("BINDIR")
+
+
+def wait_for_update(child):
+    return child.expect([r"_flashwrite_handler\(\): received data: offset=\d+ "
+                         r"len=\d+ blockwise=\d+ more=\d+\r\n",
+                         r"_flashwrite_handler\(\): finish\r\n"],
+                        timeout=UPDATING_TIMEOUT)
+
+
+def make_notify(client_url, slot, version):
+    cmd = [
+        "aiocoap-client",
+        "-m",
+        "POST",
+        "coap://{}/flashwrite".format(client_url),
+        "--payload",
+        "@tests_riotboot_flashwrite-slot{}.{}.riot.bin".format(slot, version),
+        "--payload-initial-szx",
+        "2",
+    ]
+    return subprocess.Popen(cmd, cwd=BINDIR)
+
+
+def make_riotboot_slots(version):
+    cmd = [
+        "make",
+        "USE_ETHOS={}".format(USE_ETHOS),
+        "RIOTBOOT_SKIP_COMPILE=1",
+        "APP_VER={}".format(version),
+        "riotboot",
+    ]
+    assert not subprocess.call(cmd)
+
+
+def get_ipv6_addr(child):
+    child.expect_exact('>')
+    child.sendline('ifconfig')
+    if USE_ETHOS == 0:
+        # Get device global address
+        child.expect(
+            r"inet6 addr: (?P<gladdr>[0-9a-fA-F:]+:[A-Fa-f:0-9]+)"
+            "  scope: global  VAL"
+        )
+        addr = child.match.group("gladdr").lower()
+    else:
+        # Get device local address
+        child.expect_exact("Link type: wired")
+        child.expect(
+            r"inet6 addr: (?P<lladdr>[0-9a-fA-F:]+:[A-Fa-f:0-9]+)"
+            "  scope: link  VAL"
+        )
+        addr = "{}%{}".format(child.match.group("lladdr").lower(), TAP)
+    return addr
+
+
+def ping6(client):
+    print("pinging node...")
+    ping_ok = False
+    for _ in range(10):
+        try:
+            subprocess.check_call(["ping", "-q", "-c1", "-w1", client])
+            ping_ok = True
+            break
+        except subprocess.CalledProcessError:
+            pass
+
+    if not ping_ok:
+        print("pinging node failed. aborting test.")
+        sys.exit(1)
+    else:
+        print("pinging node succeeded.")
+    return ping_ok
+
+
+def get_reachable_addr(child):
+    # Give some time for the network interface to be configured
+    time.sleep(1)
+    # Get address
+    client_addr = get_ipv6_addr(child)
+    # Verify address is reachable
+    ping6(client_addr)
+    return "[{}]".format(client_addr)
+
+
+def app_version(child):
+    utils.test_utils_interactive_sync_shell(child, 5, 1)
+    # get version of currently running image
+    # "Image Version: 0x00000000"
+    child.sendline('riotboot-hdr')
+    child.expect(r"Image Version: (?P<app_ver>0x[0-9a-fA-F:]+)\r\n")
+    app_ver = int(child.match.group("app_ver"), 16)
+    return app_ver
+
+
+def running_slot(child):
+    utils.test_utils_interactive_sync_shell(child, 5, 1)
+    # get version of currently running image
+    # "Image Version: 0x00000000"
+    child.sendline('current-slot')
+    child.expect(r"Running from slot (\d+)\r\n")
+    slot = int(child.match.group(1))
+    return slot
+
+
+def testfunc(child):
+    # Get current app_ver and slot
+    current_app_ver = app_version(child)
+    current_slot = running_slot(child)
+    # Verify client is reachable and get address
+    client = get_reachable_addr(child)
+
+    for version in [current_app_ver + 1, current_app_ver + 2]:
+        # Create newer slots bins
+        make_riotboot_slots(version)
+        # Trigger update process
+        make_notify(client, current_slot ^ 1, version)
+        child.expect(
+            r"riotboot_flashwrite: initializing update to target slot (\d+)\r\n",
+        )
+        target_slot = int(child.match.group(1))
+        # Wait for update to complete
+        while wait_for_update(child) == 0:
+            pass
+        child.sendline('reboot')
+        child.expect_exact("Starting the shell")
+        # Verify running slot
+        current_slot = running_slot(child)
+        assert target_slot == current_slot, "BOOTED FROM SAME SLOT"
+        # Verify client is reachable and get address
+        client = get_reachable_addr(child)
+
+    child.sendline("riotboot-invalidate {}".format(current_slot))
+    child.sendline('reboot')
+    child.expect_exact("Starting the shell")
+    assert running_slot(child) != current_slot, "DID NOT INVALIDATE"
+
+    print("TEST PASSED")
+
+
+if __name__ == "__main__":
+    sys.exit(run(testfunc, echo=True))
diff --git a/tests/sys_arduino/Makefile.ci b/tests/sys_arduino/Makefile.ci
index b9ff275375..6dd33c6f04 100644
--- a/tests/sys_arduino/Makefile.ci
+++ b/tests/sys_arduino/Makefile.ci
@@ -1,3 +1,6 @@
 BOARD_INSUFFICIENT_MEMORY := \
+    arduino-uno \
+    arduino-duemilanove \
+    arduino-nano \
     nucleo-l011k4 \
     #
diff --git a/tests/sys_crypto/Makefile b/tests/sys_crypto/Makefile
index 0389e162a0..f9438f3de8 100644
--- a/tests/sys_crypto/Makefile
+++ b/tests/sys_crypto/Makefile
@@ -2,7 +2,9 @@ include ../Makefile.tests_common
 
 USEMODULE += embunit
 
-USEMODULE += crypto_3des
 USEMODULE += cipher_modes
+USEMODULE += crypto_aes_128
+USEMODULE += crypto_aes_192
+USEMODULE += crypto_aes_256
 
 include $(RIOTBASE)/Makefile.include
diff --git a/tests/sys_crypto/Makefile.ci b/tests/sys_crypto/Makefile.ci
index 6f722e32bd..aa7a5ddab2 100644
--- a/tests/sys_crypto/Makefile.ci
+++ b/tests/sys_crypto/Makefile.ci
@@ -4,9 +4,14 @@ BOARD_INSUFFICIENT_MEMORY := \
     arduino-mega2560 \
     arduino-nano \
     arduino-uno \
+    atmega1284p \
     atmega328p \
     atmega328p-xplained-mini \
     atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
+    derfmega128 \
+    mega-xplained \
+    microduino-corerf \
     msb-430 \
     msb-430h \
     nucleo-f031k6 \
@@ -19,4 +24,5 @@ BOARD_INSUFFICIENT_MEMORY := \
     telosb \
     waspmote-pro \
     z1 \
+    zigduino \
     #
diff --git a/tests/sys_crypto/README.md b/tests/sys_crypto/README.md
new file mode 100644
index 0000000000..97f16ef3c9
--- /dev/null
+++ b/tests/sys_crypto/README.md
@@ -0,0 +1,33 @@
+# Overview
+
+This test application tests all the components of the crypto module in RIOT.
+Specifically these are:
+
+* ChaCha. Test vectors from [draft-strombergson-chacha-test-vectors-00].
+* Poly1305. Test vectors from [draft-nir-cfrg-chacha20-poly1305-06].
+* ChaCha20-Poly1305. Test vectors from [rfc7539].
+* AES-CBC. Test vectors from [SP 800-38C].
+* AES-CCM. Test vectors from [RFC3610], [SP 800-38C], [Wycheproof].
+* AES-CTR. Test vectors from [SP 800-38C].
+* AES-ECB. Test vectors from [SP 800-38C].
+* AES-OCB. Test vectors from [RFC7253].
+
+To build the test application run
+
+```
+make
+```
+
+To execute the test run
+
+```
+make term
+```
+
+[draft-nir-cfrg-chacha20-poly1305-06]: https://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-06#appendix-A.3
+[draft-strombergson-chacha-test-vectors-00]: https://tools.ietf.org/html/draft-strombergson-chacha-test-vectors-00
+[rfc7539]: https://tools.ietf.org/html/rfc7539#appendix-A
+[SP 800-38C]: http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
+[RFC3610]: https://tools.ietf.org/html/rfc3610
+[Wycheproof]: https://github.com/google/wycheproof/blob/master/testvectors/aes_ccm_test.json
+[RFC7253]: https://tools.ietf.org/html/rfc7253#appendix-A
\ No newline at end of file
diff --git a/tests/sys_crypto/app.config.test b/tests/sys_crypto/app.config.test
index de98095fab..8420f852d5 100644
--- a/tests/sys_crypto/app.config.test
+++ b/tests/sys_crypto/app.config.test
@@ -1,7 +1,10 @@
 # this file enables modules defined in Kconfig. Do not use this file for
 # application configuration. This is only needed during migration.
 
-CONFIG_MODULE_CRYPTO_3DES=y
+CONFIG_MODULE_CRYPTO=y
+CONFIG_MODULE_CRYPTO_AES_128=y
+CONFIG_MODULE_CRYPTO_AES_192=y
+CONFIG_MODULE_CRYPTO_AES_256=y
 CONFIG_MODULE_CIPHER_MODES=y
 
 CONFIG_MODULE_EMBUNIT=y
diff --git a/tests/sys_crypto/tests-crypto-aes.c b/tests/sys_crypto/tests-crypto-aes.c
index f7b3e23d6d..fb67fed73c 100644
--- a/tests/sys_crypto/tests-crypto-aes.c
+++ b/tests/sys_crypto/tests-crypto-aes.c
@@ -91,27 +91,12 @@ static void test_crypto_aes_init_key_length(void)
     cipher_context_t ctx;
     int err;
 
-    /* A keylength of 192 bit is not supported by the current implementation */
-    uint8_t unsupported_key_1[24];
-
-    memset(unsupported_key_1, 0, sizeof(unsupported_key_1));
-
-    /* A keylength of 256 bit is not supported by the current implementation */
-    uint8_t unsupported_key_2[32];
-    memset(unsupported_key_2, 0, sizeof(unsupported_key_2));
-
     /* A keylength of 64 bit is not supported by AES */
-    uint8_t unsupported_key_3[8];
-    memset(unsupported_key_3, 0, sizeof(unsupported_key_3));
+    uint8_t unsupported_key_1[8];
+    memset(unsupported_key_1, 0, sizeof(unsupported_key_1));
 
     err = aes_init(&ctx, unsupported_key_1, sizeof(unsupported_key_1));
     TEST_ASSERT_EQUAL_INT(CIPHER_ERR_INVALID_KEY_SIZE, err);
-
-    err = aes_init(&ctx, unsupported_key_2, sizeof(unsupported_key_2));
-    TEST_ASSERT_EQUAL_INT(CIPHER_ERR_INVALID_KEY_SIZE, err);
-
-    err = aes_init(&ctx, unsupported_key_3, sizeof(unsupported_key_3));
-    TEST_ASSERT_EQUAL_INT(CIPHER_ERR_INVALID_KEY_SIZE, err);
 }
 
 Test *tests_crypto_aes_tests(void)
diff --git a/tests/sys_crypto/tests-crypto-chacha.c b/tests/sys_crypto/tests-crypto-chacha.c
index 0097239613..71de747a71 100644
--- a/tests/sys_crypto/tests-crypto-chacha.c
+++ b/tests/sys_crypto/tests-crypto-chacha.c
@@ -13,6 +13,13 @@
 
 #include <string.h>
 
+/*
+ *  Test Vectors for the Stream Cipher ChaCha
+ *  draft-strombergson-chacha-test-vectors-00
+ *
+ *   https://tools.ietf.org/html/draft-strombergson-chacha-test-vectors-00
+ */
+
 static const uint8_t TC8_KEY[32] = {
     0xc4, 0x6e, 0xc1, 0xb1, 0x8c, 0xe8, 0xa8, 0x78,
     0x72, 0x5a, 0x37, 0xe7, 0x80, 0xdf, 0xb7, 0x35,
diff --git a/tests/sys_crypto/tests-crypto-chacha20poly1305.c b/tests/sys_crypto/tests-crypto-chacha20poly1305.c
index a22cd67d00..c5979c4c00 100644
--- a/tests/sys_crypto/tests-crypto-chacha20poly1305.c
+++ b/tests/sys_crypto/tests-crypto-chacha20poly1305.c
@@ -15,6 +15,12 @@
 
 #include "crypto/chacha20poly1305.h"
 
+/*
+ *  Example and Test Vector for AEAD_CHACHA20_POLY1305
+ *
+ *  https://tools.ietf.org/html/rfc7539#appendix-A
+ */
+
 /* ciphertext buffer */
 uint8_t ebuf[1024];
 /* Plaintext buffer */
diff --git a/tests/sys_crypto/tests-crypto-cipher.c b/tests/sys_crypto/tests-crypto-cipher.c
index 7337bc364a..0eeeecf01c 100644
--- a/tests/sys_crypto/tests-crypto-cipher.c
+++ b/tests/sys_crypto/tests-crypto-cipher.c
@@ -34,7 +34,7 @@ static void test_crypto_cipher_aes_encrypt(void)
     int err, cmp;
     uint8_t data[16] = { 0 };
 
-    err = cipher_init(&cipher, CIPHER_AES_128, TEST_KEY, 16);
+    err = cipher_init(&cipher, CIPHER_AES, TEST_KEY, 16);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     err = cipher_encrypt(&cipher, TEST_INP, data);
@@ -50,7 +50,7 @@ static void test_crypto_cipher_aes_decrypt(void)
     int err, cmp;
     uint8_t data[16];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, TEST_KEY, 16);
+    err = cipher_init(&cipher, CIPHER_AES, TEST_KEY, 16);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     err = cipher_decrypt(&cipher, TEST_ENC_AES, data);
@@ -65,33 +65,14 @@ static void test_crypto_cipher_init_aes_key_length(void)
     cipher_t cipher;
     int err;
 
-    /* A keylength of 192 bit is not supported by the current implementation */
-    uint8_t unsupported_key_1[24];
-
-    memset(unsupported_key_1, 0, sizeof(unsupported_key_1));
-
-    /* A keylength of 256 bit is not supported by the current implementation */
-    uint8_t unsupported_key_2[32];
-    memset(unsupported_key_2, 0, sizeof(unsupported_key_2));
-
     /* A keylength of 64 bit is not supported by AES */
-    uint8_t unsupported_key_3[8];
-    memset(unsupported_key_3, 0, sizeof(unsupported_key_3));
+    uint8_t unsupported_key_1[8];
+    memset(unsupported_key_1, 0, sizeof(unsupported_key_1));
 
     err =
-        cipher_init(&cipher, CIPHER_AES_128, unsupported_key_1,
+        cipher_init(&cipher, CIPHER_AES, unsupported_key_1,
                     sizeof(unsupported_key_1));
     TEST_ASSERT_EQUAL_INT(CIPHER_ERR_INVALID_KEY_SIZE, err);
-
-    err =
-        cipher_init(&cipher, CIPHER_AES_128, unsupported_key_2,
-                    sizeof(unsupported_key_2));
-    TEST_ASSERT_EQUAL_INT(CIPHER_ERR_INVALID_KEY_SIZE, err);
-
-    err =
-        cipher_init(&cipher, CIPHER_AES_128, unsupported_key_3,
-                    sizeof(unsupported_key_3));
-    TEST_ASSERT_EQUAL_INT(CIPHER_ERR_INVALID_KEY_SIZE, err);
 }
 
 Test *tests_crypto_cipher_tests(void)
diff --git a/tests/sys_crypto/tests-crypto-modes-cbc.c b/tests/sys_crypto/tests-crypto-modes-cbc.c
index c4c0ef618f..bd3f1e0bd3 100644
--- a/tests/sys_crypto/tests-crypto-modes-cbc.c
+++ b/tests/sys_crypto/tests-crypto-modes-cbc.c
@@ -32,12 +32,27 @@ static uint8_t TEST_1_KEY[] = {
 };
 static uint8_t TEST_1_KEY_LEN = 16;
 
-static uint8_t TEST_1_IV[16] = {
+static uint8_t TEST_2_KEY[] = {
+    0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
+    0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
+    0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b
+};
+static uint8_t TEST_2_KEY_LEN = 24;
+
+static uint8_t TEST_3_KEY[] = {
+    0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
+    0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
+    0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
+    0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4
+};
+static uint8_t TEST_3_KEY_LEN = 32;
+
+static uint8_t TEST_IV[16] = {
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
 };
 
-static uint8_t TEST_1_PLAIN[] = {
+static uint8_t TEST_PLAIN[] = {
     0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
     0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
     0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
@@ -47,7 +62,7 @@ static uint8_t TEST_1_PLAIN[] = {
     0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
     0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
 };
-static uint8_t TEST_1_PLAIN_LEN = 64;
+static uint8_t TEST_PLAIN_LEN = 64;
 
 static uint8_t TEST_1_CIPHER[] = {
     0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
@@ -59,9 +74,31 @@ static uint8_t TEST_1_CIPHER[] = {
     0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09,
     0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
 };
-static uint8_t TEST_1_CIPHER_LEN = 64;
 
-static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t iv[16],
+static uint8_t TEST_2_CIPHER[] = {
+    0x4f, 0x02, 0x1d, 0xb2, 0x43, 0xbc, 0x63, 0x3d,
+    0x71, 0x78, 0x18, 0x3a, 0x9f, 0xa0, 0x71, 0xe8,
+    0xb4, 0xd9, 0xad, 0xa9, 0xad, 0x7d, 0xed, 0xf4,
+    0xe5, 0xe7, 0x38, 0x76, 0x3f, 0x69, 0x14, 0x5a,
+    0x57, 0x1b, 0x24, 0x20, 0x12, 0xfb, 0x7a, 0xe0,
+    0x7f, 0xa9, 0xba, 0xac, 0x3d, 0xf1, 0x02, 0xe0,
+    0x08, 0xb0, 0xe2, 0x79, 0x88, 0x59, 0x88, 0x81,
+    0xd9, 0x20, 0xa9, 0xe6, 0x4f, 0x56, 0x15, 0xcd
+};
+
+static uint8_t TEST_3_CIPHER[] = {
+    0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba,
+    0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
+    0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d,
+    0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
+    0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf,
+    0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
+    0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc,
+    0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b
+};
+static uint8_t TEST_CIPHER_LEN = 64;
+
+static void test_encrypt_op_128(uint8_t *key, uint8_t key_len, uint8_t iv[16],
                             uint8_t *input, uint8_t input_len, uint8_t *output,
                             uint8_t output_len)
 {
@@ -69,7 +106,7 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t iv[16],
     int len, err, cmp;
     uint8_t data[64];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_encrypt_cbc(&cipher, iv, input, input_len, data);
@@ -81,7 +118,7 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t iv[16],
 
 }
 
-static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t iv[16],
+static void test_encrypt_op_192(uint8_t *key, uint8_t key_len, uint8_t iv[16],
                             uint8_t *input, uint8_t input_len, uint8_t *output,
                             uint8_t output_len)
 {
@@ -89,10 +126,29 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t iv[16],
     int len, err, cmp;
     uint8_t data[64];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
-    len = cipher_decrypt_cbc(&cipher, iv, input, input_len, data);
+    len = cipher_encrypt_cbc(&cipher, iv, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_encrypt_op_256(uint8_t *key, uint8_t key_len, uint8_t iv[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_cbc(&cipher, iv, input, input_len, data);
     TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
 
     TEST_ASSERT_EQUAL_INT(output_len, len);
@@ -101,16 +157,88 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t iv[16],
 
 }
 
+static void test_decrypt_op_128(uint8_t *key, uint8_t key_len, uint8_t iv[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_cbc(&cipher, iv, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Decryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong plaintext");
+
+}
+
+static void test_decrypt_op_192(uint8_t *key, uint8_t key_len, uint8_t iv[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_cbc(&cipher, iv, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Decryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong plaintext");
+
+}
+
+static void test_decrypt_op_256(uint8_t *key, uint8_t key_len, uint8_t iv[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_cbc(&cipher, iv, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Decryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong plaintext");
+
+}
+
 static void test_crypto_modes_cbc_encrypt(void)
 {
-    test_encrypt_op(TEST_1_KEY, TEST_1_KEY_LEN, TEST_1_IV, TEST_1_PLAIN,
-                    TEST_1_PLAIN_LEN, TEST_1_CIPHER, TEST_1_CIPHER_LEN);
+    test_encrypt_op_128(TEST_1_KEY, TEST_1_KEY_LEN, TEST_IV, TEST_PLAIN,
+                    TEST_PLAIN_LEN, TEST_1_CIPHER, TEST_CIPHER_LEN);
+
+    test_encrypt_op_192(TEST_2_KEY, TEST_2_KEY_LEN, TEST_IV, TEST_PLAIN,
+                    TEST_PLAIN_LEN, TEST_2_CIPHER, TEST_CIPHER_LEN);
+
+    test_encrypt_op_256(TEST_3_KEY, TEST_3_KEY_LEN, TEST_IV, TEST_PLAIN,
+                    TEST_PLAIN_LEN, TEST_3_CIPHER, TEST_CIPHER_LEN);
 }
 
 static void test_crypto_modes_cbc_decrypt(void)
 {
-    test_decrypt_op(TEST_1_KEY, TEST_1_KEY_LEN, TEST_1_IV, TEST_1_CIPHER,
-                    TEST_1_CIPHER_LEN, TEST_1_PLAIN, TEST_1_PLAIN_LEN);
+    test_decrypt_op_128(TEST_1_KEY, TEST_1_KEY_LEN, TEST_IV, TEST_1_CIPHER,
+                    TEST_CIPHER_LEN, TEST_PLAIN, TEST_PLAIN_LEN);
+
+    test_decrypt_op_192(TEST_2_KEY, TEST_2_KEY_LEN, TEST_IV, TEST_2_CIPHER,
+                    TEST_CIPHER_LEN, TEST_PLAIN, TEST_PLAIN_LEN);
+
+    test_decrypt_op_256(TEST_3_KEY, TEST_3_KEY_LEN, TEST_IV, TEST_3_CIPHER,
+                    TEST_CIPHER_LEN, TEST_PLAIN, TEST_PLAIN_LEN);
 }
 
 
diff --git a/tests/sys_crypto/tests-crypto-modes-ccm.c b/tests/sys_crypto/tests-crypto-modes-ccm.c
index ea6be9724b..d623e9fde5 100644
--- a/tests/sys_crypto/tests-crypto-modes-ccm.c
+++ b/tests/sys_crypto/tests-crypto-modes-ccm.c
@@ -1105,7 +1105,7 @@ static void test_encrypt_op(const uint8_t *key, uint8_t key_len,
     TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
                         "Output buffer too small");
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_encrypt_ccm(&cipher, adata, adata_len,
@@ -1133,7 +1133,7 @@ static void test_decrypt_op(const uint8_t *key, uint8_t key_len,
     TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
                         "Output buffer too small");
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_decrypt_ccm(&cipher, adata, adata_len,
@@ -1271,7 +1271,7 @@ static int _test_ccm_len(func_ccm_t func, uint8_t len_encoding,
 
     uint8_t nonce_len = nonce_and_len_encoding_size - len_encoding;
 
-    cipher_init(&cipher, CIPHER_AES_128, key, 16);
+    cipher_init(&cipher, CIPHER_AES, key, 16);
 
     ret = func(&cipher, NULL, adata_len, mac_length, len_encoding,
                nonce, nonce_len, input, input_len, data);
diff --git a/tests/sys_crypto/tests-crypto-modes-ctr.c b/tests/sys_crypto/tests-crypto-modes-ctr.c
index ee506ae8a6..d6c0257326 100644
--- a/tests/sys_crypto/tests-crypto-modes-ctr.c
+++ b/tests/sys_crypto/tests-crypto-modes-ctr.c
@@ -32,12 +32,27 @@ static uint8_t TEST_1_KEY[] = {
 };
 static uint8_t TEST_1_KEY_LEN = 16;
 
-static uint8_t TEST_1_COUNTER[16] = {
+static uint8_t TEST_2_KEY[] = {
+    0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
+    0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
+    0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b
+};
+static uint8_t TEST_2_KEY_LEN = 24;
+
+static uint8_t TEST_3_KEY[] = {
+    0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
+    0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
+    0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
+    0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4
+};
+static uint8_t TEST_3_KEY_LEN = 32;
+
+static uint8_t TEST_COUNTER[16] = {
     0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
 };
 
-static uint8_t TEST_1_PLAIN[] = {
+static uint8_t TEST_PLAIN[] = {
     0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
     0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
     0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
@@ -47,7 +62,7 @@ static uint8_t TEST_1_PLAIN[] = {
     0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
     0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
 };
-static uint8_t TEST_1_PLAIN_LEN = 64;
+static uint8_t TEST_PLAIN_LEN = 64;
 
 static uint8_t TEST_1_CIPHER[] = {
     0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
@@ -59,9 +74,31 @@ static uint8_t TEST_1_CIPHER[] = {
     0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
     0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee
 };
-static uint8_t TEST_1_CIPHER_LEN = 64;
 
-static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
+static uint8_t TEST_2_CIPHER[] = {
+    0x1a, 0xbc, 0x93, 0x24, 0x17, 0x52, 0x1c, 0xa2,
+    0x4f, 0x2b, 0x04, 0x59, 0xfe, 0x7e, 0x6e, 0x0b,
+    0x09, 0x03, 0x39, 0xec, 0x0a, 0xa6, 0xfa, 0xef,
+    0xd5, 0xcc, 0xc2, 0xc6, 0xf4, 0xce, 0x8e, 0x94,
+    0x1e, 0x36, 0xb2, 0x6b, 0xd1, 0xeb, 0xc6, 0x70,
+    0xd1, 0xbd, 0x1d, 0x66, 0x56, 0x20, 0xab, 0xf7,
+    0x4f, 0x78, 0xa7, 0xf6, 0xd2, 0x98, 0x09, 0x58,
+    0x5a, 0x97, 0xda, 0xec, 0x58, 0xc6, 0xb0, 0x50
+};
+
+static uint8_t TEST_3_CIPHER[] = {
+    0x60, 0x1e, 0xc3, 0x13, 0x77, 0x57, 0x89, 0xa5,
+    0xb7, 0xa7, 0xf5, 0x04, 0xbb, 0xf3, 0xd2, 0x28,
+    0xf4, 0x43, 0xe3, 0xca, 0x4d, 0x62, 0xb5, 0x9a,
+    0xca, 0x84, 0xe9, 0x90, 0xca, 0xca, 0xf5, 0xc5,
+    0x2b, 0x09, 0x30, 0xda, 0xa2, 0x3d, 0xe9, 0x4c,
+    0xe8, 0x70, 0x17, 0xba, 0x2d, 0x84, 0x98, 0x8d,
+    0xdf, 0xc9, 0xc5, 0x8d, 0xb6, 0x7a, 0xad, 0xa6,
+    0x13, 0xc2, 0xdd, 0x08, 0x45, 0x79, 0x41, 0xa6
+};
+static uint8_t TEST_CIPHER_LEN = 64;
+
+static void test_encrypt_op_128(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
                             uint8_t *input, uint8_t input_len, uint8_t *output,
                             uint8_t output_len)
 {
@@ -69,7 +106,7 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
     int len, err, cmp;
     uint8_t data[64];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_encrypt_ctr(&cipher, ctr, 0, input, input_len, data);
@@ -81,7 +118,26 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
 
 }
 
-static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
+static void test_encrypt_op_192(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ctr(&cipher, ctr, 0, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_encrypt_op_256(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
                             uint8_t *input, uint8_t input_len, uint8_t *output,
                             uint8_t output_len)
 {
@@ -89,7 +145,26 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
     int len, err, cmp;
     uint8_t data[64];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ctr(&cipher, ctr, 0, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_decrypt_op_128(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_decrypt_ctr(&cipher, ctr, 0, input, input_len, data);
@@ -98,25 +173,78 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
     TEST_ASSERT_EQUAL_INT(output_len, len);
     cmp = compare(output, data, len);
     TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_decrypt_op_192(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
 
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ctr(&cipher, ctr, 0, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_decrypt_op_256(uint8_t *key, uint8_t key_len, uint8_t ctr[16],
+                            uint8_t *input, uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ctr(&cipher, ctr, 0, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
 }
 
 static void test_crypto_modes_ctr_encrypt(void)
 {
     uint8_t ctr[16];
 
-    memcpy(ctr, TEST_1_COUNTER, 16);
-    test_encrypt_op(TEST_1_KEY, TEST_1_KEY_LEN, ctr, TEST_1_PLAIN,
-                    TEST_1_PLAIN_LEN, TEST_1_CIPHER, TEST_1_CIPHER_LEN);
+    memcpy(ctr, TEST_COUNTER, 16);
+    test_encrypt_op_128(TEST_1_KEY, TEST_1_KEY_LEN, ctr, TEST_PLAIN,
+                    TEST_PLAIN_LEN, TEST_1_CIPHER, TEST_CIPHER_LEN);
+
+    memcpy(ctr, TEST_COUNTER, 16);
+    test_encrypt_op_192(TEST_2_KEY, TEST_2_KEY_LEN, ctr, TEST_PLAIN,
+                    TEST_PLAIN_LEN, TEST_2_CIPHER, TEST_CIPHER_LEN);
+
+    memcpy(ctr, TEST_COUNTER, 16);
+    test_encrypt_op_256(TEST_3_KEY, TEST_3_KEY_LEN, ctr, TEST_PLAIN,
+                    TEST_PLAIN_LEN, TEST_3_CIPHER, TEST_CIPHER_LEN);
 }
 
 static void test_crypto_modes_ctr_decrypt(void)
 {
     uint8_t ctr[16];
 
-    memcpy(ctr, TEST_1_COUNTER, 16);
-    test_decrypt_op(TEST_1_KEY, TEST_1_KEY_LEN, ctr, TEST_1_CIPHER,
-                    TEST_1_CIPHER_LEN, TEST_1_PLAIN, TEST_1_PLAIN_LEN);
+    memcpy(ctr, TEST_COUNTER, 16);
+    test_decrypt_op_128(TEST_1_KEY, TEST_1_KEY_LEN, ctr, TEST_1_CIPHER,
+                    TEST_CIPHER_LEN, TEST_PLAIN, TEST_PLAIN_LEN);
+
+    memcpy(ctr, TEST_COUNTER, 16);
+    test_decrypt_op_192(TEST_2_KEY, TEST_2_KEY_LEN, ctr, TEST_2_CIPHER,
+                    TEST_CIPHER_LEN, TEST_PLAIN, TEST_PLAIN_LEN);
+
+    memcpy(ctr, TEST_COUNTER, 16);
+    test_decrypt_op_256(TEST_3_KEY, TEST_3_KEY_LEN, ctr, TEST_3_CIPHER,
+                    TEST_CIPHER_LEN, TEST_PLAIN, TEST_PLAIN_LEN);
 }
 
 
diff --git a/tests/sys_crypto/tests-crypto-modes-ecb.c b/tests/sys_crypto/tests-crypto-modes-ecb.c
index c7091bddcd..151d11dcd4 100644
--- a/tests/sys_crypto/tests-crypto-modes-ecb.c
+++ b/tests/sys_crypto/tests-crypto-modes-ecb.c
@@ -32,7 +32,22 @@ static uint8_t TEST_1_KEY[] = {
 };
 static uint8_t TEST_1_KEY_LEN = 16;
 
-static uint8_t TEST_1_PLAIN[] = {
+static uint8_t TEST_2_KEY[] = {
+    0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
+    0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
+    0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b
+};
+static uint8_t TEST_2_KEY_LEN = 24;
+
+static uint8_t TEST_3_KEY[] = {
+    0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
+    0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
+    0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
+    0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4
+};
+static uint8_t TEST_3_KEY_LEN = 32;
+
+static uint8_t TEST_PLAIN[] = {
     0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
     0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
     0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
@@ -42,7 +57,7 @@ static uint8_t TEST_1_PLAIN[] = {
     0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
     0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
 };
-static uint8_t TEST_1_PLAIN_LEN = 64;
+static uint8_t TEST_PLAIN_LEN = 64;
 
 static uint8_t TEST_1_CIPHER[] = {
     0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
@@ -54,9 +69,31 @@ static uint8_t TEST_1_CIPHER[] = {
     0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f,
     0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
 };
-static uint8_t TEST_1_CIPHER_LEN = 64;
 
-static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t *input,
+static uint8_t TEST_2_CIPHER[] = {
+    0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f,
+    0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc,
+    0x97, 0x41, 0x04, 0x84, 0x6d, 0x0a, 0xd3, 0xad,
+    0x77, 0x34, 0xec, 0xb3, 0xec, 0xee, 0x4e, 0xef,
+    0xef, 0x7a, 0xfd, 0x22, 0x70, 0xe2, 0xe6, 0x0a,
+    0xdc, 0xe0, 0xba, 0x2f, 0xac, 0xe6, 0x44, 0x4e,
+    0x9a, 0x4b, 0x41, 0xba, 0x73, 0x8d, 0x6c, 0x72,
+    0xfb, 0x16, 0x69, 0x16, 0x03, 0xc1, 0x8e, 0x0e
+};
+
+static uint8_t TEST_3_CIPHER[] = {
+    0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c,
+    0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8,
+    0x59, 0x1c, 0xcb, 0x10, 0xd4, 0x10, 0xed, 0x26,
+    0xdc, 0x5b, 0xa7, 0x4a, 0x31, 0x36, 0x28, 0x70,
+    0xb6, 0xed, 0x21, 0xb9, 0x9c, 0xa6, 0xf4, 0xf9,
+    0xf1, 0x53, 0xe7, 0xb1, 0xbe, 0xaf, 0xed, 0x1d,
+    0x23, 0x30, 0x4b, 0x7a, 0x39, 0xf9, 0xf3, 0xff,
+    0x06, 0x7d, 0x8d, 0x8f, 0x9e, 0x24, 0xec, 0xc7
+};
+static uint8_t TEST_CIPHER_LEN = 64;
+
+static void test_encrypt_op_128(uint8_t *key, uint8_t key_len, uint8_t *input,
                             uint8_t input_len, uint8_t *output,
                             uint8_t output_len)
 {
@@ -64,7 +101,7 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t *input,
     int len, err, cmp;
     uint8_t data[64];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_encrypt_ecb(&cipher, input, input_len, data);
@@ -76,7 +113,7 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len, uint8_t *input,
 
 }
 
-static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t *input,
+static void test_encrypt_op_192(uint8_t *key, uint8_t key_len, uint8_t *input,
                             uint8_t input_len, uint8_t *output,
                             uint8_t output_len)
 {
@@ -84,7 +121,87 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t *input,
     int len, err, cmp;
     uint8_t data[64];
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ecb(&cipher, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+static void test_encrypt_op_256(uint8_t *key, uint8_t key_len, uint8_t *input,
+                            uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ecb(&cipher, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+static void test_decrypt_op_128(uint8_t *key, uint8_t key_len, uint8_t *input,
+                            uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ecb(&cipher, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+static void test_decrypt_op_192(uint8_t *key, uint8_t key_len, uint8_t *input,
+                            uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ecb(&cipher, input, input_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_len, len);
+    cmp = compare(output, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+static void test_decrypt_op_256(uint8_t *key, uint8_t key_len, uint8_t *input,
+                            uint8_t input_len, uint8_t *output,
+                            uint8_t output_len)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    uint8_t data[64];
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_decrypt_ecb(&cipher, input, input_len, data);
@@ -98,17 +215,30 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len, uint8_t *input,
 
 static void test_crypto_modes_ecb_encrypt(void)
 {
-    test_encrypt_op(TEST_1_KEY, TEST_1_KEY_LEN, TEST_1_PLAIN, TEST_1_PLAIN_LEN,
-                    TEST_1_CIPHER, TEST_1_CIPHER_LEN);
+    test_encrypt_op_128(TEST_1_KEY, TEST_1_KEY_LEN, TEST_PLAIN, TEST_PLAIN_LEN,
+                    TEST_1_CIPHER, TEST_CIPHER_LEN);
+
+    test_encrypt_op_192(TEST_2_KEY, TEST_2_KEY_LEN, TEST_PLAIN, TEST_PLAIN_LEN,
+                    TEST_2_CIPHER, TEST_CIPHER_LEN);
+
+    test_encrypt_op_256(TEST_3_KEY, TEST_3_KEY_LEN, TEST_PLAIN, TEST_PLAIN_LEN,
+                    TEST_3_CIPHER, TEST_CIPHER_LEN);
 }
 
 static void test_crypto_modes_ecb_decrypt(void)
 {
-    test_decrypt_op(TEST_1_KEY, TEST_1_KEY_LEN, TEST_1_CIPHER,
-                    TEST_1_CIPHER_LEN,
-                    TEST_1_PLAIN, TEST_1_PLAIN_LEN);
-}
+    test_decrypt_op_128(TEST_1_KEY, TEST_1_KEY_LEN, TEST_1_CIPHER,
+                    TEST_CIPHER_LEN,
+                    TEST_PLAIN, TEST_PLAIN_LEN);
 
+    test_decrypt_op_192(TEST_2_KEY, TEST_2_KEY_LEN, TEST_2_CIPHER,
+                    TEST_CIPHER_LEN,
+                    TEST_PLAIN, TEST_PLAIN_LEN);
+
+    test_decrypt_op_256(TEST_2_KEY, TEST_2_KEY_LEN, TEST_2_CIPHER,
+                    TEST_CIPHER_LEN,
+                    TEST_PLAIN, TEST_PLAIN_LEN);
+}
 
 Test *tests_crypto_modes_ecb_tests(void)
 {
diff --git a/tests/sys_crypto/tests-crypto-modes-ocb.c b/tests/sys_crypto/tests-crypto-modes-ocb.c
index ac9403d0ca..70209155bc 100644
--- a/tests/sys_crypto/tests-crypto-modes-ocb.c
+++ b/tests/sys_crypto/tests-crypto-modes-ocb.c
@@ -277,7 +277,7 @@ static void test_encrypt_op(uint8_t *key, uint8_t key_len,
     TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
                         "Output buffer too small");
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_encrypt_ocb(&cipher, adata, adata_len,
@@ -327,7 +327,7 @@ static void test_decrypt_op(uint8_t *key, uint8_t key_len,
     TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
                         "Output buffer too small");
 
-    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
     TEST_ASSERT_EQUAL_INT(1, err);
 
     len = cipher_decrypt_ocb(&cipher, adata, adata_len,
@@ -412,7 +412,7 @@ static void test_crypto_modes_ocb_bad_parameter_values(void)
     uint8_t key[16], auth_data[1], nonce[16], input[16], output[32];
     cipher_t cipher;
 
-    cipher_init(&cipher, CIPHER_AES_128, key, 16);
+    cipher_init(&cipher, CIPHER_AES, key, 16);
     /* tag length must be positive */
     int rv = cipher_encrypt_ocb(&cipher, auth_data, sizeof(auth_data), 0, nonce,
                                 15, input, sizeof(input), output);
diff --git a/tests/sys_crypto/tests-crypto-poly1305.c b/tests/sys_crypto/tests-crypto-poly1305.c
index 2ca5a29a45..38351e85a9 100644
--- a/tests/sys_crypto/tests-crypto-poly1305.c
+++ b/tests/sys_crypto/tests-crypto-poly1305.c
@@ -14,6 +14,12 @@
 
 #include <string.h>
 
+/*
+ *  Poly1305 Message Authentication Code
+ *
+ *  https://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-06#appendix-A.3
+ */
+
 static const uint8_t key_1[32] = { 0 };
 static const uint8_t msg_1[64] = { 0 };
 static const uint8_t tag_1[16] = { 0 };
diff --git a/tests/sys_crypto_aes_ccm/Makefile b/tests/sys_crypto_aes_ccm/Makefile
new file mode 100644
index 0000000000..f9438f3de8
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/Makefile
@@ -0,0 +1,10 @@
+include ../Makefile.tests_common
+
+USEMODULE += embunit
+
+USEMODULE += cipher_modes
+USEMODULE += crypto_aes_128
+USEMODULE += crypto_aes_192
+USEMODULE += crypto_aes_256
+
+include $(RIOTBASE)/Makefile.include
diff --git a/tests/sys_crypto_aes_ccm/Makefile.ci b/tests/sys_crypto_aes_ccm/Makefile.ci
new file mode 100644
index 0000000000..aa7a5ddab2
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/Makefile.ci
@@ -0,0 +1,28 @@
+BOARD_INSUFFICIENT_MEMORY := \
+    arduino-duemilanove \
+    arduino-leonardo \
+    arduino-mega2560 \
+    arduino-nano \
+    arduino-uno \
+    atmega1284p \
+    atmega328p \
+    atmega328p-xplained-mini \
+    atxmega-a1u-xpro \
+    atxmega-a3bu-xplained \
+    derfmega128 \
+    mega-xplained \
+    microduino-corerf \
+    msb-430 \
+    msb-430h \
+    nucleo-f031k6 \
+    nucleo-f042k6 \
+    nucleo-l011k4 \
+    nucleo-l031k6 \
+    samd10-xmini \
+    stk3200 \
+    stm32f030f4-demo \
+    telosb \
+    waspmote-pro \
+    z1 \
+    zigduino \
+    #
diff --git a/tests/sys_crypto_aes_ccm/README.md b/tests/sys_crypto_aes_ccm/README.md
new file mode 100644
index 0000000000..c580d81731
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/README.md
@@ -0,0 +1,18 @@
+# Overview
+
+This test application specifically tests the AES CCM implementation for 128, 192 and 256
+bit keys. The test utilizes the [CAVP AES CCM DVTP] test vectors.
+
+To build the test application run
+
+```
+make
+```
+
+To execute the test run
+
+```
+make term
+```
+
+[CAVP AES CCM DVTP]: https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/cavp-testing-block-cipher-modes
\ No newline at end of file
diff --git a/tests/sys_crypto_aes_ccm/app.config.test b/tests/sys_crypto_aes_ccm/app.config.test
new file mode 100644
index 0000000000..8420f852d5
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/app.config.test
@@ -0,0 +1,11 @@
+# this file enables modules defined in Kconfig. Do not use this file for
+# application configuration. This is only needed during migration.
+
+CONFIG_MODULE_CRYPTO=y
+CONFIG_MODULE_CRYPTO_AES_128=y
+CONFIG_MODULE_CRYPTO_AES_192=y
+CONFIG_MODULE_CRYPTO_AES_256=y
+CONFIG_MODULE_CIPHER_MODES=y
+
+CONFIG_MODULE_EMBUNIT=y
+CONFIG_MODULE_TEST_UTILS_INTERACTIVE_SYNC=y
diff --git a/tests/sys_crypto_aes_ccm/main.c b/tests/sys_crypto_aes_ccm/main.c
new file mode 100644
index 0000000000..0cb83c9dd3
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/main.c
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2021 Nils Ollrogge
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+#include "tests-crypto.h"
+
+int main(void)
+{
+    TESTS_START();
+    TESTS_RUN(tests_crypto_modes_ccm_tests_128());
+    TESTS_RUN(tests_crypto_modes_ccm_tests_192());
+    TESTS_RUN(tests_crypto_modes_ccm_tests_256());
+    TESTS_END();
+    return 0;
+}
diff --git a/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-128.c b/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-128.c
new file mode 100644
index 0000000000..5c06226c5b
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-128.c
@@ -0,0 +1,2438 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+#include <limits.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "embUnit.h"
+#include "crypto/ciphers.h"
+#include "crypto/modes/ccm.h"
+#include "tests-crypto.h"
+
+/**
+ * AES CCM DVTP test vectors (SP 800-38C) for 128 bit keys.
+ * https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/cavp-testing-block-cipher-modes
+ */
+
+static const size_t nonce_and_len_encoding_size = 15;
+
+/* Alen = 0, Plen = 0, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_0_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_0_KEY[] = {
+    0x4a, 0xe7, 0x01, 0x10, 0x3c, 0x63, 0xde, 0xca,
+    0x5b, 0x5a, 0x39, 0x39, 0xd7, 0xd0, 0x59, 0x92,
+};
+static const size_t TEST_DVPT128_GROUP_0_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_0_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_0_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_0_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_0_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_0_EXPECTED[] = {
+    0x02, 0x20, 0x9f, 0x55,
+};
+static const size_t TEST_DVPT128_0_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_0_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_0_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_4_NONCE[] = {
+    0x05, 0xe1, 0x6f, 0x0f, 0x42, 0xa6, 0xf4,
+};
+static const size_t TEST_DVPT128_4_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_4_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_4_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_4_EXPECTED[] = {
+    0xf0, 0x9c, 0x29, 0x86,
+};
+static const size_t TEST_DVPT128_4_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_4_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_4_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_11_NONCE[] = {
+    0xa9, 0xdf, 0x4f, 0x37, 0x84, 0x7e, 0x1f,
+};
+static const size_t TEST_DVPT128_11_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_11_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_11_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_11_EXPECTED[] = {
+    0x19, 0x86, 0x7a, 0xa5,
+};
+static const size_t TEST_DVPT128_11_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_11_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_11_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_12_NONCE[] = {
+    0x11, 0xdf, 0x57, 0xfc, 0xd1, 0x31, 0xe9,
+};
+static const size_t TEST_DVPT128_12_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_12_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_12_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_12_EXPECTED[] = {
+    0x3b, 0x39, 0x2a, 0x52,
+};
+static const size_t TEST_DVPT128_12_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_12_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_12_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_13_NONCE[] = {
+    0x89, 0x0f, 0xff, 0x56, 0xd1, 0x0d, 0xc0,
+};
+static const size_t TEST_DVPT128_13_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_13_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_13_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_13_EXPECTED[] = {
+    0x1c, 0x5e, 0x47, 0xe0,
+};
+static const size_t TEST_DVPT128_13_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_13_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_13_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_1_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_1_KEY[] = {
+    0x4b, 0xb3, 0xc4, 0xa4, 0xf8, 0x93, 0xad, 0x8c,
+    0x9b, 0xdc, 0x83, 0x3c, 0x32, 0x5d, 0x62, 0xb3,
+};
+static const size_t TEST_DVPT128_GROUP_1_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_15_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_15_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_15_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_15_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_15_EXPECTED[] = {
+    0x75, 0xd5, 0x82, 0xdb, 0x43, 0xce, 0x9b, 0x13,
+    0xab, 0x4b, 0x6f, 0x7f, 0x14, 0x34, 0x13, 0x30,
+};
+static const size_t TEST_DVPT128_15_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_15_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_15_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_19_NONCE[] = {
+    0x05, 0xe1, 0x6f, 0x0f, 0x42, 0xa6, 0xf4,
+};
+static const size_t TEST_DVPT128_19_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_19_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_19_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_19_EXPECTED[] = {
+    0xe2, 0xe8, 0x7c, 0xa8, 0x25, 0x23, 0xcc, 0xfe,
+    0xb4, 0x16, 0xb4, 0x2a, 0xf9, 0xd9, 0xaa, 0xdc,
+};
+static const size_t TEST_DVPT128_19_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_19_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_19_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_26_NONCE[] = {
+    0xa9, 0xdf, 0x4f, 0x37, 0x84, 0x7e, 0x1f,
+};
+static const size_t TEST_DVPT128_26_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_26_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_26_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_26_EXPECTED[] = {
+    0x0e, 0x15, 0x0a, 0xf4, 0x22, 0xf6, 0xda, 0x23,
+    0x8b, 0xb4, 0x76, 0x81, 0x0b, 0x2d, 0x5b, 0xc2,
+};
+static const size_t TEST_DVPT128_26_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_26_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_26_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_27_NONCE[] = {
+    0x11, 0xdf, 0x57, 0xfc, 0xd1, 0x31, 0xe9,
+};
+static const size_t TEST_DVPT128_27_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_27_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_27_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_27_EXPECTED[] = {
+    0x8e, 0x11, 0x50, 0x75, 0x6f, 0xf3, 0xa7, 0x33,
+    0xa1, 0x27, 0x44, 0x70, 0xf0, 0x72, 0xb7, 0x4c,
+};
+static const size_t TEST_DVPT128_27_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_27_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_27_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_28_NONCE[] = {
+    0x89, 0x0f, 0xff, 0x56, 0xd1, 0x0d, 0xc0,
+};
+static const size_t TEST_DVPT128_28_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_28_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_28_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_28_EXPECTED[] = {
+    0xa1, 0xf7, 0x0d, 0xf3, 0xfa, 0x9c, 0xfe, 0xb9,
+    0x5f, 0x86, 0x9b, 0x3f, 0xe0, 0x84, 0x66, 0xe0,
+};
+static const size_t TEST_DVPT128_28_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_28_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_28_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_2_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_2_KEY[] = {
+    0x4b, 0xb3, 0xc4, 0xa4, 0xf8, 0x93, 0xad, 0x8c,
+    0x9b, 0xdc, 0x83, 0x3c, 0x32, 0x5d, 0x62, 0xb3,
+};
+static const size_t TEST_DVPT128_GROUP_2_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_30_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_30_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_30_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_30_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_30_EXPECTED[] = {
+    0x90, 0x15, 0x6f, 0x3f,
+};
+static const size_t TEST_DVPT128_30_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_30_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_30_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_34_NONCE[] = {
+    0x93, 0x5c, 0x1e, 0xf3, 0xd4, 0x03, 0x2f, 0xf0,
+    0x90, 0xf9, 0x11, 0x41, 0xf3,
+};
+static const size_t TEST_DVPT128_34_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_34_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_34_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_34_EXPECTED[] = {
+    0x1b, 0xc8, 0x2b, 0x3d,
+};
+static const size_t TEST_DVPT128_34_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_34_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_34_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_41_NONCE[] = {
+    0xd0, 0xa1, 0x50, 0x8f, 0xde, 0xfc, 0xf5, 0xbe,
+    0x30, 0xa4, 0x59, 0xb8, 0x13,
+};
+static const size_t TEST_DVPT128_41_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_41_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_41_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_41_EXPECTED[] = {
+    0x36, 0xa3, 0x7a, 0x59,
+};
+static const size_t TEST_DVPT128_41_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_41_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_41_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_42_NONCE[] = {
+    0x53, 0x81, 0xa6, 0x1b, 0x44, 0x9d, 0xc6, 0xa4,
+    0x2a, 0xa4, 0xc7, 0x9b, 0x95,
+};
+static const size_t TEST_DVPT128_42_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_42_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_42_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_42_EXPECTED[] = {
+    0xdb, 0xa0, 0x2a, 0x36,
+};
+static const size_t TEST_DVPT128_42_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_42_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_42_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_43_NONCE[] = {
+    0xc5, 0x54, 0x30, 0xf2, 0xda, 0x06, 0x87, 0xea,
+    0x40, 0x31, 0x38, 0x84, 0xab,
+};
+static const size_t TEST_DVPT128_43_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_43_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_43_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_43_EXPECTED[] = {
+    0x25, 0xdc, 0xb3, 0xc5,
+};
+static const size_t TEST_DVPT128_43_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_43_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_43_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_3_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_3_KEY[] = {
+    0x19, 0xeb, 0xfd, 0xe2, 0xd5, 0x46, 0x8b, 0xa0,
+    0xa3, 0x03, 0x1b, 0xde, 0x62, 0x9b, 0x11, 0xfd,
+};
+static const size_t TEST_DVPT128_GROUP_3_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_45_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_45_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_45_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_45_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_45_EXPECTED[] = {
+    0xfb, 0x04, 0xdc, 0x5a, 0x44, 0xc6, 0xbb, 0x00,
+    0x0f, 0x24, 0x40, 0xf5, 0x15, 0x43, 0x64, 0xb4,
+};
+static const size_t TEST_DVPT128_45_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_45_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_45_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_49_NONCE[] = {
+    0x93, 0x5c, 0x1e, 0xf3, 0xd4, 0x03, 0x2f, 0xf0,
+    0x90, 0xf9, 0x11, 0x41, 0xf3,
+};
+static const size_t TEST_DVPT128_49_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_49_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_49_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_49_EXPECTED[] = {
+    0x3d, 0xac, 0xc7, 0x11, 0x69, 0xf6, 0xda, 0x77,
+    0xec, 0x91, 0xff, 0x1d, 0x2f, 0x64, 0x9e, 0xd1,
+};
+static const size_t TEST_DVPT128_49_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_49_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_49_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_56_NONCE[] = {
+    0xd0, 0xa1, 0x50, 0x8f, 0xde, 0xfc, 0xf5, 0xbe,
+    0x30, 0xa4, 0x59, 0xb8, 0x13,
+};
+static const size_t TEST_DVPT128_56_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_56_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_56_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_56_EXPECTED[] = {
+    0x1a, 0xe3, 0x42, 0x07, 0xe7, 0x4c, 0x8c, 0x78,
+    0x89, 0x0a, 0xe1, 0x7e, 0x32, 0x0e, 0x84, 0xbd,
+};
+static const size_t TEST_DVPT128_56_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_56_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_56_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_57_NONCE[] = {
+    0x53, 0x81, 0xa6, 0x1b, 0x44, 0x9d, 0xc6, 0xa4,
+    0x2a, 0xa4, 0xc7, 0x9b, 0x95,
+};
+static const size_t TEST_DVPT128_57_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_57_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_57_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_57_EXPECTED[] = {
+    0x5c, 0x5f, 0xa2, 0x54, 0xc0, 0xbe, 0x50, 0x3b,
+    0x02, 0xca, 0xff, 0xad, 0xe6, 0xb8, 0x52, 0x59,
+};
+static const size_t TEST_DVPT128_57_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_57_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_57_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_58_NONCE[] = {
+    0xc5, 0x54, 0x30, 0xf2, 0xda, 0x06, 0x87, 0xea,
+    0x40, 0x31, 0x38, 0x84, 0xab,
+};
+static const size_t TEST_DVPT128_58_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_58_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_58_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_58_EXPECTED[] = {
+    0x93, 0x40, 0x26, 0x67, 0x30, 0xea, 0x36, 0x20,
+    0x7b, 0xb7, 0x34, 0x81, 0x9d, 0x35, 0x53, 0xe9,
+};
+static const size_t TEST_DVPT128_58_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_58_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_58_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 24, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_4_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_4_KEY[] = {
+    0x19, 0xeb, 0xfd, 0xe2, 0xd5, 0x46, 0x8b, 0xa0,
+    0xa3, 0x03, 0x1b, 0xde, 0x62, 0x9b, 0x11, 0xfd,
+};
+static const size_t TEST_DVPT128_GROUP_4_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_60_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_60_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_60_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_60_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_60_EXPECTED[] = {
+    0xa9, 0x0e, 0x8e, 0xa4, 0x40, 0x85, 0xce, 0xd7,
+    0x91, 0xb2, 0xfd, 0xb7, 0xfd, 0x44, 0xb5, 0xcf,
+    0x0b, 0xd7, 0xd2, 0x77, 0x18, 0x02, 0x9b, 0xb7,
+    0x03, 0xe1, 0xfa, 0x6b,
+};
+static const size_t TEST_DVPT128_60_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_60_INPUT[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+};
+static const size_t TEST_DVPT128_60_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_64_NONCE[] = {
+    0x12, 0x3a, 0x0b, 0xea, 0xce, 0x4e, 0x39,
+};
+static const size_t TEST_DVPT128_64_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_64_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_64_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_64_EXPECTED[] = {
+    0x47, 0xd7, 0x14, 0x09, 0xa0, 0x3c, 0x33, 0x0b,
+    0xe9, 0x45, 0x1b, 0x3f, 0x92, 0xc9, 0xd2, 0x1c,
+    0x58, 0x43, 0x91, 0xad, 0x10, 0x10, 0xe9, 0xd6,
+    0x09, 0xb8, 0x98, 0x01,
+};
+static const size_t TEST_DVPT128_64_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_64_INPUT[] = {
+    0x9d, 0x03, 0x3e, 0x3b, 0x66, 0xef, 0xed, 0x14,
+    0x67, 0x86, 0x8f, 0x38, 0x24, 0x17, 0xc8, 0x05,
+    0x94, 0x87, 0x7a, 0x28, 0xbc, 0x97, 0xf4, 0x06,
+};
+static const size_t TEST_DVPT128_64_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_71_NONCE[] = {
+    0xf6, 0x7b, 0x98, 0xef, 0xd3, 0x9b, 0x55,
+};
+static const size_t TEST_DVPT128_71_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_71_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_71_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_71_EXPECTED[] = {
+    0xdd, 0x17, 0x59, 0x05, 0xa7, 0xea, 0x3a, 0xef,
+    0x9f, 0xce, 0x06, 0x8e, 0x6c, 0xb7, 0x8e, 0x9c,
+    0xc6, 0x05, 0x19, 0x75, 0x5a, 0x17, 0x8c, 0x77,
+    0xb7, 0x53, 0x18, 0x1c,
+};
+static const size_t TEST_DVPT128_71_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_71_INPUT[] = {
+    0xf2, 0xe9, 0x44, 0xe1, 0xae, 0x47, 0xad, 0x58,
+    0x73, 0xbf, 0x39, 0x1f, 0x1b, 0x0c, 0xc0, 0x7f,
+    0x61, 0x51, 0xeb, 0x4c, 0x50, 0xbb, 0x45, 0xb2,
+};
+static const size_t TEST_DVPT128_71_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_72_NONCE[] = {
+    0xe6, 0x0e, 0x2c, 0x00, 0x2d, 0x1c, 0x99,
+};
+static const size_t TEST_DVPT128_72_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_72_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_72_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_72_EXPECTED[] = {
+    0x8a, 0xd6, 0xb7, 0x6f, 0x54, 0x39, 0x2e, 0xe0,
+    0xf2, 0x83, 0x4f, 0x09, 0x14, 0x25, 0x45, 0xbc,
+    0xde, 0x9b, 0xf0, 0x3d, 0x04, 0xd6, 0x4a, 0xa1,
+    0x08, 0x76, 0xf2, 0xda,
+};
+static const size_t TEST_DVPT128_72_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_72_INPUT[] = {
+    0x70, 0xf4, 0x8d, 0xc1, 0xd7, 0x6e, 0x50, 0x28,
+    0xda, 0x07, 0xe2, 0x98, 0x52, 0x80, 0x13, 0x75,
+    0xa9, 0xed, 0xb2, 0x21, 0x4a, 0x5e, 0xa4, 0xc0,
+};
+static const size_t TEST_DVPT128_72_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_73_NONCE[] = {
+    0x09, 0x8e, 0x05, 0x3f, 0xa0, 0x80, 0x43,
+};
+static const size_t TEST_DVPT128_73_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_73_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_73_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_73_EXPECTED[] = {
+    0x80, 0x8e, 0xb3, 0xe0, 0x4c, 0x39, 0xab, 0xde,
+    0x64, 0x67, 0x4f, 0x0f, 0x77, 0x16, 0xdd, 0xe1,
+    0x16, 0x99, 0xcf, 0xf8, 0xdd, 0x36, 0x7c, 0x4c,
+    0xd4, 0xf7, 0xfc, 0x07,
+};
+static const size_t TEST_DVPT128_73_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_73_INPUT[] = {
+    0xbd, 0x81, 0x68, 0x0e, 0x3d, 0xc0, 0xb3, 0x54,
+    0x31, 0xc9, 0x25, 0x98, 0xdc, 0xaa, 0x26, 0xef,
+    0x09, 0xca, 0x0d, 0xa5, 0xe7, 0x71, 0x93, 0xde,
+};
+static const size_t TEST_DVPT128_73_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_5_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_5_KEY[] = {
+    0x19, 0x7a, 0xfb, 0x02, 0xff, 0xbd, 0x8f, 0x69,
+    0x9d, 0xac, 0xae, 0x87, 0x09, 0x4d, 0x52, 0x43,
+};
+static const size_t TEST_DVPT128_GROUP_5_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_75_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_75_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_75_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_75_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_75_EXPECTED[] = {
+    0x24, 0xab, 0x9e, 0xeb, 0x0e, 0x55, 0x08, 0xca,
+    0xe8, 0x00, 0x74, 0xf1, 0x07, 0x0e, 0xe1, 0x88,
+    0xa6, 0x37, 0x17, 0x18, 0x60, 0x88, 0x1f, 0x1f,
+    0x2d, 0x9a, 0x3f, 0xbc, 0x21, 0x05, 0x95, 0xb7,
+    0xb8, 0xb1, 0xb4, 0x15, 0x23, 0x11, 0x1a, 0x8e,
+};
+static const size_t TEST_DVPT128_75_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_75_INPUT[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+};
+static const size_t TEST_DVPT128_75_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_79_NONCE[] = {
+    0x12, 0x3a, 0x0b, 0xea, 0xce, 0x4e, 0x39,
+};
+static const size_t TEST_DVPT128_79_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_79_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_79_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_79_EXPECTED[] = {
+    0xd4, 0x30, 0x35, 0xcd, 0xb5, 0xa1, 0x86, 0x8a,
+    0xa4, 0x30, 0xe8, 0xb4, 0x1a, 0x1d, 0xc5, 0x7a,
+    0x63, 0x90, 0x87, 0x23, 0x8e, 0x38, 0xbd, 0x62,
+    0x8f, 0xee, 0xda, 0x2e, 0x8f, 0x24, 0x9d, 0xd9,
+    0x3a, 0x83, 0x58, 0xde, 0xf7, 0x63, 0x98, 0x75,
+};
+static const size_t TEST_DVPT128_79_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_79_INPUT[] = {
+    0x9d, 0x03, 0x3e, 0x3b, 0x66, 0xef, 0xed, 0x14,
+    0x67, 0x86, 0x8f, 0x38, 0x24, 0x17, 0xc8, 0x05,
+    0x94, 0x87, 0x7a, 0x28, 0xbc, 0x97, 0xf4, 0x06,
+};
+static const size_t TEST_DVPT128_79_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_86_NONCE[] = {
+    0xf6, 0x7b, 0x98, 0xef, 0xd3, 0x9b, 0x55,
+};
+static const size_t TEST_DVPT128_86_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_86_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_86_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_86_EXPECTED[] = {
+    0x37, 0xd6, 0x3c, 0x2b, 0xbf, 0x44, 0xd2, 0xeb,
+    0x15, 0x5e, 0xcc, 0x1a, 0x84, 0x48, 0x41, 0xd5,
+    0xc3, 0x3f, 0x1a, 0x6d, 0x44, 0x34, 0x19, 0x33,
+    0x02, 0x17, 0xa4, 0xf1, 0xf4, 0xfb, 0x30, 0x22,
+    0x57, 0xb0, 0xde, 0x7c, 0x9d, 0xa2, 0xe7, 0x50,
+};
+static const size_t TEST_DVPT128_86_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_86_INPUT[] = {
+    0xf2, 0xe9, 0x44, 0xe1, 0xae, 0x47, 0xad, 0x58,
+    0x73, 0xbf, 0x39, 0x1f, 0x1b, 0x0c, 0xc0, 0x7f,
+    0x61, 0x51, 0xeb, 0x4c, 0x50, 0xbb, 0x45, 0xb2,
+};
+static const size_t TEST_DVPT128_86_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_87_NONCE[] = {
+    0xe6, 0x0e, 0x2c, 0x00, 0x2d, 0x1c, 0x99,
+};
+static const size_t TEST_DVPT128_87_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_87_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_87_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_87_EXPECTED[] = {
+    0x33, 0xe0, 0xdc, 0xe4, 0x41, 0x0e, 0x51, 0xbe,
+    0xd5, 0x32, 0x3e, 0xa4, 0x94, 0x90, 0x20, 0x70,
+    0x84, 0xac, 0x91, 0x73, 0x2b, 0xae, 0x42, 0x92,
+    0x36, 0xa3, 0x05, 0xd5, 0x20, 0xa1, 0xa2, 0x49,
+    0x30, 0xa7, 0x0a, 0x31, 0x1a, 0xa3, 0x69, 0x5d,
+};
+static const size_t TEST_DVPT128_87_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_87_INPUT[] = {
+    0x70, 0xf4, 0x8d, 0xc1, 0xd7, 0x6e, 0x50, 0x28,
+    0xda, 0x07, 0xe2, 0x98, 0x52, 0x80, 0x13, 0x75,
+    0xa9, 0xed, 0xb2, 0x21, 0x4a, 0x5e, 0xa4, 0xc0,
+};
+static const size_t TEST_DVPT128_87_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_88_NONCE[] = {
+    0x09, 0x8e, 0x05, 0x3f, 0xa0, 0x80, 0x43,
+};
+static const size_t TEST_DVPT128_88_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_88_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_88_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_88_EXPECTED[] = {
+    0x1d, 0x73, 0x2c, 0x33, 0x43, 0x19, 0xbd, 0x77,
+    0x5e, 0x7c, 0xf9, 0x3d, 0xbd, 0xc4, 0x20, 0x4b,
+    0xbd, 0xb5, 0x81, 0x92, 0xbe, 0x08, 0x28, 0x04,
+    0x81, 0xe3, 0xd6, 0x4e, 0xd5, 0x46, 0xb6, 0xb7,
+    0x0e, 0xe0, 0x88, 0xa6, 0x93, 0xf5, 0x5f, 0xbb,
+};
+static const size_t TEST_DVPT128_88_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_88_INPUT[] = {
+    0xbd, 0x81, 0x68, 0x0e, 0x3d, 0xc0, 0xb3, 0x54,
+    0x31, 0xc9, 0x25, 0x98, 0xdc, 0xaa, 0x26, 0xef,
+    0x09, 0xca, 0x0d, 0xa5, 0xe7, 0x71, 0x93, 0xde,
+};
+static const size_t TEST_DVPT128_88_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_6_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_6_KEY[] = {
+    0x19, 0x7a, 0xfb, 0x02, 0xff, 0xbd, 0x8f, 0x69,
+    0x9d, 0xac, 0xae, 0x87, 0x09, 0x4d, 0x52, 0x43,
+};
+static const size_t TEST_DVPT128_GROUP_6_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_90_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_90_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_90_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_90_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_90_EXPECTED[] = {
+    0x4a, 0x55, 0x01, 0x34, 0xf9, 0x44, 0x55, 0x97,
+    0x9e, 0xc4, 0xbf, 0x89, 0xad, 0x2b, 0xd8, 0x0d,
+    0x25, 0xa7, 0x7a, 0xe9, 0x4e, 0x45, 0x61, 0x34,
+    0xa3, 0xe1, 0x38, 0xb9,
+};
+static const size_t TEST_DVPT128_90_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_90_INPUT[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+};
+static const size_t TEST_DVPT128_90_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_94_NONCE[] = {
+    0x24, 0xb7, 0xa6, 0x53, 0x91, 0xf8, 0x8b, 0xea,
+    0x38, 0xfc, 0xd5, 0x4a, 0x9a,
+};
+static const size_t TEST_DVPT128_94_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_94_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_94_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_94_EXPECTED[] = {
+    0x05, 0xf2, 0x0b, 0x2a, 0xe7, 0x0f, 0xcb, 0x0e,
+    0xa7, 0x9a, 0xa1, 0x84, 0x5c, 0x15, 0xb8, 0x99,
+    0xa7, 0x99, 0xca, 0x60, 0xf5, 0x1e, 0x6c, 0x29,
+    0x64, 0x13, 0x02, 0x0a,
+};
+static const size_t TEST_DVPT128_94_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_94_INPUT[] = {
+    0x43, 0x41, 0x97, 0x15, 0xce, 0xf9, 0xa4, 0x8d,
+    0xc7, 0x28, 0x0b, 0xc0, 0x35, 0x08, 0x2a, 0x65,
+    0x81, 0xaf, 0xd1, 0xd8, 0x2b, 0xee, 0x9d, 0x1a,
+};
+static const size_t TEST_DVPT128_94_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_101_NONCE[] = {
+    0xc4, 0x7a, 0xf8, 0x0c, 0xd2, 0x6d, 0x04, 0x76,
+    0x30, 0xc1, 0xfd, 0xf0, 0xd1,
+};
+static const size_t TEST_DVPT128_101_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_101_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_101_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_101_EXPECTED[] = {
+    0xa2, 0xa5, 0x90, 0x41, 0xc3, 0xf7, 0x8f, 0x6e,
+    0x10, 0xc3, 0x04, 0x51, 0x18, 0xe8, 0xa4, 0x75,
+    0x94, 0x5e, 0x24, 0xc8, 0x5b, 0x02, 0xab, 0xc4,
+    0x0f, 0x8f, 0xb9, 0x49,
+};
+static const size_t TEST_DVPT128_101_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_101_INPUT[] = {
+    0xd8, 0x30, 0x6c, 0x9c, 0x4e, 0xa6, 0xc6, 0x9c,
+    0x6e, 0x2a, 0xd0, 0xfc, 0x0e, 0x49, 0xb1, 0xe0,
+    0x12, 0x6b, 0x01, 0x07, 0x8d, 0x64, 0x19, 0xff,
+};
+static const size_t TEST_DVPT128_101_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_102_NONCE[] = {
+    0x70, 0xe1, 0x32, 0x02, 0x3a, 0xca, 0xe1, 0xf8,
+    0x8c, 0x7a, 0x23, 0x7b, 0x68,
+};
+static const size_t TEST_DVPT128_102_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_102_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_102_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_102_EXPECTED[] = {
+    0x19, 0xb4, 0xad, 0x22, 0x27, 0x95, 0x32, 0x6c,
+    0xb0, 0x31, 0xcf, 0xdb, 0x07, 0xb6, 0x52, 0xdb,
+    0xf6, 0x4c, 0xa5, 0xdb, 0x5f, 0xf5, 0xd6, 0xd5,
+    0x69, 0xd8, 0xab, 0x41,
+};
+static const size_t TEST_DVPT128_102_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_102_INPUT[] = {
+    0xd0, 0xb2, 0xbe, 0xf5, 0xed, 0x1a, 0x87, 0xd9,
+    0xc7, 0x3d, 0x4a, 0x45, 0x9c, 0xb0, 0x5c, 0x11,
+    0x79, 0x9c, 0x4f, 0x51, 0xad, 0x64, 0x0b, 0x1e,
+};
+static const size_t TEST_DVPT128_102_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_103_NONCE[] = {
+    0x80, 0x10, 0xd3, 0xa2, 0xa1, 0x4f, 0x72, 0xf5,
+    0x58, 0x5d, 0xef, 0xc9, 0x40,
+};
+static const size_t TEST_DVPT128_103_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_103_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_103_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_103_EXPECTED[] = {
+    0x76, 0xb6, 0x6b, 0x90, 0x86, 0x57, 0xf4, 0xdf,
+    0x8a, 0x32, 0x9c, 0x34, 0xcc, 0xdd, 0xe5, 0x0a,
+    0xe7, 0xfc, 0x71, 0xc4, 0xa7, 0x18, 0xb7, 0x12,
+    0xf0, 0x0f, 0xe7, 0x64,
+};
+static const size_t TEST_DVPT128_103_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_103_INPUT[] = {
+    0x4f, 0xab, 0xa0, 0x55, 0x69, 0xbf, 0x7a, 0xc6,
+    0x56, 0x78, 0x0c, 0x16, 0x99, 0x5e, 0x91, 0x22,
+    0xe5, 0x65, 0xfe, 0x99, 0x84, 0xbe, 0x8a, 0x68,
+};
+static const size_t TEST_DVPT128_103_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_7_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_7_KEY[] = {
+    0x90, 0x92, 0x9a, 0x4b, 0x0a, 0xc6, 0x5b, 0x35,
+    0x0a, 0xd1, 0x59, 0x16, 0x11, 0xfe, 0x48, 0x29,
+};
+static const size_t TEST_DVPT128_GROUP_7_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_105_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_105_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_105_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_105_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_105_EXPECTED[] = {
+    0x4b, 0xfe, 0x4e, 0x35, 0x78, 0x4f, 0x0a, 0x65,
+    0xb5, 0x45, 0x47, 0x7e, 0x5e, 0x2f, 0x4b, 0xae,
+    0x0e, 0x1e, 0x6f, 0xa7, 0x17, 0xea, 0xf2, 0xcb,
+    0x6a, 0x9a, 0x97, 0x0b, 0x9b, 0xeb, 0x2a, 0xc1,
+    0xbd, 0x4f, 0xd6, 0x21, 0x68, 0xf8, 0x37, 0x8a,
+};
+static const size_t TEST_DVPT128_105_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_105_INPUT[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+};
+static const size_t TEST_DVPT128_105_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_109_NONCE[] = {
+    0x24, 0xb7, 0xa6, 0x53, 0x91, 0xf8, 0x8b, 0xea,
+    0x38, 0xfc, 0xd5, 0x4a, 0x9a,
+};
+static const size_t TEST_DVPT128_109_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_109_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_109_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_109_EXPECTED[] = {
+    0x9f, 0xa8, 0x46, 0xef, 0x8d, 0x19, 0x8c, 0x53,
+    0x8f, 0x84, 0xf8, 0x56, 0xba, 0xb8, 0xf7, 0xf9,
+    0xc3, 0xbe, 0xd9, 0x0b, 0x53, 0xac, 0xb6, 0xa3,
+    0x26, 0x58, 0xe0, 0x77, 0x68, 0x73, 0x15, 0xea,
+    0xf1, 0x14, 0x58, 0xbd, 0xf6, 0xe3, 0xc3, 0x6a,
+};
+static const size_t TEST_DVPT128_109_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_109_INPUT[] = {
+    0x43, 0x41, 0x97, 0x15, 0xce, 0xf9, 0xa4, 0x8d,
+    0xc7, 0x28, 0x0b, 0xc0, 0x35, 0x08, 0x2a, 0x65,
+    0x81, 0xaf, 0xd1, 0xd8, 0x2b, 0xee, 0x9d, 0x1a,
+};
+static const size_t TEST_DVPT128_109_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_116_NONCE[] = {
+    0xc4, 0x7a, 0xf8, 0x0c, 0xd2, 0x6d, 0x04, 0x76,
+    0x30, 0xc1, 0xfd, 0xf0, 0xd1,
+};
+static const size_t TEST_DVPT128_116_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_116_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_116_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_116_EXPECTED[] = {
+    0x99, 0xe4, 0x0b, 0x3c, 0x67, 0xac, 0xa9, 0x5d,
+    0xd4, 0x46, 0x2c, 0x20, 0xcb, 0xd6, 0xb2, 0x74,
+    0x1e, 0x70, 0x33, 0xfc, 0x4f, 0x41, 0xa9, 0x75,
+    0xc9, 0x39, 0x0f, 0xbd, 0xb9, 0xec, 0x41, 0x62,
+    0x67, 0x09, 0x6c, 0xcb, 0xf2, 0xc1, 0x48, 0xe5,
+};
+static const size_t TEST_DVPT128_116_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_116_INPUT[] = {
+    0xd8, 0x30, 0x6c, 0x9c, 0x4e, 0xa6, 0xc6, 0x9c,
+    0x6e, 0x2a, 0xd0, 0xfc, 0x0e, 0x49, 0xb1, 0xe0,
+    0x12, 0x6b, 0x01, 0x07, 0x8d, 0x64, 0x19, 0xff,
+};
+static const size_t TEST_DVPT128_116_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_117_NONCE[] = {
+    0x70, 0xe1, 0x32, 0x02, 0x3a, 0xca, 0xe1, 0xf8,
+    0x8c, 0x7a, 0x23, 0x7b, 0x68,
+};
+static const size_t TEST_DVPT128_117_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_117_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_117_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_117_EXPECTED[] = {
+    0xde, 0x07, 0x94, 0x18, 0xc2, 0x5b, 0xa6, 0x7e,
+    0x5f, 0xda, 0x00, 0x99, 0x98, 0xe3, 0xfc, 0xe6,
+    0x1b, 0xfd, 0xc3, 0xb7, 0x78, 0x7c, 0xf0, 0x66,
+    0x55, 0xc1, 0x8a, 0xe3, 0x8b, 0x7e, 0xe7, 0xf0,
+    0x0f, 0x96, 0xcf, 0xca, 0x4f, 0xe9, 0xa2, 0xef,
+};
+static const size_t TEST_DVPT128_117_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_117_INPUT[] = {
+    0xd0, 0xb2, 0xbe, 0xf5, 0xed, 0x1a, 0x87, 0xd9,
+    0xc7, 0x3d, 0x4a, 0x45, 0x9c, 0xb0, 0x5c, 0x11,
+    0x79, 0x9c, 0x4f, 0x51, 0xad, 0x64, 0x0b, 0x1e,
+};
+static const size_t TEST_DVPT128_117_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_118_NONCE[] = {
+    0x80, 0x10, 0xd3, 0xa2, 0xa1, 0x4f, 0x72, 0xf5,
+    0x58, 0x5d, 0xef, 0xc9, 0x40,
+};
+static const size_t TEST_DVPT128_118_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_118_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_118_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT128_118_EXPECTED[] = {
+    0xfb, 0xab, 0x64, 0xd8, 0xdd, 0x8b, 0x6e, 0x33,
+    0xc7, 0xcc, 0x61, 0x24, 0xcd, 0x65, 0xf0, 0x04,
+    0xd7, 0x24, 0x72, 0x77, 0xfe, 0x98, 0xd5, 0xd3,
+    0xb3, 0x53, 0x57, 0xa3, 0x5f, 0xf9, 0xe5, 0x8e,
+    0x18, 0xd6, 0xd8, 0x0d, 0xf9, 0xfc, 0x33, 0x5d,
+};
+static const size_t TEST_DVPT128_118_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_118_INPUT[] = {
+    0x4f, 0xab, 0xa0, 0x55, 0x69, 0xbf, 0x7a, 0xc6,
+    0x56, 0x78, 0x0c, 0x16, 0x99, 0x5e, 0x91, 0x22,
+    0xe5, 0x65, 0xfe, 0x99, 0x84, 0xbe, 0x8a, 0x68,
+};
+static const size_t TEST_DVPT128_118_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 0, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_8_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_8_KEY[] = {
+    0x90, 0x92, 0x9a, 0x4b, 0x0a, 0xc6, 0x5b, 0x35,
+    0x0a, 0xd1, 0x59, 0x16, 0x11, 0xfe, 0x48, 0x29,
+};
+static const size_t TEST_DVPT128_GROUP_8_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_120_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_120_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_120_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT128_120_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_120_EXPECTED[] = {
+    0x78, 0x2e, 0x43, 0x18,
+};
+static const size_t TEST_DVPT128_120_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_120_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_120_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_124_NONCE[] = {
+    0x8c, 0x68, 0x7b, 0x43, 0x18, 0x81, 0x3a,
+};
+static const size_t TEST_DVPT128_124_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_124_ADATA[] = {
+    0xfc, 0xad, 0x52, 0xa8, 0x85, 0x44, 0x32, 0x5b,
+    0xb3, 0x1e, 0xb5, 0xde, 0x4a, 0x41, 0xdb, 0xff,
+    0x6a, 0x96, 0xf6, 0x9d, 0x09, 0x93, 0xb9, 0x69,
+    0xa0, 0x17, 0x92, 0xee, 0x23, 0x95, 0x3a, 0xcf,
+};
+static const size_t TEST_DVPT128_124_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_124_EXPECTED[] = {
+    0x1b, 0xe5, 0x35, 0xa0,
+};
+static const size_t TEST_DVPT128_124_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_124_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_124_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_131_NONCE[] = {
+    0xa1, 0xae, 0xda, 0x4b, 0x4c, 0xb8, 0xdd,
+};
+static const size_t TEST_DVPT128_131_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_131_ADATA[] = {
+    0xdb, 0x30, 0x22, 0xef, 0x4c, 0xd6, 0x8a, 0xe2,
+    0x2b, 0x50, 0x15, 0x99, 0x44, 0x8f, 0xfe, 0x2d,
+    0xda, 0x15, 0xcf, 0xd2, 0xe2, 0x59, 0x31, 0x5c,
+    0x6f, 0x6d, 0x03, 0x03, 0x6e, 0xde, 0xa9, 0x63,
+};
+static const size_t TEST_DVPT128_131_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_131_EXPECTED[] = {
+    0xe6, 0x17, 0xe0, 0x06,
+};
+static const size_t TEST_DVPT128_131_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_131_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_131_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_132_NONCE[] = {
+    0xf2, 0x48, 0xe5, 0x22, 0x5e, 0x3d, 0x9a,
+};
+static const size_t TEST_DVPT128_132_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_132_ADATA[] = {
+    0xfd, 0xc6, 0x4e, 0xf7, 0x6a, 0x3b, 0xfd, 0x0a,
+    0x15, 0xd0, 0xbc, 0x8e, 0x8b, 0xac, 0xaf, 0x64,
+    0x34, 0x67, 0x96, 0xa3, 0xe3, 0x5a, 0xfc, 0xf2,
+    0xac, 0x1a, 0xb1, 0x36, 0xf6, 0x3f, 0x7b, 0x6e,
+};
+static const size_t TEST_DVPT128_132_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_132_EXPECTED[] = {
+    0xb7, 0x90, 0x93, 0x95,
+};
+static const size_t TEST_DVPT128_132_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_132_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_132_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_133_NONCE[] = {
+    0xe6, 0x82, 0x28, 0xf5, 0xc6, 0x5b, 0x73,
+};
+static const size_t TEST_DVPT128_133_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_133_ADATA[] = {
+    0x61, 0x4e, 0xfd, 0xf8, 0x9c, 0xe2, 0xa9, 0xfc,
+    0xbd, 0x38, 0xbd, 0xc0, 0xb4, 0xce, 0xce, 0x54,
+    0xdf, 0xd7, 0x53, 0x28, 0x80, 0xe0, 0xb4, 0xce,
+    0x6e, 0xb3, 0xa4, 0x01, 0x0b, 0x7c, 0xb1, 0xe7,
+};
+static const size_t TEST_DVPT128_133_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_133_EXPECTED[] = {
+    0x8a, 0x05, 0xd2, 0xea,
+};
+static const size_t TEST_DVPT128_133_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_133_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_133_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_9_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_9_KEY[] = {
+    0x6a, 0x79, 0x8d, 0x7c, 0x5e, 0x1a, 0x72, 0xb4,
+    0x3e, 0x20, 0xad, 0x5c, 0x7b, 0x08, 0x56, 0x7b,
+};
+static const size_t TEST_DVPT128_GROUP_9_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_135_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_135_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_135_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT128_135_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_135_EXPECTED[] = {
+    0x41, 0xb4, 0x76, 0x01, 0x3f, 0x45, 0xe4, 0xa7,
+    0x81, 0xf2, 0x53, 0xa6, 0xf3, 0xb1, 0xe5, 0x30,
+};
+static const size_t TEST_DVPT128_135_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_135_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_135_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_139_NONCE[] = {
+    0x8c, 0x68, 0x7b, 0x43, 0x18, 0x81, 0x3a,
+};
+static const size_t TEST_DVPT128_139_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_139_ADATA[] = {
+    0xfc, 0xad, 0x52, 0xa8, 0x85, 0x44, 0x32, 0x5b,
+    0xb3, 0x1e, 0xb5, 0xde, 0x4a, 0x41, 0xdb, 0xff,
+    0x6a, 0x96, 0xf6, 0x9d, 0x09, 0x93, 0xb9, 0x69,
+    0xa0, 0x17, 0x92, 0xee, 0x23, 0x95, 0x3a, 0xcf,
+};
+static const size_t TEST_DVPT128_139_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_139_EXPECTED[] = {
+    0xec, 0x77, 0x4d, 0x90, 0x00, 0x76, 0x3b, 0xba,
+    0x3a, 0x5a, 0xc3, 0x07, 0x41, 0x88, 0x27, 0xb2,
+};
+static const size_t TEST_DVPT128_139_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_139_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_139_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_146_NONCE[] = {
+    0xa1, 0xae, 0xda, 0x4b, 0x4c, 0xb8, 0xdd,
+};
+static const size_t TEST_DVPT128_146_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_146_ADATA[] = {
+    0xdb, 0x30, 0x22, 0xef, 0x4c, 0xd6, 0x8a, 0xe2,
+    0x2b, 0x50, 0x15, 0x99, 0x44, 0x8f, 0xfe, 0x2d,
+    0xda, 0x15, 0xcf, 0xd2, 0xe2, 0x59, 0x31, 0x5c,
+    0x6f, 0x6d, 0x03, 0x03, 0x6e, 0xde, 0xa9, 0x63,
+};
+static const size_t TEST_DVPT128_146_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_146_EXPECTED[] = {
+    0x0b, 0x9d, 0x79, 0xe8, 0xe3, 0x3e, 0xc4, 0x55,
+    0x32, 0xaf, 0x55, 0x15, 0xa9, 0x9f, 0x05, 0xdf,
+};
+static const size_t TEST_DVPT128_146_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_146_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_146_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_147_NONCE[] = {
+    0xf2, 0x48, 0xe5, 0x22, 0x5e, 0x3d, 0x9a,
+};
+static const size_t TEST_DVPT128_147_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_147_ADATA[] = {
+    0xfd, 0xc6, 0x4e, 0xf7, 0x6a, 0x3b, 0xfd, 0x0a,
+    0x15, 0xd0, 0xbc, 0x8e, 0x8b, 0xac, 0xaf, 0x64,
+    0x34, 0x67, 0x96, 0xa3, 0xe3, 0x5a, 0xfc, 0xf2,
+    0xac, 0x1a, 0xb1, 0x36, 0xf6, 0x3f, 0x7b, 0x6e,
+};
+static const size_t TEST_DVPT128_147_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_147_EXPECTED[] = {
+    0x15, 0x83, 0xe1, 0xe5, 0xa8, 0x60, 0x01, 0xbb,
+    0xce, 0xc6, 0x22, 0x92, 0xcc, 0xfd, 0x4d, 0x48,
+};
+static const size_t TEST_DVPT128_147_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_147_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_147_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_148_NONCE[] = {
+    0xe6, 0x82, 0x28, 0xf5, 0xc6, 0x5b, 0x73,
+};
+static const size_t TEST_DVPT128_148_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_148_ADATA[] = {
+    0x61, 0x4e, 0xfd, 0xf8, 0x9c, 0xe2, 0xa9, 0xfc,
+    0xbd, 0x38, 0xbd, 0xc0, 0xb4, 0xce, 0xce, 0x54,
+    0xdf, 0xd7, 0x53, 0x28, 0x80, 0xe0, 0xb4, 0xce,
+    0x6e, 0xb3, 0xa4, 0x01, 0x0b, 0x7c, 0xb1, 0xe7,
+};
+static const size_t TEST_DVPT128_148_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_148_EXPECTED[] = {
+    0xb7, 0x2c, 0xaa, 0xc6, 0x36, 0x2e, 0x68, 0xe4,
+    0x45, 0xf6, 0x9f, 0x60, 0x5f, 0x21, 0xe0, 0xa2,
+};
+static const size_t TEST_DVPT128_148_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_148_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_148_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_10_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_10_KEY[] = {
+    0x6a, 0x79, 0x8d, 0x7c, 0x5e, 0x1a, 0x72, 0xb4,
+    0x3e, 0x20, 0xad, 0x5c, 0x7b, 0x08, 0x56, 0x7b,
+};
+static const size_t TEST_DVPT128_GROUP_10_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_150_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_150_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_150_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT128_150_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_150_EXPECTED[] = {
+    0x9f, 0x69, 0xf2, 0x4f,
+};
+static const size_t TEST_DVPT128_150_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_150_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_150_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_154_NONCE[] = {
+    0x1e, 0x7e, 0x51, 0xf0, 0xfa, 0x9a, 0x33, 0xed,
+    0x61, 0x8c, 0x26, 0xf5, 0xe3,
+};
+static const size_t TEST_DVPT128_154_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_154_ADATA[] = {
+    0xda, 0x9b, 0x8f, 0xfb, 0x0f, 0x3c, 0x2a, 0xee,
+    0x2e, 0x38, 0x6c, 0xc9, 0xf0, 0x35, 0xec, 0x1e,
+    0xb3, 0xe6, 0x29, 0xbd, 0x15, 0x44, 0xc1, 0x1d,
+    0xc2, 0x1b, 0xe4, 0xfd, 0x8a, 0xc9, 0x07, 0x4a,
+};
+static const size_t TEST_DVPT128_154_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_154_EXPECTED[] = {
+    0xc2, 0x83, 0x46, 0x6f,
+};
+static const size_t TEST_DVPT128_154_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_154_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_154_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_161_NONCE[] = {
+    0x78, 0x64, 0xc7, 0x17, 0xec, 0x93, 0xdb, 0x38,
+    0xb1, 0x06, 0x79, 0xbe, 0x47,
+};
+static const size_t TEST_DVPT128_161_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_161_ADATA[] = {
+    0x67, 0x9a, 0xad, 0x1a, 0xd1, 0xe5, 0x70, 0x29,
+    0xe3, 0x36, 0x2b, 0x32, 0x55, 0x72, 0xfc, 0x71,
+    0xca, 0xc5, 0x31, 0x84, 0xb0, 0xf1, 0x54, 0x68,
+    0x67, 0xe6, 0x65, 0xa4, 0xa5, 0x94, 0x66, 0xc4,
+};
+static const size_t TEST_DVPT128_161_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_161_EXPECTED[] = {
+    0x48, 0xf3, 0xa1, 0xec,
+};
+static const size_t TEST_DVPT128_161_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_161_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_161_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_162_NONCE[] = {
+    0xc3, 0xbf, 0x9d, 0xfe, 0x9d, 0x6c, 0x26, 0xf5,
+    0x43, 0x18, 0x8f, 0xb4, 0x57,
+};
+static const size_t TEST_DVPT128_162_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_162_ADATA[] = {
+    0xe3, 0x01, 0xf6, 0x9a, 0xd3, 0xa7, 0xe0, 0x8a,
+    0x3d, 0x02, 0x46, 0x2f, 0x0a, 0xa5, 0x84, 0x44,
+    0x9e, 0xb0, 0x44, 0x9b, 0x0e, 0x3c, 0x50, 0xaa,
+    0x8d, 0xfa, 0xa4, 0x47, 0x28, 0x16, 0xc8, 0xb0,
+};
+static const size_t TEST_DVPT128_162_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_162_EXPECTED[] = {
+    0x24, 0x76, 0x3d, 0xef,
+};
+static const size_t TEST_DVPT128_162_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_162_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_162_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_163_NONCE[] = {
+    0x15, 0x27, 0x65, 0x7d, 0x2f, 0xd9, 0x8f, 0x7d,
+    0xec, 0xa5, 0x5c, 0xc6, 0x49,
+};
+static const size_t TEST_DVPT128_163_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_163_ADATA[] = {
+    0xf4, 0xc7, 0x23, 0x43, 0x3b, 0x7c, 0xaf, 0xe3,
+    0xcd, 0xa9, 0xbb, 0x49, 0x40, 0xa2, 0x1a, 0x89,
+    0xa8, 0x38, 0x2d, 0x13, 0x01, 0x8b, 0x62, 0x2c,
+    0xcd, 0x1f, 0xfb, 0x9f, 0xfd, 0x32, 0x11, 0xaf,
+};
+static const size_t TEST_DVPT128_163_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_163_EXPECTED[] = {
+    0x63, 0x39, 0x4b, 0xee,
+};
+static const size_t TEST_DVPT128_163_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT128_163_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_163_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_11_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_11_KEY[] = {
+    0xf9, 0xfd, 0xca, 0x4a, 0xc6, 0x4f, 0xe7, 0xf0,
+    0x14, 0xde, 0x0f, 0x43, 0x03, 0x9c, 0x75, 0x71,
+};
+static const size_t TEST_DVPT128_GROUP_11_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_165_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_165_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_165_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT128_165_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_165_EXPECTED[] = {
+    0x18, 0x59, 0xac, 0x36, 0xa4, 0x0a, 0x6b, 0x28,
+    0xb3, 0x42, 0x66, 0x25, 0x36, 0x27, 0x79, 0x7a,
+};
+static const size_t TEST_DVPT128_165_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_165_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_165_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_169_NONCE[] = {
+    0x1e, 0x7e, 0x51, 0xf0, 0xfa, 0x9a, 0x33, 0xed,
+    0x61, 0x8c, 0x26, 0xf5, 0xe3,
+};
+static const size_t TEST_DVPT128_169_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_169_ADATA[] = {
+    0xda, 0x9b, 0x8f, 0xfb, 0x0f, 0x3c, 0x2a, 0xee,
+    0x2e, 0x38, 0x6c, 0xc9, 0xf0, 0x35, 0xec, 0x1e,
+    0xb3, 0xe6, 0x29, 0xbd, 0x15, 0x44, 0xc1, 0x1d,
+    0xc2, 0x1b, 0xe4, 0xfd, 0x8a, 0xc9, 0x07, 0x4a,
+};
+static const size_t TEST_DVPT128_169_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_169_EXPECTED[] = {
+    0x8b, 0x5b, 0xfe, 0x6b, 0x5b, 0x55, 0x52, 0x00,
+    0x73, 0x00, 0xba, 0xe7, 0x11, 0x72, 0x61, 0x2f,
+};
+static const size_t TEST_DVPT128_169_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_169_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_169_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_176_NONCE[] = {
+    0x78, 0x64, 0xc7, 0x17, 0xec, 0x93, 0xdb, 0x38,
+    0xb1, 0x06, 0x79, 0xbe, 0x47,
+};
+static const size_t TEST_DVPT128_176_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_176_ADATA[] = {
+    0x67, 0x9a, 0xad, 0x1a, 0xd1, 0xe5, 0x70, 0x29,
+    0xe3, 0x36, 0x2b, 0x32, 0x55, 0x72, 0xfc, 0x71,
+    0xca, 0xc5, 0x31, 0x84, 0xb0, 0xf1, 0x54, 0x68,
+    0x67, 0xe6, 0x65, 0xa4, 0xa5, 0x94, 0x66, 0xc4,
+};
+static const size_t TEST_DVPT128_176_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_176_EXPECTED[] = {
+    0xe9, 0xcf, 0xb1, 0x06, 0x93, 0x80, 0x43, 0x4f,
+    0x22, 0x1d, 0xb4, 0x22, 0x9a, 0x08, 0x3a, 0x76,
+};
+static const size_t TEST_DVPT128_176_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_176_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_176_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_177_NONCE[] = {
+    0xc3, 0xbf, 0x9d, 0xfe, 0x9d, 0x6c, 0x26, 0xf5,
+    0x43, 0x18, 0x8f, 0xb4, 0x57,
+};
+static const size_t TEST_DVPT128_177_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_177_ADATA[] = {
+    0xe3, 0x01, 0xf6, 0x9a, 0xd3, 0xa7, 0xe0, 0x8a,
+    0x3d, 0x02, 0x46, 0x2f, 0x0a, 0xa5, 0x84, 0x44,
+    0x9e, 0xb0, 0x44, 0x9b, 0x0e, 0x3c, 0x50, 0xaa,
+    0x8d, 0xfa, 0xa4, 0x47, 0x28, 0x16, 0xc8, 0xb0,
+};
+static const size_t TEST_DVPT128_177_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_177_EXPECTED[] = {
+    0x38, 0x0c, 0xb5, 0x7f, 0xd5, 0x31, 0xbb, 0x1d,
+    0xcf, 0x22, 0x35, 0x05, 0x18, 0xbb, 0xf8, 0xaf,
+};
+static const size_t TEST_DVPT128_177_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_177_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_177_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT128_178_NONCE[] = {
+    0x15, 0x27, 0x65, 0x7d, 0x2f, 0xd9, 0x8f, 0x7d,
+    0xec, 0xa5, 0x5c, 0xc6, 0x49,
+};
+static const size_t TEST_DVPT128_178_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_178_ADATA[] = {
+    0xf4, 0xc7, 0x23, 0x43, 0x3b, 0x7c, 0xaf, 0xe3,
+    0xcd, 0xa9, 0xbb, 0x49, 0x40, 0xa2, 0x1a, 0x89,
+    0xa8, 0x38, 0x2d, 0x13, 0x01, 0x8b, 0x62, 0x2c,
+    0xcd, 0x1f, 0xfb, 0x9f, 0xfd, 0x32, 0x11, 0xaf,
+};
+static const size_t TEST_DVPT128_178_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_178_EXPECTED[] = {
+    0xfb, 0xf2, 0xbe, 0xcc, 0x35, 0xb5, 0x02, 0x40,
+    0x78, 0xbf, 0xcf, 0xc1, 0xf8, 0x31, 0xb6, 0x69,
+};
+static const size_t TEST_DVPT128_178_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT128_178_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT128_178_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 24, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_12_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_12_KEY[] = {
+    0xf9, 0xfd, 0xca, 0x4a, 0xc6, 0x4f, 0xe7, 0xf0,
+    0x14, 0xde, 0x0f, 0x43, 0x03, 0x9c, 0x75, 0x71,
+};
+static const size_t TEST_DVPT128_GROUP_12_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_180_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_180_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_180_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT128_180_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_180_EXPECTED[] = {
+    0x6b, 0xe3, 0x18, 0x60, 0xca, 0x27, 0x1e, 0xf4,
+    0x48, 0xde, 0x8f, 0x8d, 0x8b, 0x39, 0x34, 0x6d,
+    0xaf, 0x4b, 0x81, 0xd7, 0xe9, 0x2d, 0x65, 0xb3,
+    0x38, 0xf1, 0x25, 0xfa,
+};
+static const size_t TEST_DVPT128_180_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_180_INPUT[] = {
+    0xa2, 0x65, 0x48, 0x0c, 0xa8, 0x8d, 0x5f, 0x53,
+    0x6d, 0xb0, 0xdc, 0x6a, 0xbc, 0x40, 0xfa, 0xf0,
+    0xd0, 0x5b, 0xe7, 0xa9, 0x66, 0x97, 0x77, 0x68,
+};
+static const size_t TEST_DVPT128_180_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_184_NONCE[] = {
+    0xcc, 0xee, 0x19, 0xd0, 0x37, 0xcf, 0x4a,
+};
+static const size_t TEST_DVPT128_184_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_184_ADATA[] = {
+    0xc0, 0x26, 0x69, 0x6e, 0x64, 0x25, 0xe6, 0xc3,
+    0x3f, 0x45, 0xb4, 0x14, 0x5f, 0xeb, 0xf1, 0x13,
+    0x7e, 0x7a, 0xc2, 0x63, 0x83, 0xc9, 0xf5, 0xaa,
+    0x4c, 0xd4, 0xe5, 0xe8, 0xab, 0xb1, 0x9e, 0x07,
+};
+static const size_t TEST_DVPT128_184_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_184_EXPECTED[] = {
+    0x9b, 0x61, 0x33, 0x5f, 0x96, 0xfc, 0x5b, 0x31,
+    0x27, 0x4c, 0xc1, 0xfb, 0x27, 0x5f, 0x29, 0xc1,
+    0x10, 0x5d, 0x68, 0xc6, 0x7b, 0x70, 0x65, 0x4f,
+    0x94, 0x05, 0xed, 0xb1,
+};
+static const size_t TEST_DVPT128_184_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_184_INPUT[] = {
+    0x0d, 0xf2, 0x02, 0x43, 0x1e, 0xe7, 0xf2, 0x51,
+    0xa3, 0x8a, 0xaf, 0x6a, 0xa8, 0xcd, 0x31, 0x37,
+    0x82, 0xbd, 0x29, 0x3a, 0xf9, 0x11, 0x40, 0x05,
+};
+static const size_t TEST_DVPT128_184_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_191_NONCE[] = {
+    0xa8, 0x40, 0xe9, 0x8d, 0xf7, 0x2a, 0xe9,
+};
+static const size_t TEST_DVPT128_191_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_191_ADATA[] = {
+    0x22, 0xc6, 0x60, 0x77, 0x32, 0xef, 0x1b, 0xdc,
+    0x7f, 0xcf, 0x61, 0x97, 0xe0, 0x37, 0xcd, 0xad,
+    0xd7, 0xee, 0x17, 0xc0, 0x08, 0x55, 0x2d, 0xd9,
+    0xf0, 0x4b, 0x85, 0x64, 0xd3, 0x4f, 0xb1, 0x7c,
+};
+static const size_t TEST_DVPT128_191_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_191_EXPECTED[] = {
+    0xf7, 0x12, 0x2c, 0xbc, 0xec, 0x93, 0xd5, 0x3f,
+    0xc7, 0xe3, 0xfc, 0x62, 0x9e, 0xa1, 0x5d, 0x28,
+    0x36, 0x3c, 0xad, 0x1c, 0x83, 0xa2, 0x3b, 0xb3,
+    0xcc, 0x5e, 0x0c, 0x4a,
+};
+static const size_t TEST_DVPT128_191_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_191_INPUT[] = {
+    0xa2, 0xf5, 0x33, 0x85, 0x61, 0x8b, 0x41, 0x30,
+    0x1f, 0x4e, 0x3e, 0xa4, 0xc5, 0x97, 0xf4, 0x11,
+    0x10, 0x3d, 0xac, 0x2b, 0x37, 0xab, 0xf5, 0xda,
+};
+static const size_t TEST_DVPT128_191_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_192_NONCE[] = {
+    0x39, 0xd9, 0x3c, 0x3c, 0xf3, 0x1a, 0x6f,
+};
+static const size_t TEST_DVPT128_192_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_192_ADATA[] = {
+    0x93, 0x7d, 0xfa, 0xc5, 0xcd, 0xed, 0x93, 0x84,
+    0x38, 0xf4, 0xe9, 0x7a, 0xab, 0xd9, 0xbe, 0xb5,
+    0x0d, 0xba, 0x40, 0xf8, 0x24, 0x19, 0x82, 0x60,
+    0xa8, 0x97, 0x29, 0x47, 0x9c, 0xfe, 0x68, 0x69,
+};
+static const size_t TEST_DVPT128_192_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_192_EXPECTED[] = {
+    0xe1, 0xca, 0xd7, 0xf9, 0x46, 0xb2, 0x0c, 0x37,
+    0x33, 0x23, 0x21, 0x8c, 0x8a, 0x89, 0xe5, 0x6e,
+    0xdf, 0x30, 0x30, 0x66, 0x2e, 0x50, 0xd4, 0x59,
+    0xfc, 0x12, 0xa5, 0x12,
+};
+static const size_t TEST_DVPT128_192_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_192_INPUT[] = {
+    0xc1, 0xbd, 0xef, 0x96, 0xdc, 0x86, 0x84, 0x46,
+    0xbe, 0x48, 0x49, 0x1b, 0x16, 0x05, 0x04, 0x54,
+    0x6f, 0x2a, 0x40, 0xdd, 0x58, 0x1f, 0x95, 0x82,
+};
+static const size_t TEST_DVPT128_192_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_193_NONCE[] = {
+    0x0b, 0xbc, 0x17, 0x70, 0x19, 0x32, 0x1e,
+};
+static const size_t TEST_DVPT128_193_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_193_ADATA[] = {
+    0xf6, 0xe0, 0x26, 0x78, 0x82, 0x0f, 0x5c, 0xcb,
+    0xed, 0xe6, 0xcb, 0xde, 0xd0, 0x2d, 0x6d, 0xd5,
+    0x8d, 0x48, 0x61, 0x66, 0xd7, 0xb1, 0x8e, 0xe9,
+    0x75, 0xa6, 0x88, 0xaf, 0x42, 0x1f, 0xb7, 0x95,
+};
+static const size_t TEST_DVPT128_193_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_193_EXPECTED[] = {
+    0xd4, 0x74, 0x18, 0x14, 0x46, 0x6a, 0x23, 0xe2,
+    0x61, 0x07, 0xd7, 0x73, 0xf1, 0x03, 0xa4, 0xc8,
+    0x3d, 0xb9, 0xd7, 0x72, 0xdb, 0xd5, 0xfd, 0xc1,
+    0xc2, 0xea, 0xf8, 0x95,
+};
+static const size_t TEST_DVPT128_193_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_193_INPUT[] = {
+    0x72, 0xa7, 0x09, 0x54, 0xd2, 0x2a, 0xd7, 0x22,
+    0xfc, 0x32, 0x75, 0x6a, 0xfc, 0xe6, 0x7b, 0x34,
+    0x4b, 0x2f, 0x3c, 0x55, 0xfe, 0x1d, 0x9e, 0xed,
+};
+static const size_t TEST_DVPT128_193_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_13_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_13_KEY[] = {
+    0xa7, 0xaa, 0x63, 0x5e, 0xa5, 0x1b, 0x0b, 0xb2,
+    0x0a, 0x09, 0x2b, 0xd5, 0x57, 0x3e, 0x72, 0x8c,
+};
+static const size_t TEST_DVPT128_GROUP_13_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_195_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT128_195_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_195_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT128_195_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_195_EXPECTED[] = {
+    0xb3, 0x51, 0xab, 0x96, 0xb2, 0xe4, 0x55, 0x15,
+    0x25, 0x45, 0x58, 0xd5, 0x21, 0x26, 0x73, 0xee,
+    0x6c, 0x77, 0x6d, 0x42, 0xdb, 0xca, 0x3b, 0x51,
+    0x2c, 0xf3, 0xa2, 0x0b, 0x7f, 0xd7, 0xc4, 0x9e,
+    0x6e, 0x79, 0xbe, 0xf4, 0x75, 0xc2, 0x90, 0x6f,
+};
+static const size_t TEST_DVPT128_195_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_195_INPUT[] = {
+    0xa2, 0x65, 0x48, 0x0c, 0xa8, 0x8d, 0x5f, 0x53,
+    0x6d, 0xb0, 0xdc, 0x6a, 0xbc, 0x40, 0xfa, 0xf0,
+    0xd0, 0x5b, 0xe7, 0xa9, 0x66, 0x97, 0x77, 0x68,
+};
+static const size_t TEST_DVPT128_195_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_199_NONCE[] = {
+    0xcc, 0xee, 0x19, 0xd0, 0x37, 0xcf, 0x4a,
+};
+static const size_t TEST_DVPT128_199_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_199_ADATA[] = {
+    0xc0, 0x26, 0x69, 0x6e, 0x64, 0x25, 0xe6, 0xc3,
+    0x3f, 0x45, 0xb4, 0x14, 0x5f, 0xeb, 0xf1, 0x13,
+    0x7e, 0x7a, 0xc2, 0x63, 0x83, 0xc9, 0xf5, 0xaa,
+    0x4c, 0xd4, 0xe5, 0xe8, 0xab, 0xb1, 0x9e, 0x07,
+};
+static const size_t TEST_DVPT128_199_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_199_EXPECTED[] = {
+    0xe6, 0x76, 0xf5, 0xdf, 0xde, 0x8a, 0xd8, 0x10,
+    0xd9, 0xe7, 0x29, 0xd1, 0x42, 0x67, 0x0e, 0xef,
+    0x77, 0xf2, 0x87, 0x83, 0x69, 0xa2, 0x87, 0x97,
+    0xd5, 0x76, 0x03, 0xd5, 0xc4, 0x56, 0x06, 0xc6,
+    0x8b, 0xe5, 0x53, 0x5c, 0x67, 0x1d, 0x54, 0x32,
+};
+static const size_t TEST_DVPT128_199_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_199_INPUT[] = {
+    0x0d, 0xf2, 0x02, 0x43, 0x1e, 0xe7, 0xf2, 0x51,
+    0xa3, 0x8a, 0xaf, 0x6a, 0xa8, 0xcd, 0x31, 0x37,
+    0x82, 0xbd, 0x29, 0x3a, 0xf9, 0x11, 0x40, 0x05,
+};
+static const size_t TEST_DVPT128_199_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_206_NONCE[] = {
+    0xa8, 0x40, 0xe9, 0x8d, 0xf7, 0x2a, 0xe9,
+};
+static const size_t TEST_DVPT128_206_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_206_ADATA[] = {
+    0x22, 0xc6, 0x60, 0x77, 0x32, 0xef, 0x1b, 0xdc,
+    0x7f, 0xcf, 0x61, 0x97, 0xe0, 0x37, 0xcd, 0xad,
+    0xd7, 0xee, 0x17, 0xc0, 0x08, 0x55, 0x2d, 0xd9,
+    0xf0, 0x4b, 0x85, 0x64, 0xd3, 0x4f, 0xb1, 0x7c,
+};
+static const size_t TEST_DVPT128_206_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_206_EXPECTED[] = {
+    0x1b, 0xcf, 0xf9, 0x40, 0xa2, 0xd9, 0xd4, 0x8e,
+    0x93, 0xbb, 0xfd, 0x13, 0xae, 0xd5, 0x94, 0x72,
+    0x37, 0x48, 0x59, 0x83, 0xe6, 0xae, 0x04, 0xb8,
+    0xb9, 0x44, 0xbb, 0x46, 0x30, 0x6a, 0x9b, 0x1e,
+    0x78, 0x3f, 0x3e, 0x54, 0xc9, 0x2d, 0x5f, 0x5e,
+};
+static const size_t TEST_DVPT128_206_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_206_INPUT[] = {
+    0xa2, 0xf5, 0x33, 0x85, 0x61, 0x8b, 0x41, 0x30,
+    0x1f, 0x4e, 0x3e, 0xa4, 0xc5, 0x97, 0xf4, 0x11,
+    0x10, 0x3d, 0xac, 0x2b, 0x37, 0xab, 0xf5, 0xda,
+};
+static const size_t TEST_DVPT128_206_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_207_NONCE[] = {
+    0x39, 0xd9, 0x3c, 0x3c, 0xf3, 0x1a, 0x6f,
+};
+static const size_t TEST_DVPT128_207_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_207_ADATA[] = {
+    0x93, 0x7d, 0xfa, 0xc5, 0xcd, 0xed, 0x93, 0x84,
+    0x38, 0xf4, 0xe9, 0x7a, 0xab, 0xd9, 0xbe, 0xb5,
+    0x0d, 0xba, 0x40, 0xf8, 0x24, 0x19, 0x82, 0x60,
+    0xa8, 0x97, 0x29, 0x47, 0x9c, 0xfe, 0x68, 0x69,
+};
+static const size_t TEST_DVPT128_207_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_207_EXPECTED[] = {
+    0x3b, 0x6c, 0x15, 0x70, 0xc8, 0x5f, 0x29, 0x70,
+    0x79, 0xbe, 0x14, 0xcd, 0x66, 0xd3, 0x35, 0x25,
+    0x1c, 0x7b, 0x52, 0xe1, 0x31, 0xa6, 0x36, 0xf1,
+    0x48, 0x60, 0x89, 0x63, 0xf3, 0x03, 0x77, 0x63,
+    0x84, 0x3b, 0x70, 0xc3, 0x5d, 0x70, 0x11, 0xf8,
+};
+static const size_t TEST_DVPT128_207_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_207_INPUT[] = {
+    0xc1, 0xbd, 0xef, 0x96, 0xdc, 0x86, 0x84, 0x46,
+    0xbe, 0x48, 0x49, 0x1b, 0x16, 0x05, 0x04, 0x54,
+    0x6f, 0x2a, 0x40, 0xdd, 0x58, 0x1f, 0x95, 0x82,
+};
+static const size_t TEST_DVPT128_207_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_208_NONCE[] = {
+    0x0b, 0xbc, 0x17, 0x70, 0x19, 0x32, 0x1e,
+};
+static const size_t TEST_DVPT128_208_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT128_208_ADATA[] = {
+    0xf6, 0xe0, 0x26, 0x78, 0x82, 0x0f, 0x5c, 0xcb,
+    0xed, 0xe6, 0xcb, 0xde, 0xd0, 0x2d, 0x6d, 0xd5,
+    0x8d, 0x48, 0x61, 0x66, 0xd7, 0xb1, 0x8e, 0xe9,
+    0x75, 0xa6, 0x88, 0xaf, 0x42, 0x1f, 0xb7, 0x95,
+};
+static const size_t TEST_DVPT128_208_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_208_EXPECTED[] = {
+    0xb5, 0x40, 0xcd, 0x8c, 0xbe, 0x73, 0x3e, 0x0c,
+    0xa2, 0xba, 0x21, 0x12, 0xea, 0x78, 0x55, 0x96,
+    0xd2, 0xc1, 0xd7, 0x07, 0xf4, 0x16, 0x08, 0x51,
+    0x4b, 0xa2, 0xd0, 0x94, 0x4c, 0x68, 0xcc, 0x36,
+    0xd4, 0x12, 0x5b, 0x3e, 0xf9, 0x07, 0x1d, 0x69,
+};
+static const size_t TEST_DVPT128_208_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_208_INPUT[] = {
+    0x72, 0xa7, 0x09, 0x54, 0xd2, 0x2a, 0xd7, 0x22,
+    0xfc, 0x32, 0x75, 0x6a, 0xfc, 0xe6, 0x7b, 0x34,
+    0x4b, 0x2f, 0x3c, 0x55, 0xfe, 0x1d, 0x9e, 0xed,
+};
+static const size_t TEST_DVPT128_208_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT128_GROUP_14_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT128_GROUP_14_KEY[] = {
+    0xa7, 0xaa, 0x63, 0x5e, 0xa5, 0x1b, 0x0b, 0xb2,
+    0x0a, 0x09, 0x2b, 0xd5, 0x57, 0x3e, 0x72, 0x8c,
+};
+static const size_t TEST_DVPT128_GROUP_14_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_210_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_210_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_210_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT128_210_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_210_EXPECTED[] = {
+    0x93, 0x4f, 0x89, 0x38, 0x24, 0xe8, 0x80, 0xf7,
+    0x43, 0xd1, 0x96, 0xb2, 0x2d, 0x1f, 0x34, 0x0a,
+    0x52, 0x60, 0x81, 0x55, 0x08, 0x7b, 0xd2, 0x8a,
+    0xc2, 0x5e, 0x53, 0x29,
+};
+static const size_t TEST_DVPT128_210_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_210_INPUT[] = {
+    0x87, 0x39, 0xb4, 0xbe, 0xa1, 0xa0, 0x99, 0xfe,
+    0x54, 0x74, 0x99, 0xcb, 0xc6, 0xd1, 0xb1, 0x3d,
+    0x84, 0x9b, 0x80, 0x84, 0xc9, 0xb6, 0xac, 0xc5,
+};
+static const size_t TEST_DVPT128_210_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_214_NONCE[] = {
+    0xe3, 0xc0, 0x3e, 0xf7, 0xe1, 0xd3, 0x19, 0x61,
+    0xee, 0x0b, 0x97, 0xbd, 0x99,
+};
+static const size_t TEST_DVPT128_214_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_214_ADATA[] = {
+    0x8a, 0x36, 0x76, 0xdd, 0x64, 0x08, 0x21, 0xb5,
+    0x8f, 0xb0, 0xf0, 0x32, 0x98, 0x55, 0xfd, 0x58,
+    0x82, 0xc3, 0x76, 0xea, 0x16, 0x6b, 0x95, 0x8b,
+    0x7a, 0xaa, 0xd2, 0x23, 0x05, 0x4e, 0x57, 0x84,
+};
+static const size_t TEST_DVPT128_214_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_214_EXPECTED[] = {
+    0xec, 0xde, 0x42, 0x09, 0x1b, 0xaa, 0x1f, 0x5c,
+    0x17, 0xb7, 0x97, 0x46, 0xe2, 0x1c, 0x3d, 0xe5,
+    0xc7, 0x89, 0x84, 0x57, 0x07, 0x48, 0x02, 0x1c,
+    0xcd, 0x39, 0x95, 0x07,
+};
+static const size_t TEST_DVPT128_214_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_214_INPUT[] = {
+    0x92, 0x97, 0x3c, 0xe7, 0x07, 0x73, 0x3a, 0x73,
+    0x11, 0x8c, 0x8c, 0xe6, 0xb5, 0xe3, 0xfc, 0x77,
+    0xa1, 0x7f, 0x44, 0x83, 0x10, 0xc0, 0x19, 0x7f,
+};
+static const size_t TEST_DVPT128_214_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_221_NONCE[] = {
+    0x93, 0xe0, 0x88, 0x54, 0x56, 0x0e, 0xdb, 0x09,
+    0x6e, 0x5d, 0x65, 0x40, 0x86,
+};
+static const size_t TEST_DVPT128_221_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_221_ADATA[] = {
+    0xbd, 0xc6, 0x0d, 0xff, 0x08, 0xbf, 0xd5, 0xd4,
+    0x43, 0x20, 0xb7, 0x5c, 0x61, 0xe4, 0x56, 0xfd,
+    0x43, 0x33, 0xc9, 0xc3, 0xd0, 0x29, 0x4d, 0x4a,
+    0x48, 0xd9, 0x36, 0xdf, 0xd5, 0x92, 0x2c, 0xe2,
+};
+static const size_t TEST_DVPT128_221_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_221_EXPECTED[] = {
+    0x1f, 0x80, 0x86, 0xa4, 0x3c, 0x1b, 0x2d, 0xea,
+    0x55, 0x79, 0x52, 0xdb, 0x88, 0xe0, 0xdb, 0xbd,
+    0xb9, 0x6a, 0xaf, 0xdb, 0x34, 0x5e, 0xdd, 0xae,
+    0x6c, 0x0b, 0x01, 0x04,
+};
+static const size_t TEST_DVPT128_221_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_221_INPUT[] = {
+    0x56, 0x9e, 0x4a, 0xec, 0x88, 0xdd, 0x51, 0xca,
+    0x51, 0x9c, 0x0a, 0x00, 0xc9, 0x22, 0xee, 0x33,
+    0xd3, 0x55, 0x9b, 0x98, 0xa3, 0x2d, 0x79, 0x06,
+};
+static const size_t TEST_DVPT128_221_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_222_NONCE[] = {
+    0xe3, 0xf3, 0x7b, 0x68, 0xff, 0x50, 0x8c, 0xfe,
+    0x29, 0x54, 0x41, 0xd9, 0xe3,
+};
+static const size_t TEST_DVPT128_222_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_222_ADATA[] = {
+    0xb2, 0xb6, 0xc5, 0x78, 0x2e, 0x4f, 0x12, 0x84,
+    0x67, 0xc5, 0x89, 0xd2, 0xa6, 0xcf, 0x55, 0xef,
+    0x12, 0x87, 0x7a, 0xdb, 0x77, 0x1b, 0xbb, 0x62,
+    0x45, 0xc5, 0xbb, 0xa9, 0xdc, 0xfd, 0x62, 0x08,
+};
+static const size_t TEST_DVPT128_222_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_222_EXPECTED[] = {
+    0xc0, 0xc5, 0xf9, 0x22, 0x85, 0xb1, 0x14, 0xe0,
+    0xa0, 0x77, 0x7e, 0x1b, 0xc2, 0x2b, 0x81, 0x0e,
+    0x7c, 0xc4, 0xf6, 0x8c, 0x28, 0xcd, 0x5c, 0xe0,
+    0x47, 0xa2, 0x8d, 0xd8,
+};
+static const size_t TEST_DVPT128_222_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_222_INPUT[] = {
+    0x02, 0xb5, 0x51, 0x12, 0x04, 0xbd, 0x55, 0xf7,
+    0xc3, 0x79, 0x73, 0xe2, 0x6f, 0x6d, 0xf5, 0x88,
+    0x3c, 0x0a, 0x53, 0x0f, 0x07, 0xc7, 0xf8, 0xc2,
+};
+static const size_t TEST_DVPT128_222_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_223_NONCE[] = {
+    0xea, 0x98, 0xec, 0x44, 0xf5, 0xa8, 0x67, 0x15,
+    0x01, 0x47, 0x83, 0x17, 0x2e,
+};
+static const size_t TEST_DVPT128_223_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_223_ADATA[] = {
+    0xe4, 0x69, 0x2b, 0x9f, 0x06, 0xb6, 0x66, 0xc7,
+    0x45, 0x1b, 0x14, 0x6c, 0x8a, 0xeb, 0x07, 0xa6,
+    0xe3, 0x0c, 0x62, 0x9d, 0x28, 0x06, 0x5c, 0x3d,
+    0xde, 0x59, 0x40, 0x32, 0x5b, 0x14, 0xb8, 0x10,
+};
+static const size_t TEST_DVPT128_223_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_223_EXPECTED[] = {
+    0x56, 0x32, 0x7f, 0x4d, 0xb9, 0xc1, 0x8f, 0x72,
+    0xbb, 0xef, 0xc3, 0xf3, 0x16, 0xd3, 0x1f, 0x97,
+    0x95, 0xdd, 0x77, 0xf4, 0x93, 0x38, 0x5a, 0xb7,
+    0xb7, 0x54, 0x35, 0x52,
+};
+static const size_t TEST_DVPT128_223_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT128_223_INPUT[] = {
+    0x4d, 0xa4, 0x0b, 0x80, 0x57, 0x9c, 0x1d, 0x9a,
+    0x53, 0x09, 0xf7, 0xef, 0xec, 0xb7, 0xc0, 0x59,
+    0xa2, 0xf9, 0x14, 0x51, 0x1c, 0xa5, 0xfc, 0x10,
+};
+static const size_t TEST_DVPT128_223_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT128_GROUP_15_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT128_GROUP_15_KEY[] = {
+    0x26, 0x51, 0x1f, 0xb5, 0x1f, 0xcf, 0xa7, 0x5c,
+    0xb4, 0xb4, 0x4d, 0xa7, 0x5a, 0x6e, 0x5a, 0x0e,
+};
+static const size_t TEST_DVPT128_GROUP_15_KEY_LEN = 16;
+
+static const uint8_t TEST_DVPT128_225_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT128_225_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_225_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT128_225_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_225_EXPECTED[] = {
+    0x50, 0x03, 0x8b, 0x5f, 0xdd, 0x36, 0x4e, 0xe7,
+    0x47, 0xb7, 0x0d, 0x00, 0xbd, 0x36, 0x84, 0x0e,
+    0xce, 0x4e, 0xa1, 0x99, 0x98, 0x12, 0x33, 0x75,
+    0xc0, 0xa4, 0x58, 0xbf, 0xca, 0xfa, 0x3b, 0x26,
+    0x09, 0xaf, 0xe0, 0xf8, 0x25, 0xcb, 0xf5, 0x03,
+};
+static const size_t TEST_DVPT128_225_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_225_INPUT[] = {
+    0x87, 0x39, 0xb4, 0xbe, 0xa1, 0xa0, 0x99, 0xfe,
+    0x54, 0x74, 0x99, 0xcb, 0xc6, 0xd1, 0xb1, 0x3d,
+    0x84, 0x9b, 0x80, 0x84, 0xc9, 0xb6, 0xac, 0xc5,
+};
+static const size_t TEST_DVPT128_225_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_229_NONCE[] = {
+    0xe3, 0xc0, 0x3e, 0xf7, 0xe1, 0xd3, 0x19, 0x61,
+    0xee, 0x0b, 0x97, 0xbd, 0x99,
+};
+static const size_t TEST_DVPT128_229_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_229_ADATA[] = {
+    0x8a, 0x36, 0x76, 0xdd, 0x64, 0x08, 0x21, 0xb5,
+    0x8f, 0xb0, 0xf0, 0x32, 0x98, 0x55, 0xfd, 0x58,
+    0x82, 0xc3, 0x76, 0xea, 0x16, 0x6b, 0x95, 0x8b,
+    0x7a, 0xaa, 0xd2, 0x23, 0x05, 0x4e, 0x57, 0x84,
+};
+static const size_t TEST_DVPT128_229_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_229_EXPECTED[] = {
+    0xc6, 0xb7, 0x68, 0x0f, 0x32, 0x11, 0x32, 0xa8,
+    0xbd, 0x00, 0xe8, 0xe9, 0x2f, 0x78, 0x5d, 0x0b,
+    0x82, 0x8b, 0x10, 0x0a, 0xf6, 0x39, 0x2a, 0x04,
+    0xd1, 0x29, 0x23, 0x73, 0xa7, 0x69, 0x70, 0xed,
+    0xa7, 0x7a, 0x81, 0x94, 0xf6, 0x27, 0x62, 0x62,
+};
+static const size_t TEST_DVPT128_229_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_229_INPUT[] = {
+    0x92, 0x97, 0x3c, 0xe7, 0x07, 0x73, 0x3a, 0x73,
+    0x11, 0x8c, 0x8c, 0xe6, 0xb5, 0xe3, 0xfc, 0x77,
+    0xa1, 0x7f, 0x44, 0x83, 0x10, 0xc0, 0x19, 0x7f,
+};
+static const size_t TEST_DVPT128_229_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_236_NONCE[] = {
+    0x93, 0xe0, 0x88, 0x54, 0x56, 0x0e, 0xdb, 0x09,
+    0x6e, 0x5d, 0x65, 0x40, 0x86,
+};
+static const size_t TEST_DVPT128_236_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_236_ADATA[] = {
+    0xbd, 0xc6, 0x0d, 0xff, 0x08, 0xbf, 0xd5, 0xd4,
+    0x43, 0x20, 0xb7, 0x5c, 0x61, 0xe4, 0x56, 0xfd,
+    0x43, 0x33, 0xc9, 0xc3, 0xd0, 0x29, 0x4d, 0x4a,
+    0x48, 0xd9, 0x36, 0xdf, 0xd5, 0x92, 0x2c, 0xe2,
+};
+static const size_t TEST_DVPT128_236_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_236_EXPECTED[] = {
+    0x7f, 0xcd, 0xce, 0x0b, 0xa5, 0x67, 0xb9, 0xa7,
+    0x08, 0xd5, 0x4f, 0xdb, 0x16, 0x12, 0x5d, 0xe7,
+    0x1d, 0xce, 0x95, 0x2f, 0x47, 0x41, 0x68, 0x4f,
+    0x4f, 0x9d, 0x30, 0x2e, 0x4f, 0x1d, 0x2a, 0x2a,
+    0xed, 0xf2, 0x76, 0x8d, 0x7b, 0x29, 0x16, 0x3f,
+};
+static const size_t TEST_DVPT128_236_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_236_INPUT[] = {
+    0x56, 0x9e, 0x4a, 0xec, 0x88, 0xdd, 0x51, 0xca,
+    0x51, 0x9c, 0x0a, 0x00, 0xc9, 0x22, 0xee, 0x33,
+    0xd3, 0x55, 0x9b, 0x98, 0xa3, 0x2d, 0x79, 0x06,
+};
+static const size_t TEST_DVPT128_236_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_237_NONCE[] = {
+    0xe3, 0xf3, 0x7b, 0x68, 0xff, 0x50, 0x8c, 0xfe,
+    0x29, 0x54, 0x41, 0xd9, 0xe3,
+};
+static const size_t TEST_DVPT128_237_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_237_ADATA[] = {
+    0xb2, 0xb6, 0xc5, 0x78, 0x2e, 0x4f, 0x12, 0x84,
+    0x67, 0xc5, 0x89, 0xd2, 0xa6, 0xcf, 0x55, 0xef,
+    0x12, 0x87, 0x7a, 0xdb, 0x77, 0x1b, 0xbb, 0x62,
+    0x45, 0xc5, 0xbb, 0xa9, 0xdc, 0xfd, 0x62, 0x08,
+};
+static const size_t TEST_DVPT128_237_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_237_EXPECTED[] = {
+    0xd4, 0x21, 0x11, 0xba, 0x22, 0x98, 0x7e, 0xac,
+    0x1e, 0xad, 0x5c, 0xc6, 0xcb, 0x85, 0x48, 0xbc,
+    0xda, 0x19, 0x0d, 0x11, 0x8d, 0xcd, 0x54, 0x61,
+    0xa5, 0x00, 0x36, 0xaf, 0x67, 0xfa, 0xda, 0xb1,
+    0x63, 0xe9, 0xda, 0xa8, 0xbd, 0x8e, 0x90, 0x30,
+};
+static const size_t TEST_DVPT128_237_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_237_INPUT[] = {
+    0x02, 0xb5, 0x51, 0x12, 0x04, 0xbd, 0x55, 0xf7,
+    0xc3, 0x79, 0x73, 0xe2, 0x6f, 0x6d, 0xf5, 0x88,
+    0x3c, 0x0a, 0x53, 0x0f, 0x07, 0xc7, 0xf8, 0xc2,
+};
+static const size_t TEST_DVPT128_237_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT128_238_NONCE[] = {
+    0xea, 0x98, 0xec, 0x44, 0xf5, 0xa8, 0x67, 0x15,
+    0x01, 0x47, 0x83, 0x17, 0x2e,
+};
+static const size_t TEST_DVPT128_238_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT128_238_ADATA[] = {
+    0xe4, 0x69, 0x2b, 0x9f, 0x06, 0xb6, 0x66, 0xc7,
+    0x45, 0x1b, 0x14, 0x6c, 0x8a, 0xeb, 0x07, 0xa6,
+    0xe3, 0x0c, 0x62, 0x9d, 0x28, 0x06, 0x5c, 0x3d,
+    0xde, 0x59, 0x40, 0x32, 0x5b, 0x14, 0xb8, 0x10,
+};
+static const size_t TEST_DVPT128_238_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT128_238_EXPECTED[] = {
+    0x1b, 0xf0, 0xba, 0x0e, 0xbb, 0x20, 0xd8, 0xed,
+    0xba, 0x59, 0xf2, 0x9a, 0x93, 0x71, 0x75, 0x0c,
+    0x9c, 0x71, 0x40, 0x78, 0xf7, 0x3c, 0x33, 0x5d,
+    0x2f, 0x13, 0x22, 0xac, 0x69, 0xb8, 0x48, 0xb0,
+    0x01, 0x47, 0x63, 0x23, 0xae, 0xd8, 0x4c, 0x47,
+};
+static const size_t TEST_DVPT128_238_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT128_238_INPUT[] = {
+    0x4d, 0xa4, 0x0b, 0x80, 0x57, 0x9c, 0x1d, 0x9a,
+    0x53, 0x09, 0xf7, 0xef, 0xec, 0xb7, 0xc0, 0x59,
+    0xa2, 0xf9, 0x14, 0x51, 0x1c, 0xa5, 0xfc, 0x10,
+};
+static const size_t TEST_DVPT128_238_INPUT_LEN = 24;
+
+/* Share test buffer output */
+static uint8_t data[512];
+
+static void test_encrypt_op(const uint8_t *key, uint8_t key_len,
+                            const uint8_t *adata, size_t adata_len,
+                            const uint8_t *nonce, uint8_t nonce_len,
+                            const uint8_t *plain, size_t plain_len,
+                            const uint8_t *output_expected,
+                            size_t output_expected_len,
+                            uint8_t mac_length)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    size_t len_encoding = nonce_and_len_encoding_size - nonce_len;
+
+    TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
+                        "Output buffer too small");
+
+    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ccm(&cipher, adata, adata_len,
+                             mac_length, len_encoding,
+                             nonce, nonce_len, plain, plain_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_expected_len, len);
+    cmp = compare(output_expected, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_decrypt_op(const uint8_t *key, uint8_t key_len,
+                            const uint8_t *adata, size_t adata_len,
+                            const uint8_t *nonce, uint8_t nonce_len,
+                            const uint8_t *encrypted, size_t encrypted_len,
+                            const uint8_t *output_expected,
+                            size_t output_expected_len,
+                            uint8_t mac_length)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    size_t len_encoding = nonce_and_len_encoding_size - nonce_len;
+
+    TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
+                        "Output buffer too small");
+
+    err = cipher_init(&cipher, CIPHER_AES_128, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ccm(&cipher, adata, adata_len,
+                             mac_length, len_encoding,
+                             nonce, nonce_len, encrypted, encrypted_len, data);
+    TEST_ASSERT_MESSAGE(len >= 0, "Decryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_expected_len, len);
+    cmp = compare(output_expected, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+#define do_test_encrypt_op(prefix, test_num, group_num) do { \
+        test_encrypt_op(TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED_LEN, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _MAC_LEN \
+                        ); \
+} while (0)
+
+#define do_test_decrypt_op(prefix, test_num, group_num) do { \
+        test_decrypt_op(TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT_LEN, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _MAC_LEN \
+                        ); \
+} while (0)
+
+static void test_crypto_modes_ccm_decrypt(void)
+{
+    do_test_decrypt_op(DVPT128, 0, 0);
+    do_test_decrypt_op(DVPT128, 4, 0);
+    do_test_decrypt_op(DVPT128, 11, 0);
+    do_test_decrypt_op(DVPT128, 12, 0);
+    do_test_decrypt_op(DVPT128, 13, 0);
+    do_test_decrypt_op(DVPT128, 15, 1);
+    do_test_decrypt_op(DVPT128, 19, 1);
+    do_test_decrypt_op(DVPT128, 26, 1);
+    do_test_decrypt_op(DVPT128, 27, 1);
+    do_test_decrypt_op(DVPT128, 28, 1);
+    do_test_decrypt_op(DVPT128, 30, 2);
+    do_test_decrypt_op(DVPT128, 34, 2);
+    do_test_decrypt_op(DVPT128, 41, 2);
+    do_test_decrypt_op(DVPT128, 42, 2);
+    do_test_decrypt_op(DVPT128, 43, 2);
+    do_test_decrypt_op(DVPT128, 45, 3);
+    do_test_decrypt_op(DVPT128, 49, 3);
+    do_test_decrypt_op(DVPT128, 56, 3);
+    do_test_decrypt_op(DVPT128, 57, 3);
+    do_test_decrypt_op(DVPT128, 58, 3);
+    do_test_decrypt_op(DVPT128, 60, 4);
+    do_test_decrypt_op(DVPT128, 64, 4);
+    do_test_decrypt_op(DVPT128, 71, 4);
+    do_test_decrypt_op(DVPT128, 72, 4);
+    do_test_decrypt_op(DVPT128, 73, 4);
+    do_test_decrypt_op(DVPT128, 75, 5);
+    do_test_decrypt_op(DVPT128, 79, 5);
+    do_test_decrypt_op(DVPT128, 86, 5);
+    do_test_decrypt_op(DVPT128, 87, 5);
+    do_test_decrypt_op(DVPT128, 88, 5);
+    do_test_decrypt_op(DVPT128, 90, 6);
+    do_test_decrypt_op(DVPT128, 94, 6);
+    do_test_decrypt_op(DVPT128, 101, 6);
+    do_test_decrypt_op(DVPT128, 102, 6);
+    do_test_decrypt_op(DVPT128, 103, 6);
+    do_test_decrypt_op(DVPT128, 105, 7);
+    do_test_decrypt_op(DVPT128, 109, 7);
+    do_test_decrypt_op(DVPT128, 116, 7);
+    do_test_decrypt_op(DVPT128, 117, 7);
+    do_test_decrypt_op(DVPT128, 118, 7);
+    do_test_decrypt_op(DVPT128, 120, 8);
+    do_test_decrypt_op(DVPT128, 124, 8);
+    do_test_decrypt_op(DVPT128, 131, 8);
+    do_test_decrypt_op(DVPT128, 132, 8);
+    do_test_decrypt_op(DVPT128, 133, 8);
+    do_test_decrypt_op(DVPT128, 135, 9);
+    do_test_decrypt_op(DVPT128, 139, 9);
+    do_test_decrypt_op(DVPT128, 146, 9);
+    do_test_decrypt_op(DVPT128, 147, 9);
+    do_test_decrypt_op(DVPT128, 148, 9);
+    do_test_decrypt_op(DVPT128, 150, 10);
+    do_test_decrypt_op(DVPT128, 154, 10);
+    do_test_decrypt_op(DVPT128, 161, 10);
+    do_test_decrypt_op(DVPT128, 162, 10);
+    do_test_decrypt_op(DVPT128, 163, 10);
+    do_test_decrypt_op(DVPT128, 165, 11);
+    do_test_decrypt_op(DVPT128, 169, 11);
+    do_test_decrypt_op(DVPT128, 176, 11);
+    do_test_decrypt_op(DVPT128, 177, 11);
+    do_test_decrypt_op(DVPT128, 178, 11);
+    do_test_decrypt_op(DVPT128, 180, 12);
+    do_test_decrypt_op(DVPT128, 184, 12);
+    do_test_decrypt_op(DVPT128, 191, 12);
+    do_test_decrypt_op(DVPT128, 192, 12);
+    do_test_decrypt_op(DVPT128, 193, 12);
+    do_test_decrypt_op(DVPT128, 195, 13);
+    do_test_decrypt_op(DVPT128, 199, 13);
+    do_test_decrypt_op(DVPT128, 206, 13);
+    do_test_decrypt_op(DVPT128, 207, 13);
+    do_test_decrypt_op(DVPT128, 208, 13);
+    do_test_decrypt_op(DVPT128, 210, 14);
+    do_test_decrypt_op(DVPT128, 214, 14);
+    do_test_decrypt_op(DVPT128, 221, 14);
+    do_test_decrypt_op(DVPT128, 222, 14);
+    do_test_decrypt_op(DVPT128, 223, 14);
+    do_test_decrypt_op(DVPT128, 225, 15);
+    do_test_decrypt_op(DVPT128, 229, 15);
+    do_test_decrypt_op(DVPT128, 236, 15);
+    do_test_decrypt_op(DVPT128, 237, 15);
+    do_test_decrypt_op(DVPT128, 238, 15);
+}
+static void test_crypto_modes_ccm_encrypt(void)
+{
+    do_test_encrypt_op(DVPT128, 0, 0);
+    do_test_encrypt_op(DVPT128, 4, 0);
+    do_test_encrypt_op(DVPT128, 11, 0);
+    do_test_encrypt_op(DVPT128, 12, 0);
+    do_test_encrypt_op(DVPT128, 13, 0);
+    do_test_encrypt_op(DVPT128, 15, 1);
+    do_test_encrypt_op(DVPT128, 19, 1);
+    do_test_encrypt_op(DVPT128, 26, 1);
+    do_test_encrypt_op(DVPT128, 27, 1);
+    do_test_encrypt_op(DVPT128, 28, 1);
+    do_test_encrypt_op(DVPT128, 30, 2);
+    do_test_encrypt_op(DVPT128, 34, 2);
+    do_test_encrypt_op(DVPT128, 41, 2);
+    do_test_encrypt_op(DVPT128, 42, 2);
+    do_test_encrypt_op(DVPT128, 43, 2);
+    do_test_encrypt_op(DVPT128, 45, 3);
+    do_test_encrypt_op(DVPT128, 49, 3);
+    do_test_encrypt_op(DVPT128, 56, 3);
+    do_test_encrypt_op(DVPT128, 57, 3);
+    do_test_encrypt_op(DVPT128, 58, 3);
+    do_test_encrypt_op(DVPT128, 60, 4);
+    do_test_encrypt_op(DVPT128, 64, 4);
+    do_test_encrypt_op(DVPT128, 71, 4);
+    do_test_encrypt_op(DVPT128, 72, 4);
+    do_test_encrypt_op(DVPT128, 73, 4);
+    do_test_encrypt_op(DVPT128, 75, 5);
+    do_test_encrypt_op(DVPT128, 79, 5);
+    do_test_encrypt_op(DVPT128, 86, 5);
+    do_test_encrypt_op(DVPT128, 87, 5);
+    do_test_encrypt_op(DVPT128, 88, 5);
+    do_test_encrypt_op(DVPT128, 90, 6);
+    do_test_encrypt_op(DVPT128, 94, 6);
+    do_test_encrypt_op(DVPT128, 101, 6);
+    do_test_encrypt_op(DVPT128, 102, 6);
+    do_test_encrypt_op(DVPT128, 103, 6);
+    do_test_encrypt_op(DVPT128, 105, 7);
+    do_test_encrypt_op(DVPT128, 109, 7);
+    do_test_encrypt_op(DVPT128, 116, 7);
+    do_test_encrypt_op(DVPT128, 117, 7);
+    do_test_encrypt_op(DVPT128, 118, 7);
+    do_test_encrypt_op(DVPT128, 120, 8);
+    do_test_encrypt_op(DVPT128, 124, 8);
+    do_test_encrypt_op(DVPT128, 131, 8);
+    do_test_encrypt_op(DVPT128, 132, 8);
+    do_test_encrypt_op(DVPT128, 133, 8);
+    do_test_encrypt_op(DVPT128, 135, 9);
+    do_test_encrypt_op(DVPT128, 139, 9);
+    do_test_encrypt_op(DVPT128, 146, 9);
+    do_test_encrypt_op(DVPT128, 147, 9);
+    do_test_encrypt_op(DVPT128, 148, 9);
+    do_test_encrypt_op(DVPT128, 150, 10);
+    do_test_encrypt_op(DVPT128, 154, 10);
+    do_test_encrypt_op(DVPT128, 161, 10);
+    do_test_encrypt_op(DVPT128, 162, 10);
+    do_test_encrypt_op(DVPT128, 163, 10);
+    do_test_encrypt_op(DVPT128, 165, 11);
+    do_test_encrypt_op(DVPT128, 169, 11);
+    do_test_encrypt_op(DVPT128, 176, 11);
+    do_test_encrypt_op(DVPT128, 177, 11);
+    do_test_encrypt_op(DVPT128, 178, 11);
+    do_test_encrypt_op(DVPT128, 180, 12);
+    do_test_encrypt_op(DVPT128, 184, 12);
+    do_test_encrypt_op(DVPT128, 191, 12);
+    do_test_encrypt_op(DVPT128, 192, 12);
+    do_test_encrypt_op(DVPT128, 193, 12);
+    do_test_encrypt_op(DVPT128, 195, 13);
+    do_test_encrypt_op(DVPT128, 199, 13);
+    do_test_encrypt_op(DVPT128, 206, 13);
+    do_test_encrypt_op(DVPT128, 207, 13);
+    do_test_encrypt_op(DVPT128, 208, 13);
+    do_test_encrypt_op(DVPT128, 210, 14);
+    do_test_encrypt_op(DVPT128, 214, 14);
+    do_test_encrypt_op(DVPT128, 221, 14);
+    do_test_encrypt_op(DVPT128, 222, 14);
+    do_test_encrypt_op(DVPT128, 223, 14);
+    do_test_encrypt_op(DVPT128, 225, 15);
+    do_test_encrypt_op(DVPT128, 229, 15);
+    do_test_encrypt_op(DVPT128, 236, 15);
+    do_test_encrypt_op(DVPT128, 237, 15);
+    do_test_encrypt_op(DVPT128, 238, 15);
+}
+
+Test *tests_crypto_modes_ccm_tests_128(void)
+{
+    EMB_UNIT_TESTFIXTURES(fixtures) {
+        new_TestFixture(test_crypto_modes_ccm_encrypt),
+        new_TestFixture(test_crypto_modes_ccm_decrypt),
+    };
+
+    EMB_UNIT_TESTCALLER(crypto_modes_ccm_tests_128, NULL, NULL, fixtures);
+
+    return (Test *)&crypto_modes_ccm_tests_128;
+}
diff --git a/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-192.c b/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-192.c
new file mode 100644
index 0000000000..20e1e44607
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-192.c
@@ -0,0 +1,2454 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+#include <limits.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "embUnit.h"
+#include "crypto/ciphers.h"
+#include "crypto/modes/ccm.h"
+#include "tests-crypto.h"
+
+/**
+ * AES CCM DVTP test vectors (SP 800-38C) for 192 bit keys.
+ * https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/cavp-testing-block-cipher-modes
+ */
+
+static const size_t nonce_and_len_encoding_size = 15;
+
+/* Alen = 0, Plen = 0, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_0_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_0_KEY[] = {
+    0xc9, 0x8a, 0xd7, 0xf3, 0x8b, 0x2c, 0x7e, 0x97,
+    0x0c, 0x9b, 0x96, 0x5e, 0xc8, 0x7a, 0x08, 0x20,
+    0x83, 0x84, 0x71, 0x8f, 0x78, 0x20, 0x6c, 0x6c,
+};
+static const size_t TEST_DVPT192_GROUP_0_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_0_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_0_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_0_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_0_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_0_EXPECTED[] = {
+    0x9d, 0x4b, 0x7f, 0x3b,
+};
+static const size_t TEST_DVPT192_0_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_0_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_0_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_4_NONCE[] = {
+    0x05, 0xe1, 0x6f, 0x0f, 0x42, 0xa6, 0xf4,
+};
+static const size_t TEST_DVPT192_4_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_4_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_4_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_4_EXPECTED[] = {
+    0xc7, 0x9d, 0x55, 0x57,
+};
+static const size_t TEST_DVPT192_4_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_4_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_4_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_11_NONCE[] = {
+    0xa9, 0xdf, 0x4f, 0x37, 0x84, 0x7e, 0x1f,
+};
+static const size_t TEST_DVPT192_11_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_11_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_11_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_11_EXPECTED[] = {
+    0x22, 0x97, 0x6e, 0x42,
+};
+static const size_t TEST_DVPT192_11_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_11_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_11_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_12_NONCE[] = {
+    0x11, 0xdf, 0x57, 0xfc, 0xd1, 0x31, 0xe9,
+};
+static const size_t TEST_DVPT192_12_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_12_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_12_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_12_EXPECTED[] = {
+    0xf4, 0x40, 0xea, 0x1d,
+};
+static const size_t TEST_DVPT192_12_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_12_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_12_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_13_NONCE[] = {
+    0x89, 0x0f, 0xff, 0x56, 0xd1, 0x0d, 0xc0,
+};
+static const size_t TEST_DVPT192_13_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_13_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_13_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_13_EXPECTED[] = {
+    0x88, 0x90, 0x3f, 0xb9,
+};
+static const size_t TEST_DVPT192_13_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_13_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_13_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_1_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_1_KEY[] = {
+    0x4b, 0xb3, 0xc4, 0xa4, 0xf8, 0x93, 0xad, 0x8c,
+    0x9b, 0xdc, 0x83, 0x3c, 0x32, 0x5d, 0x62, 0xb3,
+    0xd3, 0xad, 0x1b, 0xcc, 0xf9, 0x28, 0x2a, 0x65,
+};
+static const size_t TEST_DVPT192_GROUP_1_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_15_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_15_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_15_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_15_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_15_EXPECTED[] = {
+    0x17, 0x22, 0x30, 0x38, 0xfa, 0x99, 0xd5, 0x36,
+    0x81, 0xca, 0x1b, 0xea, 0xbe, 0x78, 0xd1, 0xb4,
+};
+static const size_t TEST_DVPT192_15_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_15_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_15_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_19_NONCE[] = {
+    0x05, 0xe1, 0x6f, 0x0f, 0x42, 0xa6, 0xf4,
+};
+static const size_t TEST_DVPT192_19_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_19_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_19_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_19_EXPECTED[] = {
+    0xfd, 0xfd, 0xbb, 0x38, 0xbf, 0x16, 0x17, 0x85,
+    0x11, 0x4f, 0x9e, 0xe2, 0x01, 0x8e, 0x89, 0x2f,
+};
+static const size_t TEST_DVPT192_19_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_19_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_19_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_26_NONCE[] = {
+    0xa9, 0xdf, 0x4f, 0x37, 0x84, 0x7e, 0x1f,
+};
+static const size_t TEST_DVPT192_26_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_26_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_26_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_26_EXPECTED[] = {
+    0x7e, 0x3b, 0xbe, 0x0e, 0xb1, 0x39, 0x88, 0xa9,
+    0x39, 0x72, 0xf2, 0xfb, 0xcd, 0x35, 0x65, 0x9e,
+};
+static const size_t TEST_DVPT192_26_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_26_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_26_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_27_NONCE[] = {
+    0x11, 0xdf, 0x57, 0xfc, 0xd1, 0x31, 0xe9,
+};
+static const size_t TEST_DVPT192_27_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_27_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_27_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_27_EXPECTED[] = {
+    0x48, 0xd7, 0xa1, 0x5c, 0xf4, 0xf5, 0x80, 0x8e,
+    0xb4, 0x5d, 0x1a, 0xd8, 0x17, 0x47, 0x05, 0x54,
+};
+static const size_t TEST_DVPT192_27_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_27_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_27_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_28_NONCE[] = {
+    0x89, 0x0f, 0xff, 0x56, 0xd1, 0x0d, 0xc0,
+};
+static const size_t TEST_DVPT192_28_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_28_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_28_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_28_EXPECTED[] = {
+    0x97, 0x18, 0x5c, 0xe6, 0x8a, 0xf1, 0xe6, 0xab,
+    0x71, 0x8c, 0x8c, 0x4b, 0x83, 0xec, 0x04, 0xcd,
+};
+static const size_t TEST_DVPT192_28_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_28_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_28_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_2_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_2_KEY[] = {
+    0x4b, 0xb3, 0xc4, 0xa4, 0xf8, 0x93, 0xad, 0x8c,
+    0x9b, 0xdc, 0x83, 0x3c, 0x32, 0x5d, 0x62, 0xb3,
+    0xd3, 0xad, 0x1b, 0xcc, 0xf9, 0x28, 0x2a, 0x65,
+};
+static const size_t TEST_DVPT192_GROUP_2_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_30_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_30_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_30_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_30_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_30_EXPECTED[] = {
+    0xfe, 0x69, 0xed, 0x84,
+};
+static const size_t TEST_DVPT192_30_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_30_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_30_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_34_NONCE[] = {
+    0x93, 0x5c, 0x1e, 0xf3, 0xd4, 0x03, 0x2f, 0xf0,
+    0x90, 0xf9, 0x11, 0x41, 0xf3,
+};
+static const size_t TEST_DVPT192_34_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_34_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_34_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_34_EXPECTED[] = {
+    0x21, 0x5e, 0x0b, 0xf2,
+};
+static const size_t TEST_DVPT192_34_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_34_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_34_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_41_NONCE[] = {
+    0xd0, 0xa1, 0x50, 0x8f, 0xde, 0xfc, 0xf5, 0xbe,
+    0x30, 0xa4, 0x59, 0xb8, 0x13,
+};
+static const size_t TEST_DVPT192_41_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_41_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_41_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_41_EXPECTED[] = {
+    0x79, 0x0b, 0x26, 0x24,
+};
+static const size_t TEST_DVPT192_41_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_41_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_41_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_42_NONCE[] = {
+    0x53, 0x81, 0xa6, 0x1b, 0x44, 0x9d, 0xc6, 0xa4,
+    0x2a, 0xa4, 0xc7, 0x9b, 0x95,
+};
+static const size_t TEST_DVPT192_42_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_42_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_42_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_42_EXPECTED[] = {
+    0x9e, 0x46, 0x63, 0x2d,
+};
+static const size_t TEST_DVPT192_42_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_42_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_42_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_43_NONCE[] = {
+    0xc5, 0x54, 0x30, 0xf2, 0xda, 0x06, 0x87, 0xea,
+    0x40, 0x31, 0x38, 0x84, 0xab,
+};
+static const size_t TEST_DVPT192_43_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_43_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_43_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_43_EXPECTED[] = {
+    0x39, 0xb8, 0x29, 0x01,
+};
+static const size_t TEST_DVPT192_43_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_43_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_43_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_3_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_3_KEY[] = {
+    0x19, 0xeb, 0xfd, 0xe2, 0xd5, 0x46, 0x8b, 0xa0,
+    0xa3, 0x03, 0x1b, 0xde, 0x62, 0x9b, 0x11, 0xfd,
+    0x40, 0x94, 0xaf, 0xcb, 0x20, 0x53, 0x93, 0xfa,
+};
+static const size_t TEST_DVPT192_GROUP_3_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_45_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_45_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_45_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_45_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_45_EXPECTED[] = {
+    0x0c, 0x66, 0xa8, 0xe5, 0x47, 0xed, 0x4f, 0x8c,
+    0x2c, 0x9a, 0x9a, 0x1e, 0xb5, 0xd4, 0x55, 0xb9,
+};
+static const size_t TEST_DVPT192_45_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_45_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_45_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_49_NONCE[] = {
+    0x93, 0x5c, 0x1e, 0xf3, 0xd4, 0x03, 0x2f, 0xf0,
+    0x90, 0xf9, 0x11, 0x41, 0xf3,
+};
+static const size_t TEST_DVPT192_49_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_49_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_49_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_49_EXPECTED[] = {
+    0x87, 0xda, 0x5d, 0xbc, 0x04, 0xe3, 0x9f, 0xc4,
+    0x68, 0xf4, 0x36, 0x75, 0xd4, 0xe7, 0xdf, 0x33,
+};
+static const size_t TEST_DVPT192_49_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_49_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_49_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_56_NONCE[] = {
+    0xd0, 0xa1, 0x50, 0x8f, 0xde, 0xfc, 0xf5, 0xbe,
+    0x30, 0xa4, 0x59, 0xb8, 0x13,
+};
+static const size_t TEST_DVPT192_56_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_56_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_56_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_56_EXPECTED[] = {
+    0xa0, 0xd0, 0x47, 0xa1, 0xf9, 0x94, 0x0d, 0x32,
+    0x5e, 0x47, 0x4d, 0xa5, 0x4a, 0xa1, 0x38, 0x97,
+};
+static const size_t TEST_DVPT192_56_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_56_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_56_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_57_NONCE[] = {
+    0x53, 0x81, 0xa6, 0x1b, 0x44, 0x9d, 0xc6, 0xa4,
+    0x2a, 0xa4, 0xc7, 0x9b, 0x95,
+};
+static const size_t TEST_DVPT192_57_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_57_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_57_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_57_EXPECTED[] = {
+    0x8a, 0x47, 0x68, 0xa2, 0x09, 0x36, 0x94, 0xb6,
+    0xbc, 0xb7, 0x08, 0x3c, 0x0b, 0xb6, 0x33, 0x1c,
+};
+static const size_t TEST_DVPT192_57_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_57_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_57_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_58_NONCE[] = {
+    0xc5, 0x54, 0x30, 0xf2, 0xda, 0x06, 0x87, 0xea,
+    0x40, 0x31, 0x38, 0x84, 0xab,
+};
+static const size_t TEST_DVPT192_58_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_58_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_58_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_58_EXPECTED[] = {
+    0xa7, 0xca, 0xfd, 0x6f, 0x68, 0xdc, 0x1f, 0x15,
+    0xa3, 0x60, 0x3d, 0xa6, 0x54, 0xce, 0x27, 0xbc,
+};
+static const size_t TEST_DVPT192_58_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_58_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_58_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 24, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_4_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_4_KEY[] = {
+    0x19, 0xeb, 0xfd, 0xe2, 0xd5, 0x46, 0x8b, 0xa0,
+    0xa3, 0x03, 0x1b, 0xde, 0x62, 0x9b, 0x11, 0xfd,
+    0x40, 0x94, 0xaf, 0xcb, 0x20, 0x53, 0x93, 0xfa,
+};
+static const size_t TEST_DVPT192_GROUP_4_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_60_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_60_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_60_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_60_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_60_EXPECTED[] = {
+    0x41, 0x19, 0x86, 0xd0, 0x4d, 0x64, 0x63, 0x10,
+    0x0b, 0xff, 0x03, 0xf7, 0xd0, 0xbd, 0xe7, 0xea,
+    0x2c, 0x34, 0x88, 0x78, 0x43, 0x78, 0x13, 0x8c,
+    0xdd, 0xc9, 0x3a, 0x54,
+};
+static const size_t TEST_DVPT192_60_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_60_INPUT[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+};
+static const size_t TEST_DVPT192_60_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_64_NONCE[] = {
+    0x12, 0x3a, 0x0b, 0xea, 0xce, 0x4e, 0x39,
+};
+static const size_t TEST_DVPT192_64_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_64_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_64_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_64_EXPECTED[] = {
+    0xb4, 0x1b, 0xfb, 0xa9, 0x4e, 0xdc, 0xaf, 0xc4,
+    0x1b, 0x4c, 0x14, 0x42, 0x69, 0xb9, 0x12, 0x6a,
+    0x6d, 0x47, 0xb1, 0x9e, 0x83, 0xb1, 0x57, 0x72,
+    0xb2, 0x8c, 0x8e, 0x38,
+};
+static const size_t TEST_DVPT192_64_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_64_INPUT[] = {
+    0x9d, 0x03, 0x3e, 0x3b, 0x66, 0xef, 0xed, 0x14,
+    0x67, 0x86, 0x8f, 0x38, 0x24, 0x17, 0xc8, 0x05,
+    0x94, 0x87, 0x7a, 0x28, 0xbc, 0x97, 0xf4, 0x06,
+};
+static const size_t TEST_DVPT192_64_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_71_NONCE[] = {
+    0xf6, 0x7b, 0x98, 0xef, 0xd3, 0x9b, 0x55,
+};
+static const size_t TEST_DVPT192_71_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_71_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_71_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_71_EXPECTED[] = {
+    0x0a, 0x7f, 0xe6, 0x30, 0x46, 0xda, 0xf8, 0xa9,
+    0x79, 0x93, 0x5b, 0x89, 0x70, 0x88, 0xc6, 0x4a,
+    0xcc, 0x1b, 0x47, 0xa5, 0xa9, 0xb8, 0x6f, 0xdd,
+    0x6d, 0xef, 0x28, 0xab,
+};
+static const size_t TEST_DVPT192_71_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_71_INPUT[] = {
+    0xf2, 0xe9, 0x44, 0xe1, 0xae, 0x47, 0xad, 0x58,
+    0x73, 0xbf, 0x39, 0x1f, 0x1b, 0x0c, 0xc0, 0x7f,
+    0x61, 0x51, 0xeb, 0x4c, 0x50, 0xbb, 0x45, 0xb2,
+};
+static const size_t TEST_DVPT192_71_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_72_NONCE[] = {
+    0xe6, 0x0e, 0x2c, 0x00, 0x2d, 0x1c, 0x99,
+};
+static const size_t TEST_DVPT192_72_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_72_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_72_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_72_EXPECTED[] = {
+    0xda, 0xf7, 0xd7, 0xdf, 0xa5, 0x12, 0xce, 0xb1,
+    0xd7, 0xd3, 0x43, 0x56, 0x34, 0xd9, 0xa7, 0x0b,
+    0x3e, 0xf6, 0xc6, 0xdc, 0x38, 0xf4, 0x09, 0xe0,
+    0x68, 0x94, 0x1f, 0xce,
+};
+static const size_t TEST_DVPT192_72_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_72_INPUT[] = {
+    0x70, 0xf4, 0x8d, 0xc1, 0xd7, 0x6e, 0x50, 0x28,
+    0xda, 0x07, 0xe2, 0x98, 0x52, 0x80, 0x13, 0x75,
+    0xa9, 0xed, 0xb2, 0x21, 0x4a, 0x5e, 0xa4, 0xc0,
+};
+static const size_t TEST_DVPT192_72_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_73_NONCE[] = {
+    0x09, 0x8e, 0x05, 0x3f, 0xa0, 0x80, 0x43,
+};
+static const size_t TEST_DVPT192_73_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_73_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_73_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_73_EXPECTED[] = {
+    0xcd, 0xb4, 0x17, 0xdf, 0xf6, 0x50, 0x22, 0x08,
+    0x77, 0x5f, 0x21, 0xe3, 0x5c, 0xdb, 0x8e, 0x3e,
+    0x11, 0x99, 0x30, 0x8d, 0x1a, 0x94, 0x22, 0x90,
+    0x51, 0xa1, 0xec, 0x4a,
+};
+static const size_t TEST_DVPT192_73_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_73_INPUT[] = {
+    0xbd, 0x81, 0x68, 0x0e, 0x3d, 0xc0, 0xb3, 0x54,
+    0x31, 0xc9, 0x25, 0x98, 0xdc, 0xaa, 0x26, 0xef,
+    0x09, 0xca, 0x0d, 0xa5, 0xe7, 0x71, 0x93, 0xde,
+};
+static const size_t TEST_DVPT192_73_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_5_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_5_KEY[] = {
+    0x19, 0x7a, 0xfb, 0x02, 0xff, 0xbd, 0x8f, 0x69,
+    0x9d, 0xac, 0xae, 0x87, 0x09, 0x4d, 0x52, 0x43,
+    0x24, 0x57, 0x6b, 0x99, 0x84, 0x4f, 0x75, 0xe1,
+};
+static const size_t TEST_DVPT192_GROUP_5_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_75_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_75_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_75_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_75_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_75_EXPECTED[] = {
+    0xcb, 0xa4, 0xb4, 0xae, 0xb8, 0x5f, 0x04, 0x92,
+    0xfd, 0x8d, 0x90, 0x5c, 0x4a, 0x6d, 0x82, 0x33,
+    0x13, 0x98, 0x33, 0x37, 0x3e, 0xf1, 0x88, 0xa8,
+    0xc5, 0xa5, 0xeb, 0xec, 0xf7, 0xac, 0x86, 0x07,
+    0xfe, 0x41, 0x21, 0x89, 0xe8, 0x3d, 0x9d, 0x20,
+};
+static const size_t TEST_DVPT192_75_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_75_INPUT[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+};
+static const size_t TEST_DVPT192_75_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_79_NONCE[] = {
+    0x12, 0x3a, 0x0b, 0xea, 0xce, 0x4e, 0x39,
+};
+static const size_t TEST_DVPT192_79_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_79_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_79_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_79_EXPECTED[] = {
+    0x71, 0xf1, 0x7c, 0xf2, 0x1c, 0x44, 0x26, 0x7c,
+    0x67, 0x66, 0x57, 0xdb, 0x9e, 0x55, 0xbe, 0xe3,
+    0x32, 0x73, 0x78, 0x74, 0x74, 0xe7, 0x7b, 0x17,
+    0xb5, 0xea, 0xb4, 0x5d, 0x7d, 0x09, 0x65, 0x77,
+    0x64, 0x38, 0x15, 0xe6, 0xd4, 0x67, 0x31, 0x2d,
+};
+static const size_t TEST_DVPT192_79_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_79_INPUT[] = {
+    0x9d, 0x03, 0x3e, 0x3b, 0x66, 0xef, 0xed, 0x14,
+    0x67, 0x86, 0x8f, 0x38, 0x24, 0x17, 0xc8, 0x05,
+    0x94, 0x87, 0x7a, 0x28, 0xbc, 0x97, 0xf4, 0x06,
+};
+static const size_t TEST_DVPT192_79_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_86_NONCE[] = {
+    0xf6, 0x7b, 0x98, 0xef, 0xd3, 0x9b, 0x55,
+};
+static const size_t TEST_DVPT192_86_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_86_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_86_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_86_EXPECTED[] = {
+    0x44, 0xa6, 0xaa, 0x95, 0x4c, 0x35, 0x08, 0xb3,
+    0xc9, 0x26, 0x4c, 0x20, 0xc2, 0x72, 0xe8, 0x0c,
+    0x0e, 0x95, 0xd5, 0x0d, 0xde, 0xc2, 0x84, 0x90,
+    0x84, 0xb4, 0x75, 0x04, 0xdc, 0xed, 0x5b, 0x70,
+    0xc3, 0x02, 0xcc, 0x93, 0x50, 0x2c, 0xc3, 0x7e,
+};
+static const size_t TEST_DVPT192_86_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_86_INPUT[] = {
+    0xf2, 0xe9, 0x44, 0xe1, 0xae, 0x47, 0xad, 0x58,
+    0x73, 0xbf, 0x39, 0x1f, 0x1b, 0x0c, 0xc0, 0x7f,
+    0x61, 0x51, 0xeb, 0x4c, 0x50, 0xbb, 0x45, 0xb2,
+};
+static const size_t TEST_DVPT192_86_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_87_NONCE[] = {
+    0xe6, 0x0e, 0x2c, 0x00, 0x2d, 0x1c, 0x99,
+};
+static const size_t TEST_DVPT192_87_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_87_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_87_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_87_EXPECTED[] = {
+    0x9d, 0x4f, 0xf7, 0xa4, 0x4c, 0xdb, 0x9b, 0x14,
+    0xf5, 0x86, 0xef, 0xc3, 0xd6, 0xbe, 0x02, 0xd0,
+    0x69, 0xb4, 0x25, 0xc0, 0x6b, 0xec, 0x4e, 0xed,
+    0x37, 0x10, 0x97, 0x39, 0xa3, 0x67, 0x6f, 0x03,
+    0xad, 0xfd, 0x74, 0x0d, 0xba, 0xa4, 0x94, 0x0d,
+};
+static const size_t TEST_DVPT192_87_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_87_INPUT[] = {
+    0x70, 0xf4, 0x8d, 0xc1, 0xd7, 0x6e, 0x50, 0x28,
+    0xda, 0x07, 0xe2, 0x98, 0x52, 0x80, 0x13, 0x75,
+    0xa9, 0xed, 0xb2, 0x21, 0x4a, 0x5e, 0xa4, 0xc0,
+};
+static const size_t TEST_DVPT192_87_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_88_NONCE[] = {
+    0x09, 0x8e, 0x05, 0x3f, 0xa0, 0x80, 0x43,
+};
+static const size_t TEST_DVPT192_88_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_88_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_88_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_88_EXPECTED[] = {
+    0x23, 0xda, 0x95, 0xe1, 0x02, 0xc7, 0x92, 0x1a,
+    0x51, 0xb1, 0x9b, 0x57, 0x33, 0xea, 0x57, 0x76,
+    0xab, 0x6c, 0x28, 0x7f, 0x60, 0x57, 0xc0, 0x0e,
+    0xc4, 0xbf, 0xac, 0xbb, 0x2f, 0x24, 0x6b, 0x57,
+    0x0e, 0xfd, 0x93, 0xd9, 0x8e, 0x99, 0xbe, 0x49,
+};
+static const size_t TEST_DVPT192_88_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_88_INPUT[] = {
+    0xbd, 0x81, 0x68, 0x0e, 0x3d, 0xc0, 0xb3, 0x54,
+    0x31, 0xc9, 0x25, 0x98, 0xdc, 0xaa, 0x26, 0xef,
+    0x09, 0xca, 0x0d, 0xa5, 0xe7, 0x71, 0x93, 0xde,
+};
+static const size_t TEST_DVPT192_88_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_6_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_6_KEY[] = {
+    0x19, 0x7a, 0xfb, 0x02, 0xff, 0xbd, 0x8f, 0x69,
+    0x9d, 0xac, 0xae, 0x87, 0x09, 0x4d, 0x52, 0x43,
+    0x24, 0x57, 0x6b, 0x99, 0x84, 0x4f, 0x75, 0xe1,
+};
+static const size_t TEST_DVPT192_GROUP_6_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_90_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_90_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_90_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_90_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_90_EXPECTED[] = {
+    0x04, 0x26, 0x53, 0xc6, 0x74, 0xef, 0x2a, 0x90,
+    0xf7, 0xfb, 0x11, 0xd3, 0x08, 0x48, 0xe5, 0x30,
+    0xae, 0x59, 0x47, 0x8f, 0x10, 0x51, 0x63, 0x3a,
+    0x34, 0xfa, 0xd2, 0x77,
+};
+static const size_t TEST_DVPT192_90_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_90_INPUT[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+};
+static const size_t TEST_DVPT192_90_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_94_NONCE[] = {
+    0x24, 0xb7, 0xa6, 0x53, 0x91, 0xf8, 0x8b, 0xea,
+    0x38, 0xfc, 0xd5, 0x4a, 0x9a,
+};
+static const size_t TEST_DVPT192_94_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_94_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_94_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_94_EXPECTED[] = {
+    0x3c, 0x18, 0x36, 0xe5, 0xd0, 0xf0, 0x47, 0x3d,
+    0xab, 0x7b, 0xfd, 0x7a, 0x95, 0xba, 0x69, 0x57,
+    0x5f, 0x7f, 0x84, 0x19, 0x70, 0xac, 0x6c, 0x67,
+    0x69, 0xac, 0x96, 0x6a,
+};
+static const size_t TEST_DVPT192_94_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_94_INPUT[] = {
+    0x43, 0x41, 0x97, 0x15, 0xce, 0xf9, 0xa4, 0x8d,
+    0xc7, 0x28, 0x0b, 0xc0, 0x35, 0x08, 0x2a, 0x65,
+    0x81, 0xaf, 0xd1, 0xd8, 0x2b, 0xee, 0x9d, 0x1a,
+};
+static const size_t TEST_DVPT192_94_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_101_NONCE[] = {
+    0xc4, 0x7a, 0xf8, 0x0c, 0xd2, 0x6d, 0x04, 0x76,
+    0x30, 0xc1, 0xfd, 0xf0, 0xd1,
+};
+static const size_t TEST_DVPT192_101_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_101_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_101_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_101_EXPECTED[] = {
+    0x34, 0x1d, 0xf3, 0xa2, 0x73, 0xe8, 0x5c, 0xf3,
+    0x87, 0xab, 0x82, 0x3b, 0xdf, 0x9c, 0x34, 0xa1,
+    0xae, 0x2c, 0x86, 0x94, 0x0c, 0xb4, 0xbf, 0xcd,
+    0xe2, 0xe9, 0x3f, 0x29,
+};
+static const size_t TEST_DVPT192_101_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_101_INPUT[] = {
+    0xd8, 0x30, 0x6c, 0x9c, 0x4e, 0xa6, 0xc6, 0x9c,
+    0x6e, 0x2a, 0xd0, 0xfc, 0x0e, 0x49, 0xb1, 0xe0,
+    0x12, 0x6b, 0x01, 0x07, 0x8d, 0x64, 0x19, 0xff,
+};
+static const size_t TEST_DVPT192_101_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_102_NONCE[] = {
+    0x70, 0xe1, 0x32, 0x02, 0x3a, 0xca, 0xe1, 0xf8,
+    0x8c, 0x7a, 0x23, 0x7b, 0x68,
+};
+static const size_t TEST_DVPT192_102_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_102_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_102_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_102_EXPECTED[] = {
+    0xa0, 0xe7, 0x99, 0x7f, 0xd6, 0x7e, 0xa6, 0x6b,
+    0x62, 0x74, 0xd7, 0x19, 0xb8, 0x4d, 0xa9, 0x24,
+    0x33, 0xfd, 0xf7, 0xd5, 0x12, 0xb1, 0x60, 0xda,
+    0x35, 0xc7, 0x08, 0x1d,
+};
+static const size_t TEST_DVPT192_102_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_102_INPUT[] = {
+    0xd0, 0xb2, 0xbe, 0xf5, 0xed, 0x1a, 0x87, 0xd9,
+    0xc7, 0x3d, 0x4a, 0x45, 0x9c, 0xb0, 0x5c, 0x11,
+    0x79, 0x9c, 0x4f, 0x51, 0xad, 0x64, 0x0b, 0x1e,
+};
+static const size_t TEST_DVPT192_102_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_103_NONCE[] = {
+    0x80, 0x10, 0xd3, 0xa2, 0xa1, 0x4f, 0x72, 0xf5,
+    0x58, 0x5d, 0xef, 0xc9, 0x40,
+};
+static const size_t TEST_DVPT192_103_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_103_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_103_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_103_EXPECTED[] = {
+    0xdd, 0x8f, 0xd1, 0x1e, 0x1c, 0x07, 0x46, 0xe7,
+    0x27, 0x3f, 0xdd, 0x2e, 0x7d, 0xfa, 0x1e, 0xe4,
+    0xfc, 0x8a, 0xd8, 0x35, 0xca, 0x31, 0x41, 0xc0,
+    0xf8, 0x3a, 0x9a, 0xd7,
+};
+static const size_t TEST_DVPT192_103_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_103_INPUT[] = {
+    0x4f, 0xab, 0xa0, 0x55, 0x69, 0xbf, 0x7a, 0xc6,
+    0x56, 0x78, 0x0c, 0x16, 0x99, 0x5e, 0x91, 0x22,
+    0xe5, 0x65, 0xfe, 0x99, 0x84, 0xbe, 0x8a, 0x68,
+};
+static const size_t TEST_DVPT192_103_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_7_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_7_KEY[] = {
+    0x90, 0x92, 0x9a, 0x4b, 0x0a, 0xc6, 0x5b, 0x35,
+    0x0a, 0xd1, 0x59, 0x16, 0x11, 0xfe, 0x48, 0x29,
+    0x7e, 0x03, 0x95, 0x6f, 0x60, 0x83, 0xe4, 0x51,
+};
+static const size_t TEST_DVPT192_GROUP_7_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_105_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_105_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_105_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_105_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_105_EXPECTED[] = {
+    0xa5, 0xb7, 0xd8, 0xcc, 0xa2, 0x06, 0x99, 0x08,
+    0xd1, 0xed, 0x88, 0xe6, 0xa9, 0xfe, 0x2c, 0x9b,
+    0xed, 0xe3, 0x13, 0x1d, 0xad, 0x54, 0x67, 0x1e,
+    0xa7, 0xad, 0xe3, 0x0a, 0x07, 0xd1, 0x85, 0x69,
+    0x2a, 0xb0, 0xeb, 0xdf, 0x4c, 0x78, 0xcf, 0x7a,
+};
+static const size_t TEST_DVPT192_105_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_105_INPUT[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+};
+static const size_t TEST_DVPT192_105_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_109_NONCE[] = {
+    0x24, 0xb7, 0xa6, 0x53, 0x91, 0xf8, 0x8b, 0xea,
+    0x38, 0xfc, 0xd5, 0x4a, 0x9a,
+};
+static const size_t TEST_DVPT192_109_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_109_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_109_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_109_EXPECTED[] = {
+    0x71, 0xf6, 0x84, 0x80, 0xa8, 0x80, 0x1d, 0x49,
+    0x66, 0xc8, 0x48, 0x07, 0xc5, 0xff, 0x61, 0x39,
+    0xd8, 0x3b, 0xa0, 0xa5, 0xb9, 0x02, 0xbe, 0xe3,
+    0x32, 0x7f, 0x5f, 0x91, 0x76, 0x3c, 0x0a, 0x0b,
+    0xec, 0x43, 0x26, 0x4c, 0x27, 0xcd, 0x23, 0x7f,
+};
+static const size_t TEST_DVPT192_109_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_109_INPUT[] = {
+    0x43, 0x41, 0x97, 0x15, 0xce, 0xf9, 0xa4, 0x8d,
+    0xc7, 0x28, 0x0b, 0xc0, 0x35, 0x08, 0x2a, 0x65,
+    0x81, 0xaf, 0xd1, 0xd8, 0x2b, 0xee, 0x9d, 0x1a,
+};
+static const size_t TEST_DVPT192_109_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_116_NONCE[] = {
+    0xc4, 0x7a, 0xf8, 0x0c, 0xd2, 0x6d, 0x04, 0x76,
+    0x30, 0xc1, 0xfd, 0xf0, 0xd1,
+};
+static const size_t TEST_DVPT192_116_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_116_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_116_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_116_EXPECTED[] = {
+    0x5b, 0x0b, 0x5e, 0x66, 0x90, 0xd6, 0x48, 0xe1,
+    0xb9, 0x2c, 0x12, 0xcf, 0xdd, 0xb4, 0x31, 0xd6,
+    0xd3, 0xdf, 0xe6, 0x89, 0xd0, 0x1d, 0xb8, 0x19,
+    0x92, 0x56, 0xac, 0xe4, 0x90, 0xc2, 0xf0, 0xaf,
+    0xb9, 0x3b, 0xa3, 0x2b, 0xe5, 0x8f, 0xd1, 0xde,
+};
+static const size_t TEST_DVPT192_116_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_116_INPUT[] = {
+    0xd8, 0x30, 0x6c, 0x9c, 0x4e, 0xa6, 0xc6, 0x9c,
+    0x6e, 0x2a, 0xd0, 0xfc, 0x0e, 0x49, 0xb1, 0xe0,
+    0x12, 0x6b, 0x01, 0x07, 0x8d, 0x64, 0x19, 0xff,
+};
+static const size_t TEST_DVPT192_116_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_117_NONCE[] = {
+    0x70, 0xe1, 0x32, 0x02, 0x3a, 0xca, 0xe1, 0xf8,
+    0x8c, 0x7a, 0x23, 0x7b, 0x68,
+};
+static const size_t TEST_DVPT192_117_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_117_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_117_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_117_EXPECTED[] = {
+    0x87, 0x22, 0xfc, 0xa7, 0x1f, 0xdf, 0x75, 0x0e,
+    0xc5, 0xd6, 0x2f, 0xc6, 0xd7, 0xba, 0x07, 0x9a,
+    0xef, 0x19, 0x21, 0x0d, 0xa7, 0x64, 0x06, 0x7a,
+    0xef, 0xd8, 0x53, 0x5d, 0xd6, 0xb7, 0xfa, 0x70,
+    0x1c, 0x9c, 0xa8, 0xc8, 0xb6, 0x35, 0xc3, 0x0b,
+};
+static const size_t TEST_DVPT192_117_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_117_INPUT[] = {
+    0xd0, 0xb2, 0xbe, 0xf5, 0xed, 0x1a, 0x87, 0xd9,
+    0xc7, 0x3d, 0x4a, 0x45, 0x9c, 0xb0, 0x5c, 0x11,
+    0x79, 0x9c, 0x4f, 0x51, 0xad, 0x64, 0x0b, 0x1e,
+};
+static const size_t TEST_DVPT192_117_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_118_NONCE[] = {
+    0x80, 0x10, 0xd3, 0xa2, 0xa1, 0x4f, 0x72, 0xf5,
+    0x58, 0x5d, 0xef, 0xc9, 0x40,
+};
+static const size_t TEST_DVPT192_118_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_118_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_118_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT192_118_EXPECTED[] = {
+    0x91, 0xac, 0x45, 0x7f, 0x5e, 0x53, 0x49, 0x23,
+    0x01, 0xe7, 0x2d, 0x9d, 0x49, 0x52, 0x77, 0xed,
+    0x17, 0xed, 0xb3, 0x0e, 0x8c, 0x7a, 0x48, 0xd2,
+    0x1b, 0x5d, 0x2c, 0xd4, 0xd5, 0xb6, 0xd2, 0xef,
+    0x48, 0x41, 0x32, 0x45, 0xa6, 0xb2, 0x7b, 0x67,
+};
+static const size_t TEST_DVPT192_118_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_118_INPUT[] = {
+    0x4f, 0xab, 0xa0, 0x55, 0x69, 0xbf, 0x7a, 0xc6,
+    0x56, 0x78, 0x0c, 0x16, 0x99, 0x5e, 0x91, 0x22,
+    0xe5, 0x65, 0xfe, 0x99, 0x84, 0xbe, 0x8a, 0x68,
+};
+static const size_t TEST_DVPT192_118_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 0, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_8_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_8_KEY[] = {
+    0x90, 0x92, 0x9a, 0x4b, 0x0a, 0xc6, 0x5b, 0x35,
+    0x0a, 0xd1, 0x59, 0x16, 0x11, 0xfe, 0x48, 0x29,
+    0x7e, 0x03, 0x95, 0x6f, 0x60, 0x83, 0xe4, 0x51,
+};
+static const size_t TEST_DVPT192_GROUP_8_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_120_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_120_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_120_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT192_120_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_120_EXPECTED[] = {
+    0x1d, 0x08, 0x9a, 0x5f,
+};
+static const size_t TEST_DVPT192_120_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_120_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_120_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_124_NONCE[] = {
+    0x8c, 0x68, 0x7b, 0x43, 0x18, 0x81, 0x3a,
+};
+static const size_t TEST_DVPT192_124_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_124_ADATA[] = {
+    0xfc, 0xad, 0x52, 0xa8, 0x85, 0x44, 0x32, 0x5b,
+    0xb3, 0x1e, 0xb5, 0xde, 0x4a, 0x41, 0xdb, 0xff,
+    0x6a, 0x96, 0xf6, 0x9d, 0x09, 0x93, 0xb9, 0x69,
+    0xa0, 0x17, 0x92, 0xee, 0x23, 0x95, 0x3a, 0xcf,
+};
+static const size_t TEST_DVPT192_124_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_124_EXPECTED[] = {
+    0x5c, 0x6a, 0x4d, 0xe2,
+};
+static const size_t TEST_DVPT192_124_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_124_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_124_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_131_NONCE[] = {
+    0xa1, 0xae, 0xda, 0x4b, 0x4c, 0xb8, 0xdd,
+};
+static const size_t TEST_DVPT192_131_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_131_ADATA[] = {
+    0xdb, 0x30, 0x22, 0xef, 0x4c, 0xd6, 0x8a, 0xe2,
+    0x2b, 0x50, 0x15, 0x99, 0x44, 0x8f, 0xfe, 0x2d,
+    0xda, 0x15, 0xcf, 0xd2, 0xe2, 0x59, 0x31, 0x5c,
+    0x6f, 0x6d, 0x03, 0x03, 0x6e, 0xde, 0xa9, 0x63,
+};
+static const size_t TEST_DVPT192_131_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_131_EXPECTED[] = {
+    0x58, 0x14, 0x10, 0x3a,
+};
+static const size_t TEST_DVPT192_131_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_131_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_131_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_132_NONCE[] = {
+    0xf2, 0x48, 0xe5, 0x22, 0x5e, 0x3d, 0x9a,
+};
+static const size_t TEST_DVPT192_132_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_132_ADATA[] = {
+    0xfd, 0xc6, 0x4e, 0xf7, 0x6a, 0x3b, 0xfd, 0x0a,
+    0x15, 0xd0, 0xbc, 0x8e, 0x8b, 0xac, 0xaf, 0x64,
+    0x34, 0x67, 0x96, 0xa3, 0xe3, 0x5a, 0xfc, 0xf2,
+    0xac, 0x1a, 0xb1, 0x36, 0xf6, 0x3f, 0x7b, 0x6e,
+};
+static const size_t TEST_DVPT192_132_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_132_EXPECTED[] = {
+    0x74, 0xc7, 0x5c, 0x4a,
+};
+static const size_t TEST_DVPT192_132_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_132_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_132_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_133_NONCE[] = {
+    0xe6, 0x82, 0x28, 0xf5, 0xc6, 0x5b, 0x73,
+};
+static const size_t TEST_DVPT192_133_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_133_ADATA[] = {
+    0x61, 0x4e, 0xfd, 0xf8, 0x9c, 0xe2, 0xa9, 0xfc,
+    0xbd, 0x38, 0xbd, 0xc0, 0xb4, 0xce, 0xce, 0x54,
+    0xdf, 0xd7, 0x53, 0x28, 0x80, 0xe0, 0xb4, 0xce,
+    0x6e, 0xb3, 0xa4, 0x01, 0x0b, 0x7c, 0xb1, 0xe7,
+};
+static const size_t TEST_DVPT192_133_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_133_EXPECTED[] = {
+    0x98, 0x84, 0x89, 0x8b,
+};
+static const size_t TEST_DVPT192_133_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_133_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_133_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_9_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_9_KEY[] = {
+    0x6a, 0x79, 0x8d, 0x7c, 0x5e, 0x1a, 0x72, 0xb4,
+    0x3e, 0x20, 0xad, 0x5c, 0x7b, 0x08, 0x56, 0x7b,
+    0x12, 0xab, 0x74, 0x4b, 0x61, 0xc0, 0x70, 0xe2,
+};
+static const size_t TEST_DVPT192_GROUP_9_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_135_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_135_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_135_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT192_135_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_135_EXPECTED[] = {
+    0x52, 0x80, 0xa2, 0x13, 0x7f, 0xee, 0x3d, 0xee,
+    0xfc, 0xfe, 0x9b, 0x63, 0xa1, 0x19, 0x9f, 0xb3,
+};
+static const size_t TEST_DVPT192_135_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_135_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_135_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_139_NONCE[] = {
+    0x8c, 0x68, 0x7b, 0x43, 0x18, 0x81, 0x3a,
+};
+static const size_t TEST_DVPT192_139_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_139_ADATA[] = {
+    0xfc, 0xad, 0x52, 0xa8, 0x85, 0x44, 0x32, 0x5b,
+    0xb3, 0x1e, 0xb5, 0xde, 0x4a, 0x41, 0xdb, 0xff,
+    0x6a, 0x96, 0xf6, 0x9d, 0x09, 0x93, 0xb9, 0x69,
+    0xa0, 0x17, 0x92, 0xee, 0x23, 0x95, 0x3a, 0xcf,
+};
+static const size_t TEST_DVPT192_139_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_139_EXPECTED[] = {
+    0x29, 0xe9, 0x67, 0xa0, 0x24, 0x56, 0x07, 0xc3,
+    0x6c, 0xf3, 0xea, 0xf0, 0x0f, 0xda, 0xe5, 0x66,
+};
+static const size_t TEST_DVPT192_139_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_139_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_139_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_146_NONCE[] = {
+    0xa1, 0xae, 0xda, 0x4b, 0x4c, 0xb8, 0xdd,
+};
+static const size_t TEST_DVPT192_146_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_146_ADATA[] = {
+    0xdb, 0x30, 0x22, 0xef, 0x4c, 0xd6, 0x8a, 0xe2,
+    0x2b, 0x50, 0x15, 0x99, 0x44, 0x8f, 0xfe, 0x2d,
+    0xda, 0x15, 0xcf, 0xd2, 0xe2, 0x59, 0x31, 0x5c,
+    0x6f, 0x6d, 0x03, 0x03, 0x6e, 0xde, 0xa9, 0x63,
+};
+static const size_t TEST_DVPT192_146_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_146_EXPECTED[] = {
+    0x70, 0xa0, 0x9a, 0xaf, 0x22, 0xac, 0x31, 0x61,
+    0x24, 0xa1, 0x69, 0xf6, 0xb0, 0xa8, 0x3f, 0xfe,
+};
+static const size_t TEST_DVPT192_146_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_146_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_146_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_147_NONCE[] = {
+    0xf2, 0x48, 0xe5, 0x22, 0x5e, 0x3d, 0x9a,
+};
+static const size_t TEST_DVPT192_147_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_147_ADATA[] = {
+    0xfd, 0xc6, 0x4e, 0xf7, 0x6a, 0x3b, 0xfd, 0x0a,
+    0x15, 0xd0, 0xbc, 0x8e, 0x8b, 0xac, 0xaf, 0x64,
+    0x34, 0x67, 0x96, 0xa3, 0xe3, 0x5a, 0xfc, 0xf2,
+    0xac, 0x1a, 0xb1, 0x36, 0xf6, 0x3f, 0x7b, 0x6e,
+};
+static const size_t TEST_DVPT192_147_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_147_EXPECTED[] = {
+    0x5b, 0xc8, 0x5e, 0xd5, 0x52, 0x1a, 0x91, 0xb9,
+    0xeb, 0x42, 0xb4, 0x37, 0x95, 0x0f, 0x0e, 0x06,
+};
+static const size_t TEST_DVPT192_147_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_147_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_147_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_148_NONCE[] = {
+    0xe6, 0x82, 0x28, 0xf5, 0xc6, 0x5b, 0x73,
+};
+static const size_t TEST_DVPT192_148_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_148_ADATA[] = {
+    0x61, 0x4e, 0xfd, 0xf8, 0x9c, 0xe2, 0xa9, 0xfc,
+    0xbd, 0x38, 0xbd, 0xc0, 0xb4, 0xce, 0xce, 0x54,
+    0xdf, 0xd7, 0x53, 0x28, 0x80, 0xe0, 0xb4, 0xce,
+    0x6e, 0xb3, 0xa4, 0x01, 0x0b, 0x7c, 0xb1, 0xe7,
+};
+static const size_t TEST_DVPT192_148_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_148_EXPECTED[] = {
+    0x98, 0x9e, 0xc0, 0xe7, 0xb1, 0x92, 0xea, 0x01,
+    0x0d, 0xd6, 0x1d, 0x3f, 0xb6, 0x4e, 0x8d, 0xe0,
+};
+static const size_t TEST_DVPT192_148_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_148_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_148_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_10_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_10_KEY[] = {
+    0x6a, 0x79, 0x8d, 0x7c, 0x5e, 0x1a, 0x72, 0xb4,
+    0x3e, 0x20, 0xad, 0x5c, 0x7b, 0x08, 0x56, 0x7b,
+    0x12, 0xab, 0x74, 0x4b, 0x61, 0xc0, 0x70, 0xe2,
+};
+static const size_t TEST_DVPT192_GROUP_10_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_150_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_150_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_150_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT192_150_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_150_EXPECTED[] = {
+    0x5e, 0x0e, 0xae, 0xbd,
+};
+static const size_t TEST_DVPT192_150_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_150_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_150_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_154_NONCE[] = {
+    0x1e, 0x7e, 0x51, 0xf0, 0xfa, 0x9a, 0x33, 0xed,
+    0x61, 0x8c, 0x26, 0xf5, 0xe3,
+};
+static const size_t TEST_DVPT192_154_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_154_ADATA[] = {
+    0xda, 0x9b, 0x8f, 0xfb, 0x0f, 0x3c, 0x2a, 0xee,
+    0x2e, 0x38, 0x6c, 0xc9, 0xf0, 0x35, 0xec, 0x1e,
+    0xb3, 0xe6, 0x29, 0xbd, 0x15, 0x44, 0xc1, 0x1d,
+    0xc2, 0x1b, 0xe4, 0xfd, 0x8a, 0xc9, 0x07, 0x4a,
+};
+static const size_t TEST_DVPT192_154_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_154_EXPECTED[] = {
+    0xbf, 0x7a, 0x8e, 0x0c,
+};
+static const size_t TEST_DVPT192_154_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_154_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_154_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_161_NONCE[] = {
+    0x78, 0x64, 0xc7, 0x17, 0xec, 0x93, 0xdb, 0x38,
+    0xb1, 0x06, 0x79, 0xbe, 0x47,
+};
+static const size_t TEST_DVPT192_161_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_161_ADATA[] = {
+    0x67, 0x9a, 0xad, 0x1a, 0xd1, 0xe5, 0x70, 0x29,
+    0xe3, 0x36, 0x2b, 0x32, 0x55, 0x72, 0xfc, 0x71,
+    0xca, 0xc5, 0x31, 0x84, 0xb0, 0xf1, 0x54, 0x68,
+    0x67, 0xe6, 0x65, 0xa4, 0xa5, 0x94, 0x66, 0xc4,
+};
+static const size_t TEST_DVPT192_161_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_161_EXPECTED[] = {
+    0xdf, 0x7f, 0x63, 0xca,
+};
+static const size_t TEST_DVPT192_161_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_161_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_161_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_162_NONCE[] = {
+    0xc3, 0xbf, 0x9d, 0xfe, 0x9d, 0x6c, 0x26, 0xf5,
+    0x43, 0x18, 0x8f, 0xb4, 0x57,
+};
+static const size_t TEST_DVPT192_162_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_162_ADATA[] = {
+    0xe3, 0x01, 0xf6, 0x9a, 0xd3, 0xa7, 0xe0, 0x8a,
+    0x3d, 0x02, 0x46, 0x2f, 0x0a, 0xa5, 0x84, 0x44,
+    0x9e, 0xb0, 0x44, 0x9b, 0x0e, 0x3c, 0x50, 0xaa,
+    0x8d, 0xfa, 0xa4, 0x47, 0x28, 0x16, 0xc8, 0xb0,
+};
+static const size_t TEST_DVPT192_162_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_162_EXPECTED[] = {
+    0xbf, 0x0b, 0x14, 0x45,
+};
+static const size_t TEST_DVPT192_162_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_162_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_162_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_163_NONCE[] = {
+    0x15, 0x27, 0x65, 0x7d, 0x2f, 0xd9, 0x8f, 0x7d,
+    0xec, 0xa5, 0x5c, 0xc6, 0x49,
+};
+static const size_t TEST_DVPT192_163_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_163_ADATA[] = {
+    0xf4, 0xc7, 0x23, 0x43, 0x3b, 0x7c, 0xaf, 0xe3,
+    0xcd, 0xa9, 0xbb, 0x49, 0x40, 0xa2, 0x1a, 0x89,
+    0xa8, 0x38, 0x2d, 0x13, 0x01, 0x8b, 0x62, 0x2c,
+    0xcd, 0x1f, 0xfb, 0x9f, 0xfd, 0x32, 0x11, 0xaf,
+};
+static const size_t TEST_DVPT192_163_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_163_EXPECTED[] = {
+    0xae, 0x85, 0x33, 0xf5,
+};
+static const size_t TEST_DVPT192_163_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT192_163_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_163_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_11_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_11_KEY[] = {
+    0xf9, 0xfd, 0xca, 0x4a, 0xc6, 0x4f, 0xe7, 0xf0,
+    0x14, 0xde, 0x0f, 0x43, 0x03, 0x9c, 0x75, 0x71,
+    0x94, 0xd5, 0x44, 0xce, 0x5d, 0x15, 0xee, 0xd4,
+};
+static const size_t TEST_DVPT192_GROUP_11_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_165_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_165_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_165_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT192_165_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_165_EXPECTED[] = {
+    0xd0, 0x7c, 0xcf, 0x9f, 0xdc, 0x3d, 0x33, 0xaa,
+    0x94, 0xcd, 0xa3, 0xd2, 0x30, 0xda, 0x70, 0x7c,
+};
+static const size_t TEST_DVPT192_165_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_165_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_165_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_169_NONCE[] = {
+    0x1e, 0x7e, 0x51, 0xf0, 0xfa, 0x9a, 0x33, 0xed,
+    0x61, 0x8c, 0x26, 0xf5, 0xe3,
+};
+static const size_t TEST_DVPT192_169_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_169_ADATA[] = {
+    0xda, 0x9b, 0x8f, 0xfb, 0x0f, 0x3c, 0x2a, 0xee,
+    0x2e, 0x38, 0x6c, 0xc9, 0xf0, 0x35, 0xec, 0x1e,
+    0xb3, 0xe6, 0x29, 0xbd, 0x15, 0x44, 0xc1, 0x1d,
+    0xc2, 0x1b, 0xe4, 0xfd, 0x8a, 0xc9, 0x07, 0x4a,
+};
+static const size_t TEST_DVPT192_169_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_169_EXPECTED[] = {
+    0xa9, 0xe8, 0x1a, 0xfd, 0x10, 0x30, 0xd1, 0x95,
+    0xc6, 0x79, 0xe2, 0xc8, 0x37, 0xae, 0xb7, 0x36,
+};
+static const size_t TEST_DVPT192_169_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_169_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_169_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_176_NONCE[] = {
+    0x78, 0x64, 0xc7, 0x17, 0xec, 0x93, 0xdb, 0x38,
+    0xb1, 0x06, 0x79, 0xbe, 0x47,
+};
+static const size_t TEST_DVPT192_176_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_176_ADATA[] = {
+    0x67, 0x9a, 0xad, 0x1a, 0xd1, 0xe5, 0x70, 0x29,
+    0xe3, 0x36, 0x2b, 0x32, 0x55, 0x72, 0xfc, 0x71,
+    0xca, 0xc5, 0x31, 0x84, 0xb0, 0xf1, 0x54, 0x68,
+    0x67, 0xe6, 0x65, 0xa4, 0xa5, 0x94, 0x66, 0xc4,
+};
+static const size_t TEST_DVPT192_176_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_176_EXPECTED[] = {
+    0xaa, 0xc0, 0x9c, 0xef, 0x96, 0x97, 0x92, 0x73,
+    0x31, 0x25, 0x1f, 0x02, 0x8d, 0x24, 0xc3, 0x1f,
+};
+static const size_t TEST_DVPT192_176_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_176_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_176_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_177_NONCE[] = {
+    0xc3, 0xbf, 0x9d, 0xfe, 0x9d, 0x6c, 0x26, 0xf5,
+    0x43, 0x18, 0x8f, 0xb4, 0x57,
+};
+static const size_t TEST_DVPT192_177_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_177_ADATA[] = {
+    0xe3, 0x01, 0xf6, 0x9a, 0xd3, 0xa7, 0xe0, 0x8a,
+    0x3d, 0x02, 0x46, 0x2f, 0x0a, 0xa5, 0x84, 0x44,
+    0x9e, 0xb0, 0x44, 0x9b, 0x0e, 0x3c, 0x50, 0xaa,
+    0x8d, 0xfa, 0xa4, 0x47, 0x28, 0x16, 0xc8, 0xb0,
+};
+static const size_t TEST_DVPT192_177_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_177_EXPECTED[] = {
+    0x56, 0xc0, 0x00, 0x70, 0xea, 0xe0, 0xdb, 0x32,
+    0x98, 0x94, 0xa0, 0x45, 0xd8, 0x66, 0xbb, 0xaf,
+};
+static const size_t TEST_DVPT192_177_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_177_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_177_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT192_178_NONCE[] = {
+    0x15, 0x27, 0x65, 0x7d, 0x2f, 0xd9, 0x8f, 0x7d,
+    0xec, 0xa5, 0x5c, 0xc6, 0x49,
+};
+static const size_t TEST_DVPT192_178_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_178_ADATA[] = {
+    0xf4, 0xc7, 0x23, 0x43, 0x3b, 0x7c, 0xaf, 0xe3,
+    0xcd, 0xa9, 0xbb, 0x49, 0x40, 0xa2, 0x1a, 0x89,
+    0xa8, 0x38, 0x2d, 0x13, 0x01, 0x8b, 0x62, 0x2c,
+    0xcd, 0x1f, 0xfb, 0x9f, 0xfd, 0x32, 0x11, 0xaf,
+};
+static const size_t TEST_DVPT192_178_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_178_EXPECTED[] = {
+    0x09, 0x00, 0x16, 0xbb, 0x96, 0xae, 0xaa, 0xbb,
+    0xf6, 0x6f, 0xd3, 0x4f, 0xc9, 0x75, 0x91, 0xa4,
+};
+static const size_t TEST_DVPT192_178_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT192_178_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT192_178_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 24, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_12_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_12_KEY[] = {
+    0xf9, 0xfd, 0xca, 0x4a, 0xc6, 0x4f, 0xe7, 0xf0,
+    0x14, 0xde, 0x0f, 0x43, 0x03, 0x9c, 0x75, 0x71,
+    0x94, 0xd5, 0x44, 0xce, 0x5d, 0x15, 0xee, 0xd4,
+};
+static const size_t TEST_DVPT192_GROUP_12_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_180_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_180_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_180_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT192_180_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_180_EXPECTED[] = {
+    0x9f, 0x6c, 0xa4, 0xaf, 0x9b, 0x15, 0x91, 0x48,
+    0xc8, 0x89, 0xa6, 0x58, 0x4d, 0x11, 0x83, 0xea,
+    0x26, 0xe2, 0x61, 0x48, 0x74, 0xb0, 0x50, 0x45,
+    0x75, 0xde, 0xa8, 0xd1,
+};
+static const size_t TEST_DVPT192_180_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_180_INPUT[] = {
+    0xa2, 0x65, 0x48, 0x0c, 0xa8, 0x8d, 0x5f, 0x53,
+    0x6d, 0xb0, 0xdc, 0x6a, 0xbc, 0x40, 0xfa, 0xf0,
+    0xd0, 0x5b, 0xe7, 0xa9, 0x66, 0x97, 0x77, 0x68,
+};
+static const size_t TEST_DVPT192_180_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_184_NONCE[] = {
+    0xcc, 0xee, 0x19, 0xd0, 0x37, 0xcf, 0x4a,
+};
+static const size_t TEST_DVPT192_184_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_184_ADATA[] = {
+    0xc0, 0x26, 0x69, 0x6e, 0x64, 0x25, 0xe6, 0xc3,
+    0x3f, 0x45, 0xb4, 0x14, 0x5f, 0xeb, 0xf1, 0x13,
+    0x7e, 0x7a, 0xc2, 0x63, 0x83, 0xc9, 0xf5, 0xaa,
+    0x4c, 0xd4, 0xe5, 0xe8, 0xab, 0xb1, 0x9e, 0x07,
+};
+static const size_t TEST_DVPT192_184_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_184_EXPECTED[] = {
+    0xc3, 0x11, 0x6d, 0x90, 0x40, 0xe1, 0xed, 0x4f,
+    0x7c, 0x94, 0x64, 0xd2, 0x70, 0xfb, 0x30, 0x2b,
+    0xd3, 0xf1, 0x56, 0x1c, 0x25, 0xc5, 0xb9, 0x5b,
+    0x8b, 0x4b, 0x53, 0xf6,
+};
+static const size_t TEST_DVPT192_184_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_184_INPUT[] = {
+    0x0d, 0xf2, 0x02, 0x43, 0x1e, 0xe7, 0xf2, 0x51,
+    0xa3, 0x8a, 0xaf, 0x6a, 0xa8, 0xcd, 0x31, 0x37,
+    0x82, 0xbd, 0x29, 0x3a, 0xf9, 0x11, 0x40, 0x05,
+};
+static const size_t TEST_DVPT192_184_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_191_NONCE[] = {
+    0xa8, 0x40, 0xe9, 0x8d, 0xf7, 0x2a, 0xe9,
+};
+static const size_t TEST_DVPT192_191_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_191_ADATA[] = {
+    0x22, 0xc6, 0x60, 0x77, 0x32, 0xef, 0x1b, 0xdc,
+    0x7f, 0xcf, 0x61, 0x97, 0xe0, 0x37, 0xcd, 0xad,
+    0xd7, 0xee, 0x17, 0xc0, 0x08, 0x55, 0x2d, 0xd9,
+    0xf0, 0x4b, 0x85, 0x64, 0xd3, 0x4f, 0xb1, 0x7c,
+};
+static const size_t TEST_DVPT192_191_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_191_EXPECTED[] = {
+    0x51, 0xb6, 0xb9, 0x28, 0xbd, 0xd1, 0xcc, 0x0b,
+    0xd0, 0xa0, 0xae, 0xd2, 0xcd, 0xa3, 0x02, 0x47,
+    0x2d, 0x61, 0x8f, 0xfa, 0xa6, 0x0e, 0x17, 0x90,
+    0x29, 0xc8, 0x78, 0x55,
+};
+static const size_t TEST_DVPT192_191_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_191_INPUT[] = {
+    0xa2, 0xf5, 0x33, 0x85, 0x61, 0x8b, 0x41, 0x30,
+    0x1f, 0x4e, 0x3e, 0xa4, 0xc5, 0x97, 0xf4, 0x11,
+    0x10, 0x3d, 0xac, 0x2b, 0x37, 0xab, 0xf5, 0xda,
+};
+static const size_t TEST_DVPT192_191_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_192_NONCE[] = {
+    0x39, 0xd9, 0x3c, 0x3c, 0xf3, 0x1a, 0x6f,
+};
+static const size_t TEST_DVPT192_192_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_192_ADATA[] = {
+    0x93, 0x7d, 0xfa, 0xc5, 0xcd, 0xed, 0x93, 0x84,
+    0x38, 0xf4, 0xe9, 0x7a, 0xab, 0xd9, 0xbe, 0xb5,
+    0x0d, 0xba, 0x40, 0xf8, 0x24, 0x19, 0x82, 0x60,
+    0xa8, 0x97, 0x29, 0x47, 0x9c, 0xfe, 0x68, 0x69,
+};
+static const size_t TEST_DVPT192_192_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_192_EXPECTED[] = {
+    0xd0, 0xab, 0xab, 0x9b, 0x8e, 0x9d, 0x6c, 0x11,
+    0xbb, 0x9c, 0x15, 0xbe, 0xa8, 0xa4, 0x86, 0x70,
+    0x4b, 0xed, 0x32, 0xc5, 0x72, 0x97, 0x05, 0x5b,
+    0x4d, 0xe8, 0xed, 0x8d,
+};
+static const size_t TEST_DVPT192_192_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_192_INPUT[] = {
+    0xc1, 0xbd, 0xef, 0x96, 0xdc, 0x86, 0x84, 0x46,
+    0xbe, 0x48, 0x49, 0x1b, 0x16, 0x05, 0x04, 0x54,
+    0x6f, 0x2a, 0x40, 0xdd, 0x58, 0x1f, 0x95, 0x82,
+};
+static const size_t TEST_DVPT192_192_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_193_NONCE[] = {
+    0x0b, 0xbc, 0x17, 0x70, 0x19, 0x32, 0x1e,
+};
+static const size_t TEST_DVPT192_193_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_193_ADATA[] = {
+    0xf6, 0xe0, 0x26, 0x78, 0x82, 0x0f, 0x5c, 0xcb,
+    0xed, 0xe6, 0xcb, 0xde, 0xd0, 0x2d, 0x6d, 0xd5,
+    0x8d, 0x48, 0x61, 0x66, 0xd7, 0xb1, 0x8e, 0xe9,
+    0x75, 0xa6, 0x88, 0xaf, 0x42, 0x1f, 0xb7, 0x95,
+};
+static const size_t TEST_DVPT192_193_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_193_EXPECTED[] = {
+    0x92, 0xfd, 0x51, 0x9a, 0x96, 0x6c, 0x0f, 0xbd,
+    0xd7, 0x08, 0x7f, 0xf5, 0xa1, 0xbd, 0x94, 0x6c,
+    0xd6, 0x63, 0x50, 0x2d, 0xb3, 0x78, 0x38, 0x35,
+    0x31, 0xd6, 0x99, 0x47,
+};
+static const size_t TEST_DVPT192_193_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_193_INPUT[] = {
+    0x72, 0xa7, 0x09, 0x54, 0xd2, 0x2a, 0xd7, 0x22,
+    0xfc, 0x32, 0x75, 0x6a, 0xfc, 0xe6, 0x7b, 0x34,
+    0x4b, 0x2f, 0x3c, 0x55, 0xfe, 0x1d, 0x9e, 0xed,
+};
+static const size_t TEST_DVPT192_193_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_13_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_13_KEY[] = {
+    0xa7, 0xaa, 0x63, 0x5e, 0xa5, 0x1b, 0x0b, 0xb2,
+    0x0a, 0x09, 0x2b, 0xd5, 0x57, 0x3e, 0x72, 0x8c,
+    0xcd, 0x4b, 0x3e, 0x8c, 0xdd, 0x2a, 0xb3, 0x3d,
+};
+static const size_t TEST_DVPT192_GROUP_13_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_195_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9,
+};
+static const size_t TEST_DVPT192_195_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_195_ADATA[] = {
+    0x37, 0x96, 0xcf, 0x51, 0xb8, 0x72, 0x66, 0x52,
+    0xa4, 0x20, 0x47, 0x33, 0xb8, 0xfb, 0xb0, 0x47,
+    0xcf, 0x00, 0xfb, 0x91, 0xa9, 0x83, 0x7e, 0x22,
+    0xec, 0x22, 0xb1, 0xa2, 0x68, 0xf8, 0x8e, 0x2c,
+};
+static const size_t TEST_DVPT192_195_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_195_EXPECTED[] = {
+    0x6a, 0xab, 0x64, 0xc4, 0x78, 0x75, 0x99, 0xd8,
+    0xf2, 0x13, 0x44, 0x6b, 0xea, 0xdb, 0x16, 0xe0,
+    0x8d, 0xba, 0x60, 0xe9, 0x7f, 0x56, 0xdb, 0xd1,
+    0x4d, 0x1d, 0x98, 0x0d, 0x6f, 0xe0, 0xfb, 0x44,
+    0xb4, 0x21, 0x99, 0x26, 0x62, 0xb9, 0x79, 0x75,
+};
+static const size_t TEST_DVPT192_195_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_195_INPUT[] = {
+    0xa2, 0x65, 0x48, 0x0c, 0xa8, 0x8d, 0x5f, 0x53,
+    0x6d, 0xb0, 0xdc, 0x6a, 0xbc, 0x40, 0xfa, 0xf0,
+    0xd0, 0x5b, 0xe7, 0xa9, 0x66, 0x97, 0x77, 0x68,
+};
+static const size_t TEST_DVPT192_195_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_199_NONCE[] = {
+    0xcc, 0xee, 0x19, 0xd0, 0x37, 0xcf, 0x4a,
+};
+static const size_t TEST_DVPT192_199_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_199_ADATA[] = {
+    0xc0, 0x26, 0x69, 0x6e, 0x64, 0x25, 0xe6, 0xc3,
+    0x3f, 0x45, 0xb4, 0x14, 0x5f, 0xeb, 0xf1, 0x13,
+    0x7e, 0x7a, 0xc2, 0x63, 0x83, 0xc9, 0xf5, 0xaa,
+    0x4c, 0xd4, 0xe5, 0xe8, 0xab, 0xb1, 0x9e, 0x07,
+};
+static const size_t TEST_DVPT192_199_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_199_EXPECTED[] = {
+    0x67, 0xd9, 0x89, 0xea, 0x93, 0x5b, 0x9c, 0xe1,
+    0x90, 0xe3, 0xa7, 0xf3, 0xb6, 0x45, 0x30, 0x5e,
+    0x1e, 0x30, 0x8a, 0x7f, 0xe6, 0x17, 0xf8, 0x0f,
+    0x17, 0x0a, 0x2b, 0x9c, 0x30, 0x9d, 0xe6, 0xc2,
+    0x32, 0x61, 0x15, 0xa7, 0x6e, 0xfb, 0xdf, 0x98,
+};
+static const size_t TEST_DVPT192_199_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_199_INPUT[] = {
+    0x0d, 0xf2, 0x02, 0x43, 0x1e, 0xe7, 0xf2, 0x51,
+    0xa3, 0x8a, 0xaf, 0x6a, 0xa8, 0xcd, 0x31, 0x37,
+    0x82, 0xbd, 0x29, 0x3a, 0xf9, 0x11, 0x40, 0x05,
+};
+static const size_t TEST_DVPT192_199_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_206_NONCE[] = {
+    0xa8, 0x40, 0xe9, 0x8d, 0xf7, 0x2a, 0xe9,
+};
+static const size_t TEST_DVPT192_206_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_206_ADATA[] = {
+    0x22, 0xc6, 0x60, 0x77, 0x32, 0xef, 0x1b, 0xdc,
+    0x7f, 0xcf, 0x61, 0x97, 0xe0, 0x37, 0xcd, 0xad,
+    0xd7, 0xee, 0x17, 0xc0, 0x08, 0x55, 0x2d, 0xd9,
+    0xf0, 0x4b, 0x85, 0x64, 0xd3, 0x4f, 0xb1, 0x7c,
+};
+static const size_t TEST_DVPT192_206_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_206_EXPECTED[] = {
+    0x53, 0xbb, 0x60, 0x8f, 0x62, 0x36, 0x79, 0x88,
+    0x39, 0xaf, 0x35, 0x88, 0x8c, 0xb0, 0xfa, 0x47,
+    0x97, 0xb5, 0x99, 0x27, 0x10, 0x84, 0xcc, 0x13,
+    0x84, 0x7b, 0x02, 0x27, 0x33, 0xca, 0x5a, 0x5e,
+    0x3c, 0x4d, 0x47, 0x23, 0x32, 0x48, 0x4b, 0x7f,
+};
+static const size_t TEST_DVPT192_206_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_206_INPUT[] = {
+    0xa2, 0xf5, 0x33, 0x85, 0x61, 0x8b, 0x41, 0x30,
+    0x1f, 0x4e, 0x3e, 0xa4, 0xc5, 0x97, 0xf4, 0x11,
+    0x10, 0x3d, 0xac, 0x2b, 0x37, 0xab, 0xf5, 0xda,
+};
+static const size_t TEST_DVPT192_206_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_207_NONCE[] = {
+    0x39, 0xd9, 0x3c, 0x3c, 0xf3, 0x1a, 0x6f,
+};
+static const size_t TEST_DVPT192_207_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_207_ADATA[] = {
+    0x93, 0x7d, 0xfa, 0xc5, 0xcd, 0xed, 0x93, 0x84,
+    0x38, 0xf4, 0xe9, 0x7a, 0xab, 0xd9, 0xbe, 0xb5,
+    0x0d, 0xba, 0x40, 0xf8, 0x24, 0x19, 0x82, 0x60,
+    0xa8, 0x97, 0x29, 0x47, 0x9c, 0xfe, 0x68, 0x69,
+};
+static const size_t TEST_DVPT192_207_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_207_EXPECTED[] = {
+    0xbe, 0x54, 0x55, 0x1d, 0x1d, 0x2f, 0x1b, 0x3e,
+    0xb6, 0x0f, 0xfe, 0x3b, 0x16, 0x55, 0x24, 0xff,
+    0x90, 0xca, 0x09, 0xfb, 0x25, 0x2b, 0xf2, 0x1c,
+    0x1c, 0x79, 0xed, 0xbf, 0x38, 0xc5, 0x0e, 0x0f,
+    0x24, 0x0a, 0x2d, 0x70, 0xf6, 0x5a, 0xa7, 0x9f,
+};
+static const size_t TEST_DVPT192_207_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_207_INPUT[] = {
+    0xc1, 0xbd, 0xef, 0x96, 0xdc, 0x86, 0x84, 0x46,
+    0xbe, 0x48, 0x49, 0x1b, 0x16, 0x05, 0x04, 0x54,
+    0x6f, 0x2a, 0x40, 0xdd, 0x58, 0x1f, 0x95, 0x82,
+};
+static const size_t TEST_DVPT192_207_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_208_NONCE[] = {
+    0x0b, 0xbc, 0x17, 0x70, 0x19, 0x32, 0x1e,
+};
+static const size_t TEST_DVPT192_208_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT192_208_ADATA[] = {
+    0xf6, 0xe0, 0x26, 0x78, 0x82, 0x0f, 0x5c, 0xcb,
+    0xed, 0xe6, 0xcb, 0xde, 0xd0, 0x2d, 0x6d, 0xd5,
+    0x8d, 0x48, 0x61, 0x66, 0xd7, 0xb1, 0x8e, 0xe9,
+    0x75, 0xa6, 0x88, 0xaf, 0x42, 0x1f, 0xb7, 0x95,
+};
+static const size_t TEST_DVPT192_208_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_208_EXPECTED[] = {
+    0xf0, 0x7c, 0x10, 0x72, 0xd8, 0xf8, 0xe0, 0x77,
+    0xdf, 0xbb, 0x3a, 0xd8, 0x6d, 0xd9, 0x2d, 0x32,
+    0xb4, 0x1f, 0x29, 0xe6, 0x47, 0xdc, 0xd7, 0xe3,
+    0xa8, 0x2c, 0xd3, 0xeb, 0xaf, 0x6c, 0x2d, 0x3e,
+    0x21, 0x74, 0x9b, 0xdf, 0x57, 0x0a, 0xd2, 0x8d,
+};
+static const size_t TEST_DVPT192_208_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_208_INPUT[] = {
+    0x72, 0xa7, 0x09, 0x54, 0xd2, 0x2a, 0xd7, 0x22,
+    0xfc, 0x32, 0x75, 0x6a, 0xfc, 0xe6, 0x7b, 0x34,
+    0x4b, 0x2f, 0x3c, 0x55, 0xfe, 0x1d, 0x9e, 0xed,
+};
+static const size_t TEST_DVPT192_208_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT192_GROUP_14_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT192_GROUP_14_KEY[] = {
+    0xa7, 0xaa, 0x63, 0x5e, 0xa5, 0x1b, 0x0b, 0xb2,
+    0x0a, 0x09, 0x2b, 0xd5, 0x57, 0x3e, 0x72, 0x8c,
+    0xcd, 0x4b, 0x3e, 0x8c, 0xdd, 0x2a, 0xb3, 0x3d,
+};
+static const size_t TEST_DVPT192_GROUP_14_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_210_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_210_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_210_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT192_210_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_210_EXPECTED[] = {
+    0x16, 0xe5, 0x43, 0xd0, 0xe2, 0x06, 0x15, 0xff,
+    0x0d, 0xf1, 0x5a, 0xcd, 0x99, 0x27, 0xdd, 0xfe,
+    0x40, 0x66, 0x8a, 0x54, 0xbb, 0x85, 0x4c, 0xcc,
+    0xc2, 0x5e, 0x9f, 0xce,
+};
+static const size_t TEST_DVPT192_210_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_210_INPUT[] = {
+    0x87, 0x39, 0xb4, 0xbe, 0xa1, 0xa0, 0x99, 0xfe,
+    0x54, 0x74, 0x99, 0xcb, 0xc6, 0xd1, 0xb1, 0x3d,
+    0x84, 0x9b, 0x80, 0x84, 0xc9, 0xb6, 0xac, 0xc5,
+};
+static const size_t TEST_DVPT192_210_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_214_NONCE[] = {
+    0xe3, 0xc0, 0x3e, 0xf7, 0xe1, 0xd3, 0x19, 0x61,
+    0xee, 0x0b, 0x97, 0xbd, 0x99,
+};
+static const size_t TEST_DVPT192_214_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_214_ADATA[] = {
+    0x8a, 0x36, 0x76, 0xdd, 0x64, 0x08, 0x21, 0xb5,
+    0x8f, 0xb0, 0xf0, 0x32, 0x98, 0x55, 0xfd, 0x58,
+    0x82, 0xc3, 0x76, 0xea, 0x16, 0x6b, 0x95, 0x8b,
+    0x7a, 0xaa, 0xd2, 0x23, 0x05, 0x4e, 0x57, 0x84,
+};
+static const size_t TEST_DVPT192_214_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_214_EXPECTED[] = {
+    0x24, 0xe1, 0xd3, 0x82, 0x01, 0x01, 0x41, 0x2d,
+    0x8f, 0x4d, 0x57, 0x11, 0x8c, 0xab, 0x8f, 0x7e,
+    0x48, 0x9d, 0x5c, 0xac, 0x78, 0x80, 0x2d, 0xd5,
+    0xcc, 0xf8, 0xec, 0xf0,
+};
+static const size_t TEST_DVPT192_214_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_214_INPUT[] = {
+    0x92, 0x97, 0x3c, 0xe7, 0x07, 0x73, 0x3a, 0x73,
+    0x11, 0x8c, 0x8c, 0xe6, 0xb5, 0xe3, 0xfc, 0x77,
+    0xa1, 0x7f, 0x44, 0x83, 0x10, 0xc0, 0x19, 0x7f,
+};
+static const size_t TEST_DVPT192_214_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_221_NONCE[] = {
+    0x93, 0xe0, 0x88, 0x54, 0x56, 0x0e, 0xdb, 0x09,
+    0x6e, 0x5d, 0x65, 0x40, 0x86,
+};
+static const size_t TEST_DVPT192_221_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_221_ADATA[] = {
+    0xbd, 0xc6, 0x0d, 0xff, 0x08, 0xbf, 0xd5, 0xd4,
+    0x43, 0x20, 0xb7, 0x5c, 0x61, 0xe4, 0x56, 0xfd,
+    0x43, 0x33, 0xc9, 0xc3, 0xd0, 0x29, 0x4d, 0x4a,
+    0x48, 0xd9, 0x36, 0xdf, 0xd5, 0x92, 0x2c, 0xe2,
+};
+static const size_t TEST_DVPT192_221_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_221_EXPECTED[] = {
+    0x0e, 0xf8, 0x98, 0x1d, 0xd3, 0x7c, 0x05, 0x5a,
+    0x3c, 0x3e, 0x14, 0x78, 0x6f, 0xc6, 0x62, 0xb2,
+    0xa1, 0x10, 0x65, 0x96, 0x49, 0x11, 0xd3, 0x5e,
+    0xbc, 0xc8, 0x70, 0x96,
+};
+static const size_t TEST_DVPT192_221_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_221_INPUT[] = {
+    0x56, 0x9e, 0x4a, 0xec, 0x88, 0xdd, 0x51, 0xca,
+    0x51, 0x9c, 0x0a, 0x00, 0xc9, 0x22, 0xee, 0x33,
+    0xd3, 0x55, 0x9b, 0x98, 0xa3, 0x2d, 0x79, 0x06,
+};
+static const size_t TEST_DVPT192_221_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_222_NONCE[] = {
+    0xe3, 0xf3, 0x7b, 0x68, 0xff, 0x50, 0x8c, 0xfe,
+    0x29, 0x54, 0x41, 0xd9, 0xe3,
+};
+static const size_t TEST_DVPT192_222_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_222_ADATA[] = {
+    0xb2, 0xb6, 0xc5, 0x78, 0x2e, 0x4f, 0x12, 0x84,
+    0x67, 0xc5, 0x89, 0xd2, 0xa6, 0xcf, 0x55, 0xef,
+    0x12, 0x87, 0x7a, 0xdb, 0x77, 0x1b, 0xbb, 0x62,
+    0x45, 0xc5, 0xbb, 0xa9, 0xdc, 0xfd, 0x62, 0x08,
+};
+static const size_t TEST_DVPT192_222_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_222_EXPECTED[] = {
+    0xfc, 0x18, 0x70, 0xcf, 0xc4, 0x40, 0xf7, 0x4f,
+    0x73, 0xf4, 0x0e, 0x68, 0x2c, 0xf4, 0x71, 0x3d,
+    0x02, 0x7c, 0x29, 0x7b, 0x94, 0x26, 0xc3, 0xef,
+    0xe9, 0x81, 0xe9, 0x35,
+};
+static const size_t TEST_DVPT192_222_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_222_INPUT[] = {
+    0x02, 0xb5, 0x51, 0x12, 0x04, 0xbd, 0x55, 0xf7,
+    0xc3, 0x79, 0x73, 0xe2, 0x6f, 0x6d, 0xf5, 0x88,
+    0x3c, 0x0a, 0x53, 0x0f, 0x07, 0xc7, 0xf8, 0xc2,
+};
+static const size_t TEST_DVPT192_222_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_223_NONCE[] = {
+    0xea, 0x98, 0xec, 0x44, 0xf5, 0xa8, 0x67, 0x15,
+    0x01, 0x47, 0x83, 0x17, 0x2e,
+};
+static const size_t TEST_DVPT192_223_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_223_ADATA[] = {
+    0xe4, 0x69, 0x2b, 0x9f, 0x06, 0xb6, 0x66, 0xc7,
+    0x45, 0x1b, 0x14, 0x6c, 0x8a, 0xeb, 0x07, 0xa6,
+    0xe3, 0x0c, 0x62, 0x9d, 0x28, 0x06, 0x5c, 0x3d,
+    0xde, 0x59, 0x40, 0x32, 0x5b, 0x14, 0xb8, 0x10,
+};
+static const size_t TEST_DVPT192_223_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_223_EXPECTED[] = {
+    0x9f, 0xc2, 0xc4, 0x62, 0xdf, 0xf1, 0xba, 0x97,
+    0x56, 0x77, 0x2d, 0x73, 0xde, 0x5c, 0x4e, 0x82,
+    0x2b, 0x5e, 0xa0, 0xbc, 0x88, 0x84, 0x5a, 0x32,
+    0x3b, 0x98, 0xde, 0x4f,
+};
+static const size_t TEST_DVPT192_223_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT192_223_INPUT[] = {
+    0x4d, 0xa4, 0x0b, 0x80, 0x57, 0x9c, 0x1d, 0x9a,
+    0x53, 0x09, 0xf7, 0xef, 0xec, 0xb7, 0xc0, 0x59,
+    0xa2, 0xf9, 0x14, 0x51, 0x1c, 0xa5, 0xfc, 0x10,
+};
+static const size_t TEST_DVPT192_223_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT192_GROUP_15_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT192_GROUP_15_KEY[] = {
+    0x26, 0x51, 0x1f, 0xb5, 0x1f, 0xcf, 0xa7, 0x5c,
+    0xb4, 0xb4, 0x4d, 0xa7, 0x5a, 0x6e, 0x5a, 0x0e,
+    0xb8, 0xd9, 0xc8, 0xf3, 0xb9, 0x06, 0xf8, 0x86,
+};
+static const size_t TEST_DVPT192_GROUP_15_KEY_LEN = 24;
+
+static const uint8_t TEST_DVPT192_225_NONCE[] = {
+    0x5a, 0x8a, 0xa4, 0x85, 0xc3, 0x16, 0xe9, 0x40,
+    0x3a, 0xff, 0x85, 0x9f, 0xbb,
+};
+static const size_t TEST_DVPT192_225_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_225_ADATA[] = {
+    0xa1, 0x6a, 0x2e, 0x74, 0x1f, 0x1c, 0xd9, 0x71,
+    0x72, 0x85, 0xb6, 0xd8, 0x82, 0xc1, 0xfc, 0x53,
+    0x65, 0x5e, 0x97, 0x73, 0x76, 0x1a, 0xd6, 0x97,
+    0xa7, 0xee, 0x64, 0x10, 0x18, 0x4c, 0x79, 0x82,
+};
+static const size_t TEST_DVPT192_225_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_225_EXPECTED[] = {
+    0xc5, 0xb0, 0xb2, 0xef, 0x17, 0x49, 0x8c, 0x55,
+    0x70, 0xeb, 0x33, 0x5d, 0xf4, 0x58, 0x80, 0x32,
+    0x95, 0x8b, 0xa3, 0xd6, 0x9b, 0xf6, 0xf3, 0x17,
+    0x84, 0x64, 0xa6, 0xf7, 0xfa, 0x2b, 0x76, 0x74,
+    0x4e, 0x8e, 0x8d, 0x95, 0x69, 0x1c, 0xec, 0xb8,
+};
+static const size_t TEST_DVPT192_225_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_225_INPUT[] = {
+    0x87, 0x39, 0xb4, 0xbe, 0xa1, 0xa0, 0x99, 0xfe,
+    0x54, 0x74, 0x99, 0xcb, 0xc6, 0xd1, 0xb1, 0x3d,
+    0x84, 0x9b, 0x80, 0x84, 0xc9, 0xb6, 0xac, 0xc5,
+};
+static const size_t TEST_DVPT192_225_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_229_NONCE[] = {
+    0xe3, 0xc0, 0x3e, 0xf7, 0xe1, 0xd3, 0x19, 0x61,
+    0xee, 0x0b, 0x97, 0xbd, 0x99,
+};
+static const size_t TEST_DVPT192_229_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_229_ADATA[] = {
+    0x8a, 0x36, 0x76, 0xdd, 0x64, 0x08, 0x21, 0xb5,
+    0x8f, 0xb0, 0xf0, 0x32, 0x98, 0x55, 0xfd, 0x58,
+    0x82, 0xc3, 0x76, 0xea, 0x16, 0x6b, 0x95, 0x8b,
+    0x7a, 0xaa, 0xd2, 0x23, 0x05, 0x4e, 0x57, 0x84,
+};
+static const size_t TEST_DVPT192_229_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_229_EXPECTED[] = {
+    0xea, 0xa9, 0x95, 0x94, 0x6e, 0xd9, 0x1d, 0x6a,
+    0x08, 0xad, 0xe1, 0x4b, 0x26, 0x0a, 0xc7, 0x52,
+    0xcb, 0xd1, 0x08, 0x1d, 0x5a, 0x7c, 0xad, 0x90,
+    0x78, 0x36, 0x18, 0x37, 0x4f, 0x6d, 0x03, 0xdf,
+    0x28, 0xee, 0x57, 0xa1, 0xa5, 0xaa, 0x38, 0xd8,
+};
+static const size_t TEST_DVPT192_229_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_229_INPUT[] = {
+    0x92, 0x97, 0x3c, 0xe7, 0x07, 0x73, 0x3a, 0x73,
+    0x11, 0x8c, 0x8c, 0xe6, 0xb5, 0xe3, 0xfc, 0x77,
+    0xa1, 0x7f, 0x44, 0x83, 0x10, 0xc0, 0x19, 0x7f,
+};
+static const size_t TEST_DVPT192_229_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_236_NONCE[] = {
+    0x93, 0xe0, 0x88, 0x54, 0x56, 0x0e, 0xdb, 0x09,
+    0x6e, 0x5d, 0x65, 0x40, 0x86,
+};
+static const size_t TEST_DVPT192_236_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_236_ADATA[] = {
+    0xbd, 0xc6, 0x0d, 0xff, 0x08, 0xbf, 0xd5, 0xd4,
+    0x43, 0x20, 0xb7, 0x5c, 0x61, 0xe4, 0x56, 0xfd,
+    0x43, 0x33, 0xc9, 0xc3, 0xd0, 0x29, 0x4d, 0x4a,
+    0x48, 0xd9, 0x36, 0xdf, 0xd5, 0x92, 0x2c, 0xe2,
+};
+static const size_t TEST_DVPT192_236_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_236_EXPECTED[] = {
+    0xaf, 0x63, 0xf2, 0x7e, 0x2a, 0x9e, 0x70, 0xf1,
+    0x06, 0x47, 0x74, 0x93, 0xdc, 0x14, 0x1d, 0x16,
+    0xa1, 0xd0, 0x59, 0xdd, 0x7a, 0x8a, 0x78, 0x10,
+    0xd9, 0x90, 0xb6, 0x42, 0x03, 0x9f, 0x24, 0x75,
+    0x57, 0x90, 0x33, 0x2b, 0x3c, 0xc4, 0x7c, 0x49,
+};
+static const size_t TEST_DVPT192_236_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_236_INPUT[] = {
+    0x56, 0x9e, 0x4a, 0xec, 0x88, 0xdd, 0x51, 0xca,
+    0x51, 0x9c, 0x0a, 0x00, 0xc9, 0x22, 0xee, 0x33,
+    0xd3, 0x55, 0x9b, 0x98, 0xa3, 0x2d, 0x79, 0x06,
+};
+static const size_t TEST_DVPT192_236_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_237_NONCE[] = {
+    0xe3, 0xf3, 0x7b, 0x68, 0xff, 0x50, 0x8c, 0xfe,
+    0x29, 0x54, 0x41, 0xd9, 0xe3,
+};
+static const size_t TEST_DVPT192_237_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_237_ADATA[] = {
+    0xb2, 0xb6, 0xc5, 0x78, 0x2e, 0x4f, 0x12, 0x84,
+    0x67, 0xc5, 0x89, 0xd2, 0xa6, 0xcf, 0x55, 0xef,
+    0x12, 0x87, 0x7a, 0xdb, 0x77, 0x1b, 0xbb, 0x62,
+    0x45, 0xc5, 0xbb, 0xa9, 0xdc, 0xfd, 0x62, 0x08,
+};
+static const size_t TEST_DVPT192_237_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_237_EXPECTED[] = {
+    0x1d, 0x2a, 0xe8, 0x8c, 0x87, 0x86, 0x84, 0xa0,
+    0xb4, 0x04, 0x98, 0x62, 0x52, 0xb3, 0xa7, 0x58,
+    0x3e, 0x1a, 0x5a, 0x51, 0x16, 0x3d, 0xdc, 0x60,
+    0x6d, 0x39, 0x68, 0xfd, 0xce, 0xaa, 0xe5, 0x13,
+    0x8c, 0x41, 0x1a, 0x29, 0xd0, 0xd3, 0x33, 0xee,
+};
+static const size_t TEST_DVPT192_237_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_237_INPUT[] = {
+    0x02, 0xb5, 0x51, 0x12, 0x04, 0xbd, 0x55, 0xf7,
+    0xc3, 0x79, 0x73, 0xe2, 0x6f, 0x6d, 0xf5, 0x88,
+    0x3c, 0x0a, 0x53, 0x0f, 0x07, 0xc7, 0xf8, 0xc2,
+};
+static const size_t TEST_DVPT192_237_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT192_238_NONCE[] = {
+    0xea, 0x98, 0xec, 0x44, 0xf5, 0xa8, 0x67, 0x15,
+    0x01, 0x47, 0x83, 0x17, 0x2e,
+};
+static const size_t TEST_DVPT192_238_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT192_238_ADATA[] = {
+    0xe4, 0x69, 0x2b, 0x9f, 0x06, 0xb6, 0x66, 0xc7,
+    0x45, 0x1b, 0x14, 0x6c, 0x8a, 0xeb, 0x07, 0xa6,
+    0xe3, 0x0c, 0x62, 0x9d, 0x28, 0x06, 0x5c, 0x3d,
+    0xde, 0x59, 0x40, 0x32, 0x5b, 0x14, 0xb8, 0x10,
+};
+static const size_t TEST_DVPT192_238_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT192_238_EXPECTED[] = {
+    0x30, 0xc1, 0x54, 0xc6, 0x16, 0x94, 0x6e, 0xcc,
+    0xc2, 0xe2, 0x41, 0xd3, 0x36, 0xad, 0x33, 0x72,
+    0x09, 0x53, 0xe4, 0x49, 0xa0, 0xe6, 0xb0, 0xf0,
+    0xdb, 0xf8, 0xe9, 0x46, 0x49, 0x09, 0xbd, 0xf3,
+    0x37, 0xe4, 0x80, 0x93, 0xc0, 0x82, 0xa1, 0x0b,
+};
+static const size_t TEST_DVPT192_238_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT192_238_INPUT[] = {
+    0x4d, 0xa4, 0x0b, 0x80, 0x57, 0x9c, 0x1d, 0x9a,
+    0x53, 0x09, 0xf7, 0xef, 0xec, 0xb7, 0xc0, 0x59,
+    0xa2, 0xf9, 0x14, 0x51, 0x1c, 0xa5, 0xfc, 0x10,
+};
+static const size_t TEST_DVPT192_238_INPUT_LEN = 24;
+
+/* Share test buffer output */
+static uint8_t data[512];
+
+static void test_encrypt_op(const uint8_t *key, uint8_t key_len,
+                            const uint8_t *adata, size_t adata_len,
+                            const uint8_t *nonce, uint8_t nonce_len,
+                            const uint8_t *plain, size_t plain_len,
+                            const uint8_t *output_expected,
+                            size_t output_expected_len,
+                            uint8_t mac_length)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    size_t len_encoding = nonce_and_len_encoding_size - nonce_len;
+
+    TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
+                        "Output buffer too small");
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ccm(&cipher, adata, adata_len,
+                             mac_length, len_encoding,
+                             nonce, nonce_len, plain, plain_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_expected_len, len);
+    cmp = compare(output_expected, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_decrypt_op(const uint8_t *key, uint8_t key_len,
+                            const uint8_t *adata, size_t adata_len,
+                            const uint8_t *nonce, uint8_t nonce_len,
+                            const uint8_t *encrypted, size_t encrypted_len,
+                            const uint8_t *output_expected,
+                            size_t output_expected_len,
+                            uint8_t mac_length)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    size_t len_encoding = nonce_and_len_encoding_size - nonce_len;
+
+    TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
+                        "Output buffer too small");
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ccm(&cipher, adata, adata_len,
+                             mac_length, len_encoding,
+                             nonce, nonce_len, encrypted, encrypted_len, data);
+    TEST_ASSERT_MESSAGE(len >= 0, "Decryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_expected_len, len);
+    cmp = compare(output_expected, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+#define do_test_encrypt_op(prefix, test_num, group_num) do { \
+        test_encrypt_op(TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED_LEN, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _MAC_LEN \
+                        ); \
+} while (0)
+
+#define do_test_decrypt_op(prefix, test_num, group_num) do { \
+        test_decrypt_op(TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT_LEN, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _MAC_LEN \
+                        ); \
+} while (0)
+
+static void test_crypto_modes_ccm_decrypt(void)
+{
+    do_test_decrypt_op(DVPT192, 0, 0);
+    do_test_decrypt_op(DVPT192, 4, 0);
+    do_test_decrypt_op(DVPT192, 11, 0);
+    do_test_decrypt_op(DVPT192, 12, 0);
+    do_test_decrypt_op(DVPT192, 13, 0);
+    do_test_decrypt_op(DVPT192, 15, 1);
+    do_test_decrypt_op(DVPT192, 19, 1);
+    do_test_decrypt_op(DVPT192, 26, 1);
+    do_test_decrypt_op(DVPT192, 27, 1);
+    do_test_decrypt_op(DVPT192, 28, 1);
+    do_test_decrypt_op(DVPT192, 30, 2);
+    do_test_decrypt_op(DVPT192, 34, 2);
+    do_test_decrypt_op(DVPT192, 41, 2);
+    do_test_decrypt_op(DVPT192, 42, 2);
+    do_test_decrypt_op(DVPT192, 43, 2);
+    do_test_decrypt_op(DVPT192, 45, 3);
+    do_test_decrypt_op(DVPT192, 49, 3);
+    do_test_decrypt_op(DVPT192, 56, 3);
+    do_test_decrypt_op(DVPT192, 57, 3);
+    do_test_decrypt_op(DVPT192, 58, 3);
+    do_test_decrypt_op(DVPT192, 60, 4);
+    do_test_decrypt_op(DVPT192, 64, 4);
+    do_test_decrypt_op(DVPT192, 71, 4);
+    do_test_decrypt_op(DVPT192, 72, 4);
+    do_test_decrypt_op(DVPT192, 73, 4);
+    do_test_decrypt_op(DVPT192, 75, 5);
+    do_test_decrypt_op(DVPT192, 79, 5);
+    do_test_decrypt_op(DVPT192, 86, 5);
+    do_test_decrypt_op(DVPT192, 87, 5);
+    do_test_decrypt_op(DVPT192, 88, 5);
+    do_test_decrypt_op(DVPT192, 90, 6);
+    do_test_decrypt_op(DVPT192, 94, 6);
+    do_test_decrypt_op(DVPT192, 101, 6);
+    do_test_decrypt_op(DVPT192, 102, 6);
+    do_test_decrypt_op(DVPT192, 103, 6);
+    do_test_decrypt_op(DVPT192, 105, 7);
+    do_test_decrypt_op(DVPT192, 109, 7);
+    do_test_decrypt_op(DVPT192, 116, 7);
+    do_test_decrypt_op(DVPT192, 117, 7);
+    do_test_decrypt_op(DVPT192, 118, 7);
+    do_test_decrypt_op(DVPT192, 120, 8);
+    do_test_decrypt_op(DVPT192, 124, 8);
+    do_test_decrypt_op(DVPT192, 131, 8);
+    do_test_decrypt_op(DVPT192, 132, 8);
+    do_test_decrypt_op(DVPT192, 133, 8);
+    do_test_decrypt_op(DVPT192, 135, 9);
+    do_test_decrypt_op(DVPT192, 139, 9);
+    do_test_decrypt_op(DVPT192, 146, 9);
+    do_test_decrypt_op(DVPT192, 147, 9);
+    do_test_decrypt_op(DVPT192, 148, 9);
+    do_test_decrypt_op(DVPT192, 150, 10);
+    do_test_decrypt_op(DVPT192, 154, 10);
+    do_test_decrypt_op(DVPT192, 161, 10);
+    do_test_decrypt_op(DVPT192, 162, 10);
+    do_test_decrypt_op(DVPT192, 163, 10);
+    do_test_decrypt_op(DVPT192, 165, 11);
+    do_test_decrypt_op(DVPT192, 169, 11);
+    do_test_decrypt_op(DVPT192, 176, 11);
+    do_test_decrypt_op(DVPT192, 177, 11);
+    do_test_decrypt_op(DVPT192, 178, 11);
+    do_test_decrypt_op(DVPT192, 180, 12);
+    do_test_decrypt_op(DVPT192, 184, 12);
+    do_test_decrypt_op(DVPT192, 191, 12);
+    do_test_decrypt_op(DVPT192, 192, 12);
+    do_test_decrypt_op(DVPT192, 193, 12);
+    do_test_decrypt_op(DVPT192, 195, 13);
+    do_test_decrypt_op(DVPT192, 199, 13);
+    do_test_decrypt_op(DVPT192, 206, 13);
+    do_test_decrypt_op(DVPT192, 207, 13);
+    do_test_decrypt_op(DVPT192, 208, 13);
+    do_test_decrypt_op(DVPT192, 210, 14);
+    do_test_decrypt_op(DVPT192, 214, 14);
+    do_test_decrypt_op(DVPT192, 221, 14);
+    do_test_decrypt_op(DVPT192, 222, 14);
+    do_test_decrypt_op(DVPT192, 223, 14);
+    do_test_decrypt_op(DVPT192, 225, 15);
+    do_test_decrypt_op(DVPT192, 229, 15);
+    do_test_decrypt_op(DVPT192, 236, 15);
+    do_test_decrypt_op(DVPT192, 237, 15);
+    do_test_decrypt_op(DVPT192, 238, 15);
+}
+static void test_crypto_modes_ccm_encrypt(void)
+{
+    do_test_encrypt_op(DVPT192, 0, 0);
+    do_test_encrypt_op(DVPT192, 4, 0);
+    do_test_encrypt_op(DVPT192, 11, 0);
+    do_test_encrypt_op(DVPT192, 12, 0);
+    do_test_encrypt_op(DVPT192, 13, 0);
+    do_test_encrypt_op(DVPT192, 15, 1);
+    do_test_encrypt_op(DVPT192, 19, 1);
+    do_test_encrypt_op(DVPT192, 26, 1);
+    do_test_encrypt_op(DVPT192, 27, 1);
+    do_test_encrypt_op(DVPT192, 28, 1);
+    do_test_encrypt_op(DVPT192, 30, 2);
+    do_test_encrypt_op(DVPT192, 34, 2);
+    do_test_encrypt_op(DVPT192, 41, 2);
+    do_test_encrypt_op(DVPT192, 42, 2);
+    do_test_encrypt_op(DVPT192, 43, 2);
+    do_test_encrypt_op(DVPT192, 45, 3);
+    do_test_encrypt_op(DVPT192, 49, 3);
+    do_test_encrypt_op(DVPT192, 56, 3);
+    do_test_encrypt_op(DVPT192, 57, 3);
+    do_test_encrypt_op(DVPT192, 58, 3);
+    do_test_encrypt_op(DVPT192, 60, 4);
+    do_test_encrypt_op(DVPT192, 64, 4);
+    do_test_encrypt_op(DVPT192, 71, 4);
+    do_test_encrypt_op(DVPT192, 72, 4);
+    do_test_encrypt_op(DVPT192, 73, 4);
+    do_test_encrypt_op(DVPT192, 75, 5);
+    do_test_encrypt_op(DVPT192, 79, 5);
+    do_test_encrypt_op(DVPT192, 86, 5);
+    do_test_encrypt_op(DVPT192, 87, 5);
+    do_test_encrypt_op(DVPT192, 88, 5);
+    do_test_encrypt_op(DVPT192, 90, 6);
+    do_test_encrypt_op(DVPT192, 94, 6);
+    do_test_encrypt_op(DVPT192, 101, 6);
+    do_test_encrypt_op(DVPT192, 102, 6);
+    do_test_encrypt_op(DVPT192, 103, 6);
+    do_test_encrypt_op(DVPT192, 105, 7);
+    do_test_encrypt_op(DVPT192, 109, 7);
+    do_test_encrypt_op(DVPT192, 116, 7);
+    do_test_encrypt_op(DVPT192, 117, 7);
+    do_test_encrypt_op(DVPT192, 118, 7);
+    do_test_encrypt_op(DVPT192, 120, 8);
+    do_test_encrypt_op(DVPT192, 124, 8);
+    do_test_encrypt_op(DVPT192, 131, 8);
+    do_test_encrypt_op(DVPT192, 132, 8);
+    do_test_encrypt_op(DVPT192, 133, 8);
+    do_test_encrypt_op(DVPT192, 135, 9);
+    do_test_encrypt_op(DVPT192, 139, 9);
+    do_test_encrypt_op(DVPT192, 146, 9);
+    do_test_encrypt_op(DVPT192, 147, 9);
+    do_test_encrypt_op(DVPT192, 148, 9);
+    do_test_encrypt_op(DVPT192, 150, 10);
+    do_test_encrypt_op(DVPT192, 154, 10);
+    do_test_encrypt_op(DVPT192, 161, 10);
+    do_test_encrypt_op(DVPT192, 162, 10);
+    do_test_encrypt_op(DVPT192, 163, 10);
+    do_test_encrypt_op(DVPT192, 165, 11);
+    do_test_encrypt_op(DVPT192, 169, 11);
+    do_test_encrypt_op(DVPT192, 176, 11);
+    do_test_encrypt_op(DVPT192, 177, 11);
+    do_test_encrypt_op(DVPT192, 178, 11);
+    do_test_encrypt_op(DVPT192, 180, 12);
+    do_test_encrypt_op(DVPT192, 184, 12);
+    do_test_encrypt_op(DVPT192, 191, 12);
+    do_test_encrypt_op(DVPT192, 192, 12);
+    do_test_encrypt_op(DVPT192, 193, 12);
+    do_test_encrypt_op(DVPT192, 195, 13);
+    do_test_encrypt_op(DVPT192, 199, 13);
+    do_test_encrypt_op(DVPT192, 206, 13);
+    do_test_encrypt_op(DVPT192, 207, 13);
+    do_test_encrypt_op(DVPT192, 208, 13);
+    do_test_encrypt_op(DVPT192, 210, 14);
+    do_test_encrypt_op(DVPT192, 214, 14);
+    do_test_encrypt_op(DVPT192, 221, 14);
+    do_test_encrypt_op(DVPT192, 222, 14);
+    do_test_encrypt_op(DVPT192, 223, 14);
+    do_test_encrypt_op(DVPT192, 225, 15);
+    do_test_encrypt_op(DVPT192, 229, 15);
+    do_test_encrypt_op(DVPT192, 236, 15);
+    do_test_encrypt_op(DVPT192, 237, 15);
+    do_test_encrypt_op(DVPT192, 238, 15);
+}
+
+Test *tests_crypto_modes_ccm_tests_192(void)
+{
+    EMB_UNIT_TESTFIXTURES(fixtures) {
+        new_TestFixture(test_crypto_modes_ccm_encrypt),
+        new_TestFixture(test_crypto_modes_ccm_decrypt),
+    };
+
+    EMB_UNIT_TESTCALLER(crypto_modes_ccm_tests_192, NULL, NULL, fixtures);
+
+    return (Test *)&crypto_modes_ccm_tests_192;
+}
diff --git a/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-256.c b/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-256.c
new file mode 100644
index 0000000000..9174442a35
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/tests-crypto-modes-ccm-256.c
@@ -0,0 +1,2470 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+#include <limits.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "embUnit.h"
+#include "crypto/ciphers.h"
+#include "crypto/modes/ccm.h"
+#include "tests-crypto.h"
+
+/**
+ * AES CCM DVTP test vectors (SP 800-38C) for 256 bit keys.
+ * https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program/cavp-testing-block-cipher-modes
+ */
+
+static const size_t nonce_and_len_encoding_size = 15;
+
+/* Alen = 0, Plen = 0, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_0_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_0_KEY[] = {
+    0xed, 0xa3, 0x2f, 0x75, 0x14, 0x56, 0xe3, 0x31,
+    0x95, 0xf1, 0xf4, 0x99, 0xcf, 0x2d, 0xc7, 0xc9,
+    0x7e, 0xa1, 0x27, 0xb6, 0xd4, 0x88, 0xf2, 0x11,
+    0xcc, 0xc5, 0x12, 0x6f, 0xbb, 0x24, 0xaf, 0xa6,
+};
+static const size_t TEST_DVPT256_GROUP_0_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_0_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_0_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_0_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_0_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_0_EXPECTED[] = {
+    0x46, 0x9c, 0x90, 0xbb,
+};
+static const size_t TEST_DVPT256_0_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_0_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_0_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_4_NONCE[] = {
+    0xdb, 0xb3, 0x92, 0x31, 0x56, 0xcf, 0xd6,
+};
+static const size_t TEST_DVPT256_4_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_4_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_4_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_4_EXPECTED[] = {
+    0x13, 0x02, 0xd5, 0x15,
+};
+static const size_t TEST_DVPT256_4_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_4_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_4_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_6_NONCE[] = {
+    0xa2, 0x59, 0xc1, 0x14, 0xea, 0xac, 0x89,
+};
+static const size_t TEST_DVPT256_6_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_6_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_6_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_6_EXPECTED[] = {
+    0x4f, 0xe0, 0x6e, 0x92,
+};
+static const size_t TEST_DVPT256_6_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_6_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_6_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_11_NONCE[] = {
+    0xe1, 0xbe, 0x89, 0xaf, 0x98, 0xff, 0xd7,
+};
+static const size_t TEST_DVPT256_11_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_11_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_11_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_11_EXPECTED[] = {
+    0xe5, 0x41, 0x7f, 0x6b,
+};
+static const size_t TEST_DVPT256_11_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_11_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_11_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_13_NONCE[] = {
+    0x1a, 0xa7, 0x58, 0xeb, 0x2f, 0x9a, 0x28,
+};
+static const size_t TEST_DVPT256_13_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_13_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_13_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_13_EXPECTED[] = {
+    0xf8, 0xfa, 0x8e, 0x71,
+};
+static const size_t TEST_DVPT256_13_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_13_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_13_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_1_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_1_KEY[] = {
+    0xe1, 0xb8, 0xa9, 0x27, 0xa9, 0x5e, 0xfe, 0x94,
+    0x65, 0x66, 0x77, 0xb6, 0x92, 0x66, 0x20, 0x00,
+    0x27, 0x8b, 0x44, 0x1c, 0x79, 0xe8, 0x79, 0xdd,
+    0x5c, 0x0d, 0xdc, 0x75, 0x8b, 0xdc, 0x9e, 0xe8,
+};
+static const size_t TEST_DVPT256_GROUP_1_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_15_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_15_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_15_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_15_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_15_EXPECTED[] = {
+    0x82, 0x07, 0xeb, 0x14, 0xd3, 0x38, 0x55, 0xa5,
+    0x2a, 0xcc, 0xee, 0xd1, 0x7d, 0xbc, 0xbf, 0x6e,
+};
+static const size_t TEST_DVPT256_15_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_15_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_15_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_19_NONCE[] = {
+    0xdb, 0xb3, 0x92, 0x31, 0x56, 0xcf, 0xd6,
+};
+static const size_t TEST_DVPT256_19_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_19_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_19_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_19_EXPECTED[] = {
+    0xe4, 0xdc, 0x5e, 0x03, 0xaa, 0xce, 0xa6, 0x91,
+    0x26, 0x2e, 0xe6, 0x9c, 0xee, 0x8f, 0xfb, 0xbe,
+};
+static const size_t TEST_DVPT256_19_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_19_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_19_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_21_NONCE[] = {
+    0xa2, 0x59, 0xc1, 0x14, 0xea, 0xac, 0x89,
+};
+static const size_t TEST_DVPT256_21_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_21_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_21_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_21_EXPECTED[] = {
+    0xf7, 0x9c, 0x53, 0xfd, 0x5e, 0x69, 0x83, 0x5b,
+    0x7e, 0x70, 0x49, 0x6e, 0xa9, 0x99, 0x71, 0x8b,
+};
+static const size_t TEST_DVPT256_21_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_21_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_21_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_26_NONCE[] = {
+    0xe1, 0xbe, 0x89, 0xaf, 0x98, 0xff, 0xd7,
+};
+static const size_t TEST_DVPT256_26_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_26_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_26_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_26_EXPECTED[] = {
+    0x10, 0xd3, 0xf6, 0xfe, 0x08, 0x28, 0x0d, 0x45,
+    0xe6, 0x7e, 0x58, 0xfe, 0x41, 0xa7, 0xf0, 0x36,
+};
+static const size_t TEST_DVPT256_26_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_26_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_26_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_28_NONCE[] = {
+    0x1a, 0xa7, 0x58, 0xeb, 0x2f, 0x9a, 0x28,
+};
+static const size_t TEST_DVPT256_28_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_28_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_28_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_28_EXPECTED[] = {
+    0x25, 0x90, 0xdf, 0x24, 0x53, 0xcb, 0x94, 0xc3,
+    0x04, 0xba, 0x0a, 0x2b, 0xff, 0x3f, 0x3c, 0x71,
+};
+static const size_t TEST_DVPT256_28_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_28_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_28_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_2_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_2_KEY[] = {
+    0xe1, 0xb8, 0xa9, 0x27, 0xa9, 0x5e, 0xfe, 0x94,
+    0x65, 0x66, 0x77, 0xb6, 0x92, 0x66, 0x20, 0x00,
+    0x27, 0x8b, 0x44, 0x1c, 0x79, 0xe8, 0x79, 0xdd,
+    0x5c, 0x0d, 0xdc, 0x75, 0x8b, 0xdc, 0x9e, 0xe8,
+};
+static const size_t TEST_DVPT256_GROUP_2_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_30_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_30_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_30_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_30_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_30_EXPECTED[] = {
+    0x8a, 0x19, 0xa1, 0x33,
+};
+static const size_t TEST_DVPT256_30_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_30_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_30_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_34_NONCE[] = {
+    0x79, 0xac, 0x20, 0x4a, 0x26, 0xb9, 0xfe, 0xe1,
+    0x13, 0x23, 0x70, 0xc2, 0x0f,
+};
+static const size_t TEST_DVPT256_34_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_34_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_34_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_34_EXPECTED[] = {
+    0x15, 0x40, 0x24, 0xb2,
+};
+static const size_t TEST_DVPT256_34_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_34_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_34_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_36_NONCE[] = {
+    0x05, 0x45, 0xfd, 0x9e, 0xcb, 0xc7, 0x3c, 0xcd,
+    0xbb, 0xbd, 0x42, 0x44, 0xfd,
+};
+static const size_t TEST_DVPT256_36_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_36_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_36_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_36_EXPECTED[] = {
+    0x5c, 0x34, 0x9f, 0xb2,
+};
+static const size_t TEST_DVPT256_36_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_36_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_36_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_41_NONCE[] = {
+    0x0a, 0x37, 0xf2, 0xe7, 0xc6, 0x64, 0x90, 0xe9,
+    0x72, 0x85, 0xf1, 0xb0, 0x9e,
+};
+static const size_t TEST_DVPT256_41_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_41_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_41_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_41_EXPECTED[] = {
+    0xc5, 0x9b, 0xf1, 0x4c,
+};
+static const size_t TEST_DVPT256_41_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_41_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_41_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_43_NONCE[] = {
+    0xc1, 0xad, 0x81, 0x2b, 0xf2, 0xbb, 0xb2, 0xcd,
+    0xae, 0xe4, 0x63, 0x6e, 0xe7,
+};
+static const size_t TEST_DVPT256_43_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_43_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_43_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_43_EXPECTED[] = {
+    0x5b, 0x96, 0xf4, 0x1d,
+};
+static const size_t TEST_DVPT256_43_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_43_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_43_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 0, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_3_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_3_KEY[] = {
+    0xaf, 0x06, 0x36, 0x39, 0xe6, 0x6c, 0x28, 0x40,
+    0x83, 0xc5, 0xcf, 0x72, 0xb7, 0x0d, 0x8b, 0xc2,
+    0x77, 0xf5, 0x97, 0x8e, 0x80, 0xd9, 0x32, 0x2d,
+    0x99, 0xf2, 0xfd, 0xc7, 0x18, 0xcd, 0xa5, 0x69,
+};
+static const size_t TEST_DVPT256_GROUP_3_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_45_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_45_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_45_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_45_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_45_EXPECTED[] = {
+    0x97, 0xe1, 0xa8, 0xdd, 0x42, 0x59, 0xcc, 0xd2,
+    0xe4, 0x31, 0xe0, 0x57, 0xb0, 0x39, 0x7f, 0xcf,
+};
+static const size_t TEST_DVPT256_45_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_45_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_45_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_49_NONCE[] = {
+    0x79, 0xac, 0x20, 0x4a, 0x26, 0xb9, 0xfe, 0xe1,
+    0x13, 0x23, 0x70, 0xc2, 0x0f,
+};
+static const size_t TEST_DVPT256_49_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_49_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_49_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_49_EXPECTED[] = {
+    0x5c, 0x8c, 0x9a, 0x5b, 0x97, 0xbe, 0x8c, 0x7b,
+    0xc0, 0x1c, 0xa8, 0xd6, 0x93, 0xb8, 0x09, 0xf9,
+};
+static const size_t TEST_DVPT256_49_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_49_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_49_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_51_NONCE[] = {
+    0x05, 0x45, 0xfd, 0x9e, 0xcb, 0xc7, 0x3c, 0xcd,
+    0xbb, 0xbd, 0x42, 0x44, 0xfd,
+};
+static const size_t TEST_DVPT256_51_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_51_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_51_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_51_EXPECTED[] = {
+    0x84, 0x20, 0x16, 0x62, 0xb2, 0x13, 0xc7, 0xa1,
+    0xff, 0x0c, 0x1b, 0x3c, 0x25, 0xe4, 0xec, 0x45,
+};
+static const size_t TEST_DVPT256_51_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_51_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_51_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_56_NONCE[] = {
+    0x0a, 0x37, 0xf2, 0xe7, 0xc6, 0x64, 0x90, 0xe9,
+    0x72, 0x85, 0xf1, 0xb0, 0x9e,
+};
+static const size_t TEST_DVPT256_56_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_56_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_56_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_56_EXPECTED[] = {
+    0x58, 0x6e, 0x72, 0x81, 0x93, 0xce, 0x6d, 0xb9,
+    0xa9, 0x26, 0xb0, 0x3b, 0x2d, 0x77, 0xdd, 0x6e,
+};
+static const size_t TEST_DVPT256_56_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_56_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_56_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_58_NONCE[] = {
+    0xc1, 0xad, 0x81, 0x2b, 0xf2, 0xbb, 0xb2, 0xcd,
+    0xae, 0xe4, 0x63, 0x6e, 0xe7,
+};
+static const size_t TEST_DVPT256_58_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_58_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_58_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_58_EXPECTED[] = {
+    0x64, 0x86, 0x4d, 0x21, 0xb6, 0xee, 0x3f, 0xca,
+    0x13, 0xf0, 0x7f, 0xc0, 0x48, 0x6e, 0x23, 0x2d,
+};
+static const size_t TEST_DVPT256_58_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_58_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_58_INPUT_LEN = 0;
+
+/* Alen = 0, Plen = 24, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_4_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_4_KEY[] = {
+    0xaf, 0x06, 0x36, 0x39, 0xe6, 0x6c, 0x28, 0x40,
+    0x83, 0xc5, 0xcf, 0x72, 0xb7, 0x0d, 0x8b, 0xc2,
+    0x77, 0xf5, 0x97, 0x8e, 0x80, 0xd9, 0x32, 0x2d,
+    0x99, 0xf2, 0xfd, 0xc7, 0x18, 0xcd, 0xa5, 0x69,
+};
+static const size_t TEST_DVPT256_GROUP_4_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_60_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_60_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_60_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_60_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_60_EXPECTED[] = {
+    0x64, 0xa1, 0x34, 0x16, 0x79, 0x97, 0x2d, 0xc5,
+    0x86, 0x9f, 0xcf, 0x69, 0xb1, 0x9d, 0x5c, 0x5e,
+    0xa5, 0x0a, 0xa0, 0xb5, 0xe9, 0x85, 0xf5, 0xb7,
+    0x22, 0xaa, 0x8d, 0x59,
+};
+static const size_t TEST_DVPT256_60_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_60_INPUT[] = {
+    0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
+    0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
+    0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
+};
+static const size_t TEST_DVPT256_60_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_64_NONCE[] = {
+    0x9d, 0x77, 0x3a, 0x31, 0xfe, 0x2e, 0xc7,
+};
+static const size_t TEST_DVPT256_64_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_64_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_64_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_64_EXPECTED[] = {
+    0x5a, 0xcf, 0xbe, 0x5e, 0x48, 0x89, 0x76, 0xd8,
+    0xb9, 0xb7, 0x7e, 0x69, 0xa7, 0x36, 0xe8, 0xc9,
+    0x19, 0x05, 0x3f, 0x94, 0x15, 0x55, 0x12, 0x09,
+    0xdc, 0xe2, 0xd2, 0x5e,
+};
+static const size_t TEST_DVPT256_64_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_64_INPUT[] = {
+    0x83, 0x9d, 0x8c, 0xfa, 0x2c, 0x92, 0x1c, 0x3c,
+    0xce, 0xb7, 0xd1, 0xf4, 0x6b, 0xd2, 0xea, 0xad,
+    0x70, 0x6e, 0x53, 0xf6, 0x45, 0x23, 0xd8, 0xc0,
+};
+static const size_t TEST_DVPT256_64_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_66_NONCE[] = {
+    0x24, 0xb7, 0xa6, 0x53, 0x91, 0xf8, 0x8b,
+};
+static const size_t TEST_DVPT256_66_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_66_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_66_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_66_EXPECTED[] = {
+    0xf0, 0x06, 0x28, 0xe1, 0x0e, 0x8e, 0x01, 0x15,
+    0xb4, 0xa4, 0x53, 0x2a, 0x12, 0x12, 0xa2, 0x3a,
+    0xad, 0xe4, 0x09, 0x08, 0x32, 0xc1, 0x97, 0x2d,
+    0x75, 0x01, 0x25, 0xf3,
+};
+static const size_t TEST_DVPT256_66_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_66_INPUT[] = {
+    0x3b, 0xed, 0x52, 0x23, 0x61, 0x82, 0xc1, 0x94,
+    0x18, 0x86, 0x7d, 0x46, 0x8d, 0xbf, 0x47, 0xc8,
+    0xaa, 0xc4, 0x6c, 0x02, 0x44, 0x5f, 0x99, 0xbb,
+};
+static const size_t TEST_DVPT256_66_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_71_NONCE[] = {
+    0xb6, 0x72, 0xc9, 0x13, 0x76, 0xf5, 0x33,
+};
+static const size_t TEST_DVPT256_71_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_71_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_71_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_71_EXPECTED[] = {
+    0x75, 0x8a, 0xa0, 0x3d, 0xc7, 0x2c, 0x36, 0x2c,
+    0x43, 0xb5, 0xf8, 0x5b, 0xfa, 0xa3, 0xdb, 0x4a,
+    0x74, 0x86, 0x08, 0x87, 0xa8, 0xc2, 0x9e, 0x47,
+    0xd5, 0x64, 0x28, 0x30,
+};
+static const size_t TEST_DVPT256_71_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_71_INPUT[] = {
+    0x4f, 0x7a, 0x56, 0x1e, 0x61, 0xb7, 0x86, 0x17,
+    0x19, 0xe4, 0x44, 0x50, 0x57, 0xac, 0x9b, 0x74,
+    0xa9, 0xbe, 0x95, 0x3b, 0x77, 0x2b, 0x09, 0xec,
+};
+static const size_t TEST_DVPT256_71_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_73_NONCE[] = {
+    0xa6, 0xd0, 0x1f, 0xb8, 0x8c, 0xa5, 0x47,
+};
+static const size_t TEST_DVPT256_73_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_73_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_73_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_73_EXPECTED[] = {
+    0x61, 0x5c, 0xbe, 0xab, 0xbe, 0x16, 0x3b, 0xa8,
+    0xbc, 0x9c, 0x07, 0x3d, 0xf9, 0xad, 0x40, 0x83,
+    0x3f, 0xcf, 0x3f, 0x42, 0x46, 0x44, 0xcc, 0xc3,
+    0x7a, 0xa9, 0x99, 0xd7,
+};
+static const size_t TEST_DVPT256_73_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_73_INPUT[] = {
+    0xa3, 0x61, 0x55, 0xde, 0x47, 0x73, 0x64, 0x23,
+    0x65, 0x91, 0xe4, 0x53, 0x00, 0x81, 0x14, 0x07,
+    0x5b, 0x48, 0x72, 0x12, 0x0e, 0xf1, 0x72, 0x64,
+};
+static const size_t TEST_DVPT256_73_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_5_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_5_KEY[] = {
+    0xf7, 0x07, 0x9d, 0xfa, 0x3b, 0x5c, 0x7b, 0x05,
+    0x63, 0x47, 0xd7, 0xe4, 0x37, 0xbc, 0xde, 0xd6,
+    0x83, 0xab, 0xd6, 0xe2, 0xc9, 0xe0, 0x69, 0xd3,
+    0x33, 0x28, 0x40, 0x82, 0xcb, 0xb5, 0xd4, 0x53,
+};
+static const size_t TEST_DVPT256_GROUP_5_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_75_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_75_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_75_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_75_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_75_EXPECTED[] = {
+    0xbc, 0x51, 0xc3, 0x92, 0x5a, 0x96, 0x0e, 0x77,
+    0x32, 0x53, 0x3e, 0x4e, 0xf3, 0xa4, 0xf6, 0x9e,
+    0xe6, 0x82, 0x6d, 0xe9, 0x52, 0xbc, 0xb0, 0xfd,
+    0x37, 0x4f, 0x3b, 0xb6, 0xdb, 0x83, 0x77, 0xeb,
+    0xfc, 0x79, 0x67, 0x48, 0x58, 0xc4, 0xf3, 0x05,
+};
+static const size_t TEST_DVPT256_75_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_75_INPUT[] = {
+    0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
+    0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
+    0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
+};
+static const size_t TEST_DVPT256_75_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_79_NONCE[] = {
+    0x9d, 0x77, 0x3a, 0x31, 0xfe, 0x2e, 0xc7,
+};
+static const size_t TEST_DVPT256_79_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_79_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_79_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_79_EXPECTED[] = {
+    0x45, 0x39, 0xbb, 0x13, 0x38, 0x2b, 0x03, 0x4d,
+    0xdb, 0x16, 0xa3, 0x32, 0x91, 0x48, 0xf9, 0x24,
+    0x3a, 0x4e, 0xee, 0x99, 0x8f, 0xe4, 0x44, 0xaf,
+    0xf2, 0x87, 0x0c, 0xe1, 0x98, 0xaf, 0x11, 0xf4,
+    0xfb, 0x69, 0x8a, 0x67, 0xaf, 0x6c, 0x89, 0xad,
+};
+static const size_t TEST_DVPT256_79_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_79_INPUT[] = {
+    0x83, 0x9d, 0x8c, 0xfa, 0x2c, 0x92, 0x1c, 0x3c,
+    0xce, 0xb7, 0xd1, 0xf4, 0x6b, 0xd2, 0xea, 0xad,
+    0x70, 0x6e, 0x53, 0xf6, 0x45, 0x23, 0xd8, 0xc0,
+};
+static const size_t TEST_DVPT256_79_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_81_NONCE[] = {
+    0x24, 0xb7, 0xa6, 0x53, 0x91, 0xf8, 0x8b,
+};
+static const size_t TEST_DVPT256_81_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_81_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_81_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_81_EXPECTED[] = {
+    0x6d, 0x0f, 0x92, 0x83, 0x52, 0xa1, 0x7d, 0x63,
+    0xac, 0xa1, 0x89, 0x9c, 0xbd, 0x30, 0x5e, 0x1f,
+    0x83, 0x1f, 0x16, 0x38, 0xd2, 0x7c, 0x1e, 0x24,
+    0x43, 0x27, 0x04, 0xef, 0xf9, 0xb6, 0x83, 0x04,
+    0x76, 0xdb, 0x3d, 0x30, 0xd4, 0xc1, 0x03, 0xe4,
+};
+static const size_t TEST_DVPT256_81_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_81_INPUT[] = {
+    0x3b, 0xed, 0x52, 0x23, 0x61, 0x82, 0xc1, 0x94,
+    0x18, 0x86, 0x7d, 0x46, 0x8d, 0xbf, 0x47, 0xc8,
+    0xaa, 0xc4, 0x6c, 0x02, 0x44, 0x5f, 0x99, 0xbb,
+};
+static const size_t TEST_DVPT256_81_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_86_NONCE[] = {
+    0xb6, 0x72, 0xc9, 0x13, 0x76, 0xf5, 0x33,
+};
+static const size_t TEST_DVPT256_86_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_86_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_86_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_86_EXPECTED[] = {
+    0xf2, 0x3a, 0xc1, 0x42, 0x6c, 0xb1, 0x13, 0x0c,
+    0x9a, 0x09, 0x13, 0xb3, 0x47, 0xd8, 0xef, 0xaf,
+    0xb6, 0xed, 0x12, 0x59, 0x13, 0xaa, 0x67, 0x8a,
+    0x9d, 0xc4, 0x2d, 0x22, 0xa5, 0x43, 0x6b, 0xc1,
+    0x2e, 0xff, 0x55, 0x05, 0xed, 0xb2, 0x5e, 0x19,
+};
+static const size_t TEST_DVPT256_86_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_86_INPUT[] = {
+    0x4f, 0x7a, 0x56, 0x1e, 0x61, 0xb7, 0x86, 0x17,
+    0x19, 0xe4, 0x44, 0x50, 0x57, 0xac, 0x9b, 0x74,
+    0xa9, 0xbe, 0x95, 0x3b, 0x77, 0x2b, 0x09, 0xec,
+};
+static const size_t TEST_DVPT256_86_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_88_NONCE[] = {
+    0xa6, 0xd0, 0x1f, 0xb8, 0x8c, 0xa5, 0x47,
+};
+static const size_t TEST_DVPT256_88_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_88_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_88_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_88_EXPECTED[] = {
+    0x77, 0x3b, 0x8e, 0xea, 0x2e, 0x98, 0x30, 0x29,
+    0x7a, 0xc1, 0x1d, 0x3c, 0x1f, 0x6e, 0xa4, 0x00,
+    0x8c, 0x96, 0x04, 0x0e, 0x83, 0xd7, 0x6d, 0x55,
+    0x78, 0x9d, 0x20, 0x43, 0x17, 0x9f, 0xdd, 0x8f,
+    0xdc, 0xbd, 0x52, 0x31, 0x3b, 0x7b, 0x15, 0xcb,
+};
+static const size_t TEST_DVPT256_88_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_88_INPUT[] = {
+    0xa3, 0x61, 0x55, 0xde, 0x47, 0x73, 0x64, 0x23,
+    0x65, 0x91, 0xe4, 0x53, 0x00, 0x81, 0x14, 0x07,
+    0x5b, 0x48, 0x72, 0x12, 0x0e, 0xf1, 0x72, 0x64,
+};
+static const size_t TEST_DVPT256_88_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_6_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_6_KEY[] = {
+    0xf7, 0x07, 0x9d, 0xfa, 0x3b, 0x5c, 0x7b, 0x05,
+    0x63, 0x47, 0xd7, 0xe4, 0x37, 0xbc, 0xde, 0xd6,
+    0x83, 0xab, 0xd6, 0xe2, 0xc9, 0xe0, 0x69, 0xd3,
+    0x33, 0x28, 0x40, 0x82, 0xcb, 0xb5, 0xd4, 0x53,
+};
+static const size_t TEST_DVPT256_GROUP_6_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_90_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_90_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_90_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_90_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_90_EXPECTED[] = {
+    0x63, 0xe0, 0x0d, 0x30, 0xe4, 0xb0, 0x8f, 0xd2,
+    0xa1, 0xcc, 0x8d, 0x70, 0xfa, 0xb3, 0x27, 0xb2,
+    0x36, 0x8e, 0x77, 0xa9, 0x3b, 0xe4, 0xf4, 0x12,
+    0x3d, 0x14, 0xfb, 0x3f,
+};
+static const size_t TEST_DVPT256_90_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_90_INPUT[] = {
+    0x3c, 0x0e, 0x28, 0x15, 0xd3, 0x7d, 0x84, 0x4f,
+    0x7a, 0xc2, 0x40, 0xba, 0x9d, 0x6e, 0x3a, 0x0b,
+    0x2a, 0x86, 0xf7, 0x06, 0xe8, 0x85, 0x95, 0x9e,
+};
+static const size_t TEST_DVPT256_90_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_94_NONCE[] = {
+    0x15, 0x01, 0xa2, 0x43, 0xbf, 0x60, 0xb2, 0xcb,
+    0x40, 0xd5, 0xaa, 0x20, 0xca,
+};
+static const size_t TEST_DVPT256_94_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_94_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_94_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_94_EXPECTED[] = {
+    0x37, 0x7b, 0x2f, 0x1e, 0x7b, 0xd9, 0xe3, 0xd1,
+    0x07, 0x70, 0x38, 0xe0, 0x84, 0xf6, 0x19, 0x50,
+    0x76, 0x13, 0x61, 0x09, 0x5f, 0x7e, 0xee, 0xbb,
+    0xf1, 0xa7, 0x2a, 0xfc,
+};
+static const size_t TEST_DVPT256_94_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_94_INPUT[] = {
+    0xf5, 0x73, 0x0a, 0x05, 0xfe, 0xc3, 0x1a, 0x11,
+    0x66, 0x2e, 0x2e, 0x14, 0xe3, 0x62, 0xcc, 0xc7,
+    0x5c, 0x7c, 0x30, 0xcd, 0xfc, 0xcb, 0xf9, 0x94,
+};
+static const size_t TEST_DVPT256_94_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_96_NONCE[] = {
+    0xd6, 0x5e, 0x0e, 0x53, 0xf7, 0x65, 0xf9, 0xd5,
+    0xe6, 0x79, 0x5c, 0x0c, 0x5e,
+};
+static const size_t TEST_DVPT256_96_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_96_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_96_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_96_EXPECTED[] = {
+    0x6c, 0xab, 0x30, 0x60, 0xbf, 0x3b, 0x33, 0xb1,
+    0x63, 0xb9, 0x33, 0xc2, 0xed, 0x0b, 0xa5, 0x14,
+    0x06, 0x81, 0x0b, 0x54, 0xd0, 0xed, 0xcf, 0x5c,
+    0x9d, 0x0e, 0xf4, 0xf7,
+};
+static const size_t TEST_DVPT256_96_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_96_INPUT[] = {
+    0x20, 0xe3, 0x94, 0xc7, 0xcc, 0x90, 0xbd, 0xfa,
+    0x61, 0x86, 0xfc, 0x1b, 0xa6, 0xff, 0xf1, 0x58,
+    0xdf, 0xc6, 0x90, 0xe2, 0x4b, 0xa4, 0xc9, 0xfb,
+};
+static const size_t TEST_DVPT256_96_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_101_NONCE[] = {
+    0xa6, 0xb2, 0x37, 0x1a, 0xcf, 0x83, 0x21, 0x86,
+    0x4c, 0x08, 0xdd, 0xb4, 0xd8,
+};
+static const size_t TEST_DVPT256_101_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_101_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_101_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_101_EXPECTED[] = {
+    0xc5, 0xaa, 0x50, 0x0d, 0x1f, 0x7c, 0x09, 0xa5,
+    0x90, 0xe9, 0xd1, 0x5d, 0x68, 0x60, 0xc4, 0x43,
+    0x36, 0x84, 0xe0, 0x4d, 0xd6, 0xbc, 0x5c, 0x8f,
+    0x94, 0xf2, 0x23, 0xf0,
+};
+static const size_t TEST_DVPT256_101_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_101_INPUT[] = {
+    0x1a, 0x43, 0xca, 0x62, 0x80, 0x26, 0x21, 0x9c,
+    0x5a, 0x43, 0x0c, 0x54, 0x02, 0x1a, 0x5a, 0x31,
+    0x52, 0xae, 0x51, 0x71, 0x67, 0x39, 0x96, 0x35,
+};
+static const size_t TEST_DVPT256_101_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_103_NONCE[] = {
+    0xc2, 0xb6, 0x0f, 0x14, 0xc8, 0x94, 0xec, 0x61,
+    0x78, 0xfe, 0x79, 0x91, 0x9f,
+};
+static const size_t TEST_DVPT256_103_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_103_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_103_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_103_EXPECTED[] = {
+    0x85, 0x2c, 0xca, 0x90, 0x3d, 0x7f, 0xdf, 0x89,
+    0x98, 0x07, 0xbd, 0x14, 0x64, 0x20, 0x57, 0x53,
+    0x4c, 0x8a, 0x0c, 0xca, 0xcb, 0x8c, 0x7b, 0x8f,
+    0xb4, 0xd3, 0x5d, 0x44,
+};
+static const size_t TEST_DVPT256_103_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_103_INPUT[] = {
+    0x3e, 0x70, 0x7d, 0x98, 0xf1, 0x99, 0x72, 0xa6,
+    0x3d, 0x91, 0x3e, 0x6e, 0xa7, 0x53, 0x3a, 0xf2,
+    0xf4, 0x1f, 0xf9, 0x8a, 0xee, 0x2b, 0x2a, 0x36,
+};
+static const size_t TEST_DVPT256_103_INPUT_LEN = 24;
+
+/* Alen = 0, Plen = 24, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_7_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_7_KEY[] = {
+    0x1b, 0x0e, 0x8d, 0xf6, 0x3c, 0x57, 0xf0, 0x5d,
+    0x9a, 0xc4, 0x57, 0x57, 0x5e, 0xa7, 0x64, 0x52,
+    0x4b, 0x86, 0x10, 0xae, 0x51, 0x64, 0xe6, 0x21,
+    0x5f, 0x42, 0x6f, 0x5a, 0x7a, 0xe6, 0xed, 0xe4,
+};
+static const size_t TEST_DVPT256_GROUP_7_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_105_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_105_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_105_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_105_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_105_EXPECTED[] = {
+    0xf0, 0x05, 0x0a, 0xd1, 0x63, 0x92, 0x02, 0x1a,
+    0x3f, 0x40, 0x20, 0x7b, 0xed, 0x35, 0x21, 0xfb,
+    0x1e, 0x9f, 0x80, 0x8f, 0x49, 0x83, 0x0c, 0x42,
+    0x3a, 0x57, 0x8d, 0x17, 0x99, 0x02, 0xf9, 0x12,
+    0xf9, 0xea, 0x1a, 0xfb, 0xce, 0x11, 0x20, 0xb3,
+};
+static const size_t TEST_DVPT256_105_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_105_INPUT[] = {
+    0x3c, 0x0e, 0x28, 0x15, 0xd3, 0x7d, 0x84, 0x4f,
+    0x7a, 0xc2, 0x40, 0xba, 0x9d, 0x6e, 0x3a, 0x0b,
+    0x2a, 0x86, 0xf7, 0x06, 0xe8, 0x85, 0x95, 0x9e,
+};
+static const size_t TEST_DVPT256_105_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_109_NONCE[] = {
+    0x15, 0x01, 0xa2, 0x43, 0xbf, 0x60, 0xb2, 0xcb,
+    0x40, 0xd5, 0xaa, 0x20, 0xca,
+};
+static const size_t TEST_DVPT256_109_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_109_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_109_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_109_EXPECTED[] = {
+    0x25, 0x4b, 0x84, 0x7d, 0x41, 0x75, 0xbb, 0xb4,
+    0x4a, 0x82, 0xb4, 0xe8, 0x05, 0x51, 0x4f, 0xa4,
+    0x44, 0xc2, 0x24, 0x71, 0x09, 0x33, 0xf3, 0xec,
+    0x8a, 0xaa, 0x3f, 0x01, 0x33, 0x23, 0x4c, 0x0c,
+    0xd9, 0x16, 0x09, 0x98, 0x2a, 0xdc, 0x03, 0x4b,
+};
+static const size_t TEST_DVPT256_109_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_109_INPUT[] = {
+    0xf5, 0x73, 0x0a, 0x05, 0xfe, 0xc3, 0x1a, 0x11,
+    0x66, 0x2e, 0x2e, 0x14, 0xe3, 0x62, 0xcc, 0xc7,
+    0x5c, 0x7c, 0x30, 0xcd, 0xfc, 0xcb, 0xf9, 0x94,
+};
+static const size_t TEST_DVPT256_109_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_111_NONCE[] = {
+    0xd6, 0x5e, 0x0e, 0x53, 0xf7, 0x65, 0xf9, 0xd5,
+    0xe6, 0x79, 0x5c, 0x0c, 0x5e,
+};
+static const size_t TEST_DVPT256_111_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_111_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_111_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_111_EXPECTED[] = {
+    0xc3, 0x61, 0x8c, 0x99, 0x1b, 0x15, 0xde, 0x64,
+    0x1d, 0x29, 0x14, 0x19, 0xff, 0x69, 0x57, 0xe8,
+    0xb9, 0xae, 0x50, 0x46, 0xdd, 0x8c, 0x6f, 0x08,
+    0xfa, 0xfb, 0x76, 0xad, 0xf1, 0x2f, 0x36, 0x74,
+    0x03, 0x47, 0xe3, 0xed, 0xae, 0x62, 0xbc, 0xa4,
+};
+static const size_t TEST_DVPT256_111_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_111_INPUT[] = {
+    0x20, 0xe3, 0x94, 0xc7, 0xcc, 0x90, 0xbd, 0xfa,
+    0x61, 0x86, 0xfc, 0x1b, 0xa6, 0xff, 0xf1, 0x58,
+    0xdf, 0xc6, 0x90, 0xe2, 0x4b, 0xa4, 0xc9, 0xfb,
+};
+static const size_t TEST_DVPT256_111_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_116_NONCE[] = {
+    0xa6, 0xb2, 0x37, 0x1a, 0xcf, 0x83, 0x21, 0x86,
+    0x4c, 0x08, 0xdd, 0xb4, 0xd8,
+};
+static const size_t TEST_DVPT256_116_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_116_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_116_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_116_EXPECTED[] = {
+    0xbd, 0x37, 0x32, 0x6d, 0xa1, 0x8e, 0x5a, 0xc7,
+    0x9a, 0x1a, 0x95, 0x12, 0xf7, 0x24, 0xbb, 0x53,
+    0x95, 0x30, 0x86, 0x85, 0x76, 0xb7, 0x9c, 0x67,
+    0xac, 0xb5, 0xa5, 0x1d, 0x10, 0xa5, 0x8d, 0x65,
+    0x84, 0xfb, 0xe7, 0x3f, 0x10, 0x63, 0xc3, 0x1b,
+};
+static const size_t TEST_DVPT256_116_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_116_INPUT[] = {
+    0x1a, 0x43, 0xca, 0x62, 0x80, 0x26, 0x21, 0x9c,
+    0x5a, 0x43, 0x0c, 0x54, 0x02, 0x1a, 0x5a, 0x31,
+    0x52, 0xae, 0x51, 0x71, 0x67, 0x39, 0x96, 0x35,
+};
+static const size_t TEST_DVPT256_116_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_118_NONCE[] = {
+    0xc2, 0xb6, 0x0f, 0x14, 0xc8, 0x94, 0xec, 0x61,
+    0x78, 0xfe, 0x79, 0x91, 0x9f,
+};
+static const size_t TEST_DVPT256_118_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_118_ADATA[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_118_ADATA_LEN = 0;
+
+static const uint8_t TEST_DVPT256_118_EXPECTED[] = {
+    0xec, 0xd3, 0x37, 0x64, 0x00, 0x22, 0x63, 0x5c,
+    0xe1, 0xed, 0x27, 0x37, 0x56, 0xd0, 0x2b, 0x7f,
+    0xee, 0xb2, 0x51, 0x56, 0x14, 0xc1, 0xfa, 0xdc,
+    0x95, 0xc6, 0x6d, 0x3f, 0x41, 0x1b, 0x47, 0x88,
+    0x53, 0x88, 0x6a, 0xfd, 0x17, 0x7d, 0x88, 0xc3,
+};
+static const size_t TEST_DVPT256_118_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_118_INPUT[] = {
+    0x3e, 0x70, 0x7d, 0x98, 0xf1, 0x99, 0x72, 0xa6,
+    0x3d, 0x91, 0x3e, 0x6e, 0xa7, 0x53, 0x3a, 0xf2,
+    0xf4, 0x1f, 0xf9, 0x8a, 0xee, 0x2b, 0x2a, 0x36,
+};
+static const size_t TEST_DVPT256_118_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 0, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_8_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_8_KEY[] = {
+    0x1b, 0x0e, 0x8d, 0xf6, 0x3c, 0x57, 0xf0, 0x5d,
+    0x9a, 0xc4, 0x57, 0x57, 0x5e, 0xa7, 0x64, 0x52,
+    0x4b, 0x86, 0x10, 0xae, 0x51, 0x64, 0xe6, 0x21,
+    0x5f, 0x42, 0x6f, 0x5a, 0x7a, 0xe6, 0xed, 0xe4,
+};
+static const size_t TEST_DVPT256_GROUP_8_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_120_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_120_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_120_ADATA[] = {
+    0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
+    0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
+    0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
+    0x8d, 0x15, 0xb6, 0xd3, 0x6c, 0x03, 0x8e, 0xab,
+};
+static const size_t TEST_DVPT256_120_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_120_EXPECTED[] = {
+    0x92, 0xd0, 0x0f, 0xbe,
+};
+static const size_t TEST_DVPT256_120_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_120_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_120_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_124_NONCE[] = {
+    0x3f, 0xcb, 0x32, 0x8b, 0xc9, 0x64, 0x04,
+};
+static const size_t TEST_DVPT256_124_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_124_ADATA[] = {
+    0x10, 0xb2, 0xff, 0xed, 0x4f, 0x95, 0xaf, 0x0f,
+    0x98, 0xed, 0x4f, 0x77, 0xc6, 0x77, 0xb5, 0x78,
+    0x6a, 0xd0, 0x1b, 0x31, 0xc0, 0x95, 0xbb, 0xc6,
+    0xe1, 0xc9, 0x9c, 0xf1, 0x39, 0x77, 0xab, 0xba,
+};
+static const size_t TEST_DVPT256_124_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_124_EXPECTED[] = {
+    0x11, 0x25, 0x00, 0x56,
+};
+static const size_t TEST_DVPT256_124_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_124_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_124_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_126_NONCE[] = {
+    0xc4, 0x2a, 0xc6, 0x3d, 0xe6, 0xf1, 0x2a,
+};
+static const size_t TEST_DVPT256_126_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_126_ADATA[] = {
+    0x7f, 0xf8, 0xd0, 0x6c, 0x5a, 0xbc, 0xc5, 0x0d,
+    0x38, 0x20, 0xde, 0x34, 0xb0, 0x30, 0x89, 0xe6,
+    0xc5, 0xb2, 0x02, 0xbc, 0xba, 0xab, 0xca, 0x89,
+    0x28, 0x25, 0x55, 0x3d, 0x4d, 0x30, 0x02, 0x0a,
+};
+static const size_t TEST_DVPT256_126_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_126_EXPECTED[] = {
+    0x4e, 0xed, 0x80, 0xfd,
+};
+static const size_t TEST_DVPT256_126_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_126_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_126_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_131_NONCE[] = {
+    0x3a, 0x17, 0x01, 0xb1, 0x85, 0xd3, 0x3a,
+};
+static const size_t TEST_DVPT256_131_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_131_ADATA[] = {
+    0xe5, 0xd5, 0x4d, 0xf8, 0xed, 0x9f, 0x89, 0xb9,
+    0x8c, 0x5e, 0xbb, 0x1b, 0xc5, 0xd5, 0x27, 0x9c,
+    0x2e, 0x18, 0x27, 0x84, 0xff, 0x4c, 0xd9, 0xc8,
+    0x69, 0xae, 0x15, 0x2e, 0x29, 0xd7, 0xa2, 0xb2,
+};
+static const size_t TEST_DVPT256_131_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_131_EXPECTED[] = {
+    0x9a, 0x53, 0x82, 0xc3,
+};
+static const size_t TEST_DVPT256_131_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_131_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_131_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_133_NONCE[] = {
+    0x4f, 0x49, 0x0c, 0xe0, 0x7e, 0x01, 0x50,
+};
+static const size_t TEST_DVPT256_133_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_133_ADATA[] = {
+    0x3e, 0x12, 0xd0, 0x96, 0x32, 0xc6, 0x44, 0xc5,
+    0x40, 0x07, 0x7c, 0x6f, 0x90, 0x72, 0x6d, 0x41,
+    0x67, 0x42, 0x3a, 0x67, 0x93, 0x22, 0xb2, 0x00,
+    0x0a, 0x3f, 0x19, 0xcf, 0xce, 0xa0, 0x2b, 0x33,
+};
+static const size_t TEST_DVPT256_133_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_133_EXPECTED[] = {
+    0xe1, 0x84, 0x2c, 0x46,
+};
+static const size_t TEST_DVPT256_133_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_133_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_133_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_9_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_9_KEY[] = {
+    0xa4, 0xbc, 0x10, 0xb1, 0xa6, 0x2c, 0x96, 0xd4,
+    0x59, 0xfb, 0xaf, 0x3a, 0x5a, 0xa3, 0xfa, 0xce,
+    0x73, 0x13, 0xbb, 0x9e, 0x12, 0x53, 0xe6, 0x96,
+    0xf9, 0x6a, 0x7a, 0x8e, 0x36, 0x80, 0x10, 0x88,
+};
+static const size_t TEST_DVPT256_GROUP_9_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_135_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_135_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_135_ADATA[] = {
+    0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
+    0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
+    0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
+    0x8d, 0x15, 0xb6, 0xd3, 0x6c, 0x03, 0x8e, 0xab,
+};
+static const size_t TEST_DVPT256_135_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_135_EXPECTED[] = {
+    0x93, 0xaf, 0x11, 0xa0, 0x83, 0x79, 0xeb, 0x37,
+    0xa1, 0x6a, 0xa2, 0x83, 0x7f, 0x09, 0xd6, 0x9d,
+};
+static const size_t TEST_DVPT256_135_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_135_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_135_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_139_NONCE[] = {
+    0x3f, 0xcb, 0x32, 0x8b, 0xc9, 0x64, 0x04,
+};
+static const size_t TEST_DVPT256_139_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_139_ADATA[] = {
+    0x10, 0xb2, 0xff, 0xed, 0x4f, 0x95, 0xaf, 0x0f,
+    0x98, 0xed, 0x4f, 0x77, 0xc6, 0x77, 0xb5, 0x78,
+    0x6a, 0xd0, 0x1b, 0x31, 0xc0, 0x95, 0xbb, 0xc6,
+    0xe1, 0xc9, 0x9c, 0xf1, 0x39, 0x77, 0xab, 0xba,
+};
+static const size_t TEST_DVPT256_139_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_139_EXPECTED[] = {
+    0xb3, 0x88, 0x4b, 0x69, 0xd1, 0x17, 0x14, 0x6c,
+    0xfa, 0x55, 0x29, 0x90, 0x17, 0x53, 0xdd, 0xc0,
+};
+static const size_t TEST_DVPT256_139_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_139_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_139_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_141_NONCE[] = {
+    0xc4, 0x2a, 0xc6, 0x3d, 0xe6, 0xf1, 0x2a,
+};
+static const size_t TEST_DVPT256_141_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_141_ADATA[] = {
+    0x7f, 0xf8, 0xd0, 0x6c, 0x5a, 0xbc, 0xc5, 0x0d,
+    0x38, 0x20, 0xde, 0x34, 0xb0, 0x30, 0x89, 0xe6,
+    0xc5, 0xb2, 0x02, 0xbc, 0xba, 0xab, 0xca, 0x89,
+    0x28, 0x25, 0x55, 0x3d, 0x4d, 0x30, 0x02, 0x0a,
+};
+static const size_t TEST_DVPT256_141_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_141_EXPECTED[] = {
+    0xb5, 0x3d, 0x93, 0xcb, 0xfd, 0x3d, 0x5c, 0xf3,
+    0x72, 0x0c, 0xef, 0x50, 0x80, 0xbc, 0x72, 0x24,
+};
+static const size_t TEST_DVPT256_141_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_141_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_141_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_146_NONCE[] = {
+    0x3a, 0x17, 0x01, 0xb1, 0x85, 0xd3, 0x3a,
+};
+static const size_t TEST_DVPT256_146_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_146_ADATA[] = {
+    0xe5, 0xd5, 0x4d, 0xf8, 0xed, 0x9f, 0x89, 0xb9,
+    0x8c, 0x5e, 0xbb, 0x1b, 0xc5, 0xd5, 0x27, 0x9c,
+    0x2e, 0x18, 0x27, 0x84, 0xff, 0x4c, 0xd9, 0xc8,
+    0x69, 0xae, 0x15, 0x2e, 0x29, 0xd7, 0xa2, 0xb2,
+};
+static const size_t TEST_DVPT256_146_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_146_EXPECTED[] = {
+    0x0a, 0x5d, 0x1b, 0xc0, 0x2c, 0x5f, 0xe0, 0x96,
+    0xa8, 0xb9, 0xd9, 0x4d, 0x12, 0x67, 0xc4, 0x9a,
+};
+static const size_t TEST_DVPT256_146_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_146_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_146_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_148_NONCE[] = {
+    0x4f, 0x49, 0x0c, 0xe0, 0x7e, 0x01, 0x50,
+};
+static const size_t TEST_DVPT256_148_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_148_ADATA[] = {
+    0x3e, 0x12, 0xd0, 0x96, 0x32, 0xc6, 0x44, 0xc5,
+    0x40, 0x07, 0x7c, 0x6f, 0x90, 0x72, 0x6d, 0x41,
+    0x67, 0x42, 0x3a, 0x67, 0x93, 0x22, 0xb2, 0x00,
+    0x0a, 0x3f, 0x19, 0xcf, 0xce, 0xa0, 0x2b, 0x33,
+};
+static const size_t TEST_DVPT256_148_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_148_EXPECTED[] = {
+    0x1e, 0xda, 0x43, 0xbf, 0x07, 0xf2, 0xbf, 0x00,
+    0x31, 0x07, 0xf3, 0xa0, 0xba, 0x3a, 0x4c, 0x18,
+};
+static const size_t TEST_DVPT256_148_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_148_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_148_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_10_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_10_KEY[] = {
+    0xa4, 0xbc, 0x10, 0xb1, 0xa6, 0x2c, 0x96, 0xd4,
+    0x59, 0xfb, 0xaf, 0x3a, 0x5a, 0xa3, 0xfa, 0xce,
+    0x73, 0x13, 0xbb, 0x9e, 0x12, 0x53, 0xe6, 0x96,
+    0xf9, 0x6a, 0x7a, 0x8e, 0x36, 0x80, 0x10, 0x88,
+};
+static const size_t TEST_DVPT256_GROUP_10_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_150_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_150_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_150_ADATA[] = {
+    0x3c, 0x0e, 0x28, 0x15, 0xd3, 0x7d, 0x84, 0x4f,
+    0x7a, 0xc2, 0x40, 0xba, 0x9d, 0x6e, 0x3a, 0x0b,
+    0x2a, 0x86, 0xf7, 0x06, 0xe8, 0x85, 0x95, 0x9e,
+    0x09, 0xa1, 0x00, 0x5e, 0x02, 0x4f, 0x69, 0x07,
+};
+static const size_t TEST_DVPT256_150_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_150_EXPECTED[] = {
+    0x86, 0x6d, 0x42, 0x27,
+};
+static const size_t TEST_DVPT256_150_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_150_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_150_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_154_NONCE[] = {
+    0xdf, 0xdc, 0xbd, 0xff, 0x32, 0x9f, 0x7a, 0xf7,
+    0x07, 0x31, 0xd8, 0xe2, 0x76,
+};
+static const size_t TEST_DVPT256_154_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_154_ADATA[] = {
+    0x2a, 0xe5, 0x6d, 0xdd, 0xe2, 0x87, 0x6d, 0x70,
+    0xb3, 0xb3, 0x4e, 0xda, 0x8c, 0x2b, 0x1d, 0x09,
+    0x6c, 0x83, 0x6d, 0x52, 0x25, 0xd5, 0x3e, 0xc4,
+    0x60, 0xb7, 0x24, 0xb6, 0xe1, 0x6a, 0xa5, 0xa3,
+};
+static const size_t TEST_DVPT256_154_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_154_EXPECTED[] = {
+    0xc4, 0xac, 0x09, 0x52,
+};
+static const size_t TEST_DVPT256_154_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_154_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_154_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_156_NONCE[] = {
+    0x60, 0xf2, 0x49, 0x0b, 0xa0, 0xc6, 0x58, 0x84,
+    0x88, 0x59, 0xfc, 0xbe, 0xa8,
+};
+static const size_t TEST_DVPT256_156_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_156_ADATA[] = {
+    0x3a, 0xd7, 0x43, 0x28, 0x30, 0x64, 0x92, 0x9b,
+    0xf4, 0xfe, 0x4e, 0x08, 0x07, 0xf7, 0x10, 0xf5,
+    0xe6, 0xa2, 0x73, 0xe2, 0x26, 0x14, 0xc7, 0x28,
+    0xc3, 0x28, 0x0a, 0x27, 0xb6, 0xc6, 0x14, 0xa0,
+};
+static const size_t TEST_DVPT256_156_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_156_EXPECTED[] = {
+    0x27, 0xc3, 0x95, 0x3d,
+};
+static const size_t TEST_DVPT256_156_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_156_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_156_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_161_NONCE[] = {
+    0xdb, 0x11, 0x3f, 0x38, 0xf0, 0x50, 0x46, 0x15,
+    0xc5, 0xc9, 0x34, 0x7c, 0x3d,
+};
+static const size_t TEST_DVPT256_161_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_161_ADATA[] = {
+    0x3b, 0x71, 0xbc, 0x84, 0xe4, 0x8c, 0x6d, 0xad,
+    0xf6, 0xea, 0xd1, 0x46, 0x21, 0xd2, 0x24, 0x68,
+    0xa3, 0xd4, 0xc9, 0xc1, 0x03, 0xac, 0x96, 0x97,
+    0x02, 0x69, 0x73, 0x0b, 0xcf, 0xce, 0x23, 0x9b,
+};
+static const size_t TEST_DVPT256_161_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_161_EXPECTED[] = {
+    0xc3, 0x8f, 0xbd, 0xff,
+};
+static const size_t TEST_DVPT256_161_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_161_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_161_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_163_NONCE[] = {
+    0xd3, 0x5f, 0x53, 0x1f, 0x71, 0x46, 0x94, 0xb5,
+    0xe4, 0x93, 0x03, 0xa9, 0x80,
+};
+static const size_t TEST_DVPT256_163_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_163_ADATA[] = {
+    0x55, 0xb7, 0x91, 0xee, 0x49, 0x52, 0x99, 0x91,
+    0x6f, 0xf3, 0xc2, 0x32, 0x7b, 0x49, 0x90, 0x95,
+    0x2b, 0xeb, 0xd0, 0xa2, 0xda, 0x9a, 0xcf, 0xc5,
+    0x53, 0xc6, 0xc9, 0x96, 0xe3, 0x54, 0xa4, 0xb5,
+};
+static const size_t TEST_DVPT256_163_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_163_EXPECTED[] = {
+    0xd3, 0x4e, 0x90, 0xbb,
+};
+static const size_t TEST_DVPT256_163_EXPECTED_LEN = 4;
+
+static const uint8_t TEST_DVPT256_163_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_163_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 0, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_11_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_11_KEY[] = {
+    0x8c, 0x5c, 0xf3, 0x45, 0x7f, 0xf2, 0x22, 0x28,
+    0xc3, 0x9c, 0x05, 0x1c, 0x4e, 0x05, 0xed, 0x40,
+    0x93, 0x65, 0x7e, 0xb3, 0x03, 0xf8, 0x59, 0xa9,
+    0xd4, 0xb0, 0xf8, 0xbe, 0x01, 0x27, 0xd8, 0x8a,
+};
+static const size_t TEST_DVPT256_GROUP_11_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_165_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_165_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_165_ADATA[] = {
+    0x3c, 0x0e, 0x28, 0x15, 0xd3, 0x7d, 0x84, 0x4f,
+    0x7a, 0xc2, 0x40, 0xba, 0x9d, 0x6e, 0x3a, 0x0b,
+    0x2a, 0x86, 0xf7, 0x06, 0xe8, 0x85, 0x95, 0x9e,
+    0x09, 0xa1, 0x00, 0x5e, 0x02, 0x4f, 0x69, 0x07,
+};
+static const size_t TEST_DVPT256_165_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_165_EXPECTED[] = {
+    0x86, 0x7b, 0x0d, 0x87, 0xcf, 0x6e, 0x0f, 0x71,
+    0x82, 0x00, 0xa9, 0x7b, 0x4f, 0x6d, 0x5a, 0xd5,
+};
+static const size_t TEST_DVPT256_165_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_165_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_165_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_169_NONCE[] = {
+    0xdf, 0xdc, 0xbd, 0xff, 0x32, 0x9f, 0x7a, 0xf7,
+    0x07, 0x31, 0xd8, 0xe2, 0x76,
+};
+static const size_t TEST_DVPT256_169_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_169_ADATA[] = {
+    0x2a, 0xe5, 0x6d, 0xdd, 0xe2, 0x87, 0x6d, 0x70,
+    0xb3, 0xb3, 0x4e, 0xda, 0x8c, 0x2b, 0x1d, 0x09,
+    0x6c, 0x83, 0x6d, 0x52, 0x25, 0xd5, 0x3e, 0xc4,
+    0x60, 0xb7, 0x24, 0xb6, 0xe1, 0x6a, 0xa5, 0xa3,
+};
+static const size_t TEST_DVPT256_169_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_169_EXPECTED[] = {
+    0xad, 0x87, 0x9c, 0x64, 0x42, 0x5e, 0x6c, 0x1e,
+    0xc4, 0x84, 0x1b, 0xbb, 0x0f, 0x99, 0xaa, 0x8b,
+};
+static const size_t TEST_DVPT256_169_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_169_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_169_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_171_NONCE[] = {
+    0x60, 0xf2, 0x49, 0x0b, 0xa0, 0xc6, 0x58, 0x84,
+    0x88, 0x59, 0xfc, 0xbe, 0xa8,
+};
+static const size_t TEST_DVPT256_171_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_171_ADATA[] = {
+    0x3a, 0xd7, 0x43, 0x28, 0x30, 0x64, 0x92, 0x9b,
+    0xf4, 0xfe, 0x4e, 0x08, 0x07, 0xf7, 0x10, 0xf5,
+    0xe6, 0xa2, 0x73, 0xe2, 0x26, 0x14, 0xc7, 0x28,
+    0xc3, 0x28, 0x0a, 0x27, 0xb6, 0xc6, 0x14, 0xa0,
+};
+static const size_t TEST_DVPT256_171_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_171_EXPECTED[] = {
+    0xe2, 0x75, 0x1f, 0x15, 0x3f, 0xc7, 0x6c, 0x0d,
+    0xec, 0x5e, 0x0c, 0xf2, 0xd3, 0x0c, 0x1a, 0x28,
+};
+static const size_t TEST_DVPT256_171_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_171_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_171_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_176_NONCE[] = {
+    0xdb, 0x11, 0x3f, 0x38, 0xf0, 0x50, 0x46, 0x15,
+    0xc5, 0xc9, 0x34, 0x7c, 0x3d,
+};
+static const size_t TEST_DVPT256_176_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_176_ADATA[] = {
+    0x3b, 0x71, 0xbc, 0x84, 0xe4, 0x8c, 0x6d, 0xad,
+    0xf6, 0xea, 0xd1, 0x46, 0x21, 0xd2, 0x24, 0x68,
+    0xa3, 0xd4, 0xc9, 0xc1, 0x03, 0xac, 0x96, 0x97,
+    0x02, 0x69, 0x73, 0x0b, 0xcf, 0xce, 0x23, 0x9b,
+};
+static const size_t TEST_DVPT256_176_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_176_EXPECTED[] = {
+    0xfc, 0x85, 0x46, 0x4a, 0x81, 0xfe, 0x37, 0x2c,
+    0x12, 0xc9, 0xe4, 0xf0, 0xf3, 0xbf, 0x9c, 0x37,
+};
+static const size_t TEST_DVPT256_176_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_176_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_176_INPUT_LEN = 0;
+
+static const uint8_t TEST_DVPT256_178_NONCE[] = {
+    0xd3, 0x5f, 0x53, 0x1f, 0x71, 0x46, 0x94, 0xb5,
+    0xe4, 0x93, 0x03, 0xa9, 0x80,
+};
+static const size_t TEST_DVPT256_178_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_178_ADATA[] = {
+    0x55, 0xb7, 0x91, 0xee, 0x49, 0x52, 0x99, 0x91,
+    0x6f, 0xf3, 0xc2, 0x32, 0x7b, 0x49, 0x90, 0x95,
+    0x2b, 0xeb, 0xd0, 0xa2, 0xda, 0x9a, 0xcf, 0xc5,
+    0x53, 0xc6, 0xc9, 0x96, 0xe3, 0x54, 0xa4, 0xb5,
+};
+static const size_t TEST_DVPT256_178_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_178_EXPECTED[] = {
+    0xb1, 0xc0, 0x9b, 0x09, 0x37, 0x88, 0xda, 0x19,
+    0xe3, 0x3c, 0x5a, 0x6e, 0x82, 0xed, 0x96, 0x27,
+};
+static const size_t TEST_DVPT256_178_EXPECTED_LEN = 16;
+
+static const uint8_t TEST_DVPT256_178_INPUT[] = {
+    0x00,
+};
+static const size_t TEST_DVPT256_178_INPUT_LEN = 0;
+
+/* Alen = 32, Plen = 24, Nlen = 7, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_12_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_12_KEY[] = {
+    0x8c, 0x5c, 0xf3, 0x45, 0x7f, 0xf2, 0x22, 0x28,
+    0xc3, 0x9c, 0x05, 0x1c, 0x4e, 0x05, 0xed, 0x40,
+    0x93, 0x65, 0x7e, 0xb3, 0x03, 0xf8, 0x59, 0xa9,
+    0xd4, 0xb0, 0xf8, 0xbe, 0x01, 0x27, 0xd8, 0x8a,
+};
+static const size_t TEST_DVPT256_GROUP_12_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_180_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_180_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_180_ADATA[] = {
+    0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
+    0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
+    0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
+    0x8d, 0x15, 0xb6, 0xd3, 0x6c, 0x03, 0x8e, 0xab,
+};
+static const size_t TEST_DVPT256_180_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_180_EXPECTED[] = {
+    0xc2, 0xfe, 0x12, 0x65, 0x81, 0x39, 0xf5, 0xd0,
+    0xdd, 0x22, 0xca, 0xdf, 0x2e, 0x90, 0x16, 0x95,
+    0xb5, 0x79, 0x30, 0x2a, 0x72, 0xfc, 0x56, 0x08,
+    0x3e, 0xbc, 0x77, 0x20,
+};
+static const size_t TEST_DVPT256_180_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_180_INPUT[] = {
+    0x78, 0xc4, 0x6e, 0x32, 0x49, 0xca, 0x28, 0xe1,
+    0xef, 0x05, 0x31, 0xd8, 0x0f, 0xd3, 0x7c, 0x12,
+    0x4d, 0x9a, 0xec, 0xb7, 0xbe, 0x66, 0x68, 0xe3,
+};
+static const size_t TEST_DVPT256_180_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_184_NONCE[] = {
+    0x57, 0xb9, 0x40, 0x55, 0x0a, 0x38, 0x3b,
+};
+static const size_t TEST_DVPT256_184_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_184_ADATA[] = {
+    0x33, 0xc2, 0xc3, 0xa5, 0x7b, 0xf8, 0x39, 0x3b,
+    0x12, 0x69, 0x82, 0xc9, 0x6d, 0x87, 0xda, 0xea,
+    0xcd, 0x5e, 0xad, 0xad, 0x15, 0x19, 0x07, 0x3a,
+    0xd8, 0xc8, 0x4c, 0xb9, 0xb7, 0x60, 0x29, 0x6f,
+};
+static const size_t TEST_DVPT256_184_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_184_EXPECTED[] = {
+    0xe1, 0xb4, 0xec, 0x42, 0x79, 0xbb, 0x62, 0x90,
+    0x2c, 0x12, 0x52, 0x1e, 0x6b, 0x87, 0x41, 0x71,
+    0x69, 0x5c, 0x5d, 0xa4, 0x6c, 0x64, 0x7c, 0xc0,
+    0x3b, 0x91, 0xff, 0x03,
+};
+static const size_t TEST_DVPT256_184_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_184_INPUT[] = {
+    0x6f, 0xb5, 0xce, 0x32, 0xa8, 0x51, 0x67, 0x67,
+    0x53, 0xba, 0x35, 0x23, 0xed, 0xc5, 0xca, 0x82,
+    0xaf, 0x18, 0x43, 0xff, 0xc0, 0x8f, 0x1e, 0xf0,
+};
+static const size_t TEST_DVPT256_184_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_186_NONCE[] = {
+    0xf3, 0x22, 0x22, 0xe9, 0xee, 0xc4, 0xbd,
+};
+static const size_t TEST_DVPT256_186_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_186_ADATA[] = {
+    0x68, 0x45, 0x95, 0xe3, 0x6e, 0xda, 0x1d, 0xb5,
+    0xf5, 0x86, 0x94, 0x1c, 0x9f, 0x34, 0xc9, 0xf8,
+    0xd4, 0x77, 0x97, 0x0d, 0x5c, 0xcc, 0x14, 0x63,
+    0x2d, 0x1f, 0x0c, 0xec, 0x81, 0x90, 0xae, 0x68,
+};
+static const size_t TEST_DVPT256_186_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_186_EXPECTED[] = {
+    0x22, 0x4d, 0xb2, 0x1b, 0xeb, 0x8c, 0xd0, 0x06,
+    0x90, 0x07, 0x66, 0x0e, 0x78, 0x3c, 0x3f, 0x85,
+    0x70, 0x6b, 0x01, 0x41, 0x28, 0x36, 0x8a, 0xab,
+    0x2a, 0x4e, 0x56, 0xa7,
+};
+static const size_t TEST_DVPT256_186_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_186_INPUT[] = {
+    0x2c, 0x29, 0xd4, 0xe2, 0xbb, 0x92, 0x94, 0xe9,
+    0x0c, 0xb0, 0x4e, 0xc6, 0x97, 0xe6, 0x63, 0xa1,
+    0xf7, 0x38, 0x5a, 0x39, 0xf9, 0x0c, 0x8c, 0xcf,
+};
+static const size_t TEST_DVPT256_186_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_191_NONCE[] = {
+    0x14, 0xc9, 0xbd, 0x56, 0x1c, 0x47, 0xc1,
+};
+static const size_t TEST_DVPT256_191_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_191_ADATA[] = {
+    0x14, 0x1a, 0xe3, 0x65, 0xf8, 0xe6, 0x5a, 0xb9,
+    0x19, 0x6c, 0x4e, 0x8c, 0xd4, 0xe6, 0x21, 0x89,
+    0xb3, 0x04, 0xd6, 0x7d, 0xe3, 0x8f, 0x21, 0x17,
+    0xe8, 0x4e, 0xc0, 0xec, 0x8f, 0x26, 0x0e, 0xbd,
+};
+static const size_t TEST_DVPT256_191_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_191_EXPECTED[] = {
+    0x61, 0xb4, 0x6c, 0x90, 0x24, 0xee, 0xd3, 0x98,
+    0x90, 0x64, 0xa5, 0x2d, 0xf9, 0x03, 0x49, 0xc1,
+    0x8e, 0x14, 0xe4, 0xb5, 0x52, 0x77, 0x9d, 0x3f,
+    0x8f, 0x9d, 0x68, 0x14,
+};
+static const size_t TEST_DVPT256_191_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_191_INPUT[] = {
+    0xc2, 0x25, 0x24, 0xa1, 0xea, 0x44, 0x4b, 0xe3,
+    0x41, 0x2b, 0x0d, 0x77, 0x3d, 0x4e, 0xa2, 0xff,
+    0x0a, 0xf4, 0xc1, 0xad, 0x23, 0x83, 0xcb, 0xa8,
+};
+static const size_t TEST_DVPT256_191_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_193_NONCE[] = {
+    0x1c, 0xce, 0xc9, 0x92, 0x3a, 0xa6, 0xe8,
+};
+static const size_t TEST_DVPT256_193_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_193_ADATA[] = {
+    0x88, 0xa6, 0xd0, 0x37, 0x00, 0x9a, 0x1c, 0x17,
+    0x56, 0xf7, 0x2b, 0xb4, 0x58, 0x9d, 0x6d, 0x94,
+    0x0b, 0xd5, 0x14, 0xed, 0x55, 0x38, 0x6b, 0xae,
+    0xfa, 0xcc, 0x6a, 0xc3, 0xca, 0x6f, 0x87, 0x95,
+};
+static const size_t TEST_DVPT256_193_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_193_EXPECTED[] = {
+    0x52, 0xf8, 0x20, 0x55, 0x34, 0x44, 0x7d, 0x72,
+    0x2b, 0xe2, 0xb9, 0x37, 0x7f, 0x73, 0x95, 0x93,
+    0x8c, 0xc8, 0x8a, 0xf0, 0x81, 0xa1, 0x1c, 0xcb,
+    0x0d, 0x83, 0xfa, 0x19,
+};
+static const size_t TEST_DVPT256_193_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_193_INPUT[] = {
+    0x51, 0x8a, 0x7f, 0xb1, 0x1c, 0x46, 0x3b, 0xf2,
+    0x37, 0x98, 0x98, 0x21, 0x18, 0xf3, 0xcf, 0xe4,
+    0xd7, 0xdd, 0xde, 0x91, 0x84, 0xf3, 0x7d, 0x4f,
+};
+static const size_t TEST_DVPT256_193_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 7, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_13_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_13_KEY[] = {
+    0x70, 0x53, 0x34, 0xe3, 0x0f, 0x53, 0xdd, 0x2f,
+    0x92, 0xd1, 0x90, 0xd2, 0xc1, 0x43, 0x7c, 0x87,
+    0x72, 0xf9, 0x40, 0xc5, 0x5a, 0xa3, 0x5e, 0x56,
+    0x22, 0x14, 0xed, 0x45, 0xbd, 0x45, 0x8f, 0xfe,
+};
+static const size_t TEST_DVPT256_GROUP_13_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_195_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1,
+};
+static const size_t TEST_DVPT256_195_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_195_ADATA[] = {
+    0xd3, 0xd5, 0x42, 0x4e, 0x20, 0xfb, 0xec, 0x43,
+    0xae, 0x49, 0x53, 0x53, 0xed, 0x83, 0x02, 0x71,
+    0x51, 0x5a, 0xb1, 0x04, 0xf8, 0x86, 0x0c, 0x98,
+    0x8d, 0x15, 0xb6, 0xd3, 0x6c, 0x03, 0x8e, 0xab,
+};
+static const size_t TEST_DVPT256_195_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_195_EXPECTED[] = {
+    0x33, 0x41, 0x16, 0x8e, 0xb8, 0xc4, 0x84, 0x68,
+    0xc4, 0x14, 0x34, 0x7f, 0xb0, 0x8f, 0x71, 0xd2,
+    0x08, 0x6f, 0x7c, 0x2d, 0x1b, 0xd5, 0x81, 0xce,
+    0x1a, 0xc6, 0x8b, 0xd4, 0x2f, 0x5e, 0xc7, 0xfa,
+    0x7e, 0x06, 0x8c, 0xc0, 0xec, 0xd7, 0x9c, 0x2a,
+};
+static const size_t TEST_DVPT256_195_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_195_INPUT[] = {
+    0x78, 0xc4, 0x6e, 0x32, 0x49, 0xca, 0x28, 0xe1,
+    0xef, 0x05, 0x31, 0xd8, 0x0f, 0xd3, 0x7c, 0x12,
+    0x4d, 0x9a, 0xec, 0xb7, 0xbe, 0x66, 0x68, 0xe3,
+};
+static const size_t TEST_DVPT256_195_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_199_NONCE[] = {
+    0x57, 0xb9, 0x40, 0x55, 0x0a, 0x38, 0x3b,
+};
+static const size_t TEST_DVPT256_199_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_199_ADATA[] = {
+    0x33, 0xc2, 0xc3, 0xa5, 0x7b, 0xf8, 0x39, 0x3b,
+    0x12, 0x69, 0x82, 0xc9, 0x6d, 0x87, 0xda, 0xea,
+    0xcd, 0x5e, 0xad, 0xad, 0x15, 0x19, 0x07, 0x3a,
+    0xd8, 0xc8, 0x4c, 0xb9, 0xb7, 0x60, 0x29, 0x6f,
+};
+static const size_t TEST_DVPT256_199_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_199_EXPECTED[] = {
+    0xfb, 0xfe, 0xd2, 0xc9, 0x4f, 0x50, 0xca, 0x10,
+    0x46, 0x6d, 0xa9, 0x90, 0x3e, 0xf8, 0x58, 0x33,
+    0xad, 0x48, 0xca, 0x00, 0x55, 0x6e, 0x66, 0xd1,
+    0x4d, 0x8b, 0x30, 0xdf, 0x94, 0x1f, 0x35, 0x36,
+    0xff, 0xb4, 0x20, 0x83, 0xef, 0x0e, 0x1c, 0x30,
+};
+static const size_t TEST_DVPT256_199_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_199_INPUT[] = {
+    0x6f, 0xb5, 0xce, 0x32, 0xa8, 0x51, 0x67, 0x67,
+    0x53, 0xba, 0x35, 0x23, 0xed, 0xc5, 0xca, 0x82,
+    0xaf, 0x18, 0x43, 0xff, 0xc0, 0x8f, 0x1e, 0xf0,
+};
+static const size_t TEST_DVPT256_199_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_201_NONCE[] = {
+    0xf3, 0x22, 0x22, 0xe9, 0xee, 0xc4, 0xbd,
+};
+static const size_t TEST_DVPT256_201_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_201_ADATA[] = {
+    0x68, 0x45, 0x95, 0xe3, 0x6e, 0xda, 0x1d, 0xb5,
+    0xf5, 0x86, 0x94, 0x1c, 0x9f, 0x34, 0xc9, 0xf8,
+    0xd4, 0x77, 0x97, 0x0d, 0x5c, 0xcc, 0x14, 0x63,
+    0x2d, 0x1f, 0x0c, 0xec, 0x81, 0x90, 0xae, 0x68,
+};
+static const size_t TEST_DVPT256_201_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_201_EXPECTED[] = {
+    0xda, 0xe1, 0x3e, 0x69, 0x67, 0xc8, 0xb1, 0xee,
+    0x0d, 0xd2, 0xd5, 0xba, 0x1d, 0xd1, 0xde, 0x69,
+    0xf2, 0x2c, 0x95, 0xda, 0x39, 0x52, 0x8f, 0x9e,
+    0xf7, 0x8e, 0x9e, 0x5e, 0x9f, 0xaa, 0x05, 0x81,
+    0x12, 0xaf, 0x57, 0xf4, 0xac, 0x78, 0xdb, 0x2c,
+};
+static const size_t TEST_DVPT256_201_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_201_INPUT[] = {
+    0x2c, 0x29, 0xd4, 0xe2, 0xbb, 0x92, 0x94, 0xe9,
+    0x0c, 0xb0, 0x4e, 0xc6, 0x97, 0xe6, 0x63, 0xa1,
+    0xf7, 0x38, 0x5a, 0x39, 0xf9, 0x0c, 0x8c, 0xcf,
+};
+static const size_t TEST_DVPT256_201_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_206_NONCE[] = {
+    0x14, 0xc9, 0xbd, 0x56, 0x1c, 0x47, 0xc1,
+};
+static const size_t TEST_DVPT256_206_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_206_ADATA[] = {
+    0x14, 0x1a, 0xe3, 0x65, 0xf8, 0xe6, 0x5a, 0xb9,
+    0x19, 0x6c, 0x4e, 0x8c, 0xd4, 0xe6, 0x21, 0x89,
+    0xb3, 0x04, 0xd6, 0x7d, 0xe3, 0x8f, 0x21, 0x17,
+    0xe8, 0x4e, 0xc0, 0xec, 0x8f, 0x26, 0x0e, 0xbd,
+};
+static const size_t TEST_DVPT256_206_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_206_EXPECTED[] = {
+    0xa6, 0x54, 0x23, 0x8f, 0xb8, 0xb0, 0x5e, 0x29,
+    0x3d, 0xba, 0x07, 0xf9, 0xd6, 0x8d, 0x75, 0xa7,
+    0xf0, 0xfb, 0xf4, 0x0f, 0xe2, 0x0e, 0xda, 0xeb,
+    0xa1, 0x58, 0x6b, 0xf9, 0x22, 0x41, 0x2e, 0x73,
+    0xce, 0x33, 0x8e, 0x37, 0x26, 0x15, 0xc3, 0xbc,
+};
+static const size_t TEST_DVPT256_206_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_206_INPUT[] = {
+    0xc2, 0x25, 0x24, 0xa1, 0xea, 0x44, 0x4b, 0xe3,
+    0x41, 0x2b, 0x0d, 0x77, 0x3d, 0x4e, 0xa2, 0xff,
+    0x0a, 0xf4, 0xc1, 0xad, 0x23, 0x83, 0xcb, 0xa8,
+};
+static const size_t TEST_DVPT256_206_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_208_NONCE[] = {
+    0x1c, 0xce, 0xc9, 0x92, 0x3a, 0xa6, 0xe8,
+};
+static const size_t TEST_DVPT256_208_NONCE_LEN = 7;
+
+static const uint8_t TEST_DVPT256_208_ADATA[] = {
+    0x88, 0xa6, 0xd0, 0x37, 0x00, 0x9a, 0x1c, 0x17,
+    0x56, 0xf7, 0x2b, 0xb4, 0x58, 0x9d, 0x6d, 0x94,
+    0x0b, 0xd5, 0x14, 0xed, 0x55, 0x38, 0x6b, 0xae,
+    0xfa, 0xcc, 0x6a, 0xc3, 0xca, 0x6f, 0x87, 0x95,
+};
+static const size_t TEST_DVPT256_208_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_208_EXPECTED[] = {
+    0x76, 0x50, 0x67, 0xef, 0x76, 0x89, 0x08, 0xd9,
+    0x1e, 0xe4, 0xc3, 0x92, 0x39, 0x43, 0xe0, 0xc7,
+    0xbe, 0x70, 0xe2, 0xe0, 0x6d, 0xb9, 0x9a, 0x4b,
+    0x3e, 0x3f, 0x51, 0xee, 0x37, 0xfd, 0xcc, 0x5d,
+    0x81, 0xdd, 0x85, 0xd9, 0xe9, 0xd4, 0xf4, 0x4e,
+};
+static const size_t TEST_DVPT256_208_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_208_INPUT[] = {
+    0x51, 0x8a, 0x7f, 0xb1, 0x1c, 0x46, 0x3b, 0xf2,
+    0x37, 0x98, 0x98, 0x21, 0x18, 0xf3, 0xcf, 0xe4,
+    0xd7, 0xdd, 0xde, 0x91, 0x84, 0xf3, 0x7d, 0x4f,
+};
+static const size_t TEST_DVPT256_208_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 13, Tlen = 4 */
+static const uint8_t TEST_DVPT256_GROUP_14_MAC_LEN = 4;
+
+static const uint8_t TEST_DVPT256_GROUP_14_KEY[] = {
+    0x70, 0x53, 0x34, 0xe3, 0x0f, 0x53, 0xdd, 0x2f,
+    0x92, 0xd1, 0x90, 0xd2, 0xc1, 0x43, 0x7c, 0x87,
+    0x72, 0xf9, 0x40, 0xc5, 0x5a, 0xa3, 0x5e, 0x56,
+    0x22, 0x14, 0xed, 0x45, 0xbd, 0x45, 0x8f, 0xfe,
+};
+static const size_t TEST_DVPT256_GROUP_14_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_210_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_210_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_210_ADATA[] = {
+    0x3c, 0x0e, 0x28, 0x15, 0xd3, 0x7d, 0x84, 0x4f,
+    0x7a, 0xc2, 0x40, 0xba, 0x9d, 0x6e, 0x3a, 0x0b,
+    0x2a, 0x86, 0xf7, 0x06, 0xe8, 0x85, 0x95, 0x9e,
+    0x09, 0xa1, 0x00, 0x5e, 0x02, 0x4f, 0x69, 0x07,
+};
+static const size_t TEST_DVPT256_210_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_210_EXPECTED[] = {
+    0xc0, 0xea, 0x40, 0x0b, 0x59, 0x95, 0x61, 0xe7,
+    0x90, 0x5b, 0x99, 0x26, 0x2b, 0x45, 0x65, 0xd5,
+    0xc3, 0xdc, 0x49, 0xfa, 0xd8, 0x4d, 0x7c, 0x69,
+    0xef, 0x89, 0x13, 0x39,
+};
+static const size_t TEST_DVPT256_210_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_210_INPUT[] = {
+    0xe8, 0xde, 0x97, 0x0f, 0x6e, 0xe8, 0xe8, 0x0e,
+    0xde, 0x93, 0x35, 0x81, 0xb5, 0xbc, 0xf4, 0xd8,
+    0x37, 0xe2, 0xb7, 0x2b, 0xaa, 0x8b, 0x00, 0xc3,
+};
+static const size_t TEST_DVPT256_210_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_214_NONCE[] = {
+    0x0d, 0xd6, 0x13, 0xc0, 0xfe, 0x28, 0xe9, 0x13,
+    0xc0, 0xed, 0xbb, 0x84, 0x04,
+};
+static const size_t TEST_DVPT256_214_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_214_ADATA[] = {
+    0x2a, 0xd3, 0x06, 0x57, 0x5b, 0x57, 0x7c, 0x2f,
+    0x61, 0xda, 0x72, 0x12, 0xab, 0x63, 0xe3, 0xdb,
+    0x39, 0x41, 0xf1, 0xf7, 0x51, 0xf2, 0x35, 0x6c,
+    0x74, 0x43, 0x53, 0x1a, 0x90, 0xb9, 0xd1, 0x41,
+};
+static const size_t TEST_DVPT256_214_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_214_EXPECTED[] = {
+    0xfa, 0xbe, 0x11, 0xc9, 0x62, 0x9e, 0x59, 0x82,
+    0x28, 0xf5, 0x20, 0x9f, 0x3d, 0xbc, 0xc6, 0x41,
+    0xfe, 0x4b, 0x1a, 0x22, 0xca, 0xdb, 0x08, 0x21,
+    0xd2, 0x89, 0x8c, 0x3b,
+};
+static const size_t TEST_DVPT256_214_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_214_INPUT[] = {
+    0x95, 0x22, 0xfb, 0x1f, 0x1a, 0xa5, 0x84, 0x93,
+    0xcb, 0xa6, 0x82, 0xd7, 0x88, 0x18, 0x6d, 0x90,
+    0x2c, 0xfc, 0x93, 0xe8, 0x0f, 0xd6, 0xb9, 0x98,
+};
+static const size_t TEST_DVPT256_214_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_216_NONCE[] = {
+    0x3e, 0x0f, 0xe3, 0x42, 0x7e, 0xed, 0xa8, 0x0f,
+    0x02, 0xdd, 0xa4, 0xfe, 0xd5,
+};
+static const size_t TEST_DVPT256_216_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_216_ADATA[] = {
+    0xae, 0x0d, 0x1c, 0x9c, 0x83, 0x4d, 0x60, 0xff,
+    0x0e, 0xcf, 0xb3, 0xc0, 0xd7, 0x8c, 0x72, 0xdd,
+    0xb7, 0x89, 0xe5, 0x8a, 0xdf, 0xc1, 0x66, 0xc8,
+    0x1d, 0x5f, 0xc6, 0x39, 0x5b, 0x31, 0xec, 0x33,
+};
+static const size_t TEST_DVPT256_216_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_216_EXPECTED[] = {
+    0xd8, 0x8f, 0x8f, 0xcd, 0x77, 0x21, 0x25, 0x21,
+    0x2c, 0xe0, 0x9c, 0x2a, 0x6e, 0x5b, 0x56, 0x93,
+    0xdd, 0x35, 0x07, 0x3f, 0x99, 0x20, 0x04, 0xf0,
+    0xd1, 0x8f, 0xc8, 0x89,
+};
+static const size_t TEST_DVPT256_216_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_216_INPUT[] = {
+    0x38, 0x33, 0x3c, 0xe7, 0x81, 0x10, 0xbf, 0x53,
+    0xa2, 0xc2, 0xab, 0xc7, 0xdb, 0x99, 0xe1, 0x33,
+    0xad, 0x21, 0x8c, 0xa4, 0x3f, 0xf7, 0xa7, 0xbc,
+};
+static const size_t TEST_DVPT256_216_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_221_NONCE[] = {
+    0x60, 0x12, 0x2c, 0xbd, 0x21, 0x9e, 0x5c, 0xf1,
+    0x74, 0x15, 0xe8, 0xbc, 0x09,
+};
+static const size_t TEST_DVPT256_221_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_221_ADATA[] = {
+    0x89, 0x5a, 0x45, 0xdd, 0xbe, 0x0c, 0x80, 0x79,
+    0x3e, 0xcc, 0xbf, 0x82, 0x0d, 0xe1, 0x3a, 0x23,
+    0x3b, 0x6a, 0xa7, 0x04, 0x5c, 0xfd, 0x53, 0x13,
+    0x38, 0x8e, 0x71, 0x84, 0xc3, 0x92, 0xb2, 0x16,
+};
+static const size_t TEST_DVPT256_221_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_221_EXPECTED[] = {
+    0x76, 0xbd, 0xd9, 0xa7, 0xb3, 0x4b, 0xf1, 0x4a,
+    0xe1, 0x21, 0xa8, 0x7f, 0xdf, 0xa1, 0x44, 0xf7,
+    0x1b, 0x84, 0x87, 0x44, 0xaf, 0x6a, 0x2f, 0x0b,
+    0x1c, 0x0d, 0x06, 0x7c,
+};
+static const size_t TEST_DVPT256_221_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_221_INPUT[] = {
+    0x79, 0x4e, 0x73, 0x49, 0x66, 0xe6, 0xd0, 0x00,
+    0x16, 0x99, 0xae, 0xc3, 0xf8, 0xab, 0x8f, 0x19,
+    0x4d, 0xe7, 0x65, 0x3d, 0x30, 0x91, 0xb1, 0xb9,
+};
+static const size_t TEST_DVPT256_221_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_223_NONCE[] = {
+    0x35, 0x42, 0xfb, 0xe0, 0xf5, 0x9a, 0x6d, 0x5f,
+    0x3a, 0xbf, 0x61, 0x9b, 0x7d,
+};
+static const size_t TEST_DVPT256_223_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_223_ADATA[] = {
+    0xdd, 0x45, 0x31, 0xf1, 0x58, 0xa2, 0xfa, 0x3b,
+    0xc8, 0xa3, 0x39, 0xf7, 0x70, 0x59, 0x50, 0x48,
+    0xf4, 0xa4, 0x2b, 0xc1, 0xb0, 0x3f, 0x2e, 0x82,
+    0x4e, 0xfc, 0x6b, 0xa4, 0x98, 0x51, 0x19, 0xd8,
+};
+static const size_t TEST_DVPT256_223_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_223_EXPECTED[] = {
+    0x61, 0x7d, 0x80, 0x36, 0xe2, 0x03, 0x9d, 0x51,
+    0x67, 0x09, 0x06, 0x23, 0x79, 0xe0, 0x55, 0x0c,
+    0xbd, 0x71, 0xeb, 0xb9, 0x0f, 0xea, 0x96, 0x7c,
+    0x79, 0x01, 0x8a, 0xd5,
+};
+static const size_t TEST_DVPT256_223_EXPECTED_LEN = 28;
+
+static const uint8_t TEST_DVPT256_223_INPUT[] = {
+    0xc5, 0xb3, 0xd7, 0x13, 0x12, 0xea, 0x14, 0xf2,
+    0xf8, 0xfa, 0xe5, 0xbd, 0x1a, 0x45, 0x31, 0x92,
+    0xb6, 0x60, 0x4a, 0x45, 0xdb, 0x75, 0xc5, 0xed,
+};
+static const size_t TEST_DVPT256_223_INPUT_LEN = 24;
+
+/* Alen = 32, Plen = 24, Nlen = 13, Tlen = 16 */
+static const uint8_t TEST_DVPT256_GROUP_15_MAC_LEN = 16;
+
+static const uint8_t TEST_DVPT256_GROUP_15_KEY[] = {
+    0x31, 0x4a, 0x20, 0x2f, 0x83, 0x6f, 0x9f, 0x25,
+    0x7e, 0x22, 0xd8, 0xc1, 0x17, 0x57, 0x83, 0x2a,
+    0xe5, 0x13, 0x1d, 0x35, 0x7a, 0x72, 0xdf, 0x88,
+    0xf3, 0xef, 0xf0, 0xff, 0xce, 0xe0, 0xda, 0x4e,
+};
+static const size_t TEST_DVPT256_GROUP_15_KEY_LEN = 32;
+
+static const uint8_t TEST_DVPT256_225_NONCE[] = {
+    0xa5, 0x44, 0x21, 0x8d, 0xad, 0xd3, 0xc1, 0x05,
+    0x83, 0xdb, 0x49, 0xcf, 0x39,
+};
+static const size_t TEST_DVPT256_225_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_225_ADATA[] = {
+    0x3c, 0x0e, 0x28, 0x15, 0xd3, 0x7d, 0x84, 0x4f,
+    0x7a, 0xc2, 0x40, 0xba, 0x9d, 0x6e, 0x3a, 0x0b,
+    0x2a, 0x86, 0xf7, 0x06, 0xe8, 0x85, 0x95, 0x9e,
+    0x09, 0xa1, 0x00, 0x5e, 0x02, 0x4f, 0x69, 0x07,
+};
+static const size_t TEST_DVPT256_225_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_225_EXPECTED[] = {
+    0x8d, 0x34, 0xcd, 0xca, 0x37, 0xce, 0x77, 0xbe,
+    0x68, 0xf6, 0x5b, 0xaf, 0x33, 0x82, 0xe3, 0x1e,
+    0xfa, 0x69, 0x3e, 0x63, 0xf9, 0x14, 0xa7, 0x81,
+    0x36, 0x7f, 0x30, 0xf2, 0xea, 0xad, 0x8c, 0x06,
+    0x3c, 0xa5, 0x07, 0x95, 0xac, 0xd9, 0x02, 0x03,
+};
+static const size_t TEST_DVPT256_225_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_225_INPUT[] = {
+    0xe8, 0xde, 0x97, 0x0f, 0x6e, 0xe8, 0xe8, 0x0e,
+    0xde, 0x93, 0x35, 0x81, 0xb5, 0xbc, 0xf4, 0xd8,
+    0x37, 0xe2, 0xb7, 0x2b, 0xaa, 0x8b, 0x00, 0xc3,
+};
+static const size_t TEST_DVPT256_225_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_229_NONCE[] = {
+    0x0d, 0xd6, 0x13, 0xc0, 0xfe, 0x28, 0xe9, 0x13,
+    0xc0, 0xed, 0xbb, 0x84, 0x04,
+};
+static const size_t TEST_DVPT256_229_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_229_ADATA[] = {
+    0x2a, 0xd3, 0x06, 0x57, 0x5b, 0x57, 0x7c, 0x2f,
+    0x61, 0xda, 0x72, 0x12, 0xab, 0x63, 0xe3, 0xdb,
+    0x39, 0x41, 0xf1, 0xf7, 0x51, 0xf2, 0x35, 0x6c,
+    0x74, 0x43, 0x53, 0x1a, 0x90, 0xb9, 0xd1, 0x41,
+};
+static const size_t TEST_DVPT256_229_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_229_EXPECTED[] = {
+    0x6d, 0xf0, 0x96, 0x13, 0xea, 0x98, 0x6c, 0x2d,
+    0x91, 0xa5, 0x7a, 0x45, 0xa0, 0x94, 0x2c, 0xbf,
+    0x20, 0xe0, 0xdf, 0xca, 0x12, 0xfb, 0xda, 0x8c,
+    0x94, 0x5e, 0xe6, 0xdb, 0x24, 0xae, 0xa5, 0xf5,
+    0x09, 0x89, 0x52, 0xf1, 0x20, 0x33, 0x39, 0xce,
+};
+static const size_t TEST_DVPT256_229_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_229_INPUT[] = {
+    0x95, 0x22, 0xfb, 0x1f, 0x1a, 0xa5, 0x84, 0x93,
+    0xcb, 0xa6, 0x82, 0xd7, 0x88, 0x18, 0x6d, 0x90,
+    0x2c, 0xfc, 0x93, 0xe8, 0x0f, 0xd6, 0xb9, 0x98,
+};
+static const size_t TEST_DVPT256_229_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_231_NONCE[] = {
+    0x3e, 0x0f, 0xe3, 0x42, 0x7e, 0xed, 0xa8, 0x0f,
+    0x02, 0xdd, 0xa4, 0xfe, 0xd5,
+};
+static const size_t TEST_DVPT256_231_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_231_ADATA[] = {
+    0xae, 0x0d, 0x1c, 0x9c, 0x83, 0x4d, 0x60, 0xff,
+    0x0e, 0xcf, 0xb3, 0xc0, 0xd7, 0x8c, 0x72, 0xdd,
+    0xb7, 0x89, 0xe5, 0x8a, 0xdf, 0xc1, 0x66, 0xc8,
+    0x1d, 0x5f, 0xc6, 0x39, 0x5b, 0x31, 0xec, 0x33,
+};
+static const size_t TEST_DVPT256_231_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_231_EXPECTED[] = {
+    0x2b, 0xfe, 0x51, 0xf1, 0xf4, 0x3b, 0x98, 0x2d,
+    0x47, 0xf7, 0x6e, 0xa8, 0x20, 0x6d, 0xdb, 0xf5,
+    0x85, 0xd6, 0xf3, 0x0c, 0xec, 0x0d, 0x4e, 0xf1,
+    0x6b, 0x15, 0x56, 0x63, 0x1d, 0x3b, 0x52, 0xbf,
+    0x24, 0x15, 0x4a, 0xfe, 0xc1, 0x44, 0x8e, 0xf6,
+};
+static const size_t TEST_DVPT256_231_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_231_INPUT[] = {
+    0x38, 0x33, 0x3c, 0xe7, 0x81, 0x10, 0xbf, 0x53,
+    0xa2, 0xc2, 0xab, 0xc7, 0xdb, 0x99, 0xe1, 0x33,
+    0xad, 0x21, 0x8c, 0xa4, 0x3f, 0xf7, 0xa7, 0xbc,
+};
+static const size_t TEST_DVPT256_231_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_236_NONCE[] = {
+    0x60, 0x12, 0x2c, 0xbd, 0x21, 0x9e, 0x5c, 0xf1,
+    0x74, 0x15, 0xe8, 0xbc, 0x09,
+};
+static const size_t TEST_DVPT256_236_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_236_ADATA[] = {
+    0x89, 0x5a, 0x45, 0xdd, 0xbe, 0x0c, 0x80, 0x79,
+    0x3e, 0xcc, 0xbf, 0x82, 0x0d, 0xe1, 0x3a, 0x23,
+    0x3b, 0x6a, 0xa7, 0x04, 0x5c, 0xfd, 0x53, 0x13,
+    0x38, 0x8e, 0x71, 0x84, 0xc3, 0x92, 0xb2, 0x16,
+};
+static const size_t TEST_DVPT256_236_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_236_EXPECTED[] = {
+    0xbf, 0x0d, 0x21, 0x9b, 0xb5, 0x0f, 0xcc, 0x1d,
+    0x51, 0xf6, 0x54, 0xbb, 0x0f, 0xd8, 0xb4, 0x4e,
+    0xfa, 0x25, 0xae, 0xf3, 0x9e, 0x2f, 0x11, 0xaf,
+    0xe4, 0x7d, 0x00, 0xf2, 0xee, 0xbb, 0x54, 0x4e,
+    0x6b, 0xa7, 0x55, 0x9a, 0xc2, 0xf3, 0x4e, 0xdb,
+};
+static const size_t TEST_DVPT256_236_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_236_INPUT[] = {
+    0x79, 0x4e, 0x73, 0x49, 0x66, 0xe6, 0xd0, 0x00,
+    0x16, 0x99, 0xae, 0xc3, 0xf8, 0xab, 0x8f, 0x19,
+    0x4d, 0xe7, 0x65, 0x3d, 0x30, 0x91, 0xb1, 0xb9,
+};
+static const size_t TEST_DVPT256_236_INPUT_LEN = 24;
+
+static const uint8_t TEST_DVPT256_238_NONCE[] = {
+    0x35, 0x42, 0xfb, 0xe0, 0xf5, 0x9a, 0x6d, 0x5f,
+    0x3a, 0xbf, 0x61, 0x9b, 0x7d,
+};
+static const size_t TEST_DVPT256_238_NONCE_LEN = 13;
+
+static const uint8_t TEST_DVPT256_238_ADATA[] = {
+    0xdd, 0x45, 0x31, 0xf1, 0x58, 0xa2, 0xfa, 0x3b,
+    0xc8, 0xa3, 0x39, 0xf7, 0x70, 0x59, 0x50, 0x48,
+    0xf4, 0xa4, 0x2b, 0xc1, 0xb0, 0x3f, 0x2e, 0x82,
+    0x4e, 0xfc, 0x6b, 0xa4, 0x98, 0x51, 0x19, 0xd8,
+};
+static const size_t TEST_DVPT256_238_ADATA_LEN = 32;
+
+static const uint8_t TEST_DVPT256_238_EXPECTED[] = {
+    0x39, 0xc2, 0xe8, 0xf6, 0xed, 0xfe, 0x66, 0x3b,
+    0x90, 0x96, 0x3b, 0x98, 0xeb, 0x79, 0xe2, 0xd4,
+    0xf7, 0xf2, 0x8a, 0x50, 0x53, 0xae, 0x88, 0x81,
+    0x56, 0x7a, 0x6b, 0x44, 0x26, 0xf1, 0x66, 0x71,
+    0x36, 0xbe, 0xd4, 0xa5, 0xe3, 0x2a, 0x2b, 0xc1,
+};
+static const size_t TEST_DVPT256_238_EXPECTED_LEN = 40;
+
+static const uint8_t TEST_DVPT256_238_INPUT[] = {
+    0xc5, 0xb3, 0xd7, 0x13, 0x12, 0xea, 0x14, 0xf2,
+    0xf8, 0xfa, 0xe5, 0xbd, 0x1a, 0x45, 0x31, 0x92,
+    0xb6, 0x60, 0x4a, 0x45, 0xdb, 0x75, 0xc5, 0xed,
+};
+static const size_t TEST_DVPT256_238_INPUT_LEN = 24;
+
+/* Share test buffer output */
+static uint8_t data[512];
+
+static void test_encrypt_op(const uint8_t *key, uint8_t key_len,
+                            const uint8_t *adata, size_t adata_len,
+                            const uint8_t *nonce, uint8_t nonce_len,
+                            const uint8_t *plain, size_t plain_len,
+                            const uint8_t *output_expected,
+                            size_t output_expected_len,
+                            uint8_t mac_length)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    size_t len_encoding = nonce_and_len_encoding_size - nonce_len;
+
+    TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
+                        "Output buffer too small");
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_encrypt_ccm(&cipher, adata, adata_len,
+                             mac_length, len_encoding,
+                             nonce, nonce_len, plain, plain_len, data);
+    TEST_ASSERT_MESSAGE(len > 0, "Encryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_expected_len, len);
+    cmp = compare(output_expected, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+}
+
+static void test_decrypt_op(const uint8_t *key, uint8_t key_len,
+                            const uint8_t *adata, size_t adata_len,
+                            const uint8_t *nonce, uint8_t nonce_len,
+                            const uint8_t *encrypted, size_t encrypted_len,
+                            const uint8_t *output_expected,
+                            size_t output_expected_len,
+                            uint8_t mac_length)
+{
+    cipher_t cipher;
+    int len, err, cmp;
+    size_t len_encoding = nonce_and_len_encoding_size - nonce_len;
+
+    TEST_ASSERT_MESSAGE(sizeof(data) >= output_expected_len,
+                        "Output buffer too small");
+
+    err = cipher_init(&cipher, CIPHER_AES, key, key_len);
+    TEST_ASSERT_EQUAL_INT(1, err);
+
+    len = cipher_decrypt_ccm(&cipher, adata, adata_len,
+                             mac_length, len_encoding,
+                             nonce, nonce_len, encrypted, encrypted_len, data);
+    TEST_ASSERT_MESSAGE(len >= 0, "Decryption failed");
+
+    TEST_ASSERT_EQUAL_INT(output_expected_len, len);
+    cmp = compare(output_expected, data, len);
+    TEST_ASSERT_MESSAGE(1 == cmp, "wrong ciphertext");
+
+}
+
+#define do_test_encrypt_op(prefix, test_num, group_num) do { \
+        test_encrypt_op(TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED_LEN, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _MAC_LEN \
+                        ); \
+} while (0)
+
+#define do_test_decrypt_op(prefix, test_num, group_num) do { \
+        test_decrypt_op(TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _KEY_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA, \
+                        TEST_ ## prefix ## _ ## test_num ## _ADATA_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE, \
+                        TEST_ ## prefix ## _ ## test_num ## _NONCE_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED, \
+                        TEST_ ## prefix ## _ ## test_num ## _EXPECTED_LEN, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT, \
+                        TEST_ ## prefix ## _ ## test_num ## _INPUT_LEN, \
+                        TEST_ ## prefix ## _GROUP_ ## group_num ## _MAC_LEN \
+                        ); \
+} while (0)
+
+static void test_crypto_modes_ccm_decrypt(void)
+{
+    do_test_decrypt_op(DVPT256, 0, 0);
+    do_test_decrypt_op(DVPT256, 4, 0);
+    do_test_decrypt_op(DVPT256, 6, 0);
+    do_test_decrypt_op(DVPT256, 11, 0);
+    do_test_decrypt_op(DVPT256, 13, 0);
+    do_test_decrypt_op(DVPT256, 15, 1);
+    do_test_decrypt_op(DVPT256, 19, 1);
+    do_test_decrypt_op(DVPT256, 21, 1);
+    do_test_decrypt_op(DVPT256, 26, 1);
+    do_test_decrypt_op(DVPT256, 28, 1);
+    do_test_decrypt_op(DVPT256, 30, 2);
+    do_test_decrypt_op(DVPT256, 34, 2);
+    do_test_decrypt_op(DVPT256, 36, 2);
+    do_test_decrypt_op(DVPT256, 41, 2);
+    do_test_decrypt_op(DVPT256, 43, 2);
+    do_test_decrypt_op(DVPT256, 45, 3);
+    do_test_decrypt_op(DVPT256, 49, 3);
+    do_test_decrypt_op(DVPT256, 51, 3);
+    do_test_decrypt_op(DVPT256, 56, 3);
+    do_test_decrypt_op(DVPT256, 58, 3);
+    do_test_decrypt_op(DVPT256, 60, 4);
+    do_test_decrypt_op(DVPT256, 64, 4);
+    do_test_decrypt_op(DVPT256, 66, 4);
+    do_test_decrypt_op(DVPT256, 71, 4);
+    do_test_decrypt_op(DVPT256, 73, 4);
+    do_test_decrypt_op(DVPT256, 75, 5);
+    do_test_decrypt_op(DVPT256, 79, 5);
+    do_test_decrypt_op(DVPT256, 81, 5);
+    do_test_decrypt_op(DVPT256, 86, 5);
+    do_test_decrypt_op(DVPT256, 88, 5);
+    do_test_decrypt_op(DVPT256, 90, 6);
+    do_test_decrypt_op(DVPT256, 94, 6);
+    do_test_decrypt_op(DVPT256, 96, 6);
+    do_test_decrypt_op(DVPT256, 101, 6);
+    do_test_decrypt_op(DVPT256, 103, 6);
+    do_test_decrypt_op(DVPT256, 105, 7);
+    do_test_decrypt_op(DVPT256, 109, 7);
+    do_test_decrypt_op(DVPT256, 111, 7);
+    do_test_decrypt_op(DVPT256, 116, 7);
+    do_test_decrypt_op(DVPT256, 118, 7);
+    do_test_decrypt_op(DVPT256, 120, 8);
+    do_test_decrypt_op(DVPT256, 124, 8);
+    do_test_decrypt_op(DVPT256, 126, 8);
+    do_test_decrypt_op(DVPT256, 131, 8);
+    do_test_decrypt_op(DVPT256, 133, 8);
+    do_test_decrypt_op(DVPT256, 135, 9);
+    do_test_decrypt_op(DVPT256, 139, 9);
+    do_test_decrypt_op(DVPT256, 141, 9);
+    do_test_decrypt_op(DVPT256, 146, 9);
+    do_test_decrypt_op(DVPT256, 148, 9);
+    do_test_decrypt_op(DVPT256, 150, 10);
+    do_test_decrypt_op(DVPT256, 154, 10);
+    do_test_decrypt_op(DVPT256, 156, 10);
+    do_test_decrypt_op(DVPT256, 161, 10);
+    do_test_decrypt_op(DVPT256, 163, 10);
+    do_test_decrypt_op(DVPT256, 165, 11);
+    do_test_decrypt_op(DVPT256, 169, 11);
+    do_test_decrypt_op(DVPT256, 171, 11);
+    do_test_decrypt_op(DVPT256, 176, 11);
+    do_test_decrypt_op(DVPT256, 178, 11);
+    do_test_decrypt_op(DVPT256, 180, 12);
+    do_test_decrypt_op(DVPT256, 184, 12);
+    do_test_decrypt_op(DVPT256, 186, 12);
+    do_test_decrypt_op(DVPT256, 191, 12);
+    do_test_decrypt_op(DVPT256, 193, 12);
+    do_test_decrypt_op(DVPT256, 195, 13);
+    do_test_decrypt_op(DVPT256, 199, 13);
+    do_test_decrypt_op(DVPT256, 201, 13);
+    do_test_decrypt_op(DVPT256, 206, 13);
+    do_test_decrypt_op(DVPT256, 208, 13);
+    do_test_decrypt_op(DVPT256, 210, 14);
+    do_test_decrypt_op(DVPT256, 214, 14);
+    do_test_decrypt_op(DVPT256, 216, 14);
+    do_test_decrypt_op(DVPT256, 221, 14);
+    do_test_decrypt_op(DVPT256, 223, 14);
+    do_test_decrypt_op(DVPT256, 225, 15);
+    do_test_decrypt_op(DVPT256, 229, 15);
+    do_test_decrypt_op(DVPT256, 231, 15);
+    do_test_decrypt_op(DVPT256, 236, 15);
+    do_test_decrypt_op(DVPT256, 238, 15);
+}
+static void test_crypto_modes_ccm_encrypt(void)
+{
+    do_test_encrypt_op(DVPT256, 0, 0);
+    do_test_encrypt_op(DVPT256, 4, 0);
+    do_test_encrypt_op(DVPT256, 6, 0);
+    do_test_encrypt_op(DVPT256, 11, 0);
+    do_test_encrypt_op(DVPT256, 13, 0);
+    do_test_encrypt_op(DVPT256, 15, 1);
+    do_test_encrypt_op(DVPT256, 19, 1);
+    do_test_encrypt_op(DVPT256, 21, 1);
+    do_test_encrypt_op(DVPT256, 26, 1);
+    do_test_encrypt_op(DVPT256, 28, 1);
+    do_test_encrypt_op(DVPT256, 30, 2);
+    do_test_encrypt_op(DVPT256, 34, 2);
+    do_test_encrypt_op(DVPT256, 36, 2);
+    do_test_encrypt_op(DVPT256, 41, 2);
+    do_test_encrypt_op(DVPT256, 43, 2);
+    do_test_encrypt_op(DVPT256, 45, 3);
+    do_test_encrypt_op(DVPT256, 49, 3);
+    do_test_encrypt_op(DVPT256, 51, 3);
+    do_test_encrypt_op(DVPT256, 56, 3);
+    do_test_encrypt_op(DVPT256, 58, 3);
+    do_test_encrypt_op(DVPT256, 60, 4);
+    do_test_encrypt_op(DVPT256, 64, 4);
+    do_test_encrypt_op(DVPT256, 66, 4);
+    do_test_encrypt_op(DVPT256, 71, 4);
+    do_test_encrypt_op(DVPT256, 73, 4);
+    do_test_encrypt_op(DVPT256, 75, 5);
+    do_test_encrypt_op(DVPT256, 79, 5);
+    do_test_encrypt_op(DVPT256, 81, 5);
+    do_test_encrypt_op(DVPT256, 86, 5);
+    do_test_encrypt_op(DVPT256, 88, 5);
+    do_test_encrypt_op(DVPT256, 90, 6);
+    do_test_encrypt_op(DVPT256, 94, 6);
+    do_test_encrypt_op(DVPT256, 96, 6);
+    do_test_encrypt_op(DVPT256, 101, 6);
+    do_test_encrypt_op(DVPT256, 103, 6);
+    do_test_encrypt_op(DVPT256, 105, 7);
+    do_test_encrypt_op(DVPT256, 109, 7);
+    do_test_encrypt_op(DVPT256, 111, 7);
+    do_test_encrypt_op(DVPT256, 116, 7);
+    do_test_encrypt_op(DVPT256, 118, 7);
+    do_test_encrypt_op(DVPT256, 120, 8);
+    do_test_encrypt_op(DVPT256, 124, 8);
+    do_test_encrypt_op(DVPT256, 126, 8);
+    do_test_encrypt_op(DVPT256, 131, 8);
+    do_test_encrypt_op(DVPT256, 133, 8);
+    do_test_encrypt_op(DVPT256, 135, 9);
+    do_test_encrypt_op(DVPT256, 139, 9);
+    do_test_encrypt_op(DVPT256, 141, 9);
+    do_test_encrypt_op(DVPT256, 146, 9);
+    do_test_encrypt_op(DVPT256, 148, 9);
+    do_test_encrypt_op(DVPT256, 150, 10);
+    do_test_encrypt_op(DVPT256, 154, 10);
+    do_test_encrypt_op(DVPT256, 156, 10);
+    do_test_encrypt_op(DVPT256, 161, 10);
+    do_test_encrypt_op(DVPT256, 163, 10);
+    do_test_encrypt_op(DVPT256, 165, 11);
+    do_test_encrypt_op(DVPT256, 169, 11);
+    do_test_encrypt_op(DVPT256, 171, 11);
+    do_test_encrypt_op(DVPT256, 176, 11);
+    do_test_encrypt_op(DVPT256, 178, 11);
+    do_test_encrypt_op(DVPT256, 180, 12);
+    do_test_encrypt_op(DVPT256, 184, 12);
+    do_test_encrypt_op(DVPT256, 186, 12);
+    do_test_encrypt_op(DVPT256, 191, 12);
+    do_test_encrypt_op(DVPT256, 193, 12);
+    do_test_encrypt_op(DVPT256, 195, 13);
+    do_test_encrypt_op(DVPT256, 199, 13);
+    do_test_encrypt_op(DVPT256, 201, 13);
+    do_test_encrypt_op(DVPT256, 206, 13);
+    do_test_encrypt_op(DVPT256, 208, 13);
+    do_test_encrypt_op(DVPT256, 210, 14);
+    do_test_encrypt_op(DVPT256, 214, 14);
+    do_test_encrypt_op(DVPT256, 216, 14);
+    do_test_encrypt_op(DVPT256, 221, 14);
+    do_test_encrypt_op(DVPT256, 223, 14);
+    do_test_encrypt_op(DVPT256, 225, 15);
+    do_test_encrypt_op(DVPT256, 229, 15);
+    do_test_encrypt_op(DVPT256, 231, 15);
+    do_test_encrypt_op(DVPT256, 236, 15);
+    do_test_encrypt_op(DVPT256, 238, 15);
+}
+
+Test *tests_crypto_modes_ccm_tests_256(void)
+{
+    EMB_UNIT_TESTFIXTURES(fixtures) {
+        new_TestFixture(test_crypto_modes_ccm_encrypt),
+        new_TestFixture(test_crypto_modes_ccm_decrypt),
+    };
+
+    EMB_UNIT_TESTCALLER(crypto_modes_ccm_tests_256, NULL, NULL, fixtures);
+
+    return (Test *)&crypto_modes_ccm_tests_256;
+}
diff --git a/tests/sys_crypto_aes_ccm/tests-crypto.h b/tests/sys_crypto_aes_ccm/tests-crypto.h
new file mode 100644
index 0000000000..ef65c1ca3e
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/tests-crypto.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2021 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @addtogroup  unittests
+ * @{
+ *
+ * @file
+ * @brief       Unittests for the ``crypto`` module
+ *
+ * @author      Nils Ollrogge <nils-ollrogge@outlook.de>
+ */
+#ifndef TESTS_CRYPTO_H
+#define TESTS_CRYPTO_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "embUnit.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static inline int compare(const uint8_t *a, const uint8_t *b, uint8_t len)
+{
+    int result = 1;
+
+    for (uint8_t i = 0; i < len; ++i) {
+        result &= a[i] == b[i];
+    }
+
+    return result;
+}
+
+Test *tests_crypto_modes_ccm_tests_128(void);
+Test *tests_crypto_modes_ccm_tests_192(void);
+Test *tests_crypto_modes_ccm_tests_256(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TESTS_CRYPTO_H */
+/** @} */
diff --git a/tests/sys_crypto_aes_ccm/tests/01-run.py b/tests/sys_crypto_aes_ccm/tests/01-run.py
new file mode 100755
index 0000000000..aec47345a2
--- /dev/null
+++ b/tests/sys_crypto_aes_ccm/tests/01-run.py
@@ -0,0 +1,14 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2019 Freie Universität Berlin
+#
+# This file is subject to the terms and conditions of the GNU Lesser
+# General Public License v2.1. See the file LICENSE in the top level
+# directory for more details.
+
+import sys
+from testrunner import run_check_unittests
+
+
+if __name__ == "__main__":
+    sys.exit(run_check_unittests())
diff --git a/tests/touch_dev/Makefile b/tests/touch_dev/Makefile
index 8c26eadd1c..6eea9d19e3 100644
--- a/tests/touch_dev/Makefile
+++ b/tests/touch_dev/Makefile
@@ -3,7 +3,6 @@ include ../Makefile.tests_common
 
 DISABLE_MODULE += test_utils_interactive_sync
 
-USEMODULE += stmpe811
 USEMODULE += touch_dev
 USEMODULE += xtimer
 
diff --git a/tests/touch_dev/main.c b/tests/touch_dev/main.c
index a1710d31ec..f74e0c9d70 100644
--- a/tests/touch_dev/main.c
+++ b/tests/touch_dev/main.c
@@ -25,13 +25,10 @@
 
 #include "touch_dev.h"
 
+#if IS_USED(MODULE_STMPE811)
 #include "stmpe811.h"
-#include "stmpe811_params.h"
-#include "stmpe811_touch_dev.h"
-
 #include "test_utils/expect.h"
-
-static stmpe811_t stmpe811;
+#endif
 
 static void _touch_event_cb(void *arg)
 {
@@ -41,22 +38,29 @@ static void _touch_event_cb(void *arg)
 
 int main(void)
 {
-    stmpe811_init(&stmpe811, &stmpe811_params[0], _touch_event_cb, NULL);
+    /* Use the first screen */
+    touch_dev_reg_t *touch_dev = touch_dev_reg_find_screen(0);
+    if (!touch_dev) {
+        puts("No screen found!");
+        return -1;
+    }
 
-    touch_dev_t *dev = (touch_dev_t *)&stmpe811;
-    dev->driver = &stmpe811_touch_dev_driver;
+    touch_dev_set_touch_event_callback(touch_dev->dev, _touch_event_cb, NULL);
 
-    uint16_t xmax = touch_dev_width(dev);
-    uint16_t ymax = touch_dev_height(dev);
+#if IS_USED(MODULE_STMPE811)
+    uint16_t xmax = touch_dev_width(touch_dev->dev);
+    uint16_t ymax = touch_dev_height(touch_dev->dev);
 
-    expect(xmax == stmpe811.params.xmax);
-    expect(ymax == stmpe811.params.ymax);
+    stmpe811_t *stmpe811 = (stmpe811_t *)touch_dev->dev;
+    expect(xmax == stmpe811->params.xmax);
+    expect(ymax == stmpe811->params.ymax);
+#endif
 
-    uint8_t last_touches = touch_dev_touches(dev, NULL, 1);
+    uint8_t last_touches = touch_dev_touches(touch_dev->dev, NULL, 1);
 
     while (1) {
         touch_t touches[1];
-        uint8_t current_touches = touch_dev_touches(dev, touches, 1);
+        uint8_t current_touches = touch_dev_touches(touch_dev->dev, touches, 1);
 
         if (current_touches != last_touches) {
             if (current_touches == 0) {
diff --git a/tests/trickle/main.c b/tests/trickle/main.c
index d8859d9d32..d5a246d794 100644
--- a/tests/trickle/main.c
+++ b/tests/trickle/main.c
@@ -23,6 +23,11 @@
 #include "trickle.h"
 #include "thread.h"
 #include "msg.h"
+#if IS_USED(MODULE_ZTIMER_MSEC)
+#include "ztimer.h"
+#else
+#include "xtimer.h"
+#endif
 
 #define TRICKLE_MSG     (0xfeef)
 #define TR_IMIN         (8)
@@ -45,7 +50,11 @@ static trickle_t trickle = { .callback = { .func = &callback,
 static void callback(void *args)
 {
     (void) args;
+#if IS_USED(MODULE_ZTIMER_MSEC)
+    uint32_t now = ztimer_now(ZTIMER_MSEC);
+#else
     uint32_t now = xtimer_now_usec();
+#endif
 
     printf("now = %" PRIu32 ", t = %" PRIu32 "\n", now, trickle.t);
 
diff --git a/tests/turo/tests/01-run.py b/tests/turo/tests/01-run.py
index 1476f58570..2d8ed0bcec 100755
--- a/tests/turo/tests/01-run.py
+++ b/tests/turo/tests/01-run.py
@@ -21,10 +21,10 @@ class TestTuroBase(unittest.TestCase):
     @classmethod
     def setUpClass(cls):
         cls.ctrl = RIOTCtrl()
+        cls.ctrl.reset()
         cls.ctrl.start_term()
         if cls.DEBUG:
             cls.ctrl.term.logfile = sys.stdout
-        cls.ctrl.reset()
         cls.shell = ShellInteraction(cls.ctrl)
         cls.json_parser = RapidJSONShellInteractionParser()
         cls.logger = logging.getLogger(cls.__name__)
diff --git a/tests/unittests/Makefile.ci b/tests/unittests/Makefile.ci
index 59bf38a694..fdea7a8a3d 100644
--- a/tests/unittests/Makefile.ci
+++ b/tests/unittests/Makefile.ci
@@ -79,6 +79,7 @@ BOARD_INSUFFICIENT_MEMORY := \
     nucleo-l412kb \
     nucleo-l432kc \
     nucleo-l433rc \
+    nucleo-wl55jc \
     nz32-sc151 \
     olimexino-stm32 \
     opencm904 \
diff --git a/tests/unittests/tests-core/tests-core-lifo.c b/tests/unittests/tests-core/tests-core-lifo.c
deleted file mode 100644
index d60e26dbc2..0000000000
--- a/tests/unittests/tests-core/tests-core-lifo.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2014 Martine Lenders <mlenders@inf.fu-berlin.de>
- *
- * This file is subject to the terms and conditions of the GNU Lesser
- * General Public License v2.1. See the file LICENSE in the top level
- * directory for more details.
- */
-
-#include "embUnit.h"
-
-#include "lifo.h"
-
-#include "tests-core.h"
-
-#define TEST_LIFO_MAX_ELEM   2
-
-int lifo[TEST_LIFO_MAX_ELEM + 1];
-
-static void set_up(void)
-{
-    lifo_init(lifo, TEST_LIFO_MAX_ELEM);
-}
-
-static void test_lifo_empty(void)
-{
-    TEST_ASSERT(lifo_empty(lifo));
-}
-
-static void test_lifo_insert(void)
-{
-    lifo_insert(lifo, 0);
-    TEST_ASSERT(!lifo_empty(lifo));
-}
-
-static void test_lifo_get_one(void)
-{
-    lifo_insert(lifo, 0);
-    TEST_ASSERT_EQUAL_INT(0, lifo_get(lifo));
-}
-
-static void test_lifo_get_two(void)
-{
-    lifo_insert(lifo, 0);
-    lifo_insert(lifo, 1);
-    TEST_ASSERT_EQUAL_INT(1, lifo_get(lifo));
-    TEST_ASSERT_EQUAL_INT(0, lifo_get(lifo));
-}
-
-Test *tests_core_lifo_tests(void)
-{
-    EMB_UNIT_TESTFIXTURES(fixtures) {
-        new_TestFixture(test_lifo_empty),
-        new_TestFixture(test_lifo_insert),
-        new_TestFixture(test_lifo_get_one),
-        new_TestFixture(test_lifo_get_two),
-    };
-
-    EMB_UNIT_TESTCALLER(core_lifo_tests, set_up, NULL, fixtures);
-
-    return (Test *)&core_lifo_tests;
-}
diff --git a/tests/unittests/tests-core/tests-core.c b/tests/unittests/tests-core/tests-core.c
index fe7dfe2af5..8dabaa3816 100644
--- a/tests/unittests/tests-core/tests-core.c
+++ b/tests/unittests/tests-core/tests-core.c
@@ -14,7 +14,6 @@ void tests_core(void)
     TESTS_RUN(tests_core_bitarithm_tests());
     TESTS_RUN(tests_core_cib_tests());
     TESTS_RUN(tests_core_clist_tests());
-    TESTS_RUN(tests_core_lifo_tests());
     TESTS_RUN(tests_core_list_tests());
     TESTS_RUN(tests_core_priority_queue_tests());
     TESTS_RUN(tests_core_byteorder_tests());
diff --git a/tests/unittests/tests-core/tests-core.h b/tests/unittests/tests-core/tests-core.h
index 294e888fe0..4f7f0594d7 100644
--- a/tests/unittests/tests-core/tests-core.h
+++ b/tests/unittests/tests-core/tests-core.h
@@ -57,13 +57,6 @@ Test *tests_core_cib_tests(void);
  */
 Test *tests_core_clist_tests(void);
 
-/**
- * @brief   Generates tests for lifo.h
- *
- * @return  embUnit tests if successful, NULL if not.
- */
-Test *tests_core_lifo_tests(void);
-
 /**
  * @brief   Generates tests for list.h
  *
diff --git a/tests/unittests/tests-hashes/Makefile.include b/tests/unittests/tests-hashes/Makefile.include
index d25437ed3f..9c5493cf91 100644
--- a/tests/unittests/tests-hashes/Makefile.include
+++ b/tests/unittests/tests-hashes/Makefile.include
@@ -1,2 +1,2 @@
 USEMODULE += hashes
-USEMODULE += crypto_aes
+USEMODULE += crypto_aes_128
diff --git a/tests/unittests/tests-ieee802154/tests-ieee802154.c b/tests/unittests/tests-ieee802154/tests-ieee802154.c
index ee202466a5..b3e666ba9f 100644
--- a/tests/unittests/tests-ieee802154/tests-ieee802154.c
+++ b/tests/unittests/tests-ieee802154/tests-ieee802154.c
@@ -953,6 +953,128 @@ static void test_ieee802154_get_dst_dst8_pancomp(void)
     TEST_ASSERT_EQUAL_INT(exp_pan.u16, res_pan.u16);
 }
 
+static void test_ieee802154_dst_filter_pan_fail(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const le_uint16_t exp_pan = byteorder_htols(TEST_UINT16 + 1);
+    const uint8_t mhr[] = { 0,
+                            IEEE802154_FCF_DST_ADDR_SHORT,
+                            TEST_UINT8,
+                            exp_pan.u8[0], exp_pan.u8[1],
+                            exp_addr.u8[1], exp_addr.u8[0] };
+    TEST_ASSERT_EQUAL_INT(1, ieee802154_dst_filter(mhr,
+                                                   exp_pan.u16 + 1,
+                                                   exp_addr,
+                                                   &long_addr));
+}
+
+static void test_ieee802154_dst_filter_short_addr_fail(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const le_uint16_t exp_pan = byteorder_htols(TEST_UINT16 + 1);
+    const uint8_t mhr[] = { 0,
+                            IEEE802154_FCF_DST_ADDR_SHORT,
+                            TEST_UINT8,
+                            exp_pan.u8[0], exp_pan.u8[1],
+                            exp_addr.u8[1], exp_addr.u8[0] };
+    TEST_ASSERT_EQUAL_INT(1, ieee802154_dst_filter(mhr,
+                                                   exp_pan.u16,
+                                                   byteorder_htons(exp_addr.u16 + 1),
+                                                   &long_addr));
+}
+
+static void test_ieee802154_dst_filter_long_addr_fail(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const le_uint16_t exp_pan = byteorder_htols(TEST_UINT16 + 1);
+    const eui64_t long_addr_fail =  {.uint64.u64 = TEST_UINT64 + 1};
+    const uint8_t mhr[] = { IEEE802154_FCF_PAN_COMP,
+                            IEEE802154_FCF_DST_ADDR_LONG,
+                            TEST_UINT8,
+                            exp_pan.u8[0], exp_pan.u8[1],
+                            long_addr.uint8[7], long_addr.uint8[6],
+                            long_addr.uint8[5], long_addr.uint8[4],
+                            long_addr.uint8[3], long_addr.uint8[2],
+                            long_addr.uint8[1], long_addr.uint8[0] };
+    TEST_ASSERT_EQUAL_INT(1, ieee802154_dst_filter(mhr,
+                                                   exp_pan.u16,
+                                                   exp_addr,
+                                                   &long_addr_fail));
+}
+
+static void test_ieee802154_dst_filter_pan_short(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const le_uint16_t exp_pan = byteorder_htols(TEST_UINT16 + 1);
+    const uint8_t mhr[] = { 0,
+                            IEEE802154_FCF_DST_ADDR_SHORT,
+                            TEST_UINT8,
+                            exp_pan.u8[0], exp_pan.u8[1],
+                            exp_addr.u8[1], exp_addr.u8[0] };
+    TEST_ASSERT_EQUAL_INT(0, ieee802154_dst_filter(mhr,
+                                                   exp_pan.u16,
+                                                   exp_addr,
+                                                   &long_addr));
+}
+
+static void test_ieee802154_dst_filter_bcast_short(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const uint8_t pan_bcast[] = IEEE802154_PANID_BCAST;
+    const uint8_t mhr[] = { 0,
+                            IEEE802154_FCF_DST_ADDR_SHORT,
+                            TEST_UINT8,
+                            pan_bcast[0], pan_bcast[1],
+                            exp_addr.u8[1], exp_addr.u8[0] };
+    TEST_ASSERT_EQUAL_INT(0, ieee802154_dst_filter(mhr,
+                                                   TEST_UINT16,
+                                                   exp_addr,
+                                                   &long_addr));
+}
+
+static void test_ieee802154_dst_filter_pan_long(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const le_uint16_t exp_pan = byteorder_htols(TEST_UINT16 + 1);
+    const uint8_t mhr[] = { IEEE802154_FCF_PAN_COMP,
+                            IEEE802154_FCF_DST_ADDR_LONG,
+                            TEST_UINT8,
+                            exp_pan.u8[0], exp_pan.u8[1],
+                            long_addr.uint8[7], long_addr.uint8[6],
+                            long_addr.uint8[5], long_addr.uint8[4],
+                            long_addr.uint8[3], long_addr.uint8[2],
+                            long_addr.uint8[1], long_addr.uint8[0] };
+    TEST_ASSERT_EQUAL_INT(0, ieee802154_dst_filter(mhr,
+                                                   exp_pan.u16,
+                                                   exp_addr,
+                                                   &long_addr));
+}
+
+static void test_ieee802154_dst_filter_bcast_long(void)
+{
+    const network_uint16_t exp_addr = byteorder_htons(TEST_UINT16);
+    const eui64_t long_addr = {.uint64.u64 = TEST_UINT64};
+    const uint8_t pan_bcast[] = IEEE802154_PANID_BCAST;
+    const uint8_t mhr[] = { IEEE802154_FCF_PAN_COMP,
+                            IEEE802154_FCF_DST_ADDR_LONG,
+                            TEST_UINT8,
+                            pan_bcast[0], pan_bcast[1],
+                            long_addr.uint8[7], long_addr.uint8[6],
+                            long_addr.uint8[5], long_addr.uint8[4],
+                            long_addr.uint8[3], long_addr.uint8[2],
+                            long_addr.uint8[1], long_addr.uint8[0] };
+    TEST_ASSERT_EQUAL_INT(0, ieee802154_dst_filter(mhr,
+                                                   TEST_UINT16,
+                                                   exp_addr,
+                                                   &long_addr));
+}
+
 static void test_ieee802154_get_seq(void)
 {
     const uint8_t mhr[] = { 0x00, 0x00, TEST_UINT8 };
@@ -1088,6 +1210,13 @@ Test *tests_ieee802154_tests(void)
         new_TestFixture(test_ieee802154_get_dst_dst2_pancomp),
         new_TestFixture(test_ieee802154_get_dst_dst8),
         new_TestFixture(test_ieee802154_get_dst_dst8_pancomp),
+        new_TestFixture(test_ieee802154_dst_filter_pan_fail),
+        new_TestFixture(test_ieee802154_dst_filter_short_addr_fail),
+        new_TestFixture(test_ieee802154_dst_filter_long_addr_fail),
+        new_TestFixture(test_ieee802154_dst_filter_pan_short),
+        new_TestFixture(test_ieee802154_dst_filter_bcast_short),
+        new_TestFixture(test_ieee802154_dst_filter_pan_long),
+        new_TestFixture(test_ieee802154_dst_filter_bcast_long),
         new_TestFixture(test_ieee802154_get_seq),
         new_TestFixture(test_ieee802154_get_iid_addr_len_0),
         new_TestFixture(test_ieee802154_get_iid_addr_len_SIZE_MAX),
diff --git a/tests/unittests/tests-ipv4_addr/tests-ipv4_addr.c b/tests/unittests/tests-ipv4_addr/tests-ipv4_addr.c
index 5bf790dd76..1fa1538045 100644
--- a/tests/unittests/tests-ipv4_addr/tests-ipv4_addr.c
+++ b/tests/unittests/tests-ipv4_addr/tests-ipv4_addr.c
@@ -54,7 +54,7 @@ static void test_ipv4_addr_to_str__addr_NULL(void)
 
 static void test_ipv4_addr_to_str__result_NULL(void)
 {
-    ipv4_addr_t a;
+    ipv4_addr_t a = {0};
 
     TEST_ASSERT_NULL(ipv4_addr_to_str(NULL, &a, IPV4_ADDR_MAX_STR_LEN));
 }
diff --git a/tests/unittests/tests-ipv6_addr/tests-ipv6_addr.c b/tests/unittests/tests-ipv6_addr/tests-ipv6_addr.c
index 18b0578207..1248f6dfd7 100644
--- a/tests/unittests/tests-ipv6_addr/tests-ipv6_addr.c
+++ b/tests/unittests/tests-ipv6_addr/tests-ipv6_addr.c
@@ -826,7 +826,7 @@ static void test_ipv6_addr_to_str__addr_NULL(void)
 
 static void test_ipv6_addr_to_str__result_NULL(void)
 {
-    ipv6_addr_t a;
+    ipv6_addr_t a = {0};
 
     TEST_ASSERT_NULL(ipv6_addr_to_str(NULL, &a, IPV6_ADDR_MAX_STR_LEN));
 }
diff --git a/tests/ztimer_periodic/Makefile.ci b/tests/ztimer_periodic/Makefile.ci
new file mode 100644
index 0000000000..b9ff275375
--- /dev/null
+++ b/tests/ztimer_periodic/Makefile.ci
@@ -0,0 +1,3 @@
+BOARD_INSUFFICIENT_MEMORY := \
+    nucleo-l011k4 \
+    #
diff --git a/tests/ztimer_periodic/main.c b/tests/ztimer_periodic/main.c
index 71673a52d7..16cbf705f9 100644
--- a/tests/ztimer_periodic/main.c
+++ b/tests/ztimer_periodic/main.c
@@ -32,62 +32,73 @@
 
 static mutex_t _mutex = MUTEX_INIT_LOCKED;
 
-#define MAX_OFFSET 2
 #define N 5
-#define INTERVAL 100LU
 
 static uint32_t _times[N];
+static int _count;
+#define CLOCKS { ZTIMER_MSEC, ZTIMER_USEC }
+static const char *_names[] = { "ZTIMER_MSEC", "ZTIMER_USEC" };
+static uint32_t _intervals[] = { 100, 10000 };
+static uint32_t _max_offsets[] = { 2, 100 };
 
 static int callback(void *arg)
 {
-    (void)arg;
-    static int count = 0;
+    _times[_count] = ztimer_now(arg);
 
-    _times[count] = ztimer_now(ZTIMER_MSEC);
-
-    count += 1;
+    _count += 1;
 
     /* enable this to test underflow behavior */
 #if 0
     if (count == 2) {
-        ztimer_spin(ZTIMER_MSEC, INTERVAL*2);
+        ztimer_spin(arg, INTERVAL * 2);
     }
 #endif
 
-    if (count == N) {
+    if (_count == N) {
         mutex_unlock(&_mutex);
     }
 
-    return (count == N);
+    return (_count == N);
 }
 
 int main(void)
 {
     ztimer_periodic_t t;
-
-    ztimer_periodic_init(ZTIMER_MSEC, &t, callback, NULL, INTERVAL);
-    uint32_t last = ztimer_now(ZTIMER_MSEC);
-
-    ztimer_periodic_start(&t);
-
-    if (!ztimer_is_set(ZTIMER_MSEC, &t.timer)) {
-        print_str("Test failed\n");
-        return 1;
-    }
-
-    /* wait for periodic to trigger N times */
-    mutex_lock(&_mutex);
-
+    ztimer_clock_t * const clocks[] = CLOCKS;
     int failed = 0;
 
-    for (unsigned i = 0; i < N; i++) {
-        uint32_t offset = labs((int32_t)(_times[i] - INTERVAL - last));
-        printf("i: %u time: %" PRIu32 " offset: %" PRIu32 "\n",
-               i, _times[i], offset);
-        if (offset > MAX_OFFSET) {
-            failed = 1;
+    for (size_t j = 0; j < ARRAY_SIZE(clocks); j++) {
+        printf("Testing clock: %s\n", _names[j]);
+        ztimer_clock_t *clock = clocks[j];
+        ztimer_periodic_init(clock, &t, callback, clock, _intervals[j]);
+
+        _count = 0;
+        ztimer_periodic_start(&t);
+        /* ztimer_periodic_start stores the value of ztimer_now() + period into t.last. We use that
+         * value instead of calling ztimer_now() again, as on slow boards the introduced offset can
+         * result in a failing test, despite the timeout actually being triggered close enough
+         * to the target. */
+        uint32_t last = t.last - _intervals[j];
+
+        if (!ztimer_is_set(clock, &t.timer)) {
+            print_str("Test failed\n");
+            return 1;
         }
-        last = _times[i];
+
+        /* wait for periodic to trigger N times */
+        mutex_lock(&_mutex);
+
+        for (unsigned i = 0; i < N; i++) {
+            uint32_t offset = labs((int32_t)(_times[i] - _intervals[j] - last));
+            printf("i: %u time: %" PRIu32 " offset: %" PRIu32 "\n",
+                   i, _times[i], offset);
+            if (offset > _max_offsets[j]) {
+                failed = 1;
+            }
+            last = _times[i];
+        }
+
+        ztimer_periodic_stop(&t);
     }
 
     if (!failed) {
