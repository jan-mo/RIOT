diff --git a/boards/samd21-xpro/include/board.h b/boards/samd21-xpro/include/board.h
index 8b0c4b2395..cd96a79237 100644
--- a/boards/samd21-xpro/include/board.h
+++ b/boards/samd21-xpro/include/board.h
@@ -62,6 +62,33 @@ extern "C" {
 #define BTN0_MODE           GPIO_IN_PU
 /** @} */
 
+/**
+ * @name LIS acceleration pin definitions
+ * @{
+ */
+ #ifdef MODULE_LIS2DH12_SPI
+    #define LIS2DH12_PARAM_SPI  SPI_DEV(1)
+    #define LIS2DH12_PARAM_CS   GPIO_PIN(PA, 17)
+#elif MODULE_LIS3DH
+    #define LIS3DH_PARAM_SPI    SPI_DEV(1)
+    #define LIS3DH_PARAM_CS     GPIO_PIN(PA, 17)
+    #define LIS3DH_PARAM_INT1   GPIO_PIN(PB, 11)
+    #define LIS3DH_PARAM_INT2   GPIO_PIN(PB, 10)
+#endif
+/** @} */
+
+/**
+ * @name WIFI WINC1500 pin definitions
+ * @{
+ */
+#define ATWINC15X0_PARAM_SPI            (SPI_DEV(2))
+#define ATWINC15X0_PARAM_RESET_PIN      (GPIO_PIN(PB, 30))
+#define ATWINC15X0_PARAM_WAKE_PIN       (GPIO_PIN(PA, 15))
+#define ATWINC15X0_PARAM_IRQ_PIN        (GPIO_PIN(PA, 28))
+#define ATWINC15X0_PARAM_CHIP_EN_PIN    (GPIO_PIN(PA, 27))
+#define ATWINC15X0_PARAM_SSN_PIN        (GPIO_PIN(PB, 17))
+/** @} */
+
 /**
  * @brief Initialize board specific hardware, including clock, LEDs and std-IO
  */
diff --git a/firmwareExample/Makefile b/firmwareExample/Makefile
index dc96c613eb..9a3c16cf05 100644
--- a/firmwareExample/Makefile
+++ b/firmwareExample/Makefile
@@ -17,17 +17,21 @@ USEMODULE += lis2dh12_spi
 
 # gnrc_networking
 GNRC_NETIF_NUMOF := 1
-
 USEMODULE += gnrc_netdev_default
 USEMODULE += auto_init_gnrc_netif
 USEMODULE += gnrc_ipv6
-USEMODULE += gnrc_icmpv6_error
 USEMODULE += gnrc_udp
+USEMODULE += gnrc_pktdump
 USEMODULE += gnrc_icmpv6_echo
 
+# process status
 USEMODULE += ps
-USEMODULE += netstats_l2
-USEMODULE += netstats_ipv6
+
+# WINC1500 WIFI
+USEMODULE += atwinc15x0
+### this includes the settings for WIFI
+### make sure to update the settings for your own network
+CFLAGS += -DWIFI_SSID=\"***\" -DWIFI_PASS=\"***\"
 
 # PCD8544
 USEMODULE += pcd8544
diff --git a/firmwareExample/main.c b/firmwareExample/main.c
index fc7a8ed988..c52ca7fc4f 100644
--- a/firmwareExample/main.c
+++ b/firmwareExample/main.c
@@ -31,17 +31,11 @@
 
 /* acceleration sensor config */
 #ifdef MODULE_LIS2DH12_SPI
-    #define LIS2DH12_PARAM_SPI  SPI_DEV(2)
-    #define LIS2DH12_PARAM_CS   GPIO_PIN(PB, 17)
     #include "lis2dh12.h"
     #include "lis2dh12_params.h"
     #include "lis2dh12_registers.h"
     static lis2dh12_t dev_lis;
 #elif MODULE_LIS3DH
-    #define LIS3DH_PARAM_SPI  (SPI_DEV(1))
-    #define LIS3DH_PARAM_CS   (GPIO_PIN(PA, 17))
-    #define LIS3DH_PARAM_INT1 (GPIO_PIN(PB, 11))
-    #define LIS3DH_PARAM_INT2 (GPIO_PIN(PB, 10))
     #include "lis3dh.h"
     #include "lis3dh_params.h"
     static lis3dh_t dev_lis;
@@ -55,6 +49,10 @@ static pcd8544_t dev_pcd;
 #include "graphplot.h"
 bool GRAPHPLOT_ENABLE = false;
 
+/* WINC1500 config */
+#include "atwinc15x0.h"
+#include "atwinc15x0_params.h"
+
 /* timings */
 #define SECOND          1000000
 #define MILLI_SECOND    1000
diff --git a/firmwareExample/udp.c b/firmwareExample/udp.c
new file mode 100644
index 0000000000..f7ae44df6d
--- /dev/null
+++ b/firmwareExample/udp.c
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2015-17 Freie Universit√§t Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @ingroup     examples
+ * @{
+ *
+ * @file
+ * @brief       Demonstrating the sending and receiving of UDP data
+ *
+ * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>
+ * @author      Martine Lenders <m.lenders@fu-berlin.de>
+ *
+ * @}
+ */
+
+#include <stdio.h>
+#include <inttypes.h>
+
+#include "net/gnrc.h"
+#include "net/gnrc/ipv6.h"
+#include "net/gnrc/netif.h"
+#include "net/gnrc/netif/hdr.h"
+#include "net/gnrc/udp.h"
+#include "net/gnrc/pktdump.h"
+#include "timex.h"
+#include "utlist.h"
+#if IS_USED(MODULE_ZTIMER_MSEC)
+#include "ztimer.h"
+#else
+#include "xtimer.h"
+#endif
+
+static gnrc_netreg_entry_t server =
+                        GNRC_NETREG_ENTRY_INIT_PID(GNRC_NETREG_DEMUX_CTX_ALL,
+                                                   KERNEL_PID_UNDEF);
+
+static void send(char *addr_str, char *port_str, char *data, unsigned int num,
+                 unsigned int delay)
+{
+    gnrc_netif_t *netif = NULL;
+    char *iface;
+    uint16_t port;
+    ipv6_addr_t addr;
+
+    iface = ipv6_addr_split_iface(addr_str);
+    if ((!iface) && (gnrc_netif_numof() == 1)) {
+        netif = gnrc_netif_iter(NULL);
+    }
+    else if (iface) {
+        netif = gnrc_netif_get_by_pid(atoi(iface));
+    }
+
+    /* parse destination address */
+    if (ipv6_addr_from_str(&addr, addr_str) == NULL) {
+        puts("Error: unable to parse destination address");
+        return;
+    }
+    /* parse port */
+    port = atoi(port_str);
+    if (port == 0) {
+        puts("Error: unable to parse destination port");
+        return;
+    }
+
+    for (unsigned int i = 0; i < num; i++) {
+        gnrc_pktsnip_t *payload, *udp, *ip;
+        unsigned payload_size;
+        /* allocate payload */
+        payload = gnrc_pktbuf_add(NULL, data, strlen(data), GNRC_NETTYPE_UNDEF);
+        if (payload == NULL) {
+            puts("Error: unable to copy data to packet buffer");
+            return;
+        }
+        /* store size for output */
+        payload_size = (unsigned)payload->size;
+        /* allocate UDP header, set source port := destination port */
+        udp = gnrc_udp_hdr_build(payload, port, port);
+        if (udp == NULL) {
+            puts("Error: unable to allocate UDP header");
+            gnrc_pktbuf_release(payload);
+            return;
+        }
+        /* allocate IPv6 header */
+        ip = gnrc_ipv6_hdr_build(udp, NULL, &addr);
+        if (ip == NULL) {
+            puts("Error: unable to allocate IPv6 header");
+            gnrc_pktbuf_release(udp);
+            return;
+        }
+        /* add netif header, if interface was given */
+        if (netif != NULL) {
+            gnrc_pktsnip_t *netif_hdr = gnrc_netif_hdr_build(NULL, 0, NULL, 0);
+
+            gnrc_netif_hdr_set_netif(netif_hdr->data, netif);
+            ip = gnrc_pkt_prepend(ip, netif_hdr);
+        }
+        /* send packet */
+        if (!gnrc_netapi_dispatch_send(GNRC_NETTYPE_UDP,
+                                       GNRC_NETREG_DEMUX_CTX_ALL, ip)) {
+            puts("Error: unable to locate UDP thread");
+            gnrc_pktbuf_release(ip);
+            return;
+        }
+        /* access to `payload` was implicitly given up with the send operation
+         * above
+         * => use temporary variable for output */
+        printf("Success: sent %u byte(s) to [%s]:%u\n", payload_size, addr_str,
+               port);
+#if IS_USED(MODULE_ZTIMER_MSEC)
+        ztimer_sleep(ZTIMER_MSEC, delay);
+#else
+        xtimer_usleep(delay);
+#endif
+    }
+}
+
+static void start_server(char *port_str)
+{
+    uint16_t port;
+
+    /* check if server is already running */
+    if (server.target.pid != KERNEL_PID_UNDEF) {
+        printf("Error: server already running on port %" PRIu32 "\n",
+               server.demux_ctx);
+        return;
+    }
+    /* parse port */
+    port = atoi(port_str);
+    if (port == 0) {
+        puts("Error: invalid port specified");
+        return;
+    }
+    /* start server (which means registering pktdump for the chosen port) */
+    server.target.pid = gnrc_pktdump_pid;
+    server.demux_ctx = (uint32_t)port;
+    gnrc_netreg_register(GNRC_NETTYPE_UDP, &server);
+    printf("Success: started UDP server on port %" PRIu16 "\n", port);
+}
+
+static void stop_server(void)
+{
+    /* check if server is running at all */
+    if (server.target.pid == KERNEL_PID_UNDEF) {
+        printf("Error: server was not running\n");
+        return;
+    }
+    /* stop server */
+    gnrc_netreg_unregister(GNRC_NETTYPE_UDP, &server);
+    server.target.pid = KERNEL_PID_UNDEF;
+    puts("Success: stopped UDP server");
+}
+
+int udp_cmd(int argc, char **argv)
+{
+    if (argc < 2) {
+        printf("usage: %s [send|server]\n", argv[0]);
+        return 1;
+    }
+
+    if (strcmp(argv[1], "send") == 0) {
+        uint32_t num = 1;
+        uint32_t delay = 1000000;
+        if (argc < 5) {
+#if IS_USED(MODULE_ZTIMER_MSEC)
+            printf("usage: %s send "
+                   "<addr> <port> <data> [<num> [<delay in ms>]]\n", argv[0]);
+#else
+            printf("usage: %s send "
+                   "<addr> <port> <data> [<num> [<delay in us>]]\n", argv[0]);
+#endif
+            return 1;
+        }
+        if (argc > 5) {
+            num = atoi(argv[5]);
+        }
+        if (argc > 6) {
+            delay = atoi(argv[6]);
+        }
+        send(argv[2], argv[3], argv[4], num, delay);
+    }
+    else if (strcmp(argv[1], "server") == 0) {
+        if (argc < 3) {
+            printf("usage: %s server [start|stop]\n", argv[0]);
+            return 1;
+        }
+        if (strcmp(argv[2], "start") == 0) {
+            if (argc < 4) {
+                printf("usage %s server start <port>\n", argv[0]);
+                return 1;
+            }
+            start_server(argv[3]);
+        }
+        else if (strcmp(argv[2], "stop") == 0) {
+            stop_server();
+        }
+        else {
+            puts("error: invalid command");
+        }
+    }
+    else {
+        puts("error: invalid command");
+    }
+    return 0;
+}
